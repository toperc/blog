{"title":"Java垃圾回收（三）GC算法","date":"2019-09-22T09:07:50.000Z","date_formatted":{"ll":"2019年9月22日","L":"2019/09/22","MM-DD":"09-22"},"link":"posts/1569143270","comments":true,"tags":["JVM","垃圾回收"],"categories":["Java"],"updated":"2021-01-29T12:51:44.665Z","content":"<p>在前面的一篇已经讲过GC的过程了，本篇我们就讲一讲在GC过程中所伴随的一些回收算法，Java中标记垃圾的算法主要有两种，引用计数法和可达性分析算法，其中引用计数法由于某些缺陷而不被java所采用的，现阶段所用的各种回收算法都是在可达性分析算法基础上延伸出来的。</p>\n<a id=\"more\"></a>\n<h2 id=\"引用计数法\">引用计数法<a title=\"#引用计数法\" href=\"#引用计数法\"></a></h2>\n<p>原理：引用计数法就是给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的，可以当做垃圾收集。<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/089BF98B4F5846EE841F2B3539434A9D?method=download&amp;shareKey=105f6dea4e95f17232ed864b132dfb4b\" alt=\"引用计数法图1\"></p>\n<p>引用计数算法的实现简单，判定效率也高，大部分情况下是一个不错的算法。很多地方应用到它。例如：</p>\n<blockquote>\n<p>微软公司的COM技术：Computer Object Model<br>\n使用Action3的FlashPlayer<br>\nPython</p>\n</blockquote>\n<p>但是，主流的java虚拟机并没有选用引用计数算法来管理内存，其中最主要的原因是：<strong>它很难解决对象之间相互循环引用的问题。</strong><br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/B69600A8DB934506B875B790747B4A17?method=download&amp;shareKey=daca1620759fdf0153e33457ee046d55\" alt=\"引用计数法图2\"></p>\n<p>上面的3个图中，对于最右边的那张图而言：循环引用的计数器都不为0，但是他们对于根对象都已经不可达了，但是无法释放。</p>\n<p>引用计数算法的问题：</p>\n<ul>\n<li>引用和去引用伴随加法和减法，影响性能</li>\n<li>致命的缺陷：对于循环引用的对象无法进行回收</li>\n</ul>\n<h2 id=\"可达性分析法\">可达性分析法<a title=\"#可达性分析法\" href=\"#可达性分析法\"></a></h2>\n<p>为了解决引用计数法这个循环引用不可回收问题，后来那些巨人们又想到一个牛掰的算法——可达性分析法。<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/83E6E7E11AAE4C69A355BED944CB27D6?method=download&amp;shareKey=1ec305e07a62f2a6438e6db4571c4bbf\" alt=\"可达性分析法图\"></p>\n<p>这个算法的基本思想就是通过一系列的称为 “GC Roots”的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots没有任何引用链相连的话，则证明此对象是不可用的。目前JVM所采用的各种回收算法都是在此基础上引申出来的。</p>\n<h3 id=\"什么对象可以作为gc-root？\">什么对象可以作为GC Root？<a title=\"#什么对象可以作为gc-root？\" href=\"#什么对象可以作为gc-root？\"></a></h3>\n<ul>\n<li>虚拟机栈中的引用对象</li>\n<li>方法区中的常量引用对象</li>\n<li>方法区中的类静态属性引用对象</li>\n<li>本地方法栈中的引用对象</li>\n<li>活跃线程中的引用对象</li>\n</ul>\n<h3 id=\"不可达的对象一定会回收吗？\">不可达的对象一定会回收吗？<a title=\"#不可达的对象一定会回收吗？\" href=\"#不可达的对象一定会回收吗？\"></a></h3>\n<p>答案是否定的。在可达性分析法中不可达的对象，它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选保留，筛选保留的条件是此对象是否有必要执行finalize()方法。</p>\n<p>当对象没有覆盖finalize()方法，或finalize()方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行筛选保留。被判定为需要执行筛选的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p>\n<h3 id=\"finalize的作用\">finalize的作用<a title=\"#finalize的作用\" href=\"#finalize的作用\"></a></h3>\n<ul>\n<li>finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。</li>\n<li>finalize()与C++ 中的析构函数不是对应的。C++ 中的析构函数调用的时机是确定的（对象离开作用域或delete掉），<strong>但Java中的finalize的调用具有不确定性</strong>。</li>\n<li>不建议用finalize方法完成“非内存资源”的清理工作，操作不慎可能导致错误，如果真的用，请准确使用：\n<ol>\n<li>清理本地对象(通过JNI创建的对象)；</li>\n<li>作为确保某些非内存资源(如Socket、文件等)释放的一个补充：在finalize方法中显式调用其他资源释放方法。</li>\n</ol>\n</li>\n</ul>\n<p>经验：</p>\n<ul>\n<li>避免使用finalize()，操作不慎可能导致错误。</li>\n<li>finalize 优先级低，何时被调用，不确定。</li>\n<li>何时发生gc不确定。</li>\n<li>如果需要释放资源，可以使用try-catch-finally来替代它。</li>\n</ul>\n<h3 id=\"可触及性\">可触及性<a title=\"#可触及性\" href=\"#可触及性\"></a></h3>\n<ol>\n<li>可触及：从根节点出发，可以触及到这个对象，即可达。</li>\n<li>可复活：一旦所有引用被释放，就是不可达状态，不可达并不是一定不可触及，因为在finalize()中可能复活该对象，但是同个对象finalize()方法只会进行一次。</li>\n<li>不可触及：在finalize()后，可能进入不可触及状态。不可触及对象不可能复活，所以只有一条路——回收。</li>\n</ol>\n<h3 id=\"代码说事\">代码说事<a title=\"#代码说事\" href=\"#代码说事\"></a></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestRelive</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> TestRelive tr;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>.finalize();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;TestRelive finalize called&quot;</span>);</span><br><span class=\"line\">\t\tobj = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;i am TestRelive object&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">\t\ttr = <span class=\"keyword\">new</span> TestRelive();</span><br><span class=\"line\">\t\ttr = <span class=\"keyword\">null</span>;<span class=\"comment\">//不可达，但不一定不可触及</span></span><br><span class=\"line\">\t\tSystem.gc();</span><br><span class=\"line\">\t\tThread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(tr == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">&quot;tr is null&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">&quot;tr is useable&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;the second gc&quot;</span>);</span><br><span class=\"line\">\t\ttr = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\tSystem.gc();</span><br><span class=\"line\">\t\tThread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(tr == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">&quot;tr is null&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">&quot;tr is useable&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果：<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/920116CD4B8B4D15A82CD3D633C7A90A?method=download&amp;shareKey=82d3390aeef626a2c99a35c596f3bdb8\" alt=\"重写finalize检测结果图\"></p>\n<p>当第一次tr设置成null的时候，tr处于不可达状态，并且系统调用gc，由于重写了finalize方法，在gc之前需要调用finalize，使得tr又重新处于可达状态，第二次gc的时候，由于finalize只会执行一次，所以tr就真正处于不可触及的状态了，故被清理了。</p>\n<h2 id=\"jvm常见的gc算法\">JVM常见的GC算法<a title=\"#jvm常见的gc算法\" href=\"#jvm常见的gc算法\"></a></h2>\n<p>在Java中存在着四种垃圾回收算法，他们都是在可达性分析法中延伸出来的。这四种算法分别是：<strong>标记清除算法</strong>、<strong>复制算法</strong>、<strong>标记压缩（整理）算法</strong>、<strong>分代回收算法</strong>。下边我将分别介绍一下他们。</p>\n<h3 id=\"标记-清除算法\">标记-清除算法<a title=\"#标记-清除算法\" href=\"#标记-清除算法\"></a></h3>\n<p>将垃圾回收分为两个阶段：标记阶段和清除阶段。</p>\n<p>原理：在标记阶段，首先通过根节点，标记从根节点出发的可达对象，因此，未被标记的对象就是未被引用的垃圾对象，然后，在清除阶段，清除所有未被标记的对象。<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/DCEFA2258130464DBD16DD592A8D632E?method=download&amp;shareKey=c589c59c1a1a6f3da416dea1b4fda497\" alt=\"标记清除算法图\"></p>\n<p>上图中，箭头表示引用，从根节点出发，有箭头的地方经过的节点都是可达对象，即浅灰色的部分，而深灰色的对象都是不可达对象。算法对可达对象进行标记，然后将未被标记的对象进行清理。</p>\n<p>该算法是回收算法中最基础的算法，其他的算法都是基于该算法进行改进的。面临的主要缺点有两个：</p>\n<ol>\n<li>效率问题：标记和清除两个过程的效率都不高。</li>\n<li>空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>\n</ol>\n<h3 id=\"复制算法\">复制算法<a title=\"#复制算法\" href=\"#复制算法\"></a></h3>\n<p>原理：它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉，然后交换两个内存的角色，往复进行，完成垃圾回收。<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/71DE856D983C4E37A7CF2BD54FE0F978?method=download&amp;shareKey=053f5229ef43c636936b6a216599040b\" alt=\"复制算法图\"></p>\n<p>优点：该算法每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</p>\n<p>缺点：</p>\n<ol>\n<li>效率问题，面对对象存活率较高的场合，例如老年代，需要不断的频繁复制操作，效率低下。</li>\n<li>空间问题，内存的可用大小缩小为了原来的一半，因为每次只能用其中的一半，造成空间浪费。</li>\n</ol>\n<h4 id=\"整合标记清理进行改进\">整合标记清理进行改进<a title=\"#整合标记清理进行改进\" href=\"#整合标记清理进行改进\"></a></h4>\n<p><strong>复制空间越大，浪费的空间越大，复制算法空间一般不会很大</strong>，另外大的空间，如果在极端情况下，会涉及大量存活对象的移动，这种大量的移动对于系统本身，无疑问是灾难性的。所以一般整合标记清理思想，对复制算法会做一些改进。<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/377E27B6F6F84388A2FC62BDC731F969?method=download&amp;shareKey=b4e77023d19aee6661ac27b0a080df7a\" alt=\"整合标记清理算法进行改进图\"></p>\n<p>第一块最大的作为主要存储空间（对象产生的地方，新生代中的eden），中间两块（from和to）作为复制算法的核心，老年代空间作为复制算法的担保空间；</p>\n<p>垃圾回收开始之后，首先大对象直接进入担保空间，大对象进入复制空间不合理的原因：复制空间可能不会很大，因为越大资源浪费越严重，因此大对象尽可能不要在复制空间分配，否则会引起两个问题：</p>\n<ol>\n<li>如果大对象放入复制空间，很多小对象可能没地方去，就会排挤到老年代中。</li>\n<li>大对象根本复制空间放不进去，就只能去老年代。</li>\n</ol>\n<p>因此大对象一般直接去担保空间，剩余对象（小对象、年轻对象）进入复制空间，年轻对象每被清理一次，对象年龄就会加1，如果经过几次清理都没有被清理掉，是一个长期有效的对象，就会变成老年代，接着执行老年代的一个清理工作。</p>\n<p>我们上一篇文章中讲到JVM将内存分为年轻代和老年代，其中年轻代又包括eden区和两个survivor区，和这里的整合思想分区可以做一下对比，几乎是完全吻合的。</p>\n<h3 id=\"标记-压缩算法\">标记-压缩算法<a title=\"#标记-压缩算法\" href=\"#标记-压缩算法\"></a></h3>\n<p>为了解决复制算法中在某些场合效率低下和空间浪费的问题，后来又演变出一个标记-压缩算法。</p>\n<p>原理：在标记-清除的基础上做了一些优化，和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记，但是之后，它并不简单的清理未标记对象，而是将所有的存活对象压缩到内存的一端，之后，清除边界外所有的内存空间。<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/121C3DF9BC6B480486679FB67179A3A3?method=download&amp;shareKey=2b8d25cda59a8c7d018a02c3c5cdfd4a\" alt=\"标记压缩算法图\"></p>\n<p>优点：最适用于存活对象比较多的场合，如老年代。</p>\n<h3 id=\"分代收集算法\">分代收集算法<a title=\"#分代收集算法\" href=\"#分代收集算法\"></a></h3>\n<p>原理：根据对象存活周期的不同将内存划分为几块，一般是把java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>\n<p>依据对象的存活周期进行分类：</p>\n<ul>\n<li>第一类：有些对象创建后，很快就会回收，我们把短命对象归为新生代，</li>\n<li>第二类：有些对象创建后会长期存在，有可能和JVM生命周期相同，我们把长命对象归为老年代。</li>\n</ul>\n<p>根据不同代的特点，选取合适的收集算法：</p>\n<ul>\n<li>新生代仅有少量对象存活，适合复制算法；</li>\n<li>老年代中的对象有两种：\n<ol>\n<li>多次GC没有回收掉，年龄校大的对。</li>\n<li>生命周期较长复制算法空间担保 ，直接进入 老年代的大对象。</li>\n</ol>\n</li>\n</ul>\n<p>所以老年代会有大量大年龄对象和大对象存活，适合标记清理或者标记压缩。</p>\n<h2 id=\"stop-the-world\">Stop the world<a title=\"#stop-the-world\" href=\"#stop-the-world\"></a></h2>\n<p>虚拟机在一些特定指令位置设置一些“安全点”，当程序运行到这些“安全点”的时候就会暂停所有当前运行的线程（Stop The World 所以叫STW），暂停后再找到“GC Roots”进行关系的组建，进而执行标记和清除。</p>\n<p>这些特定的指令（安全点）位置主要在：</p>\n<ul>\n<li>循环的末尾</li>\n<li>方法临返回前 | 调用方法的call指令后</li>\n<li>可能抛异常的位置</li>\n</ul>\n<h3 id=\"为什么会有这个过程呢\">为什么会有这个过程呢<a title=\"#为什么会有这个过程呢\" href=\"#为什么会有这个过程呢\"></a></h3>\n<p>我们知道垃圾回收首先是要经过标记的。对象被标记后就会根据不同的区域采用不同的收集方法。看上去很完美的一件事情，其实并不然。</p>\n<p>大家有没有想过一件事情，当虚拟机完成两次标记后，便确认了可以回收的对象。但是，垃圾回收并不会阻塞我们程序的线程，他是与当前程序并发执行的。所以问题就出在这里，当GC线程标记好了一个对象的时候，此时我们程序的线程又将该对象重新加入了“关系网”中，当执行二次标记的时候，该对象也没有重写finalize()方法，因此回收的时候就会回收这个不该回收的对象。</p>\n<h3 id=\"stw危害\">STW危害<a title=\"#stw危害\" href=\"#stw危害\"></a></h3>\n<ol>\n<li>长时间服务停止，造成系统响应时间增长或者没有响应。<br>\n2、长时间服务停止，没有响应，遇到<a href=\"https://baike.baidu.com/item/ha/2663115?fr=aladdin\" target=\"_blank\">HA系统</a>，可能引起主备切换，最终导致主备同时启动。在一些业务场景下，可能会导致数据不致，甚至无法正常工作。</li>\n</ol>\n<p>主备机切换：<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/DF166BABC13140E0BB676C8B57E4FA8A?method=download&amp;shareKey=440ea559c618c3f130fc969e8530b3be\" alt=\"主备机\"></p>\n<p>平常由主机工作，备机不工作，一般情况下，不允许主备机同时工作，会出现系统问题。如果此时主机发生gc，系统长时间没有反应，备机以为主机出现问题，此时备机开始工作；等到主机gc结束，则主备机同时开始工作，严重危害生产环境。</p>\n<h2 id=\"总结\">总结<a title=\"#总结\" href=\"#总结\"></a></h2>\n<p>本篇我们讲解了GC过程中常用的GC算法，按照大的方向从标记来说GC算法分为<strong>引用计数法</strong>和<strong>可达性分析法</strong>；引用计数法无法避免因循环造成对象无法回收的现象不被java使用，目前的GC过程所涉及的算法都是根据可达性分析法基础上延伸出来的，主要有四个：<strong>标记清除算法</strong>、<strong>复制算法</strong>、<strong>标记压缩算法</strong>、<strong>分代回收算法</strong>，最后一个也算是前三个面对不同场景的综合运用。</p>\n<p>下篇我们再深入一层，讲解一下垃圾回收器都有哪些，顺便最后简单讲一下虚拟机GC调优，做一个了断。</p>\n","prev":{"title":"Android媒体库你了解多少","link":"posts/1571496871"},"next":{"title":"Java垃圾回收（二）GC过程","link":"posts/1569139670"},"plink":"https://blog.ixin.run/posts/1569143270/","toc":[{"id":"引用计数法","title":"引用计数法","index":"1"},{"id":"可达性分析法","title":"可达性分析法","index":"2","children":[{"id":"什么对象可以作为gc-root？","title":"什么对象可以作为GC Root？","index":"2.1"},{"id":"不可达的对象一定会回收吗？","title":"不可达的对象一定会回收吗？","index":"2.2"},{"id":"finalize的作用","title":"finalize的作用","index":"2.3"},{"id":"可触及性","title":"可触及性","index":"2.4"},{"id":"代码说事","title":"代码说事","index":"2.5"}]},{"id":"jvm常见的gc算法","title":"JVM常见的GC算法","index":"3","children":[{"id":"标记-清除算法","title":"标记-清除算法","index":"3.1"},{"id":"复制算法","title":"复制算法","index":"3.2"},{"id":"标记-压缩算法","title":"标记-压缩算法","index":"3.3"},{"id":"分代收集算法","title":"分代收集算法","index":"3.4"}]},{"id":"stop-the-world","title":"Stop the world","index":"4","children":[{"id":"为什么会有这个过程呢","title":"为什么会有这个过程呢","index":"4.1"},{"id":"stw危害","title":"STW危害","index":"4.2"}]},{"id":"总结","title":"总结","index":"5"}],"reward":true,"copyright":{"author":"i猩人","link":"<a href=\"https://blog.ixin.run/posts/1569143270/\" title=\"Java垃圾回收（三）GC算法\">https://blog.ixin.run/posts/1569143270/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}