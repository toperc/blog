{"title":"位运算的那些事（二）如何位运算","date":"2019-08-25T14:18:59.000Z","date_formatted":{"ll":"2019年8月25日","L":"2019/08/25","MM-DD":"08-25"},"link":"post/1566743147","comments":true,"tags":["二进制","位运算"],"categories":["计算机基础"],"updated":"2021-01-14T08:08:54.917Z","content":"<p>上一篇为了讲位运算不得已将二进制机器码与真值之间的关系系统的解释了一通，本篇我们就根据这些基础将二进制位运算几个常用的运算符运算规则理一理，相信本文之后你就明白了这一个过程。</p>\n<p>上篇我也提到位运算符主要针对二进制，它主要包括：“与（&amp;）”、“或（|）”、“非（~）”、“异或（^）”，当然还有移位运算（左移、右移，无符号左移），这在开发过程中也是很常见的，下边我就以这两部分来说。</p>\n<a id=\"more\"></a>\n<h2 id=\"位运算过程\">位运算过程<a title=\"#位运算过程\" href=\"#位运算过程\"></a></h2>\n<p>常见的位运算都是针对两个值之间的运算，只有“非”是针对一个值计算。</p>\n<p>再次强调一下，上篇文章我提到的<strong>计算机最终参与运算和存储的是真值的二进制补码</strong>，所以本篇位运算转化为二进制都要以补码的形式进行运算，然后再还原成真值才能得到正确的结果，这也是上篇文末提到的两个过程。</p>\n<p>为了描述简单起见，下边四种位运算都用<code>a = 12, b= -21</code>来进行运算，所以我们先对这两个数字进行补码，用一个字节来表示，方便下边运算使用，如果这里还看不懂，建议返回上一篇。</p>\n<p>伪代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a &#x3D; 12 &#x3D; [0000 1100]原 &#x3D; [0000 1100]反 &#x3D; [0000 1100]补</span><br><span class=\"line\"></span><br><span class=\"line\">b &#x3D; -21 &#x3D; [1001 0101]原 &#x3D; [1110 1010]反 &#x3D; [1110 1011]补</span><br></pre></td></tr></table></figure>\n<h3 id=\"与（and）\">与（AND）<a title=\"#与（and）\" href=\"#与（and）\"></a></h3>\n<p>与运算符用符号“&amp;”表示，其使用规则如下：<br>\n<strong>两个操作数所对应的二进制补码相同坐标位值都为1，结果才为1，否则结果为0</strong>。例如下面的程序段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(<span class=\"string\">&quot;a和b，与的结果是：&quot;</span>+(a&amp;b));</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br>\na和b，与的结果是：8</p>\n<p>分析:<br>\n“a”的补码：0000 1100<br>\n“b”的补码：1110 1011<br>\n“与”的补码：0000 1000<br>\n转换为真值：[0000 1000]补 = [0000 1000]反 = [0000 1000]原 = 8</p>\n<h3 id=\"或（or）\">或（OR）<a title=\"#或（or）\" href=\"#或（or）\"></a></h3>\n<p>或运算符用符号“|”表示，其运算规则如下：<br>\n<strong>两个操作数所对应的二进制补码相同坐标位值有一个为1，结果就为1，否则结果为0</strong>。例如下面的程序段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(<span class=\"string\">&quot;a和b，或的结果是：&quot;</span>+(a|b));</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br>\na和b，或的结果是：-17</p>\n<p>分析：<br>\n“a”的补码：0000 1100<br>\n“b”的补码：1110 1011<br>\n“或”的补码：1110 1111<br>\n转换为真值：[1110 1111]补 = [1110 1110]反 = [1001 0001]原 = -17</p>\n<h3 id=\"非（not）\">非（NOT）<a title=\"#非（not）\" href=\"#非（not）\"></a></h3>\n<p>非运算符用符号“~”表示，其使用规则如下：<br>\n<strong>操作数所对应的二进制补码位值都为0，结果为1，位值为1结果为0</strong>。例如下面的程序段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(<span class=\"string\">&quot;a，非的结果是：&quot;</span>+(~a));</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br>\na，非的结果是：-13</p>\n<p>分析:<br>\n“a”的补码：0000 1100<br>\n“非”的补码：1111 0011<br>\n转换为真值：[1111 0011]补 = [1111 0010]反 = [1000 1101]原 = -13</p>\n<p>这里有一个有趣的规律：</p>\n<ul>\n<li><strong>所有正整数的非，是其本身加1的负数</strong></li>\n<li><strong>所有负整数的非，是其本身加1的正数</strong></li>\n<li><strong>0的非，是-1</strong></li>\n</ul>\n<h3 id=\"异或（xor）\">异或（XOR）<a title=\"#异或（xor）\" href=\"#异或（xor）\"></a></h3>\n<p>异或运算符用符号“^”表示，其使用规则如下：<br>\n<strong>两个操作数所对应的二进制补码相同坐标位值相同（无论同为1还是同为0）则为为0，不同则为1</strong>。例如下面的程序段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(<span class=\"string\">&quot;a和b，异或的结果是：&quot;</span>+(a^b));</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br>\na和b，异或的结果是：-25</p>\n<p>分析：<br>\n“a”的补码：0000 1100<br>\n“b”的补码：1110 1011<br>\n“异或”的补码：1110 0111<br>\n转换为真值：[1110 0111]补 = [1110 0110]反 = [1001 1001]原 = -25</p>\n<p>到这里四种位运算符的运算过程已经分析完了，是否和你之前想象的一样呢？如果一样，恭喜你，你已经理解了位运算相关运算符的运算过程了。下边我们就进一步探讨移位运算的运算过程。</p>\n<h2 id=\"移位运算过程\">移位运算过程<a title=\"#移位运算过程\" href=\"#移位运算过程\"></a></h2>\n<p>移位运算中主要涉及到三种运算符：左移（&lt;&lt;）、右移（&gt;&gt;）、无符号右移（&gt;&gt;&gt;）。假设有一个管道是固定长度的（这个长度是根据数据类型来确定的），移位运算就是一组二进制码在此管道中移动，不够的地方做补充，多余的部分省去。下边就分别讲一下这三个区别以及运算过程。</p>\n<p>为了方便下边的运算，我们这里还是先定义一个数字<code>a = -8</code>，则：<br>\n“a”的原码：1000 1000<br>\n“a”的反码：1111 0111<br>\n“a”的补码：1111 1000</p>\n<p>假设管道长度按照一个字节8位来定（按照移动位数2位，管道长度<strong>我猜可能</strong>是够用的）。</p>\n<h3 id=\"左移\">左移<a title=\"#左移\" href=\"#左移\"></a></h3>\n<p>左移运算符用符号“&lt;&lt;”表示，其使用规则如下：<br>\n<strong>操作数所对应的二进制补码整体向左移动，原来左边的数据会被溢出，右边会空缺相应的位数，需要进行补0</strong>。例如下面的程序段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(<span class=\"string\">&quot;a和b，异或的结果是：&quot;</span>+(a&lt;&lt;<span class=\"number\">2</span>));</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br>\na,左移2位的结果是：-32</p>\n<p>分析：<br>\n“a”的补码：1111 1000<br>\n“左移2位”的补码：1110 0000<br>\n转换为真值：[1110 0000]补 = [1101 1111]反 = [1010 0000]原 = -32</p>\n<h3 id=\"右移\">右移<a title=\"#右移\" href=\"#右移\"></a></h3>\n<p>右移运算符用符号“&gt;&gt;”表示，其使用规则如下：<br>\n<strong>操作数所对应的二进制补码整体向右移动，原来右边的数据会被溢出，左边会空缺相应的位数，需要进行补0或补1（根据原值的正负，正数补0，负数补1）</strong>。例如下面的程序段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(<span class=\"string\">&quot;a和b，异或的结果是：&quot;</span>+(a&gt;&gt;<span class=\"number\">2</span>));</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br>\na,右移2位的结果是：-2</p>\n<p>分析：<br>\n“a”的补码：1111 1000<br>\n“右移2位”的补码：1111 1110<br>\n转换为真值：[1111 1110]补 = [1111 1101]反 = [1000 0010]原 = -2</p>\n<h3 id=\"无符号右移\">无符号右移<a title=\"#无符号右移\" href=\"#无符号右移\"></a></h3>\n<p>无符号右移运算符用符号“&gt;&gt;&gt;”表示，其使用规则如下：<br>\n<strong>操作数所对应的二进制补码整体向右移动，原来右边的数据会被溢出，左边会空缺相应的位数，忽略正负情况，统一补0</strong>。例如下面的程序段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(<span class=\"string\">&quot;a和b，异或的结果是：&quot;</span>+(a&gt;&gt;&gt;<span class=\"number\">2</span>));</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br>\na,无符号右移2位的结果是：1073741822</p>\n<p>分析：<br>\n“a”的补码：1111 1000<br>\n“无符号右移2位”的补码：0011 1110<br>\n转换为真值：[0011 1110]补 = [0011 1110]反 = [0011 1110]原 = 62</p>\n<p>显然这个结果出入很大，其错误原因就是我定义的这个管道长度不够导致的，按照我上边说的管道长度是按照数据类型来确定的，我程序里面都是java来写的，java中一个int占四个字节即32位。所以应该这样算：<br>\na的原码：1000 0000 0000 0000 0000 0000 0000 1000<br>\na的反码：1111 1111 1111 1111 1111 1111 1111 0111<br>\na的补码：1111 1111 1111 1111 1111 1111 1111 1000<br>\n无符号右移2位的补码：0011 1111 1111 1111 1111 1111 1111 1110<br>\n转换成真值：[0011 … 1110]补 = [0011 … 1110]反 = [0011 … 1110]原 = 1073741822</p>\n<p>这样就对了，你可能会问为什么上边的左移右移没问题呢？其实当你看到最终的原码就发现了其实中间都是0，可以省略的。还有疑问吗？好，最多再给你一个问题：<strong>为什么没有无符号左移呢？</strong>，其实我也想问一句：<strong>无符号左移和左移有区别吗？</strong></p>\n<p>至此移位运算分析完毕，你有没有发现一个规律：</p>\n<ul>\n<li><strong>左移运算，相当于原值乘以2的n次方</strong></li>\n<li><strong>右移运算，相当于原值除以2的n次方</strong></li>\n</ul>\n<h2 id=\"总结\">总结<a title=\"#总结\" href=\"#总结\"></a></h2>\n<p>本篇文章将位运算和移位运算的运算过程整体分析了一遍，二者其实都可以统一叫做位运算，总之就是以上七中规则，细心看来其实这些也都有规律可循。</p>\n<p>当你看完之后是不是又惊喜又懵X，哈哈，虽然我们也知道有这样一个计算过程，但是开发过程中，无论是写代码还是看代码，总不能让我在私下先画一些小杠杠吧。其实位运算在计算机中的用途很广，拿异或来说，可用于数据的加密，并且是高度对称的，也可用于各类纠错码和校验码的编码…，虽然这些有代我们去深入开辟，但是在现阶段针对C++、java等上层语言主要用在哪些地方呢？下篇文章我会根据前两篇的思路叙说一下位运算在常规开发阶段的一个重要用途。</p>\n","prev":{"title":"位运算的那些事（三）位掩码","link":"post/1567003105"},"next":{"title":"位运算的那些事（一）搞懂机器码","link":"post/1566742995"},"plink":"https://blog.ixin.run/post/1566743147/","toc":[{"id":"位运算过程","title":"位运算过程","index":"1","children":[{"id":"与（and）","title":"与（AND）","index":"1.1"},{"id":"或（or）","title":"或（OR）","index":"1.2"},{"id":"非（not）","title":"非（NOT）","index":"1.3"},{"id":"异或（xor）","title":"异或（XOR）","index":"1.4"}]},{"id":"移位运算过程","title":"移位运算过程","index":"2","children":[{"id":"左移","title":"左移","index":"2.1"},{"id":"右移","title":"右移","index":"2.2"},{"id":"无符号右移","title":"无符号右移","index":"2.3"}]},{"id":"总结","title":"总结","index":"3"}],"reward":true,"copyright":{"custom":"转载请注明出处，谢谢支持。"}}