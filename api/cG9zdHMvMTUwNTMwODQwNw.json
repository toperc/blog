{"title":"Android开发BroadcastReceiver详解","date":"2017-09-13T13:13:27.000Z","date_formatted":{"ll":"2017年9月13日","L":"2017/09/13","MM-DD":"09-13"},"link":"posts/1505308407","comments":true,"categories":["Android"],"updated":"2021-01-29T12:51:44.624Z","content":"<p>BroadcastReceiver是Android应用中一个重要的组件，顾名思义，BroadcastReceiver代表广播消息接收器。从代码实现角度来看，BroadcastReceiver非常类似于事件编程中的监听器。与普通事件监昕器不同的是，普通事件监昕器监听的事件源是程序中的对象:而BroadcastReceiver监听的事件源是Android应用中的其他组件。本篇文章就简单讲一下BoardcastReceiver的基本使用。</p>\n<a id=\"more\"></a>\n<p>BroadcastReceiver用于接收程序（包括用户开发的程序和系统内建的程序）所发出的Broadcast Intent. 与应用程序启动Activity、Service相同的是，程序启动BroadcastReceiver也只需要两步：</p>\n<ol>\n<li>创建帘要启动的BroadcastReceiver的Intent。</li>\n<li>调用Context的sendBroadcast()等方式来启动指定的BroadcastReceiver。</li>\n</ol>\n<p>当应用程序发出一个BroadcastReceiver之后，所有匹配该Intent的BroadcastReceiver都有可能被启动。</p>\n<h2 id=\"广播接收器声明\">广播接收器声明<a title=\"#广播接收器声明\" href=\"#广播接收器声明\"></a></h2>\n<p>由于BroadcastReceiver本质上属于一个监听器，因此实现BroadcastReceiver的方法也十分简单，只要重写BroadcastReceiver的onReceive(Context context, Intent intent)方法即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyBroadcastReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">&quot;MyBroadcastReceiver&quot;</span>;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">            StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">            sb.append(<span class=\"string\">&quot;Action: &quot;</span> + intent.getAction() + <span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">            sb.append(<span class=\"string\">&quot;URI: &quot;</span> + intent.toUri(Intent.URI_INTENT_SCHEME).toString() + <span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">            String log = sb.toString();</span><br><span class=\"line\">            Log.d(TAG, log);</span><br><span class=\"line\">            Toast.makeText(context, log, Toast.LENGTH_LONG).show();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>BroadcastReceiver的onReceive()方法最长执行时间为10秒，如果此方法内的执行超过10秒，系统会认为该程序无响应，所以不要在BroadcastReceiver的onReceive()方法里执行一些耗时的操作；否则会弹出ANR（Application NO Response）对话框。</p>\n<h2 id=\"两种注册方式\">两种注册方式<a title=\"#两种注册方式\" href=\"#两种注册方式\"></a></h2>\n<p>一旦实现了BroadcastReceiver，接下来就应该指定该BroadcastReceiver能匹配的Intent，此时有两种方式。</p>\n<p>Android系统中BroadcastReceiver的注册方式分为动态注册和静态注册两种。动态注册必须在程序运行期动态注册，其实际的注册动作由ContextImpl对象完成；静态注册则是在AndroidManifest.xml中声明的。在基础篇中提到过，因为静态注册耗电、占内存、不受程序生命周期影响，所以Google在Android8.0上禁止了大部分广播的静态注册，以此来减少耗电、增加待机时间、节省内存空间、提升性能。</p>\n<blockquote>\n<p>Note: If your app targets API level 26 or higher, you cannot use the manifest to declare a receiver for implicit broadcasts (broadcasts that do not target your app specifically), except for a few implicit broadcasts that are exempted from that restriction. In most cases, you can use scheduled jobs instead.</p>\n</blockquote>\n<h3 id=\"静态注册\">静态注册<a title=\"#静态注册\" href=\"#静态注册\"></a></h3>\n<p>也称为饿汉式注册，只需在AndroidManifest.xml文件中配置。例如如下代码:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;receiver android:name=<span class=\"string\">&quot;.MyBroadcastReceiver&quot;</span>  android:exported=<span class=\"string\">&quot;true&quot;</span>&gt;</span><br><span class=\"line\">    &lt;intent-filter&gt;</span><br><span class=\"line\">        &lt;action android:name=<span class=\"string\">&quot;android.intent.action.BOOT_COMPLETED&quot;</span>/&gt;</span><br><span class=\"line\">        &lt;action android:name=<span class=\"string\">&quot;android.intent.action.INPUT_METHOD_CHANGED&quot;</span> /&gt;</span><br><span class=\"line\">    &lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"动态注册\">动态注册<a title=\"#动态注册\" href=\"#动态注册\"></a></h3>\n<p>动态注册我们只需要在程序启动过程中进行注册即可，首先声明一个全局的接收器成员：</p>\n<p><code>BroadcastReceiver br = new MyBroadcastReceiver();</code></p>\n<p>然后在Activity的周期中onCreat或者onResume中进行广播接收器的注册：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IntentFilter filter = <span class=\"keyword\">new</span> IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);</span><br><span class=\"line\">filter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);</span><br><span class=\"line\"><span class=\"keyword\">this</span>.registerReceiver(br, filter);</span><br></pre></td></tr></table></figure>\n<p>为了内存和安全的需要，在生命周期结束的时候我们要进行解注册，一般这步在生命周期中onstop或onDestroy中实现，需要注意的是解注册过程不可解注册多次。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unregisterReceiver(br);</span><br></pre></td></tr></table></figure>\n<h2 id=\"三种发送方式\">三种发送方式<a title=\"#三种发送方式\" href=\"#三种发送方式\"></a></h2>\n<p>广播发送方式有两种：</p>\n<ol>\n<li>Normal Broadcast（普通广播）</li>\n<li>Ordered Broadcast（有序广播）</li>\n</ol>\n<h3 id=\"normal-broadcast（普通广播）\">Normal Broadcast（普通广播）<a title=\"#normal-broadcast（普通广播）\" href=\"#normal-broadcast（普通广播）\"></a></h3>\n<p>Normal Broadcast是完全异步的，可以在同一时刻(逻辑上)被所有接收者接收到， 消息传递的效率比较高。但缺点是接收者不能将处理结果传递给下一个接收者，并且无法终止Broadcast Intent的传播。</p>\n<p>我们常用的<code>sendBroadcast(Intent)</code>就是普通广播。</p>\n<h3 id=\"ordered-broadcast（有序广播）\">Ordered Broadcast（有序广播）<a title=\"#ordered-broadcast（有序广播）\" href=\"#ordered-broadcast（有序广播）\"></a></h3>\n<p>Ordered broadcasts的接收者按照一定的优先级进行消息的接收。如：A,B,C的优先级依次降低，那么消息先传递给A，在传递给B，最后传递给C。优先级别声明在<intent-filter>中，取值为[-1000,1000]数值越大优先级别越高。优先级也可以在代码中通过filter.setPriority(10)方式设置。</p>\n<p>另外Ordered broadcasts的接收者可以通过abortBroadcast()的方式取消广播的传播，也可以通过setResultData或setResultExtras方法将处理的结果存入到Broadcast中，传递给下一个接收者。然后，下一个接收者通过getResultData()或getResultExtras(true)接收高优先级的接收者存入的数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FirstReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">&quot;OrderedBroadcast&quot;</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">\t\tString msg = intent.getStringExtra(<span class=\"string\">&quot;msg&quot;</span>);</span><br><span class=\"line\">\t\tLog.i(TAG, <span class=\"string\">&quot;FirstReceiver: &quot;</span> + msg);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tBundle bundle = <span class=\"keyword\">new</span> Bundle();</span><br><span class=\"line\">\t\tbundle.putString(<span class=\"string\">&quot;msg&quot;</span>, msg + <span class=\"string\">&quot;@FirstReceiver&quot;</span>);</span><br><span class=\"line\">\t\tsetResultExtras(bundle);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecondReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">&quot;OrderedBroadcast&quot;</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">\t\tString msg = getResultExtras(<span class=\"keyword\">true</span>).getString(<span class=\"string\">&quot;msg&quot;</span>);</span><br><span class=\"line\">\t\tLog.i(TAG, <span class=\"string\">&quot;SecondReceiver: &quot;</span> + msg);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tBundle bundle = <span class=\"keyword\">new</span> Bundle();</span><br><span class=\"line\">\t\tbundle.putString(<span class=\"string\">&quot;msg&quot;</span>, msg + <span class=\"string\">&quot;@SecondReceiver&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//接着往下传递</span></span><br><span class=\"line\">\t\tsetResultExtras(bundle);</span><br><span class=\"line\">\t\t<span class=\"comment\">//取消广播</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//abortBroadcast();</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我们注意到，在FirstReceiver和SecondReceiver中最后都使用了setResultExtras方法将一个Bundle对象设置为结果集对象，传递到下一个接收者那里，这样以来，优先级低的接收者可以用getResultExtras获取到最新的经过处理的信息集合。</p>\n<p>接下来我们为这两个广播在AndroidMainfest.xml注册一下，注意优先级：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;receiver android:name=<span class=\"string\">&quot;.FirstReceiver&quot;</span>&gt;</span><br><span class=\"line\">\t&lt;intent-filter android:priority=<span class=\"string\">&quot;1000&quot;</span>&gt;</span><br><span class=\"line\">\t\t&lt;action android:name=<span class=\"string\">&quot;android.intent.action.MY_BROADCAST&quot;</span>/&gt;</span><br><span class=\"line\">\t\t&lt;category android:name=<span class=\"string\">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span><br><span class=\"line\">\t&lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/receiver&gt;</span><br><span class=\"line\">&lt;receiver android:name=<span class=\"string\">&quot;.SecondReceiver&quot;</span>&gt;</span><br><span class=\"line\">\t&lt;intent-filter android:priority=<span class=\"string\">&quot;999&quot;</span>&gt;</span><br><span class=\"line\">\t\t&lt;action android:name=<span class=\"string\">&quot;android.intent.action.MY_BROADCAST&quot;</span>/&gt;</span><br><span class=\"line\">\t\t&lt;category android:name=<span class=\"string\">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span><br><span class=\"line\">\t&lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>\n<p>一切准备就绪我们就开始发送广播了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"string\">&quot;android.intent.action.MY_BROADCAST&quot;</span>);</span><br><span class=\"line\">intent.putExtra(<span class=\"string\">&quot;msg&quot;</span>, <span class=\"string\">&quot;hello receiver.&quot;</span>);</span><br><span class=\"line\">sendOrderedBroadcast(intent, <span class=\"string\">&quot;scott.permission.MY_BROADCAST_PERMISSION&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>有同学问了，sendOrderedBroadcast第二个参数是什么鬼。使用sendOrderedBroadcast方法发送有序广播时，第二个参数是权限参数，如果为null则表示不要求接收者声明指定的权限，如果不为null，则表示接收者若要接收此广播需声明指定权限。这样做是从安全角度考虑的，一般设计到系统的，我们都需要声明权限，例如拦截系统短信，就必须声明接收短信的权限。</p>\n<p>当然我们也可以自定义自己的权限，一般这种主要用在跨应用跨进程或者跨组件的安全着想：</p>\n<p>例如在被调用方进行权限定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;permission </span><br><span class=\"line\">android:protectionLevel=<span class=\"string\">&quot;normal&quot;</span></span><br><span class=\"line\">android:name=<span class=\"string\">&quot;scott.permission.MY_BROADCAST_PERMISSION&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>\n<p>然后将某个组件绑定此权限，并暴露出去：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 为receiver绑定自己的权限 --&gt;</span><br><span class=\"line\">&lt;receiver android:name=<span class=\"string\">&quot;.FirstReceiver&quot;</span> </span><br><span class=\"line\">          android:permission=<span class=\"string\">&quot;scott.permission.MY_CALL_PHONE&quot;</span>&gt;</span><br><span class=\"line\">\t&lt;intent-filter android:priority=<span class=\"string\">&quot;999&quot;</span>&gt;</span><br><span class=\"line\">\t\t&lt;action android:name=<span class=\"string\">&quot;android.intent.action.MY_BROADCAST&quot;</span>/&gt;</span><br><span class=\"line\">\t\t&lt;category android:name=<span class=\"string\">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span><br><span class=\"line\">\t&lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>\n<p>接下来就可以在调用方进行权限注册和使用了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-permission android:name=<span class=\"string\">&quot;scott.permission.MY_BROADCAST_PERMISSION&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<ul>\n<li><a href=\"https://developer.android.com/guide/components/broadcasts\">https://developer.android.com/guide/components/broadcasts</a></li>\n<li><a href=\"https://www.jianshu.com/p/bc5ffb349822\">https://www.jianshu.com/p/bc5ffb349822</a></li>\n</ul>\n","prev":{"title":"数据结构整体概括","link":"posts/1515751776"},"next":{"title":"Fragment实现懒加载之setUserVisibleHint探究","link":"posts/1501243141"},"plink":"https://blog.ixin.run/posts/1505308407/","toc":[{"id":"广播接收器声明","title":"广播接收器声明","index":"1"},{"id":"两种注册方式","title":"两种注册方式","index":"2","children":[{"id":"静态注册","title":"静态注册","index":"2.1"},{"id":"动态注册","title":"动态注册","index":"2.2"}]},{"id":"三种发送方式","title":"三种发送方式","index":"3","children":[{"id":"normal-broadcast（普通广播）","title":"Normal Broadcast（普通广播）","index":"3.1"},{"id":"ordered-broadcast（有序广播）","title":"Ordered Broadcast（有序广播）","index":"3.2"}]},{"id":"参考","title":"参考","index":"4"}],"reward":true,"copyright":{"author":"i猩人","link":"<a href=\"https://blog.ixin.run/posts/1505308407/\" title=\"Android开发BroadcastReceiver详解\">https://blog.ixin.run/posts/1505308407/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}