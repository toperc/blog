{"title":"Fragment实现懒加载之setUserVisibleHint探究","date":"2017-07-28T11:59:01.000Z","date_formatted":{"ll":"2017年7月28日","L":"2017/07/28","MM-DD":"07-28"},"link":"posts/1501243141","comments":true,"tags":["Fragment","懒加载"],"categories":["Android"],"updated":"2021-01-29T12:51:44.646Z","content":"<p>一种场景很重要，即使所见即所得，例如页面可见时才加载数据，既节省内存，又能提示用户当前数据正在处理，不必感到迷茫。</p>\n<a id=\"more\"></a>\n<h2 id=\"场景\">场景<a title=\"#场景\" href=\"#场景\"></a></h2>\n<p>针对Activity，因为是一个整体，所以在生命周期内我们便可以做到所见即所得，但是fragment就不一样了，有时候一个Activity可以包含很多个Fragment，例如FragmentPageAdapter中，一般做法时提前将数据填充到Fragment中，这样在滑动Fragment时能够如丝般顺滑。</p>\n<p>但是这样也有不好的一点，就是Fragment提前就已经把数据加载上了，滑动过程无法自动刷新数据，有同学说了我可以在onResume中实现数据的请求，但是这样不感觉很蹩脚吗？FragmentPagerAdapter或者ViewPager都有预加载的过程，加入提前在onResume()里面加载，数据量大的时候卡顿是有可能的，数据量小的话加载后滑到此Fragment用户根本不知道数据已经加载而造成对数据的不放心。并且开关屏幕显示也会在请求一遍，确实蹩脚。</p>\n<p>那么有没有一种可能，在Fragment滑动到当前tab下的时候再去加载数据，甚至数据非常重要加载过程中屏蔽滑动，并且滑到当前tab下只加载一次。不卖关子了，Fragment有一个专门针对这种懒加载场景的API————setUserVisibleHint(boolean isVisibleToUser)。</p>\n<h2 id=\"执行过程\">执行过程<a title=\"#执行过程\" href=\"#执行过程\"></a></h2>\n<p>首先setUserVisibleHint()使用范围必须在一组有序的Fragment时（FragmentPageAdapter）才会起作用，单个Fragment是不起作用的，并且该方法调用不一定在Fragment正常的生命周期之内。见源码注释：<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/A8F25A8A41434BC0A67D0E48DCDE06C3?method=download&amp;shareKey=9a508dd4a1bb5a6fcbceb90cd124d356\" alt=\"setUserVisibleHint源码注释\"></p>\n<p>在FragmentPageAdapter中，假如有四张fragment，以下将通过日志来分析一下整个执行过程。</p>\n<h3 id=\"初始时\">初始时<a title=\"#初始时\" href=\"#初始时\"></a></h3>\n<p>先执行setUserVisibleHint，将一次性加载在内存中的每个fragement（默认一次性加载两个Fragment）的该方法执行一遍，先默认都初始为false，最后将可见的那个fragment（第一个）初始为true。然后执行Fragment的生命周期：</p>\n<p>setUserVisibleHint -------&gt; onAttach、 onCreat…</p>\n<p>日志：<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/0E0C5F9043A24F52A1379562CDAFF568?method=download&amp;shareKey=9d36f8b1e475583c7a33a6730f32235f\" alt=\"FragmentPageAdapter展示第一页\"></p>\n<h3 id=\"滑动到第二页\">滑动到第二页<a title=\"#滑动到第二页\" href=\"#滑动到第二页\"></a></h3>\n<p>此时该fragment的部分生命周期已经走过（例如：onCreatView），但是该fragment的可见情况发生了变化，所以在第二页的时候只执行了setUserVisibleHint，不再执行onCreatView等生命周期方法。不过滑到第二页的时候顺便把第三页的相关方法初始一下。</p>\n<p>日志：<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/91616659E82D49A4938A3F437F043C73?method=download&amp;shareKey=d90197f788f7eb4119c87014faf64734\" alt=\"FragmentPageAdapter滑动到第二页\"></p>\n<h3 id=\"滑到最后一页\">滑到最后一页<a title=\"#滑到最后一页\" href=\"#滑到最后一页\"></a></h3>\n<p>假如这里一组只有四个Fragment，因为接下来没有第5个Fragment，所以不用进行预加载了，只需要做两步操作：</p>\n<ol>\n<li>把前一页的可见性置为false,把本页的可见性置为true。</li>\n<li>把上上一页的生命周期关闭（内存中只允许放两页，所以要把老的fragment出栈）。</li>\n</ol>\n<p>日志:<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/2E10B6471015414A9F064BF87E953A52?method=download&amp;shareKey=34423f590785829a9eca78d65f735366\" alt=\"FragmentPageAdapter滑动到第四页（最后一页）\"></p>\n<h3 id=\"间接跳转\">间接跳转<a title=\"#间接跳转\" href=\"#间接跳转\"></a></h3>\n<p>假如从第四页直接跳到第一页（这里不是滑动，是导航跳转），可见性上先根据第一页的预加载方式进行逐个初始关闭，把第四页关闭，在把第一页打开。生命周期上先预处理第一页第二页的生命开启，接着将第三页第四页的生命关闭。举一反三其他间接跳转也类似。</p>\n<p>日志：<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/EA8DFD877E744C4D9146649ECDEEE2B0?method=download&amp;shareKey=bc4575f6b44228c612e7e7db4e2b094b\" alt=\"从第四页直接跳到第一页（点击tab）\"></p>\n<h3 id=\"其余情况\">其余情况<a title=\"#其余情况\" href=\"#其余情况\"></a></h3>\n<p>想必看明白的同学根据上边规律也能摸索出其他情况执行过程了。</p>\n<p>从第二页滑动到第三页：<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/EA950AD122FE4C5D8E3B535F6906356B?method=download&amp;shareKey=05cae2ebe3500dad803e1ad0a9f4a984\" alt=\"从第二页滑动到第三页\"></p>\n<p>从第一页跳到第三页（点击tab）：<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/FFB5398BD61D436393A64978FA9B8BC4?method=download&amp;shareKey=eb032bcc3ed01d1cd3075993cb9e9d16\" alt=\"从第一页跳到第三页（点击tab）\"></p>\n<p>从第三页再滑动到第二页：<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/A83B45F7F35B423F96072ECC14837CBD?method=download&amp;shareKey=b727b18e287b00766d6a0689a1c4dbcf\" alt=\"从第三页再滑动到第二页\"></p>\n<p>第二页灭屏：<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/A96FE33EFF2342B0991BFBCA2364C802?method=download&amp;shareKey=6ff33f5436769b311f4789f94653d92a\" alt=\"第二页灭屏\"></p>\n<p>亮屏展示第二页：<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/C953BF3C560143CDBE785769F204F061?method=download&amp;shareKey=003f6ef42c2a87e41db89e47d4144492\" alt=\"亮屏展示第二页\"></p>\n<h2 id=\"分析\">分析<a title=\"#分析\" href=\"#分析\"></a></h2>\n<p>综上，其实这里只需要考虑两件事：</p>\n<ol>\n<li>设置可见性（初始可见性为false，关闭老页面可见性为false, 开启当前页可见性为true）</li>\n<li>设置生命周期（预加载新的生命周期，关闭老的生命周期）。</li>\n</ol>\n<p>因为这两件事是交替变换，可见性为true但生命周期不一定初始化，此时是不能做一些有关界面的数据填充；生命周期准备好了但是可见性为false，加载的数据用户看不到，资源显的浪费。所以在数据加载时要同时考虑这两种情况，这里设置两个全局变量（mIsPrepare：标识生命周期； mIsVisible ：标识可见状态）来标识这两个情况：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">loadData</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">  mIsPrepare = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  onLazyLoad();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUserVisibleHint</span><span class=\"params\">(<span class=\"keyword\">boolean</span> isVisibleToUser)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">super</span>.setUserVisibleHint(isVisibleToUser);</span><br><span class=\"line\">  mIsVisible = isVisibleToUser;</span><br><span class=\"line\">  onLazyLoad();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">onLazyLoad</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mIsPrepare) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始相关数据，以便于在滑动过程中能看到下一页有预处理数据</span></span><br><span class=\"line\">    initData();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mIsVisible) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 加载最终数据</span></span><br><span class=\"line\">      queryData(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","prev":{"title":"Android开发BroadcastReceiver详解","link":"posts/1505308407"},"next":{"title":"Android架构MVC、MVP和MVVM的区别","link":"posts/1488281963"},"plink":"https://blog.ixin.run/posts/1501243141/","toc":[{"id":"场景","title":"场景","index":"1"},{"id":"执行过程","title":"执行过程","index":"2","children":[{"id":"初始时","title":"初始时","index":"2.1"},{"id":"滑动到第二页","title":"滑动到第二页","index":"2.2"},{"id":"滑到最后一页","title":"滑到最后一页","index":"2.3"},{"id":"间接跳转","title":"间接跳转","index":"2.4"},{"id":"其余情况","title":"其余情况","index":"2.5"}]},{"id":"分析","title":"分析","index":"3"}],"reward":true,"copyright":{"author":"i猩人","link":"<a href=\"https://blog.ixin.run/posts/1501243141/\" title=\"Fragment实现懒加载之setUserVisibleHint探究\">https://blog.ixin.run/posts/1501243141/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}