{"title":"Android开发Handler消息机制探究","date":"2016-07-27T07:41:45.000Z","date_formatted":{"ll":"2016年7月27日","L":"2016/07/27","MM-DD":"07-27"},"link":"post/1469605305","comments":true,"tags":["线程间通信"],"categories":["Android"],"updated":"2021-01-14T08:08:54.887Z","content":"<p>我们知道一个应用启动时系统会为其创建一个进程，而每一个Activity启动的时候又会形成一个线程，这个线程叫主线程，又叫UI线程。Android的主线程是不安全的，因为从主线程中可以创建多个子线程来分配任务，一个activity的所有view都是唯一的，都有唯一的标识，如果在每个子线程中更新view，我们不能预知线程执行结果的先后顺序，也就无法预知什么时候才能更新view，所以造成结果就是view更新时的冲突问题。这也就是为什么从安卓2.0之后官方规定只能在主线程中更新界面了，子线程执行结果后通知主线程更新界面的桥梁便需要handler来帮忙，本篇深入探究一下handle的工作机制。</p>\n<a id=\"more\"></a>\n<h2 id=\"handler是什么\">Handler是什么<a title=\"#handler是什么\" href=\"#handler是什么\"></a></h2>\n<p>上边提到Android中子线程执行结果后需要通知主线程去更新界面，中间的桥梁就是handler，一句话说明白handler就是线程之间通信的桥梁。</p>\n<p>Handler重要有两个作用：</p>\n<ul>\n<li>在一个线程中发送消息。</li>\n<li>在另外一个线程中接收消息。</li>\n</ul>\n<h2 id=\"handler的使用\">Handler的使用<a title=\"#handler的使用\" href=\"#handler的使用\"></a></h2>\n<p>Handler类中包含如下方法用于发送和处理消息：</p>\n<ul>\n<li>void handlerMessage(Message msg)：处理消息的方法,该方法通常用于被重写。</li>\n<li>final boolean hasMessage(int what)：检查消息队列中是否包含what属性为指定值的消息。</li>\n<li>final boolean hasMessage(int what,Object object)：检查消息队列中是否包含what属性为指定且object属性为指定指定对象的消息。</li>\n<li>多个重载的obtainMessage()：从消息池中获取消息（消息池中没有则会重新生成一个，也可以用“Message.obtain()”来代替）</li>\n<li>sendEmptyMessage(int what)：发送空消息。</li>\n<li>final boolean sendEmptyMessageDelayed(int what,long delayMillis)：指定多少毫秒之后发送空消息。</li>\n<li>final boolean sendMessage(Message msg)：立即发送消息。</li>\n<li>final boolean sendMessageDelayed(Message msg,long delayMillis)：指定多少毫秒之后发送消息。</li>\n</ul>\n<p><strong>口说无凭，栗子先行</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Handler handler;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        <span class=\"keyword\">new</span> MyThread1().start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> MyThread2().start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>.run();</span><br><span class=\"line\"> </span><br><span class=\"line\">            Looper.prepare();</span><br><span class=\"line\"> </span><br><span class=\"line\">            handler = <span class=\"keyword\">new</span> Handler()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">super</span>.handleMessage(msg);</span><br><span class=\"line\">                    System.out.println( <span class=\"string\">&quot;threadName--&quot;</span> + Thread.currentThread().getName() + <span class=\"string\">&quot;messageWhat-&quot;</span>+ msg.what );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">            Looper.loop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread2</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>.run();</span><br><span class=\"line\"> </span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                sleep( <span class=\"number\">4000</span> );</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">            handler1.sendEmptyMessage(<span class=\"number\">0</span>) ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>眼尖的同学可能会看到创建Handler对象时上边下边分别来了一个“Looper.prepare()”、“Looper.loop()”，并且这两行去掉后程序直接报异常，但是我们平时在开发过程并没有写这两句也一样运行完好怎么回事呢？接下来通过Handler的工作原理为这些疑惑解开面纱。</p>\n<h2 id=\"handler的工作原理\">Handler的工作原理<a title=\"#handler的工作原理\" href=\"#handler的工作原理\"></a></h2>\n<p>为了更好的理解Handler的工作原理，先介绍一下与Handler一起工作的几个组件。</p>\n<ul>\n<li>Message: Handler接收和处理的消息对象。</li>\n<li>Looper:每个线程只能拥有一个Looper。它的loop方法负责读取MessageQueue中的消息，之后把消息交给发送该消息的Handler处理。</li>\n<li>MessageQueue:消息队列，使用先进先出的方式来管理Message。程序创建Looper对象时会在它的构造器中创建MessageQueue对象。</li>\n</ul>\n<p>Looper构造器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Looper</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mQueue = <span class=\"keyword\">new</span> MessageQueue();</span><br><span class=\"line\">    mRun = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    mThread = Thread.currentThread();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该构造器使用了private进行修饰，我们平时使用过程中不能直接通过此构造器创建一个实例。这个构造器同时也告诉我们在初始化Looper时会创建一个与之关联的MessageQueue，负责管理消息的存储队列。</p>\n<p>Handler主要作用就是发送消息和处理消息，Handler发送消息必须被送到指定线程的消息队列MessageQueue，所以在Handler创建之前必须要有一个属于该线程的MessageQueue的实例对象，而MessageQueue却是由Looper初始化时进行实例化的，所以在Handler创建之前必须要有一个该线程所属的Looper的存在，这就回归到之前所提的为什么要在Handler创建前后分别进行追加“Looper.prepare()”、“Looper.loop()”的疑惑了。</p>\n<h3 id=\"looper.prepare()\">Looper.prepare()<a title=\"#looper.prepare()\" href=\"#looper.prepare()\"></a></h3>\n<p>线程中创建Handler对象必须要先创建一个Looper，而我们自主创建Looper对象直接调用它的prepare()方法即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    prepare(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>prepare方法还有一个作用就是保证每个线程只有一个Looper对象，其原理就是从ThreadLocal中判断当前线程是否已经存在了一个Looper，如果有则抛出异常，告诉你Looper有了不用再创建了。针对ThreadLocal的认识，我后边也会重点研究一下。</p>\n<p>Android的UI更新必须在主线程。主UI线程中系统已经初始化了一个Looper对象，因此在主线程中直接new一个Handler对象即可，如果我们希望在子线程中创建Handler对象来更新UI，则需要传入主线程Looper：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Handler mainHandler = <span class=\"keyword\">new</span> Handler(Looper.getMainLooper());</span><br><span class=\"line\">mainHandler.post(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//在主线程中更新UI</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"消息的发送\">消息的发送<a title=\"#消息的发送\" href=\"#消息的发送\"></a></h3>\n<p>消息的发送是由Handler处理的，并且发送消息的形式有多样，但是最终都会走到一个<code>sendMessageAtTime</code>这个方法内：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageAtTime</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    MessageQueue queue = mQueue;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        RuntimeException e = <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">                <span class=\"keyword\">this</span> + <span class=\"string\">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class=\"line\">        Log.w(<span class=\"string\">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>handler在发送message的时候首先要找到handler所引用的消息队列，然后才把消息排在消息队列里。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(MessageQueue queue, Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    msg.target = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mAsynchronous) &#123;</span><br><span class=\"line\">        msg.setAsynchronous(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>准备存入消息队列的消息首先要先设定一个target，并且指向该handler自己，目的就是为了在处理消息环节中，Message能找到正确的Handler，以便准确的被抽取和向下分发。</p>\n<h3 id=\"looper.loop()\">Looper.loop()<a title=\"#looper.loop()\" href=\"#looper.loop()\"></a></h3>\n<p>“Looper.prepare()”是创建消息管理器和消息队列，而“Looper.loop()”则是对消息的依次抽取和分发。loop()方法使用一个死循环不断抽取MessageQueue中的消息，并将取出的消息分发给该消息对应的Handler进行处理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Run the message queue in this thread. Be sure to call</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #quit()&#125; to end the loop.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Looper me = myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (me == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Make sure the identity of this thread is that of the local process,</span></span><br><span class=\"line\">    <span class=\"comment\">// and keep track of what that identity token actually is.</span></span><br><span class=\"line\">    Binder.clearCallingIdentity();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ident = Binder.clearCallingIdentity();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Message msg = queue.next(); <span class=\"comment\">// might block</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// No message indicates that the message queue is quitting.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Printer logging = me.mLogging;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            logging.println(<span class=\"string\">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class=\"string\">&quot; &quot;</span> +</span><br><span class=\"line\">                    msg.callback + <span class=\"string\">&quot;: &quot;</span> + msg.what);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> traceTag = me.mTraceTag;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (traceTag != <span class=\"number\">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class=\"line\">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> start = (slowDispatchThresholdMs == <span class=\"number\">0</span>) ? <span class=\"number\">0</span> : SystemClock.uptimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> end;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            msg.target.dispatchMessage(msg);</span><br><span class=\"line\">            end = (slowDispatchThresholdMs == <span class=\"number\">0</span>) ? <span class=\"number\">0</span> : SystemClock.uptimeMillis();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (traceTag != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                Trace.traceEnd(traceTag);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slowDispatchThresholdMs &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> time = end - start;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; slowDispatchThresholdMs) &#123;</span><br><span class=\"line\">                Slog.w(TAG, <span class=\"string\">&quot;Dispatch took &quot;</span> + time + <span class=\"string\">&quot;ms on &quot;</span></span><br><span class=\"line\">                        + Thread.currentThread().getName() + <span class=\"string\">&quot;, h=&quot;</span> +</span><br><span class=\"line\">                        msg.target + <span class=\"string\">&quot; cb=&quot;</span> + msg.callback + <span class=\"string\">&quot; msg=&quot;</span> + msg.what);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logging != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            logging.println(<span class=\"string\">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class=\"string\">&quot; &quot;</span> + msg.callback);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Make sure that during the course of dispatching the</span></span><br><span class=\"line\">        <span class=\"comment\">// identity of the thread wasn&#x27;t corrupted.</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ident != newIdent) &#123;</span><br><span class=\"line\">            Log.wtf(TAG, <span class=\"string\">&quot;Thread identity changed from 0x&quot;</span></span><br><span class=\"line\">                    + Long.toHexString(ident) + <span class=\"string\">&quot; to 0x&quot;</span></span><br><span class=\"line\">                    + Long.toHexString(newIdent) + <span class=\"string\">&quot; while dispatching to &quot;</span></span><br><span class=\"line\">                    + msg.target.getClass().getName() + <span class=\"string\">&quot; &quot;</span></span><br><span class=\"line\">                    + msg.callback + <span class=\"string\">&quot; what=&quot;</span> + msg.what);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        msg.recycleUnchecked();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"消息的分发\">消息的分发<a title=\"#消息的分发\" href=\"#消息的分发\"></a></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Handle system messages here.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        handleCallback(msg);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        handleMessage(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这一步也算是最后一步消息即将传递到位，只等回调出来了。</p>\n<h2 id=\"注意\">注意<a title=\"#注意\" href=\"#注意\"></a></h2>\n<p>平时使用Handler过程中，我们要格外注意性能和内存泄漏问题。</p>\n<ol>\n<li>\n<p>消息发送有可能是很频繁的，每发送一条消息，我们就要创建一个Message对象，如果发送过快势必会不断的创建新对象导致内存消耗问题。所以我们平时创建对象一般不采用new的形式，而是从消息池中取出来一个“存在”的，有两种方式：</p>\n<ul>\n<li>Message msg = handler.obtainMessage();</li>\n<li>Message msg = Message.obtain();</li>\n</ul>\n</li>\n<li>\n<p>消息发送有可能是缓慢的，此时Handler会持有当前类的引用，这就导致内存无法及时回收进而内存泄漏。针对这个问题要三个手段进行配合最好：<br>\na. Handler定义采用静态内部类的形式定义，脱离类引用的束缚。<br>\nb. Handler内部引用当前类时采用弱引用形式引用，以便于及时回收。<br>\nc. 当前类销毁时取消一切Handler的消息发送。</p>\n</li>\n</ol>\n<p>以上是我对Handler的认识，不准确之处望各位同学指出。</p>\n","prev":{"title":"什么是进程，什么是线程","link":"post/1469682219"},"next":{"title":"JAVA设计模式之代理模式","link":"post/1465978376"},"plink":"https://blog.ixin.run/post/1469605305/","toc":[{"id":"handler是什么","title":"Handler是什么","index":"1"},{"id":"handler的使用","title":"Handler的使用","index":"2"},{"id":"handler的工作原理","title":"Handler的工作原理","index":"3","children":[{"id":"looper.prepare()","title":"Looper.prepare()","index":"3.1"},{"id":"消息的发送","title":"消息的发送","index":"3.2"},{"id":"looper.loop()","title":"Looper.loop()","index":"3.3"},{"id":"消息的分发","title":"消息的分发","index":"3.4"}]},{"id":"注意","title":"注意","index":"4"}],"reward":true,"copyright":{"custom":"转载请注明出处，谢谢支持。"}}