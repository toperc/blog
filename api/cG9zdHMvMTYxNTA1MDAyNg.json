{"title":"Android开发数据持久化有哪些形式","date":"2021-03-06T17:00:12.000Z","date_formatted":{"ll":"2021年3月7日","L":"2021/03/07","MM-DD":"03-07"},"link":"posts/1615050026","comments":true,"tags":["Android","数据持久化"],"categories":["Android"],"updated":"2021-03-10T01:15:14.488Z","content":"<p>Android数据持久化的形式最常用的有以下五种：</p>\n<ol>\n<li>使用SharedPreferences存储数据</li>\n<li>文件存储数据</li>\n<li>SQLite数据库存储数据</li>\n<li>使用ContentProvider存储数据</li>\n<li>网络存储数据</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"sharedpreferences\">SharedPreferences<a title=\"#sharedpreferences\" href=\"#sharedpreferences\"></a></h2>\n<p>SharedPreferences是Android系统提供的一种轻量级的数据存取方式，数据存取是通过键值对的形式，存放到xml中。xml文件的存放路径为：<code>/data/data/packageName/shared_prefs/目录</code>。</p>\n<h3 id=\"核心原理\">核心原理<a title=\"#核心原理\" href=\"#核心原理\"></a></h3>\n<p>SharedPreferences的本身实现就是分为两步，一步是内存，一部是磁盘，而主线程又依赖SharedPreferences的写入，所以可能当io成为瓶颈的时候，App会因为SharedPreferences变的卡顿，严重情况下会ANR，总结下来有以下几点：</p>\n<ul>\n<li>存放在xml文件中的数据会被装在到内存中，所以获取数据很快</li>\n<li>apply是异步操作，提交数据到内存，并不会马上提交到磁盘</li>\n<li>commit是同步操作，会等待数据写入到磁盘，并返回结果</li>\n<li>如果有同一个线程多次commit，则后面的要等待前面执行结束</li>\n<li>如果多个线程对同一个sp并发commit，后面的所有任务会进入到QueuedWork中排队执行，且都要等第一个执行完毕</li>\n</ul>\n<h3 id=\"几宗罪\">几宗罪<a title=\"#几宗罪\" href=\"#几宗罪\"></a></h3>\n<ol>\n<li>跨进程不安全。由于没有使用跨进程的锁，就算使用 MODE_MULTI_PROCESS，SharedPreferences 在跨进程频繁读写有可能导致数据全部丢失。根据线上统计，SharedPreferences 大约会有万分之一的损坏率。</li>\n<li>加载缓慢。SharedPreferences 文件的加载使用了异步线程，而且加载线程并没有设置优先级，如果这个时候读取数据就需要等待文件加载线程的结束。这就导致主线程等待低优先线程锁的问题，比如一个 100KB 的 SP 文件读取等待时间大约需要 50 ~ 100ms，并且建议大家提前用预加载启动过程用到的 SP 文件。</li>\n<li>全量写入。无论是 commit() 还是 apply()，即使我们只改动其中一个条目，都会把整个内容全部写到文件。而且即使我们多次写同一个文件，SP 也没有将多次修改合并为一次，这也是性能差的重要原因之一。</li>\n<li>卡顿。由于提供了异步落盘的 apply 机制，在崩溃或者其它一些异常情况可能会导致数据丢失。所以当应用收到系统广播，或者被调用 onPause 等一些时机，系统会强制把所有的 SharedPreferences 对象的数据落地到磁盘。如果没有落地完成，这时候主线程会被一直阻塞。这样非常容易造成卡顿，甚至是ANR，从线上数据来看 SP 卡顿占比一般会超过 5%。</li>\n</ol>\n<h3 id=\"优化建议\">优化建议<a title=\"#优化建议\" href=\"#优化建议\"></a></h3>\n<ol>\n<li>不要存放大的 key 或 value 在 SharedPreferences 中，否则会一直存储在内存中（Map 容器中）得不到释放，内存使用过高会频繁引发 GC，导致界面丢帧甚至 ANR。</li>\n<li>不相关的配置选项最好不要放在一起，单个文件越大加载时间越长。（参照 SharedPreferences 初始化时会开启异步线程读取对应文件，如果此时耗时较长，当对其进行相关数据操作时会导致线程等待）</li>\n<li>读取频繁的 key 和 不频繁的 key 尽量不要放在一起。（如果整个文件本身就较小则可以忽略）</li>\n<li>不要每次都 edit 操作，每次 edit 都会创建新的 EditorImpl 对象，最好批量处理统一提交。否则每次 edit().commit() 都会创建新的 EditorImpl 对象并进行一次 I/O 操作，严重影响性能。</li>\n<li>commit 提交发生在 UI 线程，apply 提交发生在工作线程，对于数据的提交最好是批量操作统一提交。虽然 apply 任务发生在工作线程（不会因为 I/O 阻塞 UI 线程），但是如果添加过多任务也有可能带来其它”严重后果“（参照系统源码 ActivityThread - handlePauseActivity 方法实现）。</li>\n<li>尽量不要存放 JSON 或 HTML 类型数据，这种可以直接文件存储。</li>\n<li>最好能够提前初始化 SharedPreferences，避免 SharedPreferences 第一次创建时读取文件内容线程未结束而出现的等待情况，参照优化点第 2 条。</li>\n<li>不要指望它能够跨进程通信：Context.MODE_MULTI_PROCESS。</li>\n</ol>\n<h2 id=\"文件存储数据\">文件存储数据<a title=\"#文件存储数据\" href=\"#文件存储数据\"></a></h2>\n<p>在很多情况下，您的应用会创建其他应用不需要访问或不应访问的文件。系统提供以下位置，用于存储此类应用专属文件：</p>\n<ul>\n<li><strong>内部存储空间目录</strong>：这些目录既包括用于存储持久性文件的专属位置，也包括用于存储缓存数据的其他位置。系统会阻止其他应用访问这些位置，并且在 Android 10（API 级别 29）及更高版本中，系统会对这些位置进行加密。这些特征使得这些位置非常适合存储只有应用本身才能访问的敏感数据。\n<ul>\n<li>getFilesDir()，<code>data/data/com.companyname.appname/files/ </code>，用于持久文件</li>\n<li>getCacheDir()，<code>data/data/com.companyname.appname/cache/ </code>，用于暂存文件</li>\n</ul>\n</li>\n<li><strong>外部存储空间目录</strong>：这些目录既包括用于存储持久性文件的专属位置，也包括用于存储缓存数据的其他位置。虽然其他应用可以在具有适当权限的情况下访问这些目录，但存储在这些目录中的文件仅供您的应用使用。如果您明确打算创建其他应用能够访问的文件，您的应用应改为将这些文件存储在外部存储空间的<a href=\"https://developer.android.com/training/data-storage/shared?hl=zh-cn\" target=\"_blank\">共享存储空间</a>部分。\n<ul>\n<li>getExternalFilesDir()，<code>/mnt/sdcard/Android/data/com.companyname.appname/files/ </code>，用于持久文件文件</li>\n<li>getExternalCacheDir()，<code>/mnt/sdcard/Android/data/com.companyname.appname/cache/</code>，用于暂存文件</li>\n</ul>\n</li>\n</ul>\n<p>以上方式都是针对该应用，一旦应用卸载，这些文件也就不复存在了，如果想要长久保存，可存储到外置SD卡其他地方，参见<a href=\"https://developer.android.com/training/data-storage/shared?hl=zh-cn\" target=\"_blank\">共享存储空间</a>。</p>\n<h3 id=\"java常规读写\">Java常规读写<a title=\"#java常规读写\" href=\"#java常规读写\"></a></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从SD卡中读取文件</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">readFromSD</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">        String content = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        ByteArrayOutputStream ops = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        FileInputStream fis = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) &#123;</span><br><span class=\"line\">                File file = <span class=\"keyword\">new</span> File(filePath);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (file.exists()) &#123;</span><br><span class=\"line\">                    fis = <span class=\"keyword\">new</span> FileInputStream(file);</span><br><span class=\"line\">                    ops = <span class=\"keyword\">new</span> ByteArrayOutputStream();</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">byte</span>[] data = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> ((len = fis.read(data)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        ops.write(data, <span class=\"number\">0</span>, len);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    content = <span class=\"keyword\">new</span> String(ops.toByteArray());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            LoggerUtil.e(e.toString());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ops != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    ops.close();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fis != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    fis.close();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 写文件到SD卡</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> append 是否追加写入</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">writeFile</span><span class=\"params\">(String filePath, String content, <span class=\"keyword\">boolean</span> append)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        FileOutputStream fos = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) &#123;</span><br><span class=\"line\">                File file = <span class=\"keyword\">new</span> File(Environment.getExternalStorageDirectory(), filePath);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!file.exists()) &#123;</span><br><span class=\"line\">                    createNewFile(file);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                fos = <span class=\"keyword\">new</span> FileOutputStream(file, append);</span><br><span class=\"line\">                fos.write(content.getBytes());</span><br><span class=\"line\">                flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            LoggerUtil.e(e.toString());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fos != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    fos.close();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> flag;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"android私有文件读写\">Android私有文件读写<a title=\"#android私有文件读写\" href=\"#android私有文件读写\"></a></h3>\n<p>Context提供了两个方法来打开数据文件里的文件IO流：</p>\n<ul>\n<li>openFileInput(String name)，读文件</li>\n<li>openFileOutput(String name, int mode)，写文件</li>\n</ul>\n<p>其中openFileOutput的第二个参数指定打开文件的模式：</p>\n<ul>\n<li>MODE_PRIVATE，默认操作模式 ，当指定同样文件名的时候会覆盖原有文件内容。</li>\n<li>MODE_APPEND，如果文件不存在就创建文件，如果存在就往后面追加。</li>\n<li>MODE_WORLD_READABLE，允许其他程序对我们的文件进行修改，过于危险 Android4.2以后已被废除。</li>\n<li>MODE_WORLD_WRITEABLE，允许其他程序对我们的文件进行修改，过于危险 Android4.2以后已被废除。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">read</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            FileInputStream inStream = <span class=\"keyword\">this</span>.openFileInput(<span class=\"string\">&quot;message.txt&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> hasRead = <span class=\"number\">0</span>;</span><br><span class=\"line\">            StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((hasRead = inStream.read(buffer)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                sb.append(<span class=\"keyword\">new</span> String(buffer, <span class=\"number\">0</span>, hasRead));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            inStream.close();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(String msg)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 步骤1：获取输入值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(msg == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 步骤2:创建一个FileOutputStream对象,MODE_APPEND追加模式</span></span><br><span class=\"line\">            FileOutputStream fos = openFileOutput(<span class=\"string\">&quot;message.txt&quot;</span>,</span><br><span class=\"line\">                    MODE_APPEND);</span><br><span class=\"line\">            <span class=\"comment\">// 步骤3：将获取过来的值放入文件</span></span><br><span class=\"line\">            fos.write(msg.getBytes());</span><br><span class=\"line\">            <span class=\"comment\">// 步骤4：关闭数据流</span></span><br><span class=\"line\">            fos.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"android-q-沙盒模式\">Android Q 沙盒模式<a title=\"#android-q-沙盒模式\" href=\"#android-q-沙盒模式\"></a></h3>\n<p>为了让用户更好地管理自己的文件并减少混乱，以 Android 10（Android Q，API 级别 29）及更高版本为目标平台的应用在默认情况下被授予了对外部存储空间的分区访问权限（即<a href=\"https://developer.android.com/training/data-storage?hl=zh-cn#scoped-storage\" target=\"_blank\">分区存储(沙盒模式)</a>）。启用分区存储后，应用将无法访问属于其他应用的应用专属目录。另外，AndroidQ中不支持file://类型访问文件，只能通过uri方式访问。</p>\n<h2 id=\"sqlite数据库存储数据\">SQLite数据库存储数据<a title=\"#sqlite数据库存储数据\" href=\"#sqlite数据库存储数据\"></a></h2>\n<p>SQLite是轻量级嵌入式数据库引擎，它支持 SQL 语言，并且只利用很少的内存就有很好的性能。现在的主流移动设备像Android、iPhone等都使用SQLite作为复杂数据的存储引擎，在我们为移动设备开发应用程序时，也许就要使用到SQLite来存储我们大量的数据，所以我们就需要掌握移动设备上的SQLite开发技巧。详细使用可参阅我之前总结的一篇文章<a href=\"https://blog.ixin.run/posts/1615050026\" target=\"_blank\">《Android开发之SQLite使用详解》</a></p>\n<p>相关ORM框架：</p>\n<ul>\n<li>greendao，已经停更</li>\n<li>room，官方jitpack推荐</li>\n</ul>\n<h2 id=\"contentprovider存储数据\">ContentProvider存储数据<a title=\"#contentprovider存储数据\" href=\"#contentprovider存储数据\"></a></h2>\n<p><strong>ContentProvider内容提供器，主要用于在不同应用程序之间实现数据的共享功能</strong>。</p>\n<p>举例来说，我们开发一个应用程序，我们不可能只使用自己的数据，也会用到其他应用的数据，像手机中的通讯录联系人，图片，音乐等是使用到最多的。我们使用的SharedPreferences，文件存储以及数据库SQLite都是从存储的应用内部的数据，实现不同应用间的数据共享就要使用到ContentProvider。</p>\n<p>ContentProvider使用方法有两种：</p>\n<ul>\n<li>使用现有的内容提供器来读取和操作相应程序中的数据</li>\n<li>创建自己的内容提供器给我们的应用提供外部访问接口</li>\n</ul>\n<p>详细使用可参阅我之前总结的一篇文章<a href=\"https://blog.ixin.run/posts/1552144290\" target=\"_blank\">《Android开发ContentProvider学习总结》</a></p>\n<h2 id=\"网络存储数据\">网络存储数据<a title=\"#网络存储数据\" href=\"#网络存储数据\"></a></h2>\n<p>通过网络提供的存储空间来存储、获取数据信息。这块不用细说了。</p>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/5fcef7f68341\">https://www.jianshu.com/p/5fcef7f68341</a></li>\n<li><a href=\"https://developer.android.com/training/data-storage/app-specific?hl=zh-cn\">https://developer.android.com/training/data-storage/app-specific?hl=zh-cn</a></li>\n</ul>\n","prev":{"title":"你了解android的进程间通信吗","link":"posts/1615119064"},"next":{"title":"Android开发Style和Theme知识面总结","link":"posts/1614958762"},"plink":"https://blog.ixin.run/posts/1615050026/","toc":[{"id":"sharedpreferences","title":"SharedPreferences","index":"1","children":[{"id":"核心原理","title":"核心原理","index":"1.1"},{"id":"几宗罪","title":"几宗罪","index":"1.2"},{"id":"优化建议","title":"优化建议","index":"1.3"}]},{"id":"文件存储数据","title":"文件存储数据","index":"2","children":[{"id":"java常规读写","title":"Java常规读写","index":"2.1"},{"id":"android私有文件读写","title":"Android私有文件读写","index":"2.2"},{"id":"android-q-沙盒模式","title":"Android Q 沙盒模式","index":"2.3"}]},{"id":"sqlite数据库存储数据","title":"SQLite数据库存储数据","index":"3"},{"id":"contentprovider存储数据","title":"ContentProvider存储数据","index":"4"},{"id":"网络存储数据","title":"网络存储数据","index":"5"},{"id":"参考","title":"参考","index":"6"}],"reward":true,"copyright":{"author":"i猩人","link":"<a href=\"https://blog.ixin.run/posts/1615050026/\" title=\"Android开发数据持久化有哪些形式\">https://blog.ixin.run/posts/1615050026/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}