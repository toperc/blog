{"title":"Stream流式编程实现原理","date":"2021-02-17T17:09:06.000Z","date_formatted":{"ll":"2021年2月18日","L":"2021/02/18","MM-DD":"02-18"},"link":"posts/1613581746","comments":true,"tags":["Java","Stream","流式编程"],"categories":["Java"],"updated":"2021-02-24T13:38:29.600Z","content":"<p>上一篇《<a href=\"https://blog.ixin.run/posts/1613575203\" target=\"_blank\">Stream流式编程知识总结</a>》我们主要针对Stream流式编程的具体使用方法进行了深入的探讨，但是如果再来一个一问三连<code>what?-why?-then?</code>是不是又开始懵比了，哈哈，本文就运用一问三连的形式来进行争取不那么麻烦的解释Stream流式编程的实现原理。</p>\n<a id=\"more\"></a>\n<p>Java8新特性系列：</p>\n<ul>\n<li><a href=\"https://blog.ixin.run/posts/1613545058\" target=\"_blank\">《Lambda表达式你会吗》</a></li>\n<li><a href=\"https://blog.ixin.run/posts/1613575203\" target=\"_blank\">《Stream流式编程知识总结》</a></li>\n<li><a href=\"https://blog.ixin.run/posts/1613581746\" target=\"_blank\">《Stream流式编程实现原理》</a></li>\n</ul>\n<h2 id=\"stream怎么用\">Stream怎么用<a title=\"#stream怎么用\" href=\"#stream怎么用\"></a></h2>\n<p>其实上篇已经讲过，Stream没用之前我们针对集合的便利帅选等操作更多的是<code>for-loop/while-loop</code>，用了Stream后发现原来代码可以如此简洁，并且越发形似SQL语句。甚至可以做很多复杂的动作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ap&lt;Integer, List&lt;String&gt;&gt; lowCaloricDishesNameGroup = </span><br><span class=\"line\">    dishes.parallelStream() <span class=\"comment\">// 开启并行处理</span></span><br><span class=\"line\">          .filter(d -&gt; d.getCalories() &lt; <span class=\"number\">400</span>) <span class=\"comment\">// 按照热量值进行筛选</span></span><br><span class=\"line\">          .sorted(comparing(Dish::getCalories)) <span class=\"comment\">// 按照热量进行排序</span></span><br><span class=\"line\">          .collect(Collectors.groupingBy( <span class=\"comment\">// 将菜品名按照热量进行分组</span></span><br><span class=\"line\">              Dish::getCalories, </span><br><span class=\"line\">              Collectors.mapping(Dish::getName, Collectors.toList())</span><br><span class=\"line\">          ));</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/41D52330A36E4E089DD469EDFA848FAE?method=download&amp;shareKey=21e4b94ad2bac447a2a6b6babad1cd33\" alt=\"Stream流式编程过滤操作哈哈图\" class=\"φbs\"></p>\n<h2 id=\"stream的操作分类\">Stream的操作分类<a title=\"#stream的操作分类\" href=\"#stream的操作分类\"></a></h2>\n<p>Stream使用一种类似SQL语句的方式，提供对集合运算的高阶抽象，可以将其处理的元素集合看做一种数据流，流在管道中传输，数据在管道节点上进行处理，比如筛选、排序、聚合等。<br>\n数据流在管道中经过中间操作(intermediate operation)处理，由终止操作(terminal operation)得到前面处理的结果。这些也在《<a href=\"https://blog.ixin.run/posts/1613575203\" target=\"_blank\">Stream流式编程知识总结</a>》有相应的说明。</p>\n<p>Stream操作分为两类：</p>\n<ul>\n<li>\n<p><strong>中间操作</strong>：将流一层层的进行处理，并向下一层进行传递，如 filter map sorted等。<br>\n中间操作又分为<code>有状态(stateful)</code>及<code>无状态(stateless)</code></p>\n<ul>\n<li>有状态：必须等上一步操作完拿到全部元素后才可操作，如sorted</li>\n<li>无状态：该操作的数据不收上一步操作的影响，如filter map</li>\n</ul>\n</li>\n<li>\n<p><strong>终止操作</strong>：触发数据的流动，并收集结果，如collect findFirst forEach等。终止操作又分为<code>短路操作(short-circuiting)</code>及<code>非短路操作(non-short-circuiting)</code></p>\n<ul>\n<li>短路操作：会在适当的时刻终止遍历，类似于break，如anyMatch findFirst等</li>\n<li>非短路操作：会遍历所有元素，如collect max等</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/15F8B355D4E543FBA79C0061434D30FF?method=download&amp;shareKey=0cde1a6fa284f693439d9e37e88ed39d\" alt=\"Stream相关操作符分类\" class=\"φbs\"></p>\n<h2 id=\"stream的实现过程\">Stream的实现过程<a title=\"#stream的实现过程\" href=\"#stream的实现过程\"></a></h2>\n<p>Stream的实现使用流水线（pipelining）的方式巧妙的避免了多次迭代，其基本思想是在一次迭代中尽可能多的执行用户指定的操作。</p>\n<p>Stream采用某种方式记录用户每一步的操作，中间操作会返回流对象，多个操作最终串联成一个管道，管道并不直接操作数据，当用户调用终止操作时将之前记录的操作叠加到一起，尽可能地在一次迭代中全部执行掉，面对如此简洁高效的API不由得使我们有所疑问：</p>\n<ul>\n<li>用户的操作如何记录？</li>\n<li>操作如何叠加？</li>\n<li>叠加后的操作如何执行？</li>\n<li>执行后的结果（如果有）在哪里？</li>\n</ul>\n<h3 id=\"操作如何记录\">操作如何记录<a title=\"#操作如何记录\" href=\"#操作如何记录\"></a></h3>\n<p>Stream中使用Stage的概念来描述一个完整的操作，并用某种实例化后的PipelineHelper来代表Stage，将各Pipeline按照先后顺序连接到一起，就构成了整个流水线。</p>\n<p>与Stream相关类和接口的继承关系如下图，其中蓝色表示继承关系，绿色表示接口实现：</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/5040F2D1240B4D629B9160155F7D3DC5?method=download&amp;shareKey=9bb7c9b516262c598f78a17f62008a3f\" alt=\"Stream相关类和接口的继承关系图\" class=\"φbs\"></p>\n<p>Head用于表示第一个Stage，该Stage不包含任何操作。StatelessOp和StatefulOp分别表示无状态和有状态的Stage。</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/E19359ABF555470280846F3A5B6673EE?method=download&amp;shareKey=dbb8a3d61565e4f2b93c08596f1dba48\" alt=\"Stream流水线组织结构示意图\" class=\"φbs\"></p>\n<p>其中：</p>\n<ul>\n<li>Head记录Stream起始操作，将包装为Spliterator的原始数据存放在Stage中</li>\n<li>StatelessOp记录无状态的中间操作</li>\n<li>StatefulOp记录有状态的中间操作</li>\n<li>TerminalOp用于触发数据数据在各Stage间的流动及处理，并收集最终数据(如果有)</li>\n</ul>\n<p>使用<code>Collection.stream</code>、<code>Arrays.stream</code>或<code>Stream.of</code>等接口会生成Head，其内部均采用<code>StreamSupport.stream</code>方法，将原始数据包装为<code>Spliterator</code>存放在Stage中。</p>\n<p>Head、StatelessOp、StatefulOp三个操作实例化会指向其父类AbstractPipeline。</p>\n<p>对于Head：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Constructor for the head of a stream pipeline.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> source &#123;<span class=\"doctag\">@code</span> Spliterator&#125; describing the stream source</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> sourceFlags the source flags for the stream source, described in</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> StreamOpFlag&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> parallel &#123;<span class=\"doctag\">@code</span> true&#125; if the pipeline is parallel</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">AbstractPipeline(Spliterator&lt;?&gt; source, <span class=\"keyword\">int</span> sourceFlags, <span class=\"keyword\">boolean</span> parallel) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.previousStage = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sourceSpliterator = source;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sourceStage = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sourceOrOpFlags = sourceFlags &amp; StreamOpFlag.STREAM_MASK;</span><br><span class=\"line\">    <span class=\"comment\">// The following is an optimization of:</span></span><br><span class=\"line\">    <span class=\"comment\">// StreamOpFlag.combineOpFlags(sourceOrOpFlags, StreamOpFlag.INITIAL_OPS_VALUE);</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.combinedFlags = (~(sourceOrOpFlags &lt;&lt; <span class=\"number\">1</span>)) &amp; StreamOpFlag.INITIAL_OPS_VALUE;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.depth = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.parallel = parallel;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Head操作会将包装为Spliterator的原始数据存放在该Stage中，将自身存放sourceStage中，并把<code>串并行操作</code>也记录在内。Head的前期功能就是记录这些源数据。</p>\n<p>对于StatelessOp及StatefulOp：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Constructor for appending an intermediate operation stage onto an</span></span><br><span class=\"line\"><span class=\"comment\"> * existing pipeline.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> previousStage the upstream pipeline stage</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> opFlags the operation flags for the new stage, described in</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> StreamOpFlag&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">AbstractPipeline(AbstractPipeline&lt;?, E_IN, ?&gt; previousStage, <span class=\"keyword\">int</span> opFlags) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (previousStage.linkedOrConsumed)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(MSG_STREAM_LINKED);</span><br><span class=\"line\">    previousStage.linkedOrConsumed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    previousStage.nextStage = <span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.previousStage = previousStage;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sourceOrOpFlags = opFlags &amp; StreamOpFlag.OP_MASK;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sourceStage = previousStage.sourceStage;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (opIsStateful())</span><br><span class=\"line\">        sourceStage.sourceAnyStateful = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.depth = previousStage.depth + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>中间操作通过previousStage及nextStage，将各Stage串联为一个双向链表，使得每一步都知道上一步与下一步的操作。</p>\n<p>每一个中间操作Stage中的sourceStage都指向前一个Stage的soureStage，如此递归，最终指向Head。卧槽，似乎是不是明白些啥了，接着往下看吧，现在仅仅是第一阶段。</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/482B4BBE20E34B0FA8EA7911020662AC?method=download&amp;shareKey=96466bdd34795d8d342495fae0a9ae61\" alt=\"Stage记录操作双链表结构示意图\" class=\"φbs\"></p>\n<h3 id=\"操作如何叠加\">操作如何叠加<a title=\"#操作如何叠加\" href=\"#操作如何叠加\"></a></h3>\n<p>上一个问题解决了每一步操作数据源以及内部实现是怎么记录的，此时并没有执行，Stage只是保存了当前的操作，并不能确定下一个Stage需要何种操作，所以想要让pipeline运行起来，需要一种将所有操作叠加到一起的方案。</p>\n<p>Stream类库采用了<code>Sink接口</code>来协调各Stage之间的关系：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Sink</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Consumer</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Resets the sink state to receive a fresh data set.  This must be called</span></span><br><span class=\"line\"><span class=\"comment\">     * before sending any data to the sink.  After calling &#123;<span class=\"doctag\">@link</span> #end()&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">     * you may call this method to reset the sink for another calculation.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> size The exact size of the data to be pushed downstream, if</span></span><br><span class=\"line\"><span class=\"comment\">     * known or &#123;<span class=\"doctag\">@code</span> -1&#125; if unknown or infinite.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;Prior to this call, the sink must be in the initial state, and after</span></span><br><span class=\"line\"><span class=\"comment\">     * this call it is in the active state.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 开始遍历前调用，通知Sink做好准备</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">begin</span><span class=\"params\">(<span class=\"keyword\">long</span> size)</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Indicates that all elements have been pushed.  If the &#123;<span class=\"doctag\">@code</span> Sink&#125; is</span></span><br><span class=\"line\"><span class=\"comment\">     * stateful, it should send any stored state downstream at this time, and</span></span><br><span class=\"line\"><span class=\"comment\">     * should clear any accumulated state (and associated resources).</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;Prior to this call, the sink must be in the active state, and after</span></span><br><span class=\"line\"><span class=\"comment\">     * this call it is returned to the initial state.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 所有元素遍历完成后调用，通知Sink没有更多元素了</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">end</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Indicates that this &#123;<span class=\"doctag\">@code</span> Sink&#125; does not wish to receive any more data.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@implSpec</span> The default implementation always returns false.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true if cancellation is requested</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 是否可以结束操作，可以让短路操作尽早结束</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">boolean</span> <span class=\"title\">cancellationRequested</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Accepts a value.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@implSpec</span> The default implementation throws IllegalStateException.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> IllegalStateException if this sink does not accept values</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 遍历时调用，接收的一个待处理元素，并对元素进行处理。</span></span><br><span class=\"line\"><span class=\"comment\">     * Stage把自己包含的操作和回调方法封装到该方法里，前一个Stage只需要调用当前</span></span><br><span class=\"line\"><span class=\"comment\">     * Stage.accept方法即可</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(T value)</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其实Stream的各种操作实现的本质，就是如何重载Sink的这四个接口方法，各个操作通过Sink接口accept方法依次向下传递执行。</p>\n<p>下面结合具体源码来理解Stage是如何将自身的操作包装成Sink，以及Sink是如何将处理结果转发给下一个Sink的。</p>\n<p>无状态Stage（Stream.map）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Stream.map 将生成一个新Stream</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> &lt;R&gt; <span class=\"function\">Stream&lt;R&gt; <span class=\"title\">map</span><span class=\"params\">(Function&lt;? <span class=\"keyword\">super</span> P_OUT, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class=\"line\">    Objects.requireNonNull(mapper);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> StatelessOp&lt;P_OUT, R&gt;(<span class=\"keyword\">this</span>, StreamShape.REFERENCE,</span><br><span class=\"line\">                                 StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 该方法将回调函数(处理逻辑)包装成Sink</span></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\">Sink&lt;P_OUT&gt; <span class=\"title\">opWrapSink</span><span class=\"params\">(<span class=\"keyword\">int</span> flags, Sink&lt;R&gt; sink)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Sink.ChainedReference&lt;P_OUT, R&gt;(sink) &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(P_OUT u)</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 接收数据，使用当前包装的回调函数处理数据，并传递给下游Sink</span></span><br><span class=\"line\">                    downstream.accept(mapper.apply(u));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有状态Stage（Stream.sorted）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RefSortingSink</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractRefSortingSink</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存放用于排序的元素</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ArrayList&lt;T&gt; list;</span><br><span class=\"line\"></span><br><span class=\"line\">    RefSortingSink(Sink&lt;? <span class=\"keyword\">super</span> T&gt; sink, Comparator&lt;? <span class=\"keyword\">super</span> T&gt; comparator) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(sink, comparator);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">begin</span><span class=\"params\">(<span class=\"keyword\">long</span> size)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size &gt;= Nodes.MAX_ARRAY_SIZE)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(Nodes.BAD_SIZE);</span><br><span class=\"line\">        <span class=\"comment\">// 创建用于存放排序元素的列表</span></span><br><span class=\"line\">        list = (size &gt;= <span class=\"number\">0</span>) ? <span class=\"keyword\">new</span> ArrayList&lt;T&gt;((<span class=\"keyword\">int</span>) size) : <span class=\"keyword\">new</span> ArrayList&lt;T&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">end</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 只有在接收到所有元素后才开始排序</span></span><br><span class=\"line\">        list.sort(comparator);</span><br><span class=\"line\">        downstream.begin(list.size());</span><br><span class=\"line\">        <span class=\"comment\">// 排序完成后，将数据传递给下游Sink</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cancellationWasRequested) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 下游Sink不包含短路操作，将数据依次传递给下游Sink</span></span><br><span class=\"line\">            list.forEach(downstream::accept);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 下游Sink包含短路操作</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (T t : list) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 对于每一个元素，都要询问是否可以结束处理</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (downstream.cancellationRequested()) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 将元素传递给下游Sink</span></span><br><span class=\"line\">                downstream.accept(t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 告知下游Sink数据传递完毕</span></span><br><span class=\"line\">        downstream.end();</span><br><span class=\"line\">        list = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 依次将需要排序的元素加入到临时列表中</span></span><br><span class=\"line\">        list.add(t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Stream.sorted会在接收到所有元素之后再进行排序，之后才开始将数据依次传递给下游Sink。</p>\n<p>两个操作之间通过Sink接口的accept方法进行挂钩，此时如果从<code>第一个Sink</code>开始执行accept方法便可以把整个管道流动起来，但是这个“如果”怎么实现呢？另外记着每一个操作中的<code>opWrapSink</code>是用于包装Sink的，也就是说只有包装后的Sink才具有条件使得整个管道流动起来。</p>\n<h3 id=\"叠加后的操作如何执行\">叠加后的操作如何执行<a title=\"#叠加后的操作如何执行\" href=\"#叠加后的操作如何执行\"></a></h3>\n<p>终止操作(TerminalOp)之后不能再有别的操作，终止操作会创建一个包装了自己操作的Sink，这个Sink只处理数据而不会将数据传递到下游Sink（没有下游了）。</p>\n<p>在调用Stream的终止操作时，会执行AbstractPipeline.evaluate：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Evaluate the pipeline with a terminal operation to produce a result.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &lt;R&gt; the type of result</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> terminalOp the terminal operation to be applied to the pipeline.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the result</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> &lt;R&gt; <span class=\"function\">R <span class=\"title\">evaluate</span><span class=\"params\">(TerminalOp&lt;E_OUT, R&gt; terminalOp <span class=\"comment\">/* 各种终止操作 */</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">assert</span> <span class=\"title\">getOutputShape</span><span class=\"params\">()</span> </span>== terminalOp.inputShape();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (linkedOrConsumed)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(MSG_STREAM_LINKED);</span><br><span class=\"line\">    linkedOrConsumed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> isParallel()</span><br><span class=\"line\">           ? terminalOp.evaluateParallel(<span class=\"keyword\">this</span>, sourceSpliterator(terminalOp.getOpFlags())) <span class=\"comment\">/* 并发执行 */</span></span><br><span class=\"line\">           : terminalOp.evaluateSequential(<span class=\"keyword\">this</span>, sourceSpliterator(terminalOp.getOpFlags())); <span class=\"comment\">/* 串行执行 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终会根据并行还是串行执行TerminalOp中不同的的evaluate方法。如果是串行执行，接下来在TerminalOp的evaluate方法中会调用wrapAndCopyInto来包装、串联各层Sink，触发pipeline，并获取最终结果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> &lt;P_IN, S extends Sink&lt;E_OUT&gt;&gt; <span class=\"function\">S <span class=\"title\">wrapAndCopyInto</span><span class=\"params\">(S sink <span class=\"comment\">/* TerminalSink */</span>, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class=\"line\">    copyInto(wrapSink(Objects.requireNonNull(sink)), spliterator);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sink;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中wrapSink（包装）实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> &lt;P_IN&gt; <span class=\"function\">Sink&lt;P_IN&gt; <span class=\"title\">wrapSink</span><span class=\"params\">(Sink&lt;E_OUT&gt; sink)</span> </span>&#123;</span><br><span class=\"line\">    Objects.requireNonNull(sink);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// AbstractPipeline.this，最后一层Stage</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"meta\">@SuppressWarnings(&quot;rawtypes&quot;)</span> AbstractPipeline p=AbstractPipeline.<span class=\"keyword\">this</span>; p.depth &gt; <span class=\"number\">0</span>; p=p.previousStage) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从下游向上游遍历，不断包装Sink</span></span><br><span class=\"line\">        sink = p.opWrapSink(p.previousStage.combinedFlags, sink <span class=\"comment\">/* 下一层Stage的Sink */</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (Sink&lt;P_IN&gt;) sink;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>wrapSink方法通过下游Stage的“opWrapSink”方法不断将下游Stage的Sink<code>从下游向上游</code>遍历包装，最终得到上文我说的<code>第一个Sink</code>。</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/EABBFE1758434C83BF1FDBC8204B3005?method=download&amp;shareKey=6622e352ddfccc2b67f8bbb8bd6d0499\" alt=\"Sink包装执行链\" class=\"φbs\"></p>\n<p>有了第一个Sink，如何执行呢，还记的<code>wrapAndCopyInto</code>中的<code>copyInto</code>吧：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> &lt;P_IN&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">copyInto</span><span class=\"params\">(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class=\"line\">    Objects.requireNonNull(wrappedSink);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不包含短路操作</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 1. begin</span></span><br><span class=\"line\">        wrappedSink.begin(spliterator.getExactSizeIfKnown());</span><br><span class=\"line\">        <span class=\"comment\">// 2. 遍历调用 sink.accept</span></span><br><span class=\"line\">        spliterator.forEachRemaining(wrappedSink);</span><br><span class=\"line\">        <span class=\"comment\">// 3. end</span></span><br><span class=\"line\">        wrappedSink.end();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 包含短路操作</span></span><br><span class=\"line\">        copyIntoWithCancel(wrappedSink, spliterator);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> &lt;P_IN&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">copyIntoWithCancel</span><span class=\"params\">(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class=\"line\">    AbstractPipeline p = AbstractPipeline.<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p.depth &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        p = p.previousStage;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 1. begin</span></span><br><span class=\"line\">    wrappedSink.begin(spliterator.getExactSizeIfKnown());</span><br><span class=\"line\">    <span class=\"comment\">// 2. 遍历调用 sink.accept</span></span><br><span class=\"line\">    <span class=\"comment\">//    每一次遍历都询问cancellationRequested结果</span></span><br><span class=\"line\">    <span class=\"comment\">//    如果cancellationRequested为true，则中断遍历</span></span><br><span class=\"line\">    p.forEachWithCancel(spliterator, wrappedSink);</span><br><span class=\"line\">    <span class=\"comment\">// 3. end</span></span><br><span class=\"line\">    wrappedSink.end();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>copyInto会根据不同的情况依次调用：</p>\n<ul>\n<li>sink.bigin</li>\n<li>sink.accept（遍历调用，如果包含短路操作，则每次遍历都需要询问cancellationRequested，适时中断遍历）</li>\n<li>sink.end</li>\n</ul>\n<h3 id=\"执行结果在哪儿\">执行结果在哪儿<a title=\"#执行结果在哪儿\" href=\"#执行结果在哪儿\"></a></h3>\n<p>每一种TerminalSink中均会提供一个获取最终结果的方法：</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/FA4F5C375278499DBAC7315D32138C98?method=download&amp;shareKey=6412d45f1ed8b8b2333ffae144845301\" alt=\"各种TerminalSink获取最终结果图示\" class=\"φbs\"></p>\n<p>TerminalOp通过调用TerminalSink中的对应方法，获取最终的数据并返回，如ReduceOp中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;P_IN&gt; <span class=\"function\">R <span class=\"title\">evaluateSequential</span><span class=\"params\">(PipelineHelper&lt;T&gt; helper,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                   Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> helper.wrapAndCopyInto(makeSink(), spliterator).get();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"stream并行执行原理\">Stream并行执行原理<a title=\"#stream并行执行原理\" href=\"#stream并行执行原理\"></a></h2>\n<p>使用<code>Collection.parallelStream</code>或<code>Stream.parallel</code>等方法可以将当前的Stream流标记为并行执行。</p>\n<p>上文提到在调用Stream的终止操作时，会执行AbstractPipeline.evaluate方法，根据paraller标识是执行并行操作还是串行操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">return</span> isParallel()</span><br><span class=\"line\">           ? terminalOp.evaluateParallel(<span class=\"keyword\">this</span>, sourceSpliterator(terminalOp.getOpFlags())) <span class=\"comment\">/* 并发执行 */</span></span><br><span class=\"line\">           : terminalOp.evaluateSequential(<span class=\"keyword\">this</span>, sourceSpliterator(terminalOp.getOpFlags())); <span class=\"comment\">/* 串行执行 */</span></span><br></pre></td></tr></table></figure>\n<p>如果被标记为sequential，则会调用TerminalOp.evaluateSequential，evaluateSequential的调用过程上文已经讲述的很清楚。</p>\n<p>如果被标记为parallel，则会调用TerminalOp.evaluateParallel，对于该方法不同的TerminalOp会有不同的实现，但都使用了ForkJoin框架，将原始数据不断拆分为更小的单元，对每一个单元做上述evaluateSequential类似的动作，最后将每一个单元计算的结果依次整合，得到最终结果。</p>\n<p>ForkJoin在《<a href=\"https://blog.ixin.run/posts/1613575203\" target=\"_blank\">Stream流式编程知识总结</a>》有所说明。默认情况下，ForkJoin的线程数即为机器的CPU核数，如果想自定义Stream并行执行的线程数，可以参考<a href=\"https://www.baeldung.com/java-8-parallel-streams-custom-threadpool\" target=\"_blank\">Custom Thread Pools In Java 8 Parallel Streams</a></p>\n<h2 id=\"最后\">最后<a title=\"#最后\" href=\"#最后\"></a></h2>\n<p>本文详细讲述了Stream流的实现原理，刚开始研究的时候也是云里雾里，弄懂后才知道原来是“一波三折”，用这个词再合适不过了:</p>\n<ol>\n<li>Head包装最初的数据源，它不属于Stream流中的任何操作，并且Stream流中每一个操作都会指向Head，用于将来数据源便捷取出。</li>\n<li>每一个操作都是一个Stage，每一个Stage都有上下游指针，使得每一个Stage进行挂钩，形成双链表。</li>\n<li>每一个Stage都会通过Sink接口协议使得两个Stage之间的操作进行挂钩，上游执行下游。</li>\n<li>终止操作根据“从下游向上游”原则依次包装Sink，最终得到第一个Sink。</li>\n<li>从第一个Sink执行使得整个管道的流动，得到最终结果。</li>\n</ol>\n<p>本文参考了各路大佬的博文，总结不易，喜欢的点个赞加个关注喽，谢谢。</p>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000018919146\">https://segmentfault.com/a/1190000018919146</a></li>\n<li><a href=\"https://www.cnblogs.com/Dorae/p/7779246.html\">https://www.cnblogs.com/Dorae/p/7779246.html</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000019143092#\">https://segmentfault.com/a/1190000019143092#</a></li>\n</ul>\n","prev":{"title":"认识LRU经典算法","link":"posts/1614164385"},"next":{"title":"Stream流式编程知识总结","link":"posts/1613575203"},"plink":"https://blog.ixin.run/posts/1613581746/","toc":[{"id":"stream怎么用","title":"Stream怎么用","index":"1"},{"id":"stream的操作分类","title":"Stream的操作分类","index":"2"},{"id":"stream的实现过程","title":"Stream的实现过程","index":"3","children":[{"id":"操作如何记录","title":"操作如何记录","index":"3.1"},{"id":"操作如何叠加","title":"操作如何叠加","index":"3.2"},{"id":"叠加后的操作如何执行","title":"叠加后的操作如何执行","index":"3.3"},{"id":"执行结果在哪儿","title":"执行结果在哪儿","index":"3.4"}]},{"id":"stream并行执行原理","title":"Stream并行执行原理","index":"4"},{"id":"最后","title":"最后","index":"5"},{"id":"参考","title":"参考","index":"6"}],"reward":true,"copyright":{"author":"i猩人","link":"<a href=\"https://blog.ixin.run/posts/1613581746/\" title=\"Stream流式编程实现原理\">https://blog.ixin.run/posts/1613581746/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}