{"per_page":10,"total":11,"current":5,"data":[{"title":"Java垃圾回收（一）四种对象引用类型","date":"2019-09-22T07:07:50.000Z","date_formatted":{"ll":"2019年9月22日","L":"2019/09/22","MM-DD":"09-22"},"excerpt":"<p>垃圾收集GC（Garbage Collection）是Java语言的核心技术之一， 在Java中，程序员不需要去关心内存动态分配和垃圾回收的问题，这一切都交给了JVM来处理。本篇我们先弄清楚在开发过程中如何使用对象引用来实现合适时机的垃圾回收，下篇再由浅入深谈谈jvm底层是如何垃圾回收的。</p>\n<p>在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用(Strong Reference)，软引用(Soft Reference)，弱引用(Weak Reference)，虚引用(Phantom Reference)四种，这四种引用强度依赖逐渐减弱。理解这四种对象引用方式也是对java垃圾回收机制的基本认识。</p>","link":"posts/1569136070","tags":["JVM","垃圾回收"],"categories":["Java"]},{"title":"JVM（一）内存分配","date":"2019-09-20T11:42:46.000Z","date_formatted":{"ll":"2019年9月20日","L":"2019/09/20","MM-DD":"09-20"},"excerpt":"<p>Java内存分配无论是处于正常开发计算过程还是绞尽脑汁思考内存回收都需要深入理解的，本文所属范畴是JVM，不应该先来个类加载和运行机制吗，为什么先研究内存分配呢？老实说因为这块很接近我们的开发，越接近后边的深入越容易理解。在了解JVM内存分配之前我们先简单熟悉一下Java HotSpot VM，因为我们经常挂在嘴边的JVM目前就是这家伙。</p>","link":"posts/1568979766","tags":["JVM","内存分配"],"categories":["Java"]},{"title":"位运算的那些事（三）位掩码","date":"2019-08-28T14:34:40.000Z","date_formatted":{"ll":"2019年8月28日","L":"2019/08/28","MM-DD":"08-28"},"excerpt":"<p>前两篇我重点针对位运算基础以及运算过程详细的进行了讲解说明，相信看过的小伙伴也都很明了了。那么基础有了，也知道运算过程了，那我们常见的战场在哪里呢？这就像排兵布阵一样，只阅读兵法，而没有实践和模拟，只能算纸上谈兵了。本篇就拉开帷幕直面开发中这个最常见的战场——位掩码（BitMask）。</p>","link":"posts/1567003105","tags":["二进制","位运算"],"categories":["计算机基础"]},{"title":"位运算的那些事（二）如何位运算","date":"2019-08-25T14:18:59.000Z","date_formatted":{"ll":"2019年8月25日","L":"2019/08/25","MM-DD":"08-25"},"excerpt":"<p>上一篇为了讲位运算不得已将二进制机器码与真值之间的关系系统的解释了一通，本篇我们就根据这些基础将二进制位运算几个常用的运算符运算规则理一理，相信本文之后你就明白了这一个过程。</p>\n<p>上篇我也提到位运算符主要针对二进制，它主要包括：“与（&amp;）”、“或（|）”、“非（~）”、“异或（^）”，当然还有移位运算（左移、右移，无符号左移），这在开发过程中也是很常见的，下边我就以这两部分来说。</p>","link":"posts/1566743147","tags":["二进制","位运算"],"categories":["计算机基础"]},{"title":"位运算的那些事（一）搞懂机器码","date":"2019-08-25T14:16:59.000Z","date_formatted":{"ll":"2019年8月25日","L":"2019/08/25","MM-DD":"08-25"},"excerpt":"<p>最近在开发过程中查看Android源码，多处看到一些类似<code>result = specSize | MEASURED_STATE_TOO_SMALL;</code>的写法，乍一看很熟悉，实际阅读起来很痛苦，这是我们大学里学过的位运算，单看代码似乎我们不可能一瞬间知道结果是多少，所以千万要和我们常见的<code>result = a || b</code>区分开来。以此为引子我们就了解一下有关位运算的那些事。</p>\n<p>位运算主要针对二进制，它包括了：“与（&amp;）”、“或(|)”、“非（~）”、“异或(^)”。从表面上看似乎有点像逻辑运算符，但逻辑运算符是针对两个关系运算符来进行逻辑运算，而位运算符主要<strong>针对两个二进制数的位</strong>进行逻辑运算。</p>\n<p>理解位运算，必须先了解二进制在计算机中转换过程，这也是本篇所讲的重点内容。这些明白了，针对一些复杂的简单的运算法则也就很清晰了。</p>","link":"posts/1566742995","tags":["二进制","位运算"],"categories":["计算机基础"]},{"title":"Android数据库GreenDao的使用完全解析","date":"2019-07-23T12:20:19.000Z","date_formatted":{"ll":"2019年7月23日","L":"2019/07/23","MM-DD":"07-23"},"excerpt":"<p>最近一直在处理公司项目本地数据库，原来的订单数据都是采用SP加密保存的，但SP仅仅适合数据量小的数据存储，随着功能的扩展发现数据越来越多越来越杂，所以这部分数据全部迁移到本地数据库还是有必要的，之前项目已经采用了Greendao，这块本来也想做个总结，但是greendao知识点比较丰富，后来上网发现别人总结的一篇很全面——<a href=\"https://www.jianshu.com/p/53083f782ea2\" target=\"_blank\">《一篇技术好文之Android数据库 GreenDao的使用完全解析》</a>，这里就做一个转载记录，方便工作过程中查阅调优。<strong>另外特别说明一下Greendao官方已经不再维护了</strong>，替代方案也有很多，例如<code>ObjectBox</code>（与Greendao同一公司）、<code>Realm</code>、<code>Room</code>（Google官方）等。本篇也有额外说明，如果想更好的使用Greendao，请结合另外一篇<a href=\"https://blog.csdn.net/sinat_15877283/article/details/51098477\" target=\"_blank\">《DataBase 数据库整理（greenDao示例）》</a>查看，会起到事半功倍的效果。</p>\n<blockquote>\n<p>本文主要从如下几个方面进行讲解：</p>\n<ol>\n<li>存储的数据库结构</li>\n<li>GreenDao的优缺点</li>\n<li>GreenDao的使用配置</li>\n<li>使用GreenDao实现数据的增删改查</li>\n<li>GreenDao的注解使用</li>\n<li>GreenDao的关系处理</li>\n<li>GreenDao的升级</li>\n<li>GreenDao数据库加密</li>\n<li>项目地址</li>\n<li>总结</li>\n<li>参考博客</li>\n</ol>\n</blockquote>","link":"posts/1563884419","tags":["SQLite","数据持久化"],"categories":["Android"]},{"title":"对象拷贝性能对比分析","date":"2019-07-20T04:30:09.000Z","date_formatted":{"ll":"2019年7月20日","L":"2019/07/20","MM-DD":"07-20"},"excerpt":"<p>对象拷贝可分为浅拷贝和深拷贝，在开发过程中深拷贝不是随处可见，大部分是引用的赋值，也即是内存地址的引用。如果简单的类似<code>Student studen1 = student0</code>这样便认为复制了一份，这就大错特错了，有些时候你会莫名的发现studen1没有任何操作里面的属性却发生变化了，不用说一定是student0在某个时候被修改了，因为这两个对象引用的是一个地址的内容。开发过程中，因为嵌套过深，对象中转过多，着实需要小心。</p>\n<p>真正的拷贝是完全复制一份，从而与原对象隔离开，保证了原对象的定格，从而在操作过程中不用担心原对象被修改，必要时可“一键还原”。</p>","link":"posts/1563597009","tags":["Android基础","Java基础"],"categories":["Android"]},{"title":"Android开发之Context认识和运用","date":"2019-05-15T15:26:33.000Z","date_formatted":{"ll":"2019年5月15日","L":"2019/05/15","MM-DD":"05-15"},"excerpt":"<p>谈到Context，做Android的可以说是无人不知无人不晓，例如“XXXXActivity.this”、“getApplicationContext()”、“getContext()”等多种形式。虽然大家都知道，可是真正的去用好它也是一门艺术，深入不全免不了也要入坑。</p>\n<p>之前我们项目上新增了一个悬浮球功能，获取的是全局Application的WINDOW_SERVICE，然而那个悬浮球的实例却采用的Activity的context，存在的问题就是内存回收时将此context回收掉，导致windowManager不能控制这个view了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.IllegalArgumentException: View not attached to window manager</span><br></pre></td></tr></table></figure>\n<p>本篇就针对的Context深入学习做一个总结吧。</p>","link":"posts/1557933993","categories":["Android"]},{"title":"Android开发之UI线程和非UI线程","date":"2019-05-12T06:15:23.000Z","date_formatted":{"ll":"2019年5月12日","L":"2019/05/12","MM-DD":"05-12"},"excerpt":"<p>这里又是老生畅谈的话了，前边已经有多篇文章针对线程进行探究解释，Android开发过程中线程的体现更是淋漓尽致。Android开发过程中涉及到的线程从大类上分可以归为两类：UI线程和非UI线程。本篇就根据这两类做一个总结。</p>","link":"posts/1557641723","tags":["线程间通信"],"categories":["Android"]},{"title":"Java线程之ThreadLocal探讨","date":"2019-05-12T06:07:50.000Z","date_formatted":{"ll":"2019年5月12日","L":"2019/05/12","MM-DD":"05-12"},"excerpt":"<p>未wan待续。。。</p>","link":"posts/1557641270","categories":["Java"]}]}