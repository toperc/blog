[{"title":"DO AS ONE WISHES","date":"2098-12-31T16:00:00.000Z","date_formatted":{"ll":"2099年1月1日","L":"2099/01/01","MM-DD":"01-01"},"updated":"2021-02-01T11:34:21.320Z","content":"\n一个合格的程序员都有自己的风格：执着、追求、向上、完美主义、无所畏惧、高傲但不自大、也有风骚也有爱、狼性编程并不只是为了工作…终极梦想就是随心所欲，凤凰涅槃。\n\n在其位谋其职，在我还没有想到下条路的时候或者现阶段不想想太多，那么我需要做的就是把眼前的事做好，把我人生在这个阶段的时光过的有意义一些，或许这件事回报的比较慢，回报率比较低，但我认为它是值得的，至少是目前是。当然我也是一个不安现状的人。\n","thumbnail":"https://area.sinaapp.com/bingImg","plink":"https://blog.ixin.run/posts/0/"},{"title":"Jvm、Dalvik和Art的区别你知道吗","date":"2021-03-15T04:45:15.000Z","date_formatted":{"ll":"2021年3月15日","L":"2021/03/15","MM-DD":"03-15"},"updated":"2021-03-15T06:23:08.379Z","content":"早前android给人的印象是卡，慢，无；但是从6.0依赖的手机似乎人们不再提android的这些诟病了，无非来一句“不高端”。知道什么原因吗？有同学说，android一个劲的提升内存，和CPU的升级，但这只是其中的表象，为什么会提升内存呢？认识一下Jvm、Dalvik和Art，你将一切都明白了。\n\n什么是JVM\nJVM本质上就是一个软件，是计算机硬件的一层软件抽象，在这之上才能够运行Java程序，JAVA在编译后会生成类似于汇编语言的.class字节码文件，与C语言编译后产生的汇编语言不同的是，C编译成的汇编语言会直接在硬件上跑，但JAVA编译后生成的.class字节码是在JVM上跑，需要由JVM把字节码翻译成机器指令，才能使JAVA程序跑起来，更确切的说是能够与底层沟通。\nJVM运行在操作系统上，屏蔽了底层实现的差异，从而有了JAVA平台独立性和Write Once Run Anywhere。\n根据JVM规范实现的具体虚拟机有几十种，主流的JVM包括Hotspot、Jikes RVM等，都是用C/C++和汇编编写的，每个JRE编译的时候针对每个平台编译，因此下载JRE（JVM、Java核心类库和支持文件）的时候是分平台的，JVM的作用是把平台无关的.class里面的字节码翻译成平台相关的机器码，来实现跨平台。\n什么是Dalvik\nAndroid 运行环境主要指的Dalvik虚拟机技术，也就是安卓虚拟机DVM。每个Android应用进程对应着一个独立的Dalvik虚拟机实例并在其解释下执行。Dalvik虚拟机使用的是寄存器架构而不是JVM中常见的栈架构。Dalvik没有遵循Java虚拟机规范，不能直接执行Java的.class文件，而是执行.dex文件。其中.dex（Dalvik Executable）文件是通过.class文件转化而来，安卓使用Java语法编写应用程序，可以直接使用大部分的Java API等。\nJVM和Dalvik的区别\n\n\nJVM 基于栈，Dalvik 基于寄存器。\nJava虚拟机运行java字节码，Dalvik虚拟机运行的是其专有的文件格式Dex。\n\nJVM与DVM 二者最大的区别在于JVM是以基于栈的虚拟机(Stack-based)，而DVM是基于寄存器的虚拟机(Register-based)。基于寄存器的虚拟机虽然比基于堆栈的虚拟机在硬件通用性上要差一些，但是它的代码执行效率却更好。 显然，后者最大的好处在于可以根据硬件实现更大的优化，这更适合移动设备的特点。\nJava类文件在编译过后，会产生至少一个.class文件包含大量冗余信息，dex文件格式会把所有 的.class文件内容整合到一个.dex文件中。通常一个应用apk只有一个classes.dex，但是开启了multiDexEnabled true分包可以生成多个.dex文件。即减少了整体文件的尺寸和IO操作，也提高了类的查找速度。增加了对新的操作码的支持，使文件结构尽量简洁，使用等长的指令，借以提高解析速度。\n什么是Art\nART(Android Runtime)是Android 4.4发布的，用来替换Dalvik虚拟，Android 4.4之前默认采用的还是DVM，系统会提供一个选项来开启ART模式。在Android 5.0时，默认采用ART，DVM从此退出历史舞台。\n在Dalvik下，应用每次运行都需要通过即时编译器（JIT，Just In Time）将字节码转换为机器码，即每次都要编译加运行，这一机制并不高效，但让应用安装比较快，而且更容易在不同硬件和架构上运行。\nART完全改变了这种做法，在应用安装时就预编译字节码到机器码，这个过程叫做预编译（AOT,Ahead-Of-Time），使其成为真正的本地应用，应用程序执行将更有效率，启动更快。\nDalvik与Art的区别\nDalvik每次都要编译再运行，这就导致需要不断的CPU计算，卡，慢，续航差。\nART优点：\n① 系统性能显著提升\n② 应用启动更快、运行更快、体验更流畅、触感反馈更及时\n③ 续航能力提升\n④ 支持更低的硬件\nART缺点\n① 更大的存储空间占用，可能增加10%-20%（空间换时间大法）\n② 更长的应用安装时间\n","plink":"https://blog.ixin.run/posts/1615783515/"},{"title":"HttpURLConnection使用细节总结","date":"2021-03-14T08:01:05.000Z","date_formatted":{"ll":"2021年3月14日","L":"2021/03/14","MM-DD":"03-14"},"updated":"2021-03-15T04:18:07.695Z","content":"Android上网络请求框架有很多，有HttpURLConnection、HttpClient、android-async-http、volley、(Retrofit+Okhttp)等。\nandroid sdk早期默认支持HttpClient和HttpURLConnection，但在android 6.0的时候就完全抛弃了HttpClient，原因是HttpClient相对HttpURLConnection开发更加繁杂，糟糕的api和糟糕的文档等诸多诟病。\n\nandroid-async-http也是相对比较早的开源库，而核心就是HttpClient，所以也就不在支持使用了。\nvolley是一个简单的异步http库，仅此而已，缺点是不支持同步，这点会限制开发模式。自带缓存，支持自定义请求。不适合大文件上传和下载。曾经一时被google万般宠爱，现在已经停更。\n说了这么多库，现在就剩下HttpURLConnection和OkHttp，这样开发者是比较欣慰的。HttpURLConnection是Android默认支持的，并且可以二次封装扩展，也是本文的重点。\nHttpURLConnection 用法\n使用 HttpURLConnection 来进行网络请求大致上可以分为4个步骤：\n\n获取到 HttpURLConnection 对象\n进行全局的网络设置并建立 Http 连接\n进行数据处理\n关闭连接\n\n获取到HttpURLConnection对象\n使用 URL 对象的 openConnection（）方法获取到 HttpURLConnection 对象，这个对象是我们进行网络请求的核心。\n12URL url = new URL(&quot;http://xxxxx.com&quot;);HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n全局HttpURLConnection设置\n获取到 HttpURLConnection 对象后，就可以调用这个对象的一些方法，进行一些网络设置，比如设置连接超时时间，读取超时时间，网络请求方式等。如以下代码所示：\n123456789101112131415161718192021222324252627//设置网络请求方式，如GET、POST、HEAD等conn.setRequestMethod(&quot;GET&quot;);//设置连接超时时间conn.setConnectTimeout(8000);//设置读取超时时间conn.setReadTimeout(8000);//设置Http请求头部conn.setRequestProperty(&quot;Accept-Encoding&quot;, &quot;identity&quot;);//是否使用缓存conn.setUseCaches(false);//是否使用重定向conn.setInstanceFollowRedirects(false);//设置可以读取输入流 (默认值为true，以后就可以使用conn.getOutputStream().write())conn.setDoInput(true);//设置可以读取输出流，在使用POST向服务器提交数据时必须要将该方法设置为trueconn.setDoOutput(true);//进行Http连接，必须写在setDoInput（）方法后面//如果采用conn.getResponseCode()获取状态码则不必再写此句conn.connect();\n数据处理\n进行数据处理包括两个方面，一个是向服务器发送数据（POST 方法会用到），一个是从服务器读取相应数据。\nPOST发送数据\n123456789// 设置此方法,允许向服务器输出内容,默认false,表示系统不允许向服务器输出内容conn.setDoOutput(true);// post请求的参数String data = content;// 获得一个输出流,向服务器写数据OutputStream out = conn.getOutputStream();out.write(data.getBytes());out.flush();out.close();\n获取响应数据\n123456789// 获取http状态码，调用此方法就不必再使用conn.connect()方法int responseCode = conn.getResponseCode();if (responseCode == 200) &#123;    InputStream is = conn.getInputStream();    String response = getStringFromInputStream(is);    return response;&#125; else &#123;    throw new NetworkErrorException(&quot;response status is &quot;+responseCode);&#125;\n下载文件\n123456789101112131415161718BufferedInputStream bin = new BufferedInputStream(httpURLConnection.getInputStream());file = new File(path);if (!file.getParentFile().exists()) &#123;    file.getParentFile().mkdirs();&#125;OutputStream out = new FileOutputStream(file);int size = 0;int len = 0;byte[] buf = new byte[1024];while ((size = bin.read(buf)) != -1) &#123;    len += size;    out.write(buf, 0, size);    // 打印下载百分比    // System.out.println(&quot;下载了-------&gt; &quot; + len * 100 / fileLength +    // &quot;%\\n&quot;);&#125;bin.close();out.close();\n上传文件\n文件上传采用multipart/form-data形式，相对比较特殊和复杂，其思想模拟拼接Http报文形式，这里不在细说，下文示例中有详细注释。\n关闭连接\n在我们完成了所有数据写入和读取的流操作后，应该调用 disconnect() 方法关闭 Http 连接，同时也要关闭各种输入输出流。\n12//关闭 Http 连接conn.disconnect();\n功能示例\n这里给大家提供一个示例样本：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364public class HttpUtil &#123;    private static final String TAG = &quot;HttpUtil&quot;;    /**     * Get方式访问     *     * @param path     * @return     */    public static String doGet(String path) &#123;        String response = &quot;&quot;;        HttpURLConnection conn = null;        InputStream is = null;        ByteArrayOutputStream baos = null;        try &#123;            URL url = new URL(path);            conn = (HttpURLConnection) url.openConnection();   //建立连接通道            conn.setConnectTimeout(10 * 1000);    //设置访问网络超时时间            conn.setReadTimeout(5 * 1000);       //设置读取数据超时时间            conn.setRequestMethod(&quot;GET&quot;);       //设置访问方式            //开始连接,调用此方法就不必再使用conn.connect()方法            int responseCode = conn.getResponseCode();            Log.e(TAG, &quot;responseCode&quot; + responseCode);            if (responseCode == HttpURLConnection.HTTP_OK) &#123;                is = conn.getInputStream(); //得到一个输入流，用来读取数据。                baos = new ByteArrayOutputStream();  //得到一个字节输出流，写入缓冲区。                byte[] buffer = new byte[1024];  //设置缓冲区大小                int len = -1;                while ((len = is.read(buffer)) != -1) &#123;                    baos.write(buffer, 0, len);                &#125;                //二进制流转成字符串                response = baos.toString();            &#125;        &#125; catch (MalformedURLException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            //从里到外，从下到上，逐个关闭            try &#123;                if (baos != null)                    baos.close(); //关闭字节输出流                if (is != null)                    is.close();  //关闭输入流            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            if (conn != null) &#123;                conn.disconnect();    //关闭连接            &#125;        &#125;        return response;    &#125;    /**     * Post方式访问     *     * @param path     * @param param     * @return     */    public static String doPost(String path, String param) &#123;        String response = &quot;&quot;;        HttpURLConnection conn = null;        DataOutputStream out = null;        InputStream is = null;        ByteArrayOutputStream baos = null;        try &#123;            URL url = new URL(path);            conn = (HttpURLConnection) url.openConnection(); //建立连接通道            conn.setConnectTimeout(10 * 1000);  //设置访问网络超时时间            conn.setReadTimeout(5 * 1000);    //设置读取数据超时时间            conn.setRequestMethod(&quot;POST&quot;);  //设置访问方式            conn.setDoOutput(true); //允许向服务器发送数据            conn.setDoInput(true);  //允许读取服务器反馈数据            conn.setUseCaches(false);   //post请求不使用缓存            conn.setInstanceFollowRedirects(true);  //是否遵循重定向原则            conn.setRequestProperty(&quot;Charset&quot;, &quot;utf-8&quot;);    //设置编码            conn.setRequestProperty(&quot;Connection&quot;, &quot;keep-alive&quot;);    //保持长链接            conn.setRequestProperty(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);   //配置本次连接的Content-Type.            //实例一个输出流，用于参数写入。            if (param != null &amp;&amp; !TextUtils.isEmpty(param.trim())) &#123;                out = new DataOutputStream(conn.getOutputStream());                out.write(param.getBytes(&quot;UTF-8&quot;));                out.flush();  //刷新            &#125;            //开始连接,调用此方法就不必再使用conn.connect()方法            int responseCode = conn.getResponseCode();            if (responseCode == HttpURLConnection.HTTP_OK) &#123;                is = conn.getInputStream();   //得到一个输入流，用来读取数据。                baos = new ByteArrayOutputStream();  //得到一个字节输出流，写入缓冲区。                byte[] buffer = new byte[1024];  //设置缓冲区大小                int len = -1;                while ((len = is.read(buffer)) != -1) &#123;                    baos.write(buffer, 0, len);                &#125;                //二进制流转成字符串                response = baos.toString();            &#125;        &#125; catch (MalformedURLException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            //从里到外，从下到上，逐个关闭            try &#123;                if (out != null)                    out.close();   //关闭参数输出流                if (baos != null)                    baos.close();  //关闭字节输出流                if (is != null)                    is.close();    //关闭输入流            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            if (conn != null) &#123;                conn.disconnect();    //关闭连接            &#125;        &#125;        return response;    &#125;    /**     * 获取网络图片     *     * @param requestPath     * @return     */    public static Bitmap doBitmap(String requestPath) &#123;        Bitmap bitmap = null;        HttpURLConnection conn = null;        InputStream is = null;        try &#123;            //建立连接通道            URL imageUrl = new URL(requestPath);            conn = (HttpURLConnection) imageUrl.openConnection();            //设置超时时间            conn.setConnectTimeout(10 * 1000);            conn.setReadTimeout(10 * 1000);            //开始连接            conn.connect();            //实例一个输入流，读取数据            is = conn.getInputStream();            //将输入流转换成Bitmap            bitmap = BitmapFactory.decodeStream(is);        &#125; catch (MalformedURLException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                if (is != null)                    is.close();    //关闭输入流            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            if (conn != null) &#123;                conn.disconnect();    //关闭连接            &#125;        &#125;        return bitmap;    &#125;    /**     * 文件下载     * @param path     * @param localPath     * @return     */    public static boolean doLoad(String path, String localPath) &#123;        boolean loadSucceed = false;        HttpURLConnection conn = null;        InputStream is = null;        FileOutputStream fos = null;        try &#123;            URL url = new URL(path);            conn = (HttpURLConnection) url.openConnection();            conn.setRequestProperty(&quot;Accept-Encoding&quot;, &quot;identity&quot;);  //获取文件长度限定条件            //设置超时时间            conn.setConnectTimeout(10 * 1000);            conn.setReadTimeout(10 * 1000);            //开始连接            conn.connect();            //实例一个输入流，读取数据            is = conn.getInputStream();            fos = new FileOutputStream(new File(localPath));            byte[] buffer = new byte[1024];            int mHasRead = 0;            int len;            while ((len = is.read(buffer)) != -1) &#123;                fos.write(buffer, 0, len);                mHasRead += len;            &#125;            fos.flush();            Log.e(Constants.LOG,&quot;++++++++mHasRead:&quot;+mHasRead+&quot;++++++++++++lengh:&quot;+conn.getContentLength());            if (mHasRead &gt; 0 &amp;&amp; mHasRead == conn.getContentLength()) &#123;                loadSucceed = true;            &#125;        &#125; catch (MalformedURLException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            //从里到外，从下到上，逐个关闭            try &#123;                if (fos != null)                    fos.close();   //关闭文件输出流                if (is != null)                    is.close();    //关闭输入流            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            if (conn != null) &#123;                conn.disconnect();    //关闭连接            &#125;        &#125;        return loadSucceed;    &#125;    /**     * 文件上传，具体上传细节类似后台form表单     *     * @param path     * @param textMap     * @param fileMap     * @return     */    public static String doUpload(String path, Map&lt;String, String&gt; textMap, Map&lt;String, File&gt; fileMap) &#123;        String response = &quot;&quot;;        HttpURLConnection conn = null;        DataOutputStream out = null;        InputStream is = null;        FileInputStream fis = null;        ByteArrayOutputStream baos = null;        //边界设定        String BOUNDARY = UUID.randomUUID().toString(); //边界标识，这里随机生成        String PREFIX = &quot;--&quot;;    //边界标识前面多了--，一定要小心        String LINE_END = &quot;\\r\\n&quot;;  //回车换行符，每一行都要有一个，一定要小心        try &#123;            URL url = new URL(path);            conn = (HttpURLConnection) url.openConnection();            conn.setConnectTimeout(10 * 1000);            conn.setReadTimeout(10 * 1000);            conn.setRequestMethod(&quot;POST&quot;);            conn.setDoOutput(true);            conn.setDoInput(true);            conn.setUseCaches(false);            conn.setInstanceFollowRedirects(true);            conn.setRequestProperty(&quot;Charset&quot;, &quot;UTF-8&quot;);//设置编码            conn.setRequestProperty(&quot;Connection&quot;, &quot;keep-alive&quot;); //保持长链接            conn.setRequestProperty(&quot;Content-Type&quot;, &quot;multipart/form-data; boundary=&quot; + BOUNDARY);            //实例一个输出流，用于参数写入            out = new DataOutputStream(conn.getOutputStream());            // text            if (textMap != null) &#123;                for (Map.Entry&lt;String, String&gt; entry : textMap.entrySet()) &#123;                    out.writeBytes(PREFIX + BOUNDARY + LINE_END);  //第一行，分界符                    out.writeBytes(&quot;Content-Disposition: form-data; name=\\&quot;&quot; + entry.getKey() + &quot;\\&quot;&quot; + LINE_END);  //第二行，key值                    out.writeBytes(LINE_END);    //第三行，回车换行                    out.write(entry.getValue().getBytes(&quot;UTF-8&quot;));   //第四行，value值                    out.writeBytes(LINE_END); //也属于第四行的                &#125;            &#125;            // file            if (fileMap != null) &#123;                for (Map.Entry&lt;String, File&gt; entry : fileMap.entrySet()) &#123;                    out.writeBytes(PREFIX + BOUNDARY + LINE_END);                    out.writeBytes(&quot;Content-Disposition: form-data; name=\\&quot;&quot; + entry.getKey() + &quot;\\&quot;; filename=\\&quot;&quot; + entry.getValue().getName() + &quot;\\&quot;&quot; + LINE_END);                    out.writeBytes(&quot;Content-Type: image/jpeg&quot; + LINE_END);                    out.writeBytes(LINE_END);                    //添加数据                    fis = new FileInputStream(entry.getValue());                    byte[] buffer = new byte[1024 * 4];                    int len = -1;                    while ((len = fis.read(buffer)) != -1) &#123;                        out.write(buffer, 0, len);                    &#125;                    out.writeBytes(LINE_END);                &#125;            &#125;            out.writeBytes(PREFIX + BOUNDARY + PREFIX + LINE_END);            out.flush();            //开始连接,调用此方法就不必再使用conn.connect()方法            int responseCode = conn.getResponseCode();            if (responseCode == HttpURLConnection.HTTP_OK) &#123;                is = conn.getInputStream();   //得到一个输入流，用来读取数据。                baos = new ByteArrayOutputStream();  //得到一个字节输出流，写入缓冲区。                byte[] buffer = new byte[1024];  //设置缓冲区大小                int len;                while ((len = is.read(buffer)) != -1) &#123;                    baos.write(buffer, 0, len);                &#125;                //二进制流转成字符串                response = baos.toString();            &#125;        &#125; catch (MalformedURLException e) &#123;            e.printStackTrace();        &#125; catch (UnsupportedEncodingException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            //从里到外，从下到上，逐个关闭            try &#123;                if (fis != null)                    fis.close();   //关闭文件读取输入流                if (out != null)                    out.close();   //关闭参数传递输出流                if (baos != null)                    baos.close();  //关闭字节输出流                if (is != null)                    is.close();    //关闭返回数据输入流            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            if (conn != null) &#123;                conn.disconnect();    //关闭连接            &#125;        &#125;        return response;    &#125;&#125;\n断点续传\n断点续传，即在文件未下载完成时，保存进度，在下次继续下载。如果是多线程模式实现断点续传呢？其实思想也很简单就是把文件分割成多份，每一份都有起始位置和结束位置，同时对这个文件下载。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208public class ResumeDownload &#123;\tpublic static final String DOWNLOAD_URL = &quot;http://7xs0af.com1.z0.glb.clouddn.com/High-Wake.mp3&quot;;\tpublic static final String DOWNLOAD_PARENT_PATH = &quot;D:\\\\test_resume_download\\\\hi&quot;;\tpublic static final int THREAD_COUNT = 3;\tpublic static void main(String[] args) &#123;\t\ttry &#123;\t\t\t// 获取到下载地址的连接\t\t\tURL mUrl = new URL(DOWNLOAD_URL);\t\t\tHttpURLConnection conn = (HttpURLConnection) mUrl.openConnection();\t\t\t// 获取下载文件的大小\t\t\tint fileLen = conn.getContentLength();\t\t\t// 通过下载链接获取下载文件的文件名\t\t\tString filePathUrl = conn.getURL().getFile();\t\t\tString fileName = filePathUrl.substring(filePathUrl.lastIndexOf(File.separator) + 1);\t\t\t// 生成下载路径\t\t\tString fileDownloadPath = DOWNLOAD_PARENT_PATH + File.separator + fileName;\t\t\t// 判断父路径是否存在，不存在就生成\t\t\tFile file = new File(fileDownloadPath);\t\t\tif (!file.getParentFile().exists()) &#123;\t\t\t\tfile.getParentFile().mkdirs();\t\t\t&#125;\t\t\t// 关闭连接\t\t\tconn.disconnect();\t\t\t/**\t\t\t * 以下为多线程下载，主要原理就是将文件大小均分多块（根据线程数） 每一个线程从不同的起始位置，下载相等大小的文件 主要通过\t\t\t * HttpUrlConnection里面设置Range参数，设置每一个线程下载的范围\t\t\t * setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + startPos + &quot;-&quot; + endPos);\t\t\t */\t\t\tint blockSize = fileLen / THREAD_COUNT;\t\t\tfor (int threadId = 1; threadId &lt;= THREAD_COUNT; threadId++) &#123;\t\t\t\t// 获取每一个线程下载的起始位置和结束位置\t\t\t\tlong startPos = (threadId - 1) * blockSize;\t\t\t\tlong endPos = threadId * blockSize - 1;\t\t\t\tif (threadId == THREAD_COUNT) &#123;\t\t\t\t\tendPos = fileLen;\t\t\t\t&#125;\t\t\t\t// 然后通过再不同线程里面实现下载逻辑\t\t\t\t// 具体实现在DownloadThread这个Runnable里面\t\t\t\tnew Thread(new DownLoadTask(threadId, startPos, endPos, fileDownloadPath, DOWNLOAD_URL)).start();\t\t\t&#125;\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t&#125;&#125;/** * 具体下载逻辑 *  * @author Administrator * */class DownLoadTask implements Runnable &#123;\tpublic static final String TEMP_NAME = &quot;_tempfile&quot;;\tprivate int threadId; // 当前线程id\tprivate long startPos; // 下载的起始位置\tprivate long endPos; // 下载的结束位置\tprivate String fileDownloadPath; // 下载文件存放的文件位置\tprivate String downloadUrl; // 下载链接\tprivate String tempFilePath; // 记录进度的临时文件路径\tpublic DownLoadTask(int threadId, long startPos, long endPos, String fileDownloadPath, String downloadUrl) &#123;\t\tsuper();\t\tthis.threadId = threadId;\t\tthis.startPos = startPos;\t\tthis.endPos = endPos;\t\tthis.fileDownloadPath = fileDownloadPath;\t\tthis.downloadUrl = downloadUrl;\t\tthis.tempFilePath = fileDownloadPath + TEMP_NAME + threadId;\t&#125;\t@Override\tpublic void run() &#123;\t\ttry &#123;\t\t\t// 记录下载的开始时间\t\t\tlong startTime = System.currentTimeMillis();\t\t\tURL mUrl = new URL(downloadUrl);\t\t\t// 为了实现断点下载，在重新下载时从缓存文件里面获取下载的起始位置\t\t\tif (getProgress(threadId) != 0) &#123;\t\t\t\tstartPos = getProgress(threadId);\t\t\t&#125;\t\t\tSystem.out.println(&quot;线程&quot; + threadId + &quot;继续下载，开始位置：&quot; + startPos + &quot;结束位置是：&quot; + endPos);\t\t\t// HttpUrlConnection的常规操作\t\t\t// 要实现断点下载的话，必须要设置mConnection.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; +\t\t\t// startPos + &quot;-&quot; + endPos);\t\t\tHttpURLConnection mConnection = (HttpURLConnection) mUrl.openConnection();\t\t\tmConnection.setRequestMethod(&quot;POST&quot;);\t\t\tmConnection.setReadTimeout(5000);\t\t\tmConnection.setRequestProperty(&quot;Charset&quot;, &quot;UTF-8&quot;);\t\t\tmConnection.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + startPos + &quot;-&quot; + endPos);\t\t\tmConnection.connect();\t\t\t// 如果下载路径不存在的话，则创建文件路径\t\t\tFile file = new File(fileDownloadPath);\t\t\tif (!file.getParentFile().exists()) &#123;\t\t\t\tfile.getParentFile().mkdirs();\t\t\t&#125;\t\t\t// 通过RandomAccessFile对要下载的文件进行读写\t\t\tRandomAccessFile downloadFile = new RandomAccessFile(fileDownloadPath, &quot;rw&quot;);\t\t\t// 写的时候，将光标移到要下载的起始位置\t\t\tdownloadFile.seek(startPos);\t\t\tBufferedInputStream bis = new BufferedInputStream(mConnection.getInputStream());\t\t\tint size = 0; // 获取缓存区存放的字节大小\t\t\tlong len = 0; // 记录本次下载的大小，以便计算本次下载的起始位置移动到了哪里\t\t\tbyte[] buf = new byte[1024];\t\t\twhile ((size = bis.read(buf)) != -1) &#123;\t\t\t\t// 累加\t\t\t\tlen += size;\t\t\t\t// 然后将缓冲区的内容写到下载文件中\t\t\t\tdownloadFile.write(buf, 0, size);\t\t\t\t// 然后将下载的起始位置移动到已经下载完的末尾，写到缓存文件里面去\t\t\t\tsetProgress(threadId, startPos + len);\t\t\t&#125;\t\t\t// 获取下载结束时间，输出\t\t\tlong curTime = System.currentTimeMillis();\t\t\tSystem.out.println(&quot;线程&quot; + threadId + &quot;已经下载完成，耗时：&quot; + (curTime - startTime) + &quot;ms.&quot;);\t\t\t// 关闭流、文件和连接\t\t\tdownloadFile.close();\t\t\tmConnection.disconnect();\t\t\tbis.close();\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t&#125;\t/**\t * 从temp文件获取下载进度\t * \t * @param threadId\t * @return\t */\tprivate long getProgress(int threadId) &#123;\t\ttry &#123;\t\t\tFile markFile = new File(tempFilePath);\t\t\tif (!markFile.exists()) &#123;\t\t\t\treturn 0;\t\t\t&#125;\t\t\tFileInputStream fis = new FileInputStream(markFile);\t\t\tBufferedInputStream bis = new BufferedInputStream(fis);\t\t\tbyte[] buf = new byte[1024];\t\t\tString startPos = &quot;&quot;;\t\t\tint len = -1;\t\t\twhile ((len = bis.read(buf)) != -1) &#123;\t\t\t\tstartPos += new String(buf, 0, len);\t\t\t&#125;\t\t\t// 不关闭流的话，不能删除文件\t\t\tfis.close();\t\t\tbis.close();\t\t\treturn Long.parseLong(startPos);\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t\treturn 0;\t&#125;\t/**\t * 在temp文件记录下载进度\t * \t * @param threadId\t * @param startPos\t */\tprivate void setProgress(int threadId, long startPos) &#123;\t\ttry &#123;\t\t\tFile markFile = new File(tempFilePath);\t\t\tif (!markFile.getParentFile().exists()) &#123;\t\t\t\tmarkFile.getParentFile().mkdirs();\t\t\t&#125;\t\t\t\t\t\tRandomAccessFile rr = new RandomAccessFile(markFile, &quot;rw&quot;);// 存储下载标记的文件\t\t\tString strStartPos = String.valueOf(startPos);\t\t\trr.write(strStartPos.getBytes(), 0, strStartPos.length());\t\t\t\t\t\trr.close();\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t&#125; finally &#123;\t\t\t// 当文件下载完成时，即开始位置和结束位置重合时，删除记录进度的缓存文件\t\t\tif (startPos &gt;= endPos) &#123;\t\t\t\tFile markFile = new File(tempFilePath);\t\t\t\tif (markFile.exists()) &#123;\t\t\t\t\tSystem.out.println(&quot;markFile delete&quot;);\t\t\t\t\tmarkFile.delete();\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n最后\n本篇文章重点总结了HttpURLConnection相关使用方法，文章代码量比较多，供大家参考。android中所有执行网络请求的部分建议都放在子线程中，请求结果如果需要页面展示在切换到主线程。\n参考\n\nhttps://blog.csdn.net/ljcitworld/article/details/78142642\n\n","plink":"https://blog.ixin.run/posts/1615708883/"},{"title":"Android多渠道打包","date":"2021-03-14T03:30:13.000Z","date_formatted":{"ll":"2021年3月14日","L":"2021/03/14","MM-DD":"03-14"},"updated":"2021-03-15T04:16:08.115Z","content":"Android的签名打包是每个android开发者都会的基本技能，但是针对多渠道打包需要当前app业务支撑，有些app是无需上线的到各个应用市场的，或者说公司不需要这些分发做定制化，这就导致可能接触不到多渠道打包，本文就记录一下Android上多渠道打包的那些事。\n\nbuild.gradle配置\napp模块下build.gradle的配置一般分为以下几个部分：\n\ndefaultConfig 默认配置\nsigningConfigs 签名信息配置\nbuildTypes 编译类型配置\nproductFlavors 编译渠道配置\ndependencies 依赖配置\n\n其中：\nsigningConfigs主要用于配置签名文件，包括签名的账户信息以及签名文件的具体位置。\nbuildTypes主要配置编译类型，例如当前打出的包事release包还是debug包。\nproductFlavors主要用于渠道的配置，例如小米、华为、360等应用市场渠道，还有多维度设置，例如小米渠道下的1.0版本，360渠道下的1.1版本等。\n打包方式\n打包方式有多种：\n\n可采用菜单上 Build-&gt; Generate Signed Bundle / Apk... 进行打包。\n右侧Gradle菜单下触发打包task，app-&gt;Tasks-&gt;build-&gt;assembleDebug/assembleRelease\n采用Terminal命令行打包，作用原理和第二种一样： 12gradlew assembleDebug &#x2F;&#x2F;编译并打Debug包gradlew assembleRelease &#x2F;&#x2F;编译并打Release的包\n更多命令使用可参看我之前写的一篇文章《AndroidStudio配置Terminal窗口及相关命令归总》\n自动化（CI/CD）打包，背后还是配置的命令行。\n\n多渠道打包\n一个多渠道打包最常使用的一个场景：\n\n亮仔呀，我想知道我们的APP在哪个应用市场渠道下载的最多，我们以后就重点推广这个渠道，用钱砸到排名前面！！！\n\n开发的app发布多个分发平台是常规操作，借助三方统计平台可以很清楚的观察到各个渠道市场的分发量和活跃度，例如友盟统计。也可以上传到自己的统计服务器。\n由于各个渠道面对的用户不同，或平台审核标准不同，甚至需要各渠道使用不同的业务逻辑，需要根据不同渠道编写针对性的差异化代码。\ngradle配置多渠道变量\n在项目的build.gradle里设置：\n1234567891011121314151617181920android &#123;...flavorDimensions &quot;default&quot;productFlavors &#123;        xiaomi &#123;            dimension &quot;default&quot;            manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;xiaomi&quot;]        &#125;        huawei &#123;            dimension &quot;default&quot;            manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;huawei&quot;]        &#125;        qihu360 &#123;            dimension &quot;default&quot;            manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;qihu360&quot;]        &#125;    &#125;&#125;\ndimension是维度，目标是在多渠道的前提下进行更细分的差异化，通过flavorDimensions提前定义，androidstudio 3.0之后必须要定义。\nmanifestPlaceholders是替换AndroidManifest.xml中的对应key的value值，例如：\n1234567manifestPlaceholders = [                STORE_APP_NAME: &quot;@string/app_name&quot;,                // 极光推送部分                JPUSH_PKGNAME : applicationId,                JPUSH_APPKEY  : &quot;49b9f44b89....&quot;, //JPush正式Appkey.                JPUSH_CHANNEL : &quot;developer-default&quot;, //暂时填写默认值即可.        ]\nmanifestPlaceholders在productFlavors下边仅仅是动态替换AndroidManifest的渠道信息。\nAndroidManifest定义渠道变量\nmeta-data是AndroidManifest多个组件下的子标签，该标签可为、、、、、等组件提供附加数据项。\n定义渠道meta-data：\n1234567891011&lt;application        android:icon=&quot;@mipmap/logo&quot;        android:label=&quot;@string/app_name&quot;        android:name=&quot;.App&quot;        android:roundIcon=&quot;@mipmap/logo&quot;        android:theme=&quot;@style/AppTheme.NoActionBar&quot;&gt;        ...        &lt;meta-data            android:name=&quot;CHANNEL_NAME&quot;            android:value=&quot;$&#123;UMENG_CHANNEL_VALUE&#125;&quot; /&gt;&lt;/application&gt;\n获取渠道变量值\n获取AndroidManifest中meta-data标签的值：\n1234567891011121314151617181920212223242526272829ApplicationInfo applicationInfo = null;        try &#123;            applicationInfo = getPackageManager().getApplicationInfo(getPackageName(), PackageManager.GET_META_DATA);            if (applicationInfo == null) &#123;                return;            &#125;            String value = applicationInfo.metaData.getString(&quot;CHANNEL_NAME&quot;);            CommonConfig.CHANNEL_NAME=value;            //按渠道设置差异化代码            System.out.println(&quot;CHANNEL_NAME:&quot;+value);            switch (value)&#123;                case &quot;xiaomi&quot;:                    // 小米渠道                    break;                case &quot;huawei&quot;:                    // 华为渠道                    break;                case &quot;qihu360&quot;:                    // 奇虎360渠道                    break;                default:                    break;            &#125;        &#125; catch (PackageManager.NameNotFoundException e) &#123;            e.printStackTrace();        &#125;\n快速打渠道包\n正常情况下我们打渠道包，因为要gradle一个一个构建，速度相应比较慢，打一次包甚至花费半个小时，如果中间在修复一下bug半天时间都浪费在打包上了，项目负责人肯定不愿意啊。怎么办呢？这里可以采用美团多渠道打包方案——Walle（瓦力）。\n早前快速渠道包生成方案是通过在META-INF目录下添加空文件，用空文件的名称来作为渠道的唯一标识，之前在META-INF下添加文件是不需要重新签名应用的，这样会节省不少打包的时间，从而提高打渠道包的速度。但在新的应用签名方案下（Android 7.0（Nougat）之后）META-INF已经被列入了保护区了，向META-INF添加空文件的方案安装时会报错。\nWalle（瓦力）渠道包生成过程：\n\n对新的应用签名方案生成的APK包中的ID-value进行扩展，提供自定义ID－value（渠道信息），并保存在APK中\n而APK在安装过程中进行的签名校验，是忽略我们添加的这个ID-value的，这样就能正常安装了\n在App运行阶段，可以通过ZIP的EOCD（End of central directory）、Central directory等结构中的信息（会涉及ZIP格式的相关知识，这里不做展开描述）找到我们自己添加的ID-value，从而实现获取渠道信息的功能\n\n具体使用细节请参考Walle（瓦力）使用说明：https://github.com/Meituan-Dianping/walle\n参考\n\n新一代开源Android渠道包生成工具Walle —— 美团\n\n","plink":"https://blog.ixin.run/posts/1615692625/"},{"title":"HTTPS协议原理必知必会","date":"2021-03-12T14:45:07.000Z","date_formatted":{"ll":"2021年3月12日","L":"2021/03/12","MM-DD":"03-12"},"updated":"2021-03-15T04:16:08.121Z","content":"前边的一篇文章《HTTP协议原理知多少》我把有关Http的知识总结了一下，Http是一个无状态，透明的网络协议，然而在当下大网络环境下，安全这块是很重要的，所以Http也被无情的拍着沙滩上了，当然前人栽树后人乘凉，前人打地基后人盖大楼，一切都离不开基础，本篇文章我就总结一下在Http基础上添加了安全模块的Https的相关知识点，细看必有收获。\n\nHTTP的缺点\nHTTP主要有以下不足：\n\n通信使用明文（不加密），内容可能会被窃听\n不验证通信方的身份，因此有可能遭遇伪装\n无法证明报文的完整性，所以有可能已遭篡改\n\n什么是HTTPS\nHTTP加上加密处理和认证以及完整性保护后即是HTTPS。\nHTTPS 要比 HTTPS 多了 secure 安全性这个概念，实际上， HTTPS 并不是一个新的应用层协议，它其实就是 HTTP + TLS/SSL 协议组合而成，而安全性的保证正是 SSL/TLS 所做的工作。\n通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP。\n\nTLS/SSL协议\n1994年网景公司为了解决HTTP的安全问题创建了SSL协议，SSL协议有三个版本，分别是SSL v1、SSL v2、SSLv3。1996年，IETF（Internet Engineering Task Force）组织在SSL v3的基础上进一步标准化了该协议，微软为这个新协议取名TLS v1.0。\n【SSL】: 安全套接层（Secure Sockets Layer）\n【TLS】: 传输层安全（Transport Layer Security）\n在理解的时候可以认为两者是一样的，TLS协议是SSL协议的升级版。\n\nTLS/SSL 的功能实现主要依赖于三类基本算法：非对称加密、对称加密和散列函数，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。\n\n加密\n密码学的四个目标\n1）机密性（隐私性）\n在网络中传递的数据如果具备机密性，那么传输的数据就是一串无意义的数字，只有拥有密钥的才能解释这些数据，密钥是加密算法的关键。在密码学中，对称加密算法和公开密钥算法都能够保证机密性。\n2）完整性\n完整性表示接收方能够确保接收到的数据就是发送方发送的原始数据，假设数据被中间人篡改，接收方如果有策略知晓数据被篡改了，那么传递的数据就具备完整性。在密码学中，主要使用消息验证码（MAC）算法保证完整性。\n3）身份验证\n互联网应用一般都有发送方和接收方，对于接收方来说，必须确认发送方的身份，才能确保收到的数据就是真实发送方发送的。反之对于发送方来说也是一样的，通信双方必须确保对端就是要通信的对象。在密码学中，一般使用数字签名技术确认身份。\n4）不可抵赖性\n举个例子，A向B借钱了，并写了张借条，当B希望A还钱的时候，A抵赖说这张借条不是他写的，理由就是有人冒充他写了这张借条，A的行为可以抵赖。在密码学中，数字签名技术能够避免抵赖。\n公开密钥算法\n公开密钥算法即非对称加密，服务端会同时产生一对密钥：公钥和私钥，公钥裸奔，私钥隐藏。\n用作加密：公钥加密私钥解密；\n用作签名：私钥加密公钥解密；\nHTTPS的加密核心\n常规加解密我们最容易想到的是对称加密，即客户端和服务端都采用相同的密码进行加解密，但这样有一个问题，万一密码被盗了，那整个数据传输通道就裸奔了。此时如果采用非对称加密，即客户端采用公钥加密服务端采用私钥解密，那这个问题就迎刃而解了。\n但是HTTPS采用的却是对称加密和非对称加密的组合形式。有同学可能会问，既然非对称加密很完美那么只采用这一种不可以吗？这里的答案是不可以。\n原因是非对称加密虽然很安全，但是非对称加密与对称加密相比，其处理速度要慢。假如传输数据流很大的话，岂不是要等个天荒地老咯。\n所以HTTPS采用一个很讨巧的方式，采用对称加密方法加密需要传输的数据流，而非对称加密方法加密前一步对称加密中产生的密钥，然后进行传输。服务器通过私钥解密就可以得到准确的数据流密钥，进而解密数据流。\n认证\n非对称加密公开密钥的方式虽然看起来很安全，但是也有一些遗憾，那就是无法证明公开密钥本身就是货真价实的公开密钥。\n\n如果公钥被中间人拿到纂改怎么办呢？\n在HTTPS中，通过 数字证书（「证书」 + 「数字签名」）来解决这个问题。\n数字签名\n数字签名功能主要是用于校验数据来源和一致性（完整性），非对称加密中的通过私钥加密公钥解密的手段实现。\n假设现在A向B发送一封邮件，具体签名校验流程如下：\n\nA先对这封Email执行哈希运算得到hash值简称“摘要”，取名h1。\n然后用自己私钥对摘要加密，生成的东西叫“数字签名”。\n把数字签名加在Email正文后面，一起发送给B。\nB收到邮件后用A的公钥对数字签名解密，成功则代表Email确实来自A，失败说明有人冒充。\n\n以上四步是对方身份的确认，接下来两步判断数据是否被篡改：\n\nB对邮件正文执行哈希运算得到hash值，取名h2。\nB会对比第4步数字签名的hash值h1和自己运算得到的h2，一致则说明邮件未被篡改。\n\n有同学可能又问了为什么签名要先经过hash运算呢？答案应该也很容易想到。\n直接对源数据加解密是个耗时工程，如果源数据比较大，那整个过程是时间和性能的巨大开销。我们这里要明白上边提到的签名的主要作用是什么。\n\n数字证书\n上边说到公钥有可能被中间人拿到替换或者篡改，为了让客户端校验身份，服务器必须配置服务器证书，证书由CA（Certificate Authority）机构签发。数字证书认证机构（CA,Certificate Authority）处于客户端与服务器双方都可信赖的第三方机构的立场上。\n数字证书包含两部分：证书和数字签名：\n\n证书是为了保证公钥来源的正确性（公钥的确来自我们自己的服务器）\n数字签名保证公钥没有被篡改。\n\n\n如果没有数字签名的话，这样子可以就会有下面情况：\n\n所以「证书」 + 「数字签名」方式可以完好的保证公钥的准确性。我们假设中间人截取到服务器的公钥后，去替换成自己的公钥，因为有数字签名的存在，这样子客户端验证发现数字签名不匹配，这样子就防止中间人替换公钥的问题。\n使用通信方式时，如何安全转交认证机关的公开密钥是一件很困难的事，因此，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。\n\n客户端是如何去对比两者数字签名的呢？\n\n浏览器会去安装一些比较权威的第三方认证机构的公钥，比如VeriSign、Symantec以及GlobalSign等等。\n验证数字签名的时候，会直接从本地拿到相应的第三方的公钥，对私钥加密后的数字签名进行解密得到真正的签名。\n然后客户端利用签名生成规则进行签名生成，看两个签名是否匹配，如果匹配认证通过，不匹配则获取证书失败。\n\n完整性保护\n在HTTPS的通信流程中，应用层发送数据时，会附加一种叫做MAC（Message Authentication Code，消息认证码）的报文摘要，MAC能够查知报文是否遭到篡改，从而保护报文的完整性。\n消息认证码MAC是一种与密钥相关的单向散列函数，无需解密只需校验。消息认证码MAC通常采用HMAC （推荐HMAC-SHA256） 或 认证加密算法（AEAD，比如AES-GCM-256 ，AES属于对称加密算法的一种）通信双方拥有相同的共享密钥。\n前提条件：\n\n在消息认证码生成的一方和校验的一方, 必须有一个秘钥\n双方约定好使用同样的哈希函数对数据进行运算\n\n工作过程如下：\n).A把消息发送给B前，先把共享密钥发送给B。\n2).A把要发送的消息使用共享密钥计算出MAC值，然后将消息和MAC发送给B。\n3).B接收到消息和MAC值后，使用共享密钥计算出MAC值，与接收到的MAC值对比。\n4).如果MAC值相同，说明接收到的消息是完整的。因为提前已经知道共享密钥除了B那就只有A拥有，所以也可以确定消息是A发的。\n工作原理举例图示：\n\n消息认证码无法解决的问题\n消息认证码虽然可以证明双方发送的消息是一致的，没有篡改，也不存在中间人伪装。但是它无法 “对第三方证明” 和 “防止抵赖”。\n无法 “对第三方证明” 原因是因为消息认证码中用到的密钥是共享密钥，通信双方都有这个密钥，所以对第三方无法证明消息到底出自双方中的哪一方。解决 “第三方证明” 的问题需要用到数字签名。\n无法 “防止抵赖” 原因是也是因为消息认证码的共享密钥双方都有，无法判断消息是发自于哪一方。所以消息认证码无法防止否认(nonrepudiation)。解决 “防止抵赖” 的问题需要用到数字签名。\n单向散列函数、消息认证码和数字签名区别\n\n单向散列函数保证消息的一致性，完整性，没有被篡改。\n消息认证码保证消息的一致性，完整性，没有被篡改，并且不存在中间人伪装。\n数字签名保证消息的一致性，完整性，没有被篡改，并且不存在中间人伪装，并且能防止抵赖。\n\nHTTPS通信过程\n\n步骤1： 客户端通过发送Client Hello报文开始SSL通信。报文中包含客户端支持的SSL的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。\n步骤2： 服务器可进行SSL通信时，会以Server Hello报文作为应答。和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。\n步骤3： 之后服务器发送Certificate报文。报文中包含公开密钥证书。\n步骤4： 最后服务器发送Server Hello Done报文通知客户端，最初阶段的SSL握手协商部分结束。\n步骤5: SSL第一次握手结束之后，客户端以Client Key Exchange报文作为回应。报文中包含通信加密中使用的一种被称为Pre-master secret的随机密码串。该报文已用步骤3中的公开密钥进行加密。\n步骤6： 接着客户端继续发送Change Cipher Spec报文。该报文会提示服务器，在此报文之后的通信会采用Pre-master secret密钥加密。\n步骤7： 客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。\n参考\n\n《图解HTTP》\n《深入浅出HTTPS》\nhttps://juejin.cn/post/6857287743966281736#heading-59\nhttps://liaodanqi.me/2020/04/11/net-sec-integrity-and-digital-signature/\nhttps://juejin.cn/post/6844904158319869960\n\n","plink":"https://blog.ixin.run/posts/1615560323/"},{"title":"Http协议原理知多少","date":"2021-03-08T13:59:05.000Z","date_formatted":{"ll":"2021年3月8日","L":"2021/03/08","MM-DD":"03-08"},"updated":"2021-03-15T04:16:08.121Z","content":"推荐一本书《图解HTTP》，我看了有好几遍，尤其是书中的图片很形象。无论是前端、移动端抑或是大后端都离不开Http协议，所以弄清楚Http相关知识和原理着实重要，本文就挑重点式总结一下Http知识。\n\nTCP/IP协议族\n为了理解HTTP，我们有必要事先了解一下TCP/IP协议族。\n\n什么是协议？\n计算机与网络设备进行通信，双方就必须基于相同的方法。比如，如何找到通信目标，采用哪种语言通信，如何结束通信等。这些都需要规则约束，我们把这种规则称之为协议（protocol）。\n\n通常使用的网络（包括互联网）是在TCP/IP协议族的基础上运作的，而HTTP、TCP、IP等协议都属于它内部的子集。切莫把TCP/IP解读为仅仅是TCP和IP协议。\n\nTCP/IP分层\nTCP/IP采用四层分层模型，自上而下分别为应用层、传输层、网络层、数据链路层。\n应用层：\n应用层决定了向用户提供应用服务时通信的活动。应用层相关的协议有：\n\nHTTP（Hyper Text Transfer Protocol，超文本传输协议）\nFTP（File TransferProtocol，文件传输协议）\nDNS（Domain Name System，域名解析系统）\n\n传输层：\n传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。传输层相关的协议有：\n\nTCP（Transmission Control Protocol，传输控制协议）\nUDP（User Data Protocol，用户数据报协议）\n\n网络层：\n处理在网络上流动的数据包，为数据包选择路由。网络层相关的协议有：\n\nIP（Internet Protocol，IP协议）\n\n数据链路层：\n用来处理连接网络的硬件部分，硬件上的范畴均在链路层的作用范围之内。\nHTTP协议\nHTTP（Hyper Text Transfer Protocol，超文本传输协议），位于TCP/IP四层模型当中的应用层。 作用：在浏览器与服务器间传送文档，也是从Web服务器传输超文本到客户端的传输协议，无状态的传输协议；不仅能够保证正确、快速、高效的传输超文本文档，而且可以确定资源加载顺序等。 在Web开发中，页面缓存控制、数据传递、文档语言参数设定等等，都离不开HTTP协议。\nHTTP协议的几个重要概念：\n\n连接(Connection)：一个传输层的实际环流，它是建立在两个相互通讯的应用程序之间。\n消息(Message)：HTTP通讯的基本单位，包括一个结构化的八元组序列并通过连接传输。\n请求(Request)：一个从客户端到服务器的请求信息包括应用于资源的方法、资源的标识符和协议的版本号\n响应(Response)：一个从服务器返回的信息包括HTTP协议的版本号、请求的状态(例如“成功”或“没找到”)和文档的MIME类型。\n资源(Resource)：由URI标识的网络数据对象或服务。\n实体(Entity)：数据资源或来自服务资源的回映的一种特殊表示方法，它可能被包围在一个请求或响应信息中。一个实体包括实体头信息和实体的本身内容。\n客户机(Client)：一个为发送请求目的而建立连接的应用程序。\n用户代理(Useragent)：初始化一个请求的客户机。它们是浏览器、编辑器或其它用户工具。\n服务器(Server)：一个接受连接并对请求返回信息的应用程序。\n源服务器(Originserver)：是一个给定资源可以在其上驻留或被创建的服务器。\n代理(Proxy)：一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。\n代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处理没有被用户代理完成的请求。\n网关(Gateway)：一个作为其它服务器中间媒介的服务器。与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。\n网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。\n通道(Tunnel)：是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。\n缓存(Cache)：反应信息的局域存储。\n\nDNS协议\nDNS（Domain Name System，域名解析服务）的缩写，主要负责将域名解析为对应的IP地址。它与HTTP协议一样位于应用层。\n对于用户来说使用一串有意义的字符去访问某台计算机是更容易接受的。例如，用www.baidu.com访问百度。将用户容易理解的域名解析为网络传输需要的IP，这就是DNS存在的意义。\n\nTCP协议\nTCP（Transmission Control Protocol，传输控制协议），TCP位于传输层，提供可靠的字节流服务。\nTCP协议为了更容易传送大数据需要将大块数据分割成以报文段（segment）为单位的数据包。而且TCP协议能够确认数据最终是否送达到对方和安全断开连接，采用的方式是三次握手和四次挥手形式。\n\nIP协议\nIP（Internet Protocol）网际协议位于网络层，IP协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是IP地址和MAC地址（Media AccessControl Address）。\nIP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会更改。\n\n网络通信传输流\n下图是根据TCP/IP分层原理，端到端数据流的走向。\n\n发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。\n单说发送端这部分，数据流中各个协议扮演的角色如下：\n\n应用层的HTTP协议将请求地址和数据按照一定的格式包装成请求体，然后向下传输。\n传输层的TCP协议负责连接、发送数据、断开连接。TCP协议保证了HTTP数据包到达接受端的可靠性。为了传输方便，在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。\n网络层IP协议，将传输层传过来的数据作为自己的数据，并在自己数据前端加上IP首部然后转发给数据链路层。值得一提的是，在IP首部指定了接受端的MAC地址。\n数据链路层负责数据信号通过硬件向接收端进行传输。\n\n各种协议与HTTP协议的关系\n通过一张图我们回顾一下整个HTTP过程：\n\nHTTP报文\n用于HTTP协议交互的信息被称为HTTP报文，HTTP报文本身是由多行（用CR+LF作换行符）数据构成的字符串文本。\n\nHTTP报文有两种：请求报文 和 响应报文。请求报文指从客户端向服务端发送的报文，响应报文指从服务端响应客户端的报文。\n这两种报文都是由 首行、报文首部、报文主体三部分组成的。\n请求报文:\n123456789101112POST &#x2F;i HTTP&#x2F;1.1Host: count.typora.ioAccept: *&#x2F;*Content-Type: application&#x2F;x-www-form-urlencodedConnection: keep-aliveCookie: __cfduid&#x3D;d345ac732c82bada5e1f1b3ec7f42498e1550563241Accept-Language: zh-cnContent-Length: 206Accept-Encoding: br, gzip, deflateUser-Agent: Typora&#x2F;1355 CFNetwork&#x2F;975.0.3 Darwin&#x2F;18.2.0 (x86_64)app_key&#x3D;3162bc659f38963b8f15099e19551\n响应报文:\n12345678910111213HTTP&#x2F;1.1 200 OKServer: nginxDate: Mon, 11 Mar 2019 03:28:05 GMTContent-Type: application&#x2F;json; charset&#x3D;utf-8Vary: Accept-EncodingAccess-Control-Allow-Origin: *X-Frame-Options: denyX-XSS-Protection: 1; mode&#x3D;blockContent-Encoding: gzipTransfer-Encoding: chunkedConnection: Keep-alive&#123;&quot;result&quot;:&quot;Success&quot;&#125;\n请求报文首行\nPOST /i HTTP/1.1是请求报文的首行。其中 POST 代表请求方法。 /i 表示请求的资源URI。HTTP/1.1 表示HTTP版本号。\n请求方法\n告知服务器请求意图，期望服务器产生某种行为。\n目前常见的方法有：\n\n通常我们只会用到GET、POST方法。GET用来请求访问已被URI识别的资源，指定的资源经服务器解析后返回响应结果。POST用来传输实体的主体。虽然GET也可以用来传输实体的主体，但是一般我们不用，而是用POST。\nPUT用来传输文件，但是由于HTTP/1.1的PUT方法不带验证机制，存在安全隐患，因此很少用到。\nDETETE和PUT存在一样的问题，因此也很少用到。但是如果服务器采用了REST风格的设计，PUT和DELETE将会被应用到。\nHEAD和GET方法一样，只是不返回响应报文的主体部分。用来确认URI的有效性和资源更新的日期时间等。例如，客户端需要一个很大的文件（几百兆），如果每次都从网络上加载文件会造成很大的开销。为了解决这个问题，客户端可以在首次GET文件后进行缓存，以后只需要HEAD请求验证文件是否更新，只有当文件更新后才需要重新GET。\n响应报文首行\nHTTP/1.1 200 OK 是响应报文的首行。其中HTTP/1.1已经介绍过了，与请求报文首行中的HTTP版本号相同。200表示返回结果的状态码。OK表示原因短语。\n状态码\n状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。\n\n状态码如200 OK，以3位数字和原因短语组成。数字中的第一位指定了响应类别，后两位无分类。响应类别有以下5种：\n\n报文首部\n123456789Host: count.typora.ioAccept: *&#x2F;*Content-Type: application&#x2F;x-www-form-urlencodedConnection: keep-aliveCookie: __cfduid&#x3D;d345ac732c82bada5e1f1b3ec7f42498e1550563241Accept-Language: zh-cnContent-Length: 206Accept-Encoding: br, gzip, deflateUser-Agent: Typora&#x2F;1355 CFNetwork&#x2F;975.0.3 Darwin&#x2F;18.2.0 (x86_64)\n报文的首部字段表示请求的各种条件和属性，它能起到传递额外重要信息的作用。根据其用途的不同可以分为以下四种：通用首部字段、请求首部字段、响应首部字段、实体首部字段。\nHTTP/1.1规范定义了如下47种首部字段。\n通用首部字段\n请求报文和响应报文都会用到的首部。\n\n请求首部字段\n请求报文用到的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。\n\n响应首部字段\n响应报文用到的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。\n\n实体首部字段\n针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。\n\n常用的报文首部\nHTTP/1.1定义了47种首部字段，另外还有一些扩展的。比较常用的几种：\n\nHTTP工作原理\nHTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。\n以下是 HTTP 请求/响应的步骤：\n1、客户端连接到Web服务器\n一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。\n2、发送HTTP请求\n通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。\n3、服务器接受请求并返回HTTP响应\nWeb服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。\n4、释放连接TCP连接\n若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;\n5、客户端浏览器解析HTML内容\n客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。\n例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：\n\n浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址；\n解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接；\n浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器；\n服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器；\n释放 TCP连接；\n浏览器将该 html 文本并显示内容；\n\nHTTP特性\n1. 无状态\nHTTP 是一种无状态协议，即HTTP不会管理之前客户端与服务器的通信状态。由于不用保存通信状态，那么服务器的CPU以及内存的压力会大大降价。这是HTTP无状态的优点，但它也会给我们带来一些的问题。\n例如，我们去某购物网站购物，提交订单之前要对我们的身份进行验证（需要我们登录账号）。但是由于HTTP的无状态特性（没有记录登录状态），每次下单都会要求我们重新登录。为了即不破坏HTTP的无状态特性又可以解决类似的问题，HTTP引入了Cookie技术。Cookie技术通过在请求报文和响应报文中加入cookie信息来实现状态的保持。在响应报文中，服务器可以通过set-cookie首部告诉客户端Cookie信息。客户端再次请求时会通过Cookie首部携带上Cookie信息。\n\n\n2. 持久连接\nHTTP依赖于TCP进行数据传输，TCP是一种稳定的长连接，即如果没有一方明确的提出过断开连接，那么连接将一直持续。\n在早些年的HTTP协议中，每进行一次HTTP通信，都会有一次TCP的连接与断开。这与TCP的长连接特性相违背。因此，在HTTP/1.1和部分HTTP/1.0中增加了持久连接（HTTP persistent connection，也称作HTTP keep-alive或HTTP connection reuse），使用同一个TCP连接来发送和接受多个HTTP通信，而不是为每一次通信都打开新的连接。HTTP就是通过Connection首部来管理持久连接的。\n\n3. 缓存机制\nHTTP允许客户端在一次URL请求完成后将响应结果存储到本地。下次向该URL请求资源时，客户端会直接从本地存储中获取到该URL的资源。引入了缓存机制后，HTTP请求会变的稍微复杂一点：\n\n\n当我们初次访问一个URL时，服务器返回请求资源并同时告诉客户端对资源进行缓存、以及缓存过期时间。\n\n\n再次访问该URL时，客户端会根据URI找到对应的缓存，并检查缓存是否有效（当前时间小于缓存的过期时间）。\n\n\n若缓存有效，客户端不会去访问服务器，而是直接从缓存中获取资源，这个过程我们称为缓存命中。\n\n\n若缓存无效（当前时间大于缓存的过期时间），客户端会去向服务器验证缓存是否有效。\n\n有效，服务器仅返回代表缓存有效的首部信息，客户端更新缓存过期时间，同时从缓存中取得资源。\n无效，服务器返回新的资源，客户端更新资源。\n\n\n\n\n\n扩展知识\nGET和POST的区别\n其实这个问题这么多年来争论一直喋喋不休。GET和POST这两种方式从&quot;明面&quot;上说可能有以下区别：\n\nGET能被缓存，POST不能缓存 。\nGET请求只能进行url编码，而POST支持多种编码方式。\nGET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。\nGET请求在URL中传送的参数是有长度限制的，而POST没有。\nGET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。\nGET只允许 ASCII 字符。POST没有限制。也允许二进制数据。\n\n然而上边的这些区别仅仅是&quot;明面&quot;上的。实际上GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。这里有一个很形象的说明：\n\n在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。\n\n针对“安全性”，我们常听到GET不如POST安全，因为POST用body传输数据，而GET用url传输，更加容易看到。但是从攻击的角度，无论是GET还是POST都不够安全，因为HTTP本身是明文协议。每个HTTP请求和返回的每个byte都会在网络上明文传播，不管是url，header还是body。\n针对&quot;长度限制&quot;，这里也有一个形象的说明：\n\n在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器（发起http请求）和服务器（接受http请求）就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物（url中无限加参数）。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。\n\nTCP和UDP的区别\n什么是UDP?\nUDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。\n它有以下几个特点：\n1.面向无连接\n首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。具体来说就是：\n\n在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了\n在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作\n\n2.有单播，多播，广播的功能\nUDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。\n3.UDP是面向报文的\n发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文\n4.不可靠性\n首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。\n并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。\n再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。\nTCP和UDP的比较:\n\nOSI七层模型\nOSI（open system interconnection，开放式系统互联参考模型）是一种概念模型，由国际标准化组织提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。\n该模型将通信系统中的数据流划分为七个层，从跨通信介质传输位的物理实现到分布式应用程序数据的最高层表示。每个中间层为其上一层提供功能，其自身功能则由其下一层提供。\n自上而下七层分别是：\n第7层 应用层\n应用层（Application Layer）提供为应用软件而设计的接口，以设置与另一应用软件之间的通信。例如：HTTP、HTTPS、FTP、Telnet、SSH、SMTP、POP3等。\n第6层 表示层\n表示层（Presentation Layer）把数据转换为能与接收者的系统格式兼容并适合传输的格式。\n第5层 会话层\n会话层（Session Layer）负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接。\n第4层 传输层\n传输层（Transport Layer）把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议（TCP）等。\n第3层 网络层\n网络层（Network Layer）决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络资料。例如:互联网协议（IP）等。\n第2层 数据链路层\n数据链路层（Data Link Layer）负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成信息框（Data Frame）。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。例如以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）等。\n分为两个子层：逻辑链路控制（logical link control，LLC）子层和介质访问控制（Media access control，MAC）子层。\n第1层 物理层\n物理层（Physical Layer）在局部局域网上发送数据帧（Data Frame），它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等。\nOSI和TCP/IP对应关系：\n\n王炸\n一张图理清全域TCP/IP：\n\n参考\n\n《图解HTTP》\n超文本传输协议–维基百科\nOSI模型–维基百科\nhttps://juejin.cn/post/6844903815531986957\nhttps://juejin.cn/post/6857287743966281736\n\n","plink":"https://blog.ixin.run/posts/1615211970/"},{"title":"你了解android的进程间通信吗","date":"2021-03-07T12:10:40.000Z","date_formatted":{"ll":"2021年3月7日","L":"2021/03/07","MM-DD":"03-07"},"updated":"2021-03-10T01:15:14.497Z","content":"你了解android的进程间通信吗？提到进程间通信，这是android开发中很重要的一环，也是面试高频知识点，本文总结一下进程间通信的几种方式，把这块知识系统起来。\n\n什么是进程间通信\n进程间通信（IPC，Interprocess communication）是一组编程接口，让程序员能够协调不同的进程，使之能在一个操作系统里同时运行，并相互传递、交换信息。\n如何开启多进程\n正常情况下，在Android中多进程是指一个应用中存在多个进程的情况，因此这里不讨论两个应用之间的多进程情况。在Android中上层应用开发使用多进程唯一一种方法，那就是给四大组件（Activity、Service、Receiver、ContentProvider）在AndroidMenifest中指定android:process属性。\n123456789101112...&lt;activity    android:name=&quot;com.ryg.chapter_2.SecondActivity&quot;    android:configChanges=&quot;screenLayout&quot;    android:label=&quot;@string/app_name&quot;    android:process=&quot;:remote&quot; /&gt;&lt;activity    android:name=&quot;com.ryg.chapter_2.ThirdActivity&quot;    android:configChanges=&quot;screenLayout&quot;    android:label=&quot;@string/app_name&quot;    android:process=&quot;com.ryg.chapter_2.remote&quot; /&gt;\n上面的示例分别为SecondActivity和ThirdActivity指定了process属性，并且它们的属性值不同，这意味着当前应用又增加了两个新进程。\n其中SecondActivity和ThirdActivity的android:process属性分别为“:remote”和“com.ryg.chapter_2.remote”，这两种方式是有区别的：\n\n首先，“:”的含义是指要在当前的进程名前面附加上当前的包名，这是一种简写的方法，对于SecondActivity来说，它完整的进程名为com.ryg.chapter_2:remote，而对于ThirdActivity中的声明方式，它是一种完整的命名方式，不会附加包名信息；\n其次，进程名以“:”开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一个进程中，而进程名不以“:”开头的进程属于全局进程，其他应用通过ShareUID方式可以和它跑在同一个进程中。\n\nAndroid系统会为每个应用分配一个唯一的UID。通常，不同的APK会具有不同的userId，因此运行时属于不同的进程中，而不同进程中的资源是不共享的，然后有些时候，我们自己公司开发了多个APK并且需要他们之间互相共享资源，那么就可以通过设置相同的shareUserId和相同的签名来实现这一目的。\n多进程影响\n我们知道Android为每一个应用分配了一个独立的虚拟机，或者说为每个进程都分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，这就导致在不同的虚拟机中访问同一个类的对象会产生多份副本。\n所以，所有运行在不同进程中的四大组件，只要它们之间需要通过内存来共享数据，都会共享失败，这也是多进程所带来的主要影响。一般来说，使用多进程会造成如下几方面的问题：\n\n（1）静态成员和单例模式完全失效。\n\n静态成员属于类，不属于对象\n因为单例模式想要保证全局只有一个对象，多进程会有多个副本了，那也就不能保证全局只有一个对象了，也就失去了作用了\n\n\n（2）线程同步机制完全失效。\n（3）SharedPreferences的可靠性下降。\n（4）Application会多次创建。\n\nIPC有哪些方式\n有问题就要有解决，为了解决这些问题，系统提供了很多跨进程通信方法，虽然说不能直接地共享内存，但是通过跨进程通信我们还是可以实现数据交互。\n关于Android中的进程间通信，大概可以通过以下方式进行：\n\nBundle：四大组件间通信\nFile：文件共享\nAIDL：Binder机制\nMessager：基于AIDL、Handler实现\nContentProvider：应用间数据共享\nSocket：建立C/S通信模型\n\n使用Bundle\n四大组件中的三大组件（Activity、Service、Receiver）都是支持在Intent中传递Bundle数据的，由于Bundle实现了Parcelable接口，所以它可以方便地在不同的进程间传输，这里说明一点ContentProvider的call方法可以使用Bundle，而在其他方法中不能使用。\n另外，Bundle不支持的类型我们无法通过它在进程间传递数据，这不用说了。\n使用File（文件共享）\n共享文件也是一种不错的进程间通信方式，两个进程通过读/写同一个文件来交换数据，比如A进程把数据写入文件，B进程通过读取这个文件来获取数据。\n由于Android系统基于Linux，使得其并发读/写文件可以没有限制地进行，甚至两个线程同时对同一个文件进行写操作都是允许的，那么我们读出的内容就有可能不是最新的，如果是并发写的话那就更严重了。\n普通文件并发执行，如果妥善处理并发的速度和频率或许可以保证数据的准确性。然而SharedPreferences是个特例，从本质上来说，SharedPreferences也属于文件的一种，但是由于系统对它的读/写有一定的缓存策略，即在内存中会有一份SharedPreferences文件的缓存，因此在多进程模式下，系统对它的读/写就变得不可靠，当面对高并发的读/写访问，Sharedpreferences有很大几率会丢失数据，因此，不建议在进程间通信中使用SharedPreferences。\n使用Messenger\nMessenger可以翻译为信使，顾名思义，通过它可以在不同进程中传递Message（信息）对象，在Messenger（信使）中进行数据传递必须将数据放入Message（信息）中，而Messenger和Message都实现了Parcelable接口，因此可以跨进程传输。\nMessenger是一种轻量级的IPC方案，它的底层实现是AIDL：\n1234567public Messenger(Handler target) &#123;     mTarget = target.getIMessenger();&#125;public Messenger(IBinder target) &#123;     mTarget = IMessenger.Stub.asInterface(target);&#125;\nMessenger的使用方法很简单，它对AIDL做了封装，使得我们可以更简便地进行进程间通信。同时，由于它一次处理一个请求，因此在服务端我们不用考虑线程同步的问题，这是因为服务端中不存在并发执行的情形。\nMessager一般用在同一个应用多个不同进程服务的通信处理，下边通过代码描述一下服务端和客户端两个过程Messager通信实现过程：\n服务端进程：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class MessengerService extends Service &#123;    private static final String TAG = &quot;MessengerService&quot;;    //继承Handler，MessengerHandler用来处理客户端发送的消息，并从消息中取出客户端发来的文本信息。    private static class MessengerHandler extends Handler &#123;        @Override        public void handleMessage(Message msg) &#123;            switch (msg.what) &#123;            case MyConstants.MSG_FROM_CLIENT:                Log.i(TAG, &quot;receive msg from Client:&quot; + msg.getData().getString(&quot;msg&quot;));                /**                 * 因为我们的Messenger是通过客户端来获取的，而在客户端那边这个Messenger是以Handler为参数创建的，                 * 所以在服务端通过客户端的Messenger发送消息后，在客户端的Handler就会处理这条消息，                 * 嘻嘻，就达到了消息传送的目的。                 */                Messenger client = msg.replyTo;                Message relpyMessage = Message.obtain(null, MyConstants.MSG_FROM_SERVICE);                Bundle bundle = new Bundle();                bundle.putString(&quot;reply&quot;, &quot;嗯，你的消息我已经收到，稍后会回复你。&quot;);                relpyMessage.setData(bundle);                try &#123;                    client.send(relpyMessage);                &#125; catch (RemoteException e) &#123;                    e.printStackTrace();                &#125;                break;            default:                super.handleMessage(msg);            &#125;        &#125;    &#125;    //这是我们服务端自己的Messenger，它是以上面的Handler对象为参数创建的，    //这个Messenger是要通过绑定该服务器的时候onBind方法传递给客户端，然后客户端获取了该Messenger，    //再以该Messenger来发送消息，这样服务端就可以接收到该消息并处理。    private final Messenger mMessenger = new Messenger(new MessengerHandler());    //这个方法是在绑定服务的过程中调用的并将结果返回给客户端的，所以通过onBind方法客户端就可以获取我们Messenger的Binder对象了，    //然后客户端可以根据该Binder对象来创建一个Messenger，这样客户端中用的Messenger和这里的Messenger就是向对应的了。    @Override    public IBinder onBind(Intent intent) &#123;        return mMessenger.getBinder();    &#125;    @Override    public void onCreate() &#123;        super.onCreate();    &#125;    @Override    public int onStartCommand(Intent intent, int flags, int startId) &#123;        return super.onStartCommand(intent, flags, startId);    &#125;&#125;\n然后，注册service，让其运行在单独的进程中：\n123&lt;service      android:name=&quot;com.ryg.chapter_2.messenger.MessengerService&quot;      android:process=&quot;:remote&quot; &gt;\n客户端进程：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class MessengerActivity extends Activity &#123;    private static final String TAG = &quot;MessengerActivity&quot;;    private Messenger mService;    //准备一个接收消息的Messenger和Handler    //这是客户端自己的Messenger，传递给服务端，让服务端返回消息用的。    private Messenger mGetReplyMessenger = new Messenger (new MessengerHandler ());    private static class MessengerHandler extends Handler &#123;        @Override        public void handleMessage(Message msg) &#123;            switch (msg.what) &#123;                case MyConstants.MSG_FROM_SERVICE:                    Log.i (TAG, &quot;receive msg from Service:&quot; + msg.getData ().getString (&quot;reply&quot;));                    break;                default:                    super.handleMessage (msg);            &#125;        &#125;    &#125;    /**     * 这个是客户端用来绑定服务端用的，在绑定过程中会调用onServiceConnected，它的第二个参数IBinder service，     * 就是在服务端中onBind方法返回的结果，这个结果是服务端的Messenger对象的Binder对象，     * 然后客户端通过这个Binder对象就可以创建一个Messenger，     * 所以就是在绑定服务的过程中将服务端的Messenger传递给了客户端，建立起了两者之间的桥梁     */    private ServiceConnection mConnection = new ServiceConnection () &#123;        public void onServiceConnected(ComponentName className, IBinder service) &#123;            mService = new Messenger (service);            Log.d (TAG, &quot;bind service&quot;);            Message msg = Message.obtain (null, MyConstants.MSG_FROM_CLIENT);            Bundle data = new Bundle ();            data.putString (&quot;msg&quot;, &quot;hello, this is client.&quot;);            msg.setData (data);            //把接收服务端回复的Messenger通过Message的replyTo参数传递给服务端            msg.replyTo = mGetReplyMessenger;            try &#123;                mService.send (msg);            &#125; catch (RemoteException e) &#123;                e.printStackTrace ();            &#125;        &#125;        public void onServiceDisconnected(ComponentName className) &#123;        &#125;    &#125;;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate (savedInstanceState);        setContentView (R.layout.activity_messenger);        Intent intent = new Intent (&quot;com.ryg.MessengerService.launch&quot;);        //在bindService的时候，服务端会通过onBind方法返回一个包含了服务端业务调用的Binder对象，        //通过这个对象，客户端就可以获取服务端提供的服务或者数据，        bindService (intent, mConnection, Context.BIND_AUTO_CREATE);    &#125;    @Override    protected void onDestroy() &#123;        unbindService (mConnection);        super.onDestroy ();    &#125;&#125;\n客户端的实现也比较简单，首先需要绑定远程进程的MessengerService，绑定成功后，根据服务端返回的binder对象创建Messenger对象并使用此对象向服务端发送消息。\nMessenger的工作原理图：\n\nMessenger是以串行的方式处理客户端发来的消息，如果大量的消息同时发送到服务端，服务端仍然只能一个个处理，如果有大量的并发请求，那么用Messenger就不太合适了。同时，Messenger的作用主要是为了传递消息，很多时候我们可能需要跨进程调用服务端的方法，这种情形用Messenger就无法做到了。但是我们可以使用AIDL来实现跨进程的方法调用。\n使用AIDL\nAIDL，一种接口定义语言，用于约束两个进程之间的通讯规则，供编译器生成代码实现Android设备的IPC。AIDL也是Messenger的底层实现，因此Messenger本质上也是AIDL，只不过系统为我们做了封装从而方便上层的调用而已。\nAIDL方式主要用于两个应用间数据传输和方法调用实现。这里简单描述一下服务端和客户端AIDL各自的工作：\n\n服务端：服务端首先要创建一个Service用来监听客户端的连接请求，然后创建一个AIDL文件，将暴露给客户端的接口在这个AIDL文件中声明，最后在Service中实现这个AIDL接口即可\n客户端：客户端所要做事情就稍微简单一些，首先需要绑定服务端的Service，绑定成功后，将服务端返回的Binder对象转成AIDL接口所属的类型，接着就可以调用AIDL中的方法了。\n\nAIDL具体使用可参看我早前写的一篇文章《Android开发之进程间通信AIDL的探究和学习》\nAIDL方法是在服务端的Binder线程池中执行的，因此当多个客户端同时连接的时候，会存在多个线程同时访问的情形，所以我们要在AIDL方法中处理线程同步，如果是用List存储对象，那么可更换为CopyonWriteArayList来进行自动的线程同步，下边实现一个aidl接口：\n12345678910111213141516171819202122232425262728293031323334353637383940414243// 定义aidl接口interface IBookManager &#123;    List&lt;Book&gt; getBookList();    void addBook(in Book book);&#125;//实现aidl接口public class BookManagerService extends Service &#123;    private static final String TAG = &quot;BookManagerService&quot;;    private CopyOnWriteArrayList&lt;Book&gt; mBookList = new CopyOnWriteArrayList&lt;&gt;();    private Binder mBinder = new IBookManager.Stub() &#123;        @Override        public List&lt;Book&gt; getBookList() throws RemoteException &#123;            return mBookList;        &#125;        @Override        public void addBook(Book book) throws RemoteException &#123;            mBookList.add(book);        &#125;    &#125;;    @Override    public void onCreate() &#123;        super.onCreate();        mBookList.add(new Book(1,&quot;Android&quot;));        mBookList.add(new Book(1,&quot;IOS&quot;));    &#125;    @Override    public IBinder onBind(Intent intent) &#123;        return mBinder;    &#125;&#125;\nAIDL工作原理图：\n\n使用ContentProvider\nContentProvider是Android中提供的专门用于不同应用间进行数据共享的方式，从这一点来看，它天生就适合进程间通信。和Messenger一样，ContentProvider的底层实现同样也是Binder，但是它的使用过程要比AIDL简单许多，这是因为系统已经为我们做了封装，使得我们无须关心底层细节即可轻松实现IPC。\n系统预置了许多ContentProvider，比如通讯录信息、日程表信息等，要跨进程访问这些信息，只需要通过ContentResolver的query、update、insert和delete方法即可。\nContentProvider的使用可参看我之前的一篇文章《Android开发ContentProvider学习总结》\n使用Socket\nSocket也称为“套接字”，是网络通信中的概念，它分为流式套接字和用户数据报套接字两种，分别对应于网络的传输控制层中的TCP和UDP协议。\n\nTCP协议是面向连接的协议，提供稳定的双向通信功能，TCP连接的建立需要经过“三次握手”才能完成，为了提供稳定的数据传输功能，其本身提供了超时重传机制，因此具有很高的稳定性；\n而UDP是无连接的，提供不稳定的单向通信功能，当然UDP也可以实现双向通信功能。\n在性能上，UDP具有更好的效率，其缺点是不保证数据一定能够正确传输，尤其是在网络拥塞的情况下。\n\n两个进程可以通过Socket来实现信息的传输，Socket本身可以支持传输任意字节流，很显然，这是一种IPC方式。\nSocket的使用可参看我之前的一篇文章《Java开发揭开socket编程的面纱》\n选择合适的IPC\n不同IPC方式有不同适用场景，在实际的开发中，只要我们选择合适的IPC方式就可以轻松完成多进程的开发场景。\nIPC方式的优缺点和适用场景表：\n\nRPC(Remote Procedure Call)：远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的思想。特指一种隐藏了过程调用时实际通信细节的IPC方法。而IPC概念泛指进程之间任何形式的通信行为。\n这里再对比上表总结一下：\n\n只有允许不同应用的客户端用 IPC 方式调用远程方法，并且想要在服务中处理多线程时，才有必要使用 AIDL\n如果需要调用远程方法，但不需要处理并发 IPC，就应该通过实现一个 Binder 创建接口\n如果您想执行 IPC，但只是传递数据，不涉及方法调用，也不需要高并发，就使用 Messenger 来实现接口\n如果需要处理一对多的进程间数据共享（主要是数据的 CRUD），就使用 ContentProvider\n如果要实现一对多的并发实时通信，就使用 Socket\n\n参考\n\n《Android开发艺术探索》\nhttps://developer.android.com/reference/android/os/Binder\n\n","plink":"https://blog.ixin.run/posts/1615119064/"},{"title":"Android开发数据持久化有哪些形式","date":"2021-03-06T17:00:12.000Z","date_formatted":{"ll":"2021年3月7日","L":"2021/03/07","MM-DD":"03-07"},"updated":"2021-03-10T01:15:14.488Z","content":"Android数据持久化的形式最常用的有以下五种：\n\n使用SharedPreferences存储数据\n文件存储数据\nSQLite数据库存储数据\n使用ContentProvider存储数据\n网络存储数据\n\n\nSharedPreferences\nSharedPreferences是Android系统提供的一种轻量级的数据存取方式，数据存取是通过键值对的形式，存放到xml中。xml文件的存放路径为：/data/data/packageName/shared_prefs/目录。\n核心原理\nSharedPreferences的本身实现就是分为两步，一步是内存，一部是磁盘，而主线程又依赖SharedPreferences的写入，所以可能当io成为瓶颈的时候，App会因为SharedPreferences变的卡顿，严重情况下会ANR，总结下来有以下几点：\n\n存放在xml文件中的数据会被装在到内存中，所以获取数据很快\napply是异步操作，提交数据到内存，并不会马上提交到磁盘\ncommit是同步操作，会等待数据写入到磁盘，并返回结果\n如果有同一个线程多次commit，则后面的要等待前面执行结束\n如果多个线程对同一个sp并发commit，后面的所有任务会进入到QueuedWork中排队执行，且都要等第一个执行完毕\n\n几宗罪\n\n跨进程不安全。由于没有使用跨进程的锁，就算使用 MODE_MULTI_PROCESS，SharedPreferences 在跨进程频繁读写有可能导致数据全部丢失。根据线上统计，SharedPreferences 大约会有万分之一的损坏率。\n加载缓慢。SharedPreferences 文件的加载使用了异步线程，而且加载线程并没有设置优先级，如果这个时候读取数据就需要等待文件加载线程的结束。这就导致主线程等待低优先线程锁的问题，比如一个 100KB 的 SP 文件读取等待时间大约需要 50 ~ 100ms，并且建议大家提前用预加载启动过程用到的 SP 文件。\n全量写入。无论是 commit() 还是 apply()，即使我们只改动其中一个条目，都会把整个内容全部写到文件。而且即使我们多次写同一个文件，SP 也没有将多次修改合并为一次，这也是性能差的重要原因之一。\n卡顿。由于提供了异步落盘的 apply 机制，在崩溃或者其它一些异常情况可能会导致数据丢失。所以当应用收到系统广播，或者被调用 onPause 等一些时机，系统会强制把所有的 SharedPreferences 对象的数据落地到磁盘。如果没有落地完成，这时候主线程会被一直阻塞。这样非常容易造成卡顿，甚至是ANR，从线上数据来看 SP 卡顿占比一般会超过 5%。\n\n优化建议\n\n不要存放大的 key 或 value 在 SharedPreferences 中，否则会一直存储在内存中（Map 容器中）得不到释放，内存使用过高会频繁引发 GC，导致界面丢帧甚至 ANR。\n不相关的配置选项最好不要放在一起，单个文件越大加载时间越长。（参照 SharedPreferences 初始化时会开启异步线程读取对应文件，如果此时耗时较长，当对其进行相关数据操作时会导致线程等待）\n读取频繁的 key 和 不频繁的 key 尽量不要放在一起。（如果整个文件本身就较小则可以忽略）\n不要每次都 edit 操作，每次 edit 都会创建新的 EditorImpl 对象，最好批量处理统一提交。否则每次 edit().commit() 都会创建新的 EditorImpl 对象并进行一次 I/O 操作，严重影响性能。\ncommit 提交发生在 UI 线程，apply 提交发生在工作线程，对于数据的提交最好是批量操作统一提交。虽然 apply 任务发生在工作线程（不会因为 I/O 阻塞 UI 线程），但是如果添加过多任务也有可能带来其它”严重后果“（参照系统源码 ActivityThread - handlePauseActivity 方法实现）。\n尽量不要存放 JSON 或 HTML 类型数据，这种可以直接文件存储。\n最好能够提前初始化 SharedPreferences，避免 SharedPreferences 第一次创建时读取文件内容线程未结束而出现的等待情况，参照优化点第 2 条。\n不要指望它能够跨进程通信：Context.MODE_MULTI_PROCESS。\n\n文件存储数据\n在很多情况下，您的应用会创建其他应用不需要访问或不应访问的文件。系统提供以下位置，用于存储此类应用专属文件：\n\n内部存储空间目录：这些目录既包括用于存储持久性文件的专属位置，也包括用于存储缓存数据的其他位置。系统会阻止其他应用访问这些位置，并且在 Android 10（API 级别 29）及更高版本中，系统会对这些位置进行加密。这些特征使得这些位置非常适合存储只有应用本身才能访问的敏感数据。\n\ngetFilesDir()，data/data/com.companyname.appname/files/ ，用于持久文件\ngetCacheDir()，data/data/com.companyname.appname/cache/ ，用于暂存文件\n\n\n外部存储空间目录：这些目录既包括用于存储持久性文件的专属位置，也包括用于存储缓存数据的其他位置。虽然其他应用可以在具有适当权限的情况下访问这些目录，但存储在这些目录中的文件仅供您的应用使用。如果您明确打算创建其他应用能够访问的文件，您的应用应改为将这些文件存储在外部存储空间的共享存储空间部分。\n\ngetExternalFilesDir()，/mnt/sdcard/Android/data/com.companyname.appname/files/ ，用于持久文件文件\ngetExternalCacheDir()，/mnt/sdcard/Android/data/com.companyname.appname/cache/，用于暂存文件\n\n\n\n以上方式都是针对该应用，一旦应用卸载，这些文件也就不复存在了，如果想要长久保存，可存储到外置SD卡其他地方，参见共享存储空间。\nJava常规读写\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/**     * 从SD卡中读取文件     */    public static String readFromSD(String filePath) &#123;        String content = &quot;&quot;;        ByteArrayOutputStream ops = null;        FileInputStream fis = null;        try &#123;            if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) &#123;                File file = new File(filePath);                if (file.exists()) &#123;                    fis = new FileInputStream(file);                    ops = new ByteArrayOutputStream();                    int len = 0;                    byte[] data = new byte[1024];                    while ((len = fis.read(data)) != -1) &#123;                        ops.write(data, 0, len);                    &#125;                    content = new String(ops.toByteArray());                &#125;            &#125;        &#125; catch (Exception e) &#123;            LoggerUtil.e(e.toString());        &#125; finally &#123;            if (ops != null) &#123;                try &#123;                    ops.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (fis != null) &#123;                try &#123;                    fis.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        return content;    &#125;    /**     * 写文件到SD卡     *     * @param append 是否追加写入     */    public static boolean writeFile(String filePath, String content, boolean append) &#123;        boolean flag = false;        FileOutputStream fos = null;        try &#123;            if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) &#123;                File file = new File(Environment.getExternalStorageDirectory(), filePath);                if (!file.exists()) &#123;                    createNewFile(file);                &#125;                fos = new FileOutputStream(file, append);                fos.write(content.getBytes());                flag = true;            &#125;        &#125; catch (Exception e) &#123;            LoggerUtil.e(e.toString());        &#125; finally &#123;            if (fos != null) &#123;                try &#123;                    fos.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        return flag;    &#125;\nAndroid私有文件读写\nContext提供了两个方法来打开数据文件里的文件IO流：\n\nopenFileInput(String name)，读文件\nopenFileOutput(String name, int mode)，写文件\n\n其中openFileOutput的第二个参数指定打开文件的模式：\n\nMODE_PRIVATE，默认操作模式 ，当指定同样文件名的时候会覆盖原有文件内容。\nMODE_APPEND，如果文件不存在就创建文件，如果存在就往后面追加。\nMODE_WORLD_READABLE，允许其他程序对我们的文件进行修改，过于危险 Android4.2以后已被废除。\nMODE_WORLD_WRITEABLE，允许其他程序对我们的文件进行修改，过于危险 Android4.2以后已被废除。\n\n123456789101112131415161718192021222324252627282930313233public String read() &#123;        try &#123;            FileInputStream inStream = this.openFileInput(&quot;message.txt&quot;);            byte[] buffer = new byte[1024];            int hasRead = 0;            StringBuilder sb = new StringBuilder();            while ((hasRead = inStream.read(buffer)) != -1) &#123;                sb.append(new String(buffer, 0, hasRead));            &#125;            inStream.close();            return sb.toString();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;         return null;    &#125;        public void write(String msg)&#123;        // 步骤1：获取输入值        if(msg == null) return;        try &#123;            // 步骤2:创建一个FileOutputStream对象,MODE_APPEND追加模式            FileOutputStream fos = openFileOutput(&quot;message.txt&quot;,                    MODE_APPEND);            // 步骤3：将获取过来的值放入文件            fos.write(msg.getBytes());            // 步骤4：关闭数据流            fos.close();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;\nAndroid Q 沙盒模式\n为了让用户更好地管理自己的文件并减少混乱，以 Android 10（Android Q，API 级别 29）及更高版本为目标平台的应用在默认情况下被授予了对外部存储空间的分区访问权限（即分区存储(沙盒模式)）。启用分区存储后，应用将无法访问属于其他应用的应用专属目录。另外，AndroidQ中不支持file://类型访问文件，只能通过uri方式访问。\nSQLite数据库存储数据\nSQLite是轻量级嵌入式数据库引擎，它支持 SQL 语言，并且只利用很少的内存就有很好的性能。现在的主流移动设备像Android、iPhone等都使用SQLite作为复杂数据的存储引擎，在我们为移动设备开发应用程序时，也许就要使用到SQLite来存储我们大量的数据，所以我们就需要掌握移动设备上的SQLite开发技巧。详细使用可参阅我之前总结的一篇文章《Android开发之SQLite使用详解》\n相关ORM框架：\n\ngreendao，已经停更\nroom，官方jitpack推荐\n\nContentProvider存储数据\nContentProvider内容提供器，主要用于在不同应用程序之间实现数据的共享功能。\n举例来说，我们开发一个应用程序，我们不可能只使用自己的数据，也会用到其他应用的数据，像手机中的通讯录联系人，图片，音乐等是使用到最多的。我们使用的SharedPreferences，文件存储以及数据库SQLite都是从存储的应用内部的数据，实现不同应用间的数据共享就要使用到ContentProvider。\nContentProvider使用方法有两种：\n\n使用现有的内容提供器来读取和操作相应程序中的数据\n创建自己的内容提供器给我们的应用提供外部访问接口\n\n详细使用可参阅我之前总结的一篇文章《Android开发ContentProvider学习总结》\n网络存储数据\n通过网络提供的存储空间来存储、获取数据信息。这块不用细说了。\n参考\n\nhttps://www.jianshu.com/p/5fcef7f68341\nhttps://developer.android.com/training/data-storage/app-specific?hl=zh-cn\n\n","plink":"https://blog.ixin.run/posts/1615050026/"},{"title":"Android开发Style和Theme知识面总结","date":"2021-03-05T15:39:22.000Z","date_formatted":{"ll":"2021年3月5日","L":"2021/03/05","MM-DD":"03-05"},"updated":"2021-03-10T01:15:14.474Z","content":"这块知识大部分同学都知道，但是同样比较碎，比如说定义一个Style，到底该用于主题还是用于某个view？再比如说Style的继承应该怎么用？等等…本文我将尽可能全面的将这块知识点总结一下。\n\n资源位置\n开发过程中style和theme等这些资源文件会放在res/values/文件夹下，都是xml文件。\n\nattrs.xml\ncolors.xml\ndimens.xml\nstring.xml\narrays.xml\nstyles.xml\nthemes.xml\n\n以上这些xml文件项目中没有的话可以新建，xml命名一般会在结尾带一个’s’，表示里面的内容不止一个。另外命名也可以根据项目模块加以区分，例如main_strings.xml，更容易管理。\nattrs.xml\n该文件主要定义一些自定义view的属性声明。\n属性声明\n1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt;    &lt;attr name=&quot;attr_str&quot; format=&quot;string&quot;&gt;&lt;/attr&gt;    &lt;attr name=&quot;attr_bool&quot; format=&quot;boolean&quot;&gt;&lt;/attr&gt;    &lt;attr name=&quot;attr_int&quot; format=&quot;integer&quot;&gt;&lt;/attr&gt;    &lt;attr name=&quot;attr_ref&quot; format=&quot;reference&quot;&gt;&lt;/attr&gt;&lt;/resources&gt;\n其中 name表示属性名，format表示其接受的输入格式。format还有其它格式，如：\n\ncolor – 颜色值\ndimension – 尺寸\nfloat – 浮点值\nfraction – 百分比\nenum – 枚举\nflag – 位或运算\n混合类型 – 多种format结合\n\nenum和flag声明（可以不指定format），如下：\n123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt;    &lt;attr name=&quot;attr_enum&quot;&gt;        &lt;enum name=&quot;first&quot; value=&quot;1&quot;&gt;&lt;/enum&gt;        &lt;enum name=&quot;second&quot; value=&quot;2&quot;&gt;&lt;/enum&gt;        &lt;enum name=&quot;third&quot; value=&quot;3&quot;&gt;&lt;/enum&gt;    &lt;/attr&gt;    &lt;attr name=&quot;attr_flag&quot;&gt;        &lt;flag name=&quot;east&quot; value=&quot;0x1&quot;&gt;&lt;/flag&gt;        &lt;flag name=&quot;west&quot; value=&quot;0x2&quot;&gt;&lt;/flag&gt;        &lt;flag name=&quot;south&quot; value=&quot;0x3&quot;&gt;&lt;/flag&gt;        &lt;flag name=&quot;north&quot; value=&quot;0x4&quot;&gt;&lt;/flag&gt;    &lt;/attr&gt;&lt;/resources&gt;\n开发过程中自定义view的属性声明并不采用在&lt;resources/&gt;中直接声明&lt;attr/&gt;的形式，因为一个attrs.xml中可以有多个view的属性声明，可采用declare-styleable声明每个view的属性组（TypedArray）：\n12345678&lt;resources&gt;    &lt;declare-styleable name=&quot;MyStyleable&quot;&gt;        &lt;attr name=&quot;attr_str&quot; format=&quot;string&quot;&gt;&lt;/attr&gt;        &lt;attr name=&quot;attr_bool&quot; format=&quot;boolean&quot;&gt;&lt;/attr&gt;        &lt;attr name=&quot;attr_int&quot; format=&quot;integer&quot;&gt;&lt;/attr&gt;        &lt;attr name=&quot;attr_ref&quot; format=&quot;reference&quot;&gt;&lt;/attr&gt;    &lt;/declare-styleable&gt;&lt;/resources&gt;\n一个attrs.xml文件中有多个view共有的属性我们可以抽取出来：\n1234567891011121314151617181920&lt;resources&gt;    //共有的attr_ref属性抽取出来    &lt;attr name=&quot;attr_ref&quot; format=&quot;reference&quot;&gt;&lt;/attr&gt;    //view0    &lt;declare-styleable name=&quot;MyStyleable0&quot;&gt;        &lt;attr name=&quot;attr_str&quot; format=&quot;string&quot;&gt;&lt;/attr&gt;        &lt;attr name=&quot;attr_bool&quot; format=&quot;boolean&quot;&gt;&lt;/attr&gt;        &lt;attr name=&quot;attr_int&quot; format=&quot;integer&quot;&gt;&lt;/attr&gt;        &lt;attr name=&quot;attr_ref&quot;/&gt;    &lt;/declare-styleable&gt;    //view1    &lt;declare-styleable name=&quot;MyStyleable0&quot;&gt;        &lt;attr name=&quot;attr_str&quot; format=&quot;string&quot;&gt;&lt;/attr&gt;        &lt;attr name=&quot;attr_bool&quot; format=&quot;boolean&quot;&gt;&lt;/attr&gt;        &lt;attr name=&quot;attr_int&quot; format=&quot;integer&quot;&gt;&lt;/attr&gt;        &lt;attr name=&quot;attr_ref&quot;/&gt;    &lt;/declare-styleable&gt;&lt;/resources&gt;\n属性值获取\nxml中设定值：\n123456789&lt;com.myapplication.attr.MyAttrView    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    app:attr_str=&quot;hello world&quot;    app:attr_bool=&quot;true&quot;    app:attr_int=&quot;99&quot;    app:attr_ref=&quot;@dimen/dp_100&quot;    &gt;&lt;/com.myapplication.attr.MyAttrView&gt;\n代码中解析值：\n12345678910111213public MyView(Context context, @Nullable AttributeSet attrs) &#123;    super(context, attrs);    //R.styleable.MyStyleable 指的是想要解析的属性    TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.MyStyleable);    String strValue = a.getString(R.styleable.MyStyleable_attr_str);    boolean boolValue = a.getBoolean(R.styleable.MyStyleable_attr_bool, false);    int intValue = a.getInt(R.styleable.MyStyleable_attr_int, 0);    float refValue = a.getDimension(R.styleable.MyStyleable_attr_ref, 0);    //typedArray 存放在缓存池，因此用完归还到缓存池    a.recycle();&#125;\n自定义属性加载优先级\n自定义属性值的方式目前可以归总为三种：\n\n在布局文件里定义属性\n在style里定义属性\n在theme里定义属性\n\n我们知道自定义view中有四个构造方法，其中第四个构造方法是\n1public View(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes)\n其中后两个入参：\n\nint defStyleAttr 默认属性\nint defStyleRes 默认style\n\n因此view的属性可能来自以下5个地方：\n\n在布局文件里定义属性。\n在style里定义属性。\n在theme里定义属性。\n默认的属性。\n默认的style。\n\n根据越精细化指定优先级越高，那么优先级从低到高排列也应该是上边5个地方的顺序了。\n自定义属性加载流程\n\nstyles.xml\n它是view中一些列属性值的集合，比如height、width、padding等，包括自定义attr属性。\nstyle的使用\n1234567&lt;resources&gt;    &lt;style name=&quot;myStyle&quot;&gt;        &lt;item name=&quot;attr_str&quot;&gt;hello world&lt;/item&gt;        &lt;item name=&quot;attr_bool&quot;&gt;true&lt;/item&gt;        &lt;item name=&quot;android:background&quot;&gt;@android:color/transparent&lt;/item&gt;    &lt;/style&gt;&lt;/resources&gt;\n12345678910111213&lt;com.myapplication.attr.MyAttrView    style=&quot;@style/myStyle&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;&gt;&lt;/com.myapplication.attr.MyAttrView&gt;等价于&lt;com.myapplication.attr.MyAttrView    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:background=&quot;@android:color/transparent&quot;    app:attr_str=&quot;hello world&quot;    app:attr_bool=&quot;true&quot;&gt;&lt;/com.myapplication.attr.MyAttrView&gt;\nstyle的继承\nStyle的继承主要分两种：\n\n指定parent继承，主要是第三方module的Style(包括系统内建的或者其他lib)\n点式继承，主要是自己本项目中的style\n\n继承第三方module的Style：\n1234567891011121314//继承系统内建的style（继承Framework中theme的属性是需要“android:”开头）&lt;style name=&quot;GreenText&quot; parent=&quot;@android:style/TextAppearance&quot;&gt;    &lt;item name=&quot;android:textColor&quot;&gt;#00FF00&lt;/item&gt;&lt;/style&gt;//继承自AppCompat下的style（继承Support Library中theme的属性是不需要“android:”开头的）&lt;style name=&quot;GreenText&quot; parent=&quot;TextAppearance.AppCompat&quot;&gt;    &lt;item name=&quot;android:textColor&quot;&gt;#00FF00&lt;/item&gt;&lt;/style&gt;//继承自其他lib的style&lt;style name=&quot;GreenText&quot; parent=&quot;@style/BaseGreenText&quot;&gt;    &lt;item name=&quot;android:textColor&quot;&gt;#00FF00&lt;/item&gt;&lt;/style&gt;\n继承自己本项目中的style：\n123&lt;style name=&quot;GreenText.Large&quot;&gt;    &lt;item name=&quot;android:textSize&quot;&gt;22dp&lt;/item&gt;&lt;/style&gt;\n继承自己本项目中的style可以不用parent属性指定，但是如果在此种方法中也使用parent，parent中指定的style优先级高于通过点操作符指定的父类style。\nthemes.xml\ntheme是为了Activity/Application复用的属性值集合，Theme与Style使用同一个元素标签&lt;style&gt;，区别在于所包含的属性不同，并且使用的地方也不一样。Theme你需要设置到AndroidManifest.xml的&lt;application&gt;或者&lt;activity&gt;标签下，设置后被设置的Activity或整个应用下所有的View都可以使用该&lt;style&gt;里面的属性了。\ntheme的使用\n123456789101112131415161718192021222324//定义主题&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt;    &lt;!-- Customize your theme here. --&gt;    &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;    &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;    &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;&lt;/style&gt;//application指定&lt;application    android:allowBackup=&quot;true&quot;    android:icon=&quot;@mipmap/ic_launcher&quot;    android:label=&quot;@string/app_name&quot;    android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;    android:supportsRtl=&quot;true&quot;    android:theme=&quot;@style/AppTheme&quot;&gt;    &lt;activity android:name=&quot;.MainActivity&quot;&gt;        &lt;intent-filter&gt;            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;        &lt;/intent-filter&gt;    &lt;/activity&gt;&lt;/application&gt;\ntheme中可以自定义很多属性，具体可以查阅官方R.styleable.Theme\n定义全局View默认样式\n如果是要在theme中定义全局的View或具体控件的属性则需要查看其支持的xml属性配置:\n123456789101112131415161718&lt;style name=&quot;MyTheme&quot; parent=&quot;AppTheme&quot;&gt;    &lt;!--重写系统view的style默认样式--&gt;    &lt;item name=&quot;android:buttonStyle&quot;&gt;@style/myButton&lt;/item&gt;    &lt;item name=&quot;android:checkboxStyle&quot;&gt;@style/myCheckBox&lt;/item&gt;&lt;/style&gt;&lt;style name=&quot;myButton&quot; parent=&quot;@style/Base.Widget.AppCompat.Button&quot;&gt;    &lt;item name=&quot;android:background&quot;&gt;@color/colorAccent&lt;/item&gt;    &lt;item name=&quot;android:textColor&quot;&gt;@color/white&lt;/item&gt;    &lt;item name=&quot;android:textAppearance&quot;&gt;@style/Base.TextAppearance.AppCompat.Small&lt;/item&gt;&lt;/style&gt;&lt;style name=&quot;myCheckBox&quot; parent=&quot;@style/Base.Widget.AppCompat.CompoundButton.CheckBox&quot;&gt;    &lt;item name=&quot;android:background&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;    &lt;item name=&quot;android:textColor&quot;&gt;@color/white&lt;/item&gt;    &lt;item name=&quot;android:textAppearance&quot;&gt;@style/Base.TextAppearance.AppCompat.Display1&lt;/item&gt;    &lt;item name=&quot;android:checked&quot;&gt;true&lt;/item&gt;&lt;/style&gt;\nMaterial Color system\n如果使用的是Material Theme，它提供了很多的 color attribute 使用：\n\ncolorPrimary : 顧名思義，就是主要的顏色，這個通常指得是 App 本身產品的代表色，通常也是品牌的主要視覺色\ncolorPrimaryVariant：主要顏色的變體，通常會從 colorPrimary 往較淡或較濃的色澤\ncolorOnPrimary：字面意思就是主要顏色上頭的顏色，這個顏色通常使用在背景色是主要顏色的元件上頭(例如字樣 Label 、icon 等)\ncolorSecondary：app 次要的品牌顏色，這些用於裝飾某些特定需要的 widget\ncolorSecondaryVariant：次要顏色的變體，也就是次要顏色偏暗或偏亮的樣式\ncolorOnSecondary：用於顯示於次要顏色上元件的顏色\ncolorError：顯示錯誤的顏色 (最常見的就是紅色)\ncolorOnError：在錯誤顏色上頭元件的顏色\ncolorSurface：表層顏色(就是 Sheet 的顏色)\ncolorOnSurface：在表層顏色上的的元件顏色\nandroid:colorBackground：最底的背景色\ncolorOnBackground：用於對底背景色上頭的元件用的顏色\n\n利用这些属性，搭配上面的那些技巧，可以組合出很棒的效果。\n\n版本兼容\n随着android版本升级，不同版本下的api可能不一样，可以通过在res文件夹下创建指定values版本的style来解决兼容问题：\n12res/values/styles.xml        # 如果没有指定版本，默认使用此style中的定义res/values-v21/styles.xml    # 对于Api 21以上的版本会优先使用此style种的定义\n举个例子，比如Android5.0(API level 21)及以上版本汇总，增加了window的切换动画。\n默认res/values/styles.xml\n1234567891011&lt;resources&gt;    &lt;!-- base set of styles that apply to all versions --&gt;    &lt;style name=&quot;BaseAppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt;        &lt;item name=&quot;colorPrimary&quot;&gt;@color/primaryColor&lt;/item&gt;        &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/primaryTextColor&lt;/item&gt;        &lt;item name=&quot;colorAccent&quot;&gt;@color/secondaryColor&lt;/item&gt;    &lt;/style&gt;    &lt;!-- declare the theme name that&#x27;s actually applied in the manifest file --&gt;    &lt;style name=&quot;AppTheme&quot; parent=&quot;BaseAppTheme&quot; /&gt;&lt;/resources&gt;\nApi 21的版本res/values-v21/styles.xml\n12345678&lt;resources&gt;    &lt;!-- extend the base theme to add styles available only with API level 21+ --&gt;    &lt;style name=&quot;AppTheme&quot; parent=&quot;BaseAppTheme&quot;&gt;        &lt;item name=&quot;android:windowActivityTransitions&quot;&gt;true&lt;/item&gt;        &lt;item name=&quot;android:windowEnterTransition&quot;&gt;@android:transition/slide_right&lt;/item&gt;        &lt;item name=&quot;android:windowExitTransition&quot;&gt;@android:transition/slide_left&lt;/item&gt;    &lt;/style&gt;&lt;/resources&gt;\n这种方式还可用于处理其他资源的不同版本兼容问题。\n@android, ?attr/ 和 ?android 的区别\n开发过程中经常遇到&quot;@android&quot;、“?attr/“或者”?android”。例如，设置一些可点击组件的波纹效果时，我们会用到：android:foreground=&quot;?attr/selectableItemBackground&quot;。有同学可能就懵逼了，到底什么时候用&quot;@android&quot;什么时候用&quot;?attr/&quot;呢？\n其实@和?的区别是：\n\n@：引用固定的系统资源\n?: 引用attr指定属性资源\n\n最为常见的引用系统固定资源格式如下：\n1@[&lt;package_name&gt;:]&lt;resource_type&gt;&#x2F;&lt;resource_name&gt;\n这种方式是最为常见的，直接获取对应的包下的资源，一般在相同的包下，可以省略包名，比如为 TextView 设置文字时，就可以通过这样的方式来获取我们应用内定义的 string 资源：\n1android:text=&quot;@string/hello&quot;\n@android: 引用安卓内建的系统资源\n1android:background=“@android:drawable/ic_menu_delete”\n对应的是当前compileSdkVersion版本下的android系统下的固定资源。\n?attr/ 引用应用内的属性资源\n通常我们会在 values/ 文件夹下建一个 attrs 文件，在这里保存一些我们自己的 style 属性，其实这些属性就可以通过 ?attr/ 这种方式来引用了：\n123456//attrs文件中定义&lt;attr name=&quot;colorReallyGreen&quot; format=&quot;color&quot;/&gt;...//view中引用android:background=&quot;?attr/colorReallyGreen&quot;\n当然，要想让该属性起作用还需要在style或者theme中下指定值：\n12345&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt;    &lt;!-- Customize your theme here. --&gt;    ...    &lt;item name=&quot;colorReallyGreen&quot;&gt;@color/colorReallyGreen&lt;/item&gt;&lt;/style&gt;\n由于在 layout 中，可以自动识别出当前所需的是属性资源，所以可以省略 attr/ 而直接使用 ?colorReallyGreen 就可以了。\n?android: 引用系统内建的属性资源\n与 ?attr/ 类似，通过这种方式可以直接访问到安卓内建的属性资源，只不过是省略了 attr/ 而已，比如给 TextView 引用一个系统内的 style buttonStyleSmall：\n12345&lt;TextView    style=&quot;?android:buttonStyleSmall&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:text=&quot;You Are Beautiful&quot; /&gt;\n总结\n以上是我针对自定义属性以及自定义style和自定义theme的相关知识点总结，这部分是自定义view的基础，内容还是比较多的，有一部分没有涉及到，例如主题切换，感兴趣的童鞋可以自行学习，喜欢本篇文章的点个赞加个关注，记得收藏哦。\n参考\n\nhttps://developer.android.com/guide/topics/ui/look-and-feel/themes?hl=zh-cn\nhttps://medium.com/jastzeonic/style-theme-的那一兩件事情-8499a6603bbb\nhttps://mp.weixin.qq.com/s/Vo8MXlHF5ur2QsZxWAccIg\nhttps://juejin.cn/post/6844904200673968141#heading-8\n\n","plink":"https://blog.ixin.run/posts/1614958762/"},{"title":"Android开发之玩转Android属性动画","date":"2021-02-28T15:57:29.000Z","date_formatted":{"ll":"2021年2月28日","L":"2021/02/28","MM-DD":"02-28"},"updated":"2021-03-10T01:15:14.486Z","content":"前两篇重点讲述了Android开发过程中补间动画和帧动画知识点，本篇文章我们重点总结一下属性动画的使用和原理。\n\nAndroid动画系列：\n\n《Android开发之玩转Android补间动画》\n《Android开发之玩转Android帧动画》\n《Android开发之玩转Android属性动画》\n\n什么是属性动画\n在一段时间内通过修改对象的属性而形成的动画叫属性动画（Property Animation），Google官方在Android 3.0添加Property Animation。属性动画的主要是修改对象的属性，如 View 的背景颜色、透明值、位置等。\n属性动画和补间动画的区别\n有同学可能会问不是已经有补间动画吗，为什么要引入属性动画？换句话说，Property Animation 到底能干哪些 Tween Animation 不能干的活呢？\nTween Animation 存在的问题：\n\nTween Animation 只能作用于 View，不能作用于普通 Object 的属性。\nTween Animation 只能改变 View 的一部分属性。Tween Animation 只支持修改 View 的这几个方面：Alpha、Scale、Translate、Rotate 和这些的组合，一旦想要改变的 View 的属性不在这个范围内，Tween Animation 就无能为力了，如 View 的 BackgroundColor。\nTween Animation 只能改变 View 的“表面”位置，不能改变 View 的实际位置。\n\n属性动画相关类\n属性动画涉及的类主要有：\n\nAnimator，所有 Animator 的父类，主要用于定义通用的接口。\nAnimatorSet，主要用于组合多个属性动画。\nValueAnimator，属性动画的一种，主要用于根据起始值和终止值产生动画，只负责产生在起始值和终止值之间的值，\n不负责更新界面，需要用户自己实现更新界面的逻辑。\nObjectAnimator，属性动画的一种，主要用于根据起始值和终止值产生动画，并将动画产生的值设置在目标对象上。\nTimeAnimator，提供了一个简单的回调机制，通过 TimeAnimator.TimeListener，在动画的每一帧处通知你。这个动画器没有时间，插值或是对象值设定。回调监听器为每一帧动画接受信息，包括总运行时间和从前一帧到现在的运行时间。\n\n继承结构如下：\n\nValueAnimator和ObjectAnimator主要区别\n该类作为ValueAnimator的子类不仅继承了ValueAnimator的所有方法和特性，并且还封装很多实用的方法，方便开发人员快速实现动画。同时，由于属性值会自动更新，使用ObjectAnimator实现动画不需要像ValueAnimator那样必须实现 ValueAnimator.AnimatorUpdateListener ，因此实现任意对象的动画显示就更加容易了。我们在大部分的开发工作中，都会使用ObjectAnimator而非ValueAnimator实现我们所需的动画效果。\n属性动画实现形式\n属性动画的实现形式有两种：xml创建和code实现。其中xml创建的xml动画文件要放在res/animator目录下，注意此处和补间动画（Tween Animation）存放位置不同。\n通常情况下属性动画一般建议通过代码进行实现，因为他更灵活，尤其是在自定义View中常常有属性动画的身影。当然也需要根据实际场景自行选择，下边就通过这两种形式来总结一下属性动画几个类的使用。\nValueAnimator\nValueAnimator是Property Animation系统的核心类，它包含了配置Property Animation属性的大部分方法，那要实现一个Property Animation,都需要直接或间接使用ValueAnimator类。\n一般使用ValueAnimator实现动画分为以下几个步骤：\n\n调用ValueAnimation类中的ofInt(int…values)、ofFloat(String propertyName,float…values)等静态方法实例化ValueAnimator对象;\n调用addUpdateListener(AnimatorUpdateListener mListener)方法为ValueAnimator对象设置属性变化的监听器，并在AnimatorUpdateListener 中的实现方法为目标对象的属性设置计算好的属性值。\n创建自定义的插值器（Interpolator），调用setInterpolator(TimeInterpolator value)为ValueAniamtor设置自定义的Interpolator;(可选，不设置默认为缺省值)\n创建自定义的估值器（TypeEvaluator）,调用setEvaluator(TypeEvaluator value)为ValueAnimator设置自定义的TypeEvaluator;(可选，不设置默认为缺省值)\n设置动画的持续时间、是否重复及重复次数等属性;\n为ValueAnimator设置目标对象并开始执行动画。\n\n需要注意目标对象的需要被设置的属性必须拥有get\\set方法，格式类似 set()。\n通过XML创建\n语法：\n1234567891011&lt;animator    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:duration=&quot;int&quot;    android:interpolator=&quot;@[package:]anim/interpolator_resource&quot;    android:valueType=[&quot;intType&quot; | &quot;floatType&quot;]    android:valueFrom=&quot;float | int | color&quot;    android:valueTo=&quot;float | int | color&quot;    android:startOffset=&quot;int&quot;    android:repeatCount=&quot;int&quot;    android:repeatMode=[&quot;repeat&quot; | &quot;reverse&quot;]    /&gt;\n\n示例：\n12345678910111213141516171819202122//1. 创建 value_animator.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:duration=&quot;1800&quot;    android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;    android:valueType=&quot;floatType&quot;    android:valueFrom=&quot;-100&quot;    android:valueTo=&quot;800&quot;    android:startOffset=&quot;0&quot;    android:repeatCount=&quot;infinite&quot;    android:repeatMode=&quot;reverse&quot;    /&gt;    //2. 在代码中使用 value_animatorValueAnimator mValueAnimator = (ValueAnimator) AnimatorInflater.loadAnimator(this, R.animator.value_animator);mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;    @Override    public void onAnimationUpdate(ValueAnimator animation) &#123;        mTarget.setY((Float) animation.getAnimatedValue());    &#125;&#125;);mValueAnimator.start();\n通过代码实现\n语法：\n123456ValueAnimator valueAnimator = ValueAnimator.ofFloat(float... values);valueAnimator.setDuration(long duration);valueAnimator.setInterpolator(TimeInterpolator value);valueAnimator.addUpdateListener(AnimatorUpdateListener listener);…valueAnimator.start();\n示例：\n123456789101112ValueAnimator mValueAnimator = ValueAnimator.ofFloat(0, 800);mValueAnimator.setDuration(1800);mValueAnimator.setInterpolator(new AccelerateDecelerateInterpolator());mValueAnimator.setRepeatCount(ValueAnimator.INFINITE);mValueAnimator.setRepeatMode(ValueAnimator.REVERSE);mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;    @Override    public void onAnimationUpdate(ValueAnimator animation) &#123;        mTarget.setY((Float) animation.getAnimatedValue());    &#125;&#125;);mValueAnimator.start();\nObjectAnimator\n要动画显示 View 对象的某个属性，比如颜色或旋转值，我们所有要做的事情就是创建一个 Property animation，并设定对应的 View 属性。那接下来我们就用ObjectAnimator类来分别实现View的透明度渐变、收缩、移动和旋转等动画效果，那在此之前我们也来总结下使用ObjectAnimator实现动画的几个步骤，如下：\n\n通过调用ofFloat()、ofInt()等方法创建ObjectAnimator对象，并设置目标对象、需要改变的目标属性名、初始值和结束值；\n设置动画的持续时间、是否重复及重复次数等属性；\n启动动画。\n\n常用的几个属性值解释：\n\ntranslationX 和 translationY：这两个属性控制着 View 的屏幕位置坐标变化量，以 layout 容器的左上角为坐标原点;\nrotation、rotationX 和 rotationY：这三个属性控制着 2D 旋转角度（rotation属性）和围绕某枢轴点的 3D 旋转角度;\nscaleX、scaleY：这两个属性控制着 View 围绕某枢轴点的 2D 缩放比例;\npivotX 和 pivotY: 这两个属性控制着枢轴点的位置，前述的旋转和缩放都是以此点为中心展开的,缺省的枢轴点是 View 对象的中心点;\nx 和 y：这是指 View 在容器内的最终位置，等于 View 左上角相对于容器的坐标加上 translationX 和 translationY 后的值;\nalpha：表示 View 的 alpha 透明度。缺省值为 1 （不透明），为 0 则表示完全透明（看不见）;\n\n通过XML创建\n语法：\n123456789101112&lt;objectAnimator    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:duration=&quot;int&quot;    android:interpolator=&quot;@[package:]anim/interpolator_resource&quot;    android:propertyName=&quot;string&quot;    android:valueType=[&quot;intType&quot; | &quot;floatType&quot;]    android:valueFrom=&quot;float | int | color&quot;    android:valueTo=&quot;float | int | color&quot;    android:startOffset=&quot;int&quot;    android:repeatCount=&quot;int&quot;    android:repeatMode=[&quot;repeat&quot; | &quot;reverse&quot;]    /&gt;\n\n示例：\n123456789101112131415161718//1. 创建 object_animator.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:duration=&quot;1800&quot;    android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;    android:propertyName=&quot;Y&quot;    android:valueType=&quot;floatType&quot;    android:valueFrom=&quot;0&quot;    android:valueTo=&quot;800&quot;    android:startOffset=&quot;0&quot;    android:repeatCount=&quot;infinite&quot;    android:repeatMode=&quot;reverse&quot;    /&gt;    //2. 在代码中使用 object_animatorObjectAnimator mObjectAnimator = (ObjectAnimator) AnimatorInflater.loadAnimator(this, R.animator.object_animator);mObjectAnimator.setTarget(mTarget);mObjectAnimator.start();\n通过代码实现\n语法：\n12345ObjectAnimator objectAnimator = ObjectAnimator.ofObject(Object target, String propertyName, TypeEvaluator evaluator, Object... values);objectAnimator.setDuration(long duration);objectAnimator.setInterpolator(TimeInterpolator value);…objectAnimator.start();\n示例：\n123456ObjectAnimator mObjectAnimator = ObjectAnimator.ofFloat(mTarget, &quot;y&quot;, 0, 800);mObjectAnimator.setDuration(1800);mObjectAnimator.setInterpolator(new AccelerateDecelerateInterpolator());mObjectAnimator.setRepeatCount(ValueAnimator.INFINITE);mObjectAnimator.setRepeatMode(ValueAnimator.REVERSE);mObjectAnimator.start();\nAnimatorSet\n通过XML创建\n语法：\n123456789101112131415161718192021222324252627&lt;set    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:ordering=[&quot;together&quot; | &quot;sequentially&quot;]&gt;    &lt;objectAnimator        android:propertyName=&quot;string&quot;        android:duration=&quot;int&quot;        android:valueFrom=&quot;float | int | color&quot;        android:valueTo=&quot;float | int | color&quot;        android:startOffset=&quot;int&quot;        android:repeatCount=&quot;int&quot;        android:repeatMode=[&quot;repeat&quot; | &quot;reverse&quot;]        android:valueType=[&quot;intType&quot; | &quot;floatType&quot;]/&gt;    &lt;animator        android:duration=&quot;int&quot;        android:valueFrom=&quot;float | int | color&quot;        android:valueTo=&quot;float | int | color&quot;        android:startOffset=&quot;int&quot;        android:repeatCount=&quot;int&quot;        android:repeatMode=[&quot;repeat&quot; | &quot;reverse&quot;]        android:valueType=[&quot;intType&quot; | &quot;floatType&quot;]/&gt;    &lt;set&gt;        ...    &lt;/set&gt;&lt;/set&gt;\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344//1. 创建 animator_set.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:ordering=&quot;together&quot;    &gt;    &lt;objectAnimator        android:duration=&quot;@integer/integer_one_thousand_and_eight_hundred&quot;        android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;        android:propertyName=&quot;Y&quot;        android:valueType=&quot;floatType&quot;        android:valueFrom=&quot;0&quot;        android:valueTo=&quot;800&quot;        android:startOffset=&quot;0&quot;        android:repeatCount=&quot;infinite&quot;        android:repeatMode=&quot;reverse&quot;        /&gt;    &lt;objectAnimator        android:duration=&quot;@integer/integer_one_thousand_and_eight_hundred&quot;        android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;        android:propertyName=&quot;ScaleX&quot;        android:valueType=&quot;floatType&quot;        android:valueFrom=&quot;1&quot;        android:valueTo=&quot;2&quot;        android:startOffset=&quot;0&quot;        android:repeatCount=&quot;infinite&quot;        android:repeatMode=&quot;reverse&quot;        /&gt;    &lt;objectAnimator        android:duration=&quot;@integer/integer_one_thousand_and_eight_hundred&quot;        android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;        android:propertyName=&quot;ScaleY&quot;        android:valueType=&quot;floatType&quot;        android:valueFrom=&quot;1&quot;        android:valueTo=&quot;2&quot;        android:startOffset=&quot;0&quot;        android:repeatCount=&quot;infinite&quot;        android:repeatMode=&quot;reverse&quot;        /&gt;&lt;/set&gt;//2. 在代码中使用 animator_setAnimatorSet mAnimatorSet = (AnimatorSet)AnimatorInflater.loadAnimator(this, R.animator.animator_set);mAnimatorSet.setTarget(mTarget);mAnimatorSet.start();\n通过代码实现\n语法：\n1234567AnimatorSet animatorSet = new AnimatorSet();animatorSet.playTogether(Animator... items);animatorSet.playSequentially(Animator... items);//非必须animatorSet.setTarget(mTarget);…animatorSet.start();\n示例：\n123456789101112131415161718192021ObjectAnimator translateYObjectAnimator = ObjectAnimator.ofFloat(mTarget, &quot;y&quot;, 0, 800);translateYObjectAnimator.setDuration(1800);translateYObjectAnimator.setInterpolator(new AccelerateDecelerateInterpolator());translateYObjectAnimator.setRepeatCount(ValueAnimator.INFINITE);translateYObjectAnimator.setRepeatMode(ValueAnimator.REVERSE);ObjectAnimator scaleXObjectAnimator = ObjectAnimator.ofFloat(mTarget, &quot;scaleX&quot;, 1, 2);scaleXObjectAnimator.setDuration(1800);scaleXObjectAnimator.setInterpolator(new AccelerateDecelerateInterpolator());scaleXObjectAnimator.setRepeatCount(ValueAnimator.INFINITE);scaleXObjectAnimator.setRepeatMode(ValueAnimator.REVERSE);ObjectAnimator scaleYObjectAnimator = ObjectAnimator.ofFloat(mTarget, &quot;scaleY&quot;, 1, 2);scaleYObjectAnimator.setDuration(1800);scaleYObjectAnimator.setInterpolator(new AccelerateDecelerateInterpolator());scaleYObjectAnimator.setRepeatCount(ValueAnimator.INFINITE);scaleYObjectAnimator.setRepeatMode(ValueAnimator.REVERSE);mAnimatorSet = new AnimatorSet();mAnimatorSet.playTogether(translateYObjectAnimator, scaleXObjectAnimator, scaleYObjectAnimator);mAnimatorSet.playSequentially();//非必须//        mAnimatorSet.setTarget(mTarget);mAnimatorSet.start();\n动画监听\nProperty Animation 中一共有三种监听事件：\n\nAnimatorListener；\nAnimatorPauseListener；\nAnimatorUpdateListener；\n\nAnimatorListener\nAnimatorListener 接口主要用于监听 Property Animation 的开始、结束、取消、重复状态，需要实现的方法分别是：\n1234567891011@Overridepublic void onAnimationStart(Animator animation) &#123;&#125;@Overridepublic void onAnimationEnd(Animator animation) &#123;&#125;@Overridepublic void onAnimationCancel(Animator animation) &#123;&#125;@Overridepublic void onAnimationRepeat(Animator animation) &#123;&#125;\nAnimatorPauseListener\nAnimatorPauseListener 主要用于监听 Property Animation 的暂停、恢复状态，需要实现的方法分别是：\n12345@Overridepublic void onAnimationPause(Animator animation) &#123;&#125;@Overridepublic void onAnimationResume(Animator animation) &#123;&#125;\nAnimatorUpdateListener\nAnimatorUpdateListener 是 ValueAnimator 及其子类特有的接口，主要用于监听动画中值的变化，用于手动更新界面，需要实现的方法是：\n12@Overridepublic void onAnimationUpdate(ValueAnimator animation) &#123;&#125;\n属性动画工作原理\n当 ValueAnimator 调用 start 方法之后，ValueAnimator 会根据 Property Animation 当前运行时间与总的动画持续时间计算出一个时间消耗百分数（The elapsed fraction）。紧接着，ValueAnimator 将这个时间消耗百分数交给当前 ValueAnimator 的插值器（Interpolator），不同的 Interpolator 会根据不同的算法将这个时间消耗百分数转换成插值百分数（The interpolated fraction）。紧接着，ValueAnimator 会将这个插值百分数交给当前 ValueAnimator 的估值器（TypeEvaluator），不同的 TypeEvaluator 会根据不同的算法将这个插值百分数转换最终的动画值（The final value）。\n拿AccelerateDecelerateInterpolator插值器举例：\n1234567891011121314151617181920212223public class AccelerateDecelerateInterpolator extends BaseInterpolator        implements NativeInterpolatorFactory &#123;    public AccelerateDecelerateInterpolator() &#123;    &#125;    @SuppressWarnings(&#123;&quot;UnusedDeclaration&quot;&#125;)    public AccelerateDecelerateInterpolator(Context context, AttributeSet attrs) &#123;    &#125;    /**     * param input (The elapsed fraction)     * return (The interpolated fraction)     */    public float getInterpolation(float input) &#123;        return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f;    &#125;    /** @hide */    @Override    public long createNativeInterpolator() &#123;        return NativeInterpolatorFactoryHelper.createAccelerateDecelerateInterpolator();    &#125;&#125;\n\n上面这个属性动画的 Duration 为 40ms，Intepolator 为 AccelerateDecelerateInterpolator，Distance 为 40。\n在 t = 10ms 时，The elapsed fraction 为 0.25 = 10/40，The interpolated fraction = (float)(Math.cos((0.25 + 1) * Math.PI) / 2.0f) + 0.5f = 0.14644662，The final value 为 5.8578648 = (40 - 0) * 0.14644662。\n自定义插值器\n自定义插值器要实现 Interpolator 接口，上篇文章已经有所说明，不做过多阐述。\n1234567public class DecelerateAccelerateInterpolator implements Interpolator &#123;    @Override    public float getInterpolation(float input) &#123;        return (float) ((Math.tan(Math.PI/2 * input - Math.PI/4) + 1)/2);    &#125;&#125;\n自定义估值器\n自定义估值器，只要实现 TypeEvaluator 接口，并实现其中定义的 evaluate 方法即可：\n12345678910111213public class CustomTypeEvaluator implements TypeEvaluator &#123;    /**     * param fraction 插值器最终值     * param startValue 属性开始值     * param endValue 属性结束值     */    @Override    public Object evaluate(float fraction, Object startValue, Object endValue) &#123;        float startFloat = ((Number) startValue).floatValue();        return 200 + fraction * (((Number) endValue).floatValue() - startFloat);    &#125;&#125;\nViewPropertyAnimator 使用简介\nViewPropertyAnimator、ObjectAnimator、ValueAnimator 这三种 Animator，它们其实是一种递进的关系：从左到右依次变得更加难用，也更加灵活。\n它们的性能是一样的，因为 ViewPropertyAnimator 和 ObjectAnimator 的内部实现其实都是 ValueAnimator，ObjectAnimator 更是本来就是 ValueAnimator 的子类，它们三个的性能并没有差别。\n它们的差别只是使用的便捷性以及功能的灵活性。所以在实际使用时候的选择，只要遵循一个原则就行：尽量用简单的。能用 View.animate() 实现就不用 ObjectAnimator，能用 ObjectAnimator 就不用 ValueAnimator。\n当需要同时更改 View 的多个属性的时候，一般有三种方法：\n\nObjectAnimator + AnimatorSet；\nPropertyValuesHolder + ObjectAnimator；\nViewPropertyAnimator；\n\n接下来，分别用三种方法分别实现同一种效果：View 的 Y 值从当前位置增到 400，Alpha 值 从 1.0f 变成 0.1f。\nObjectAnimator + AnimatorSet\n12345ObjectAnimator alphaObjectAnimator = ObjectAnimator.ofFloat(mTarget, &quot;alpha&quot;, 1.0f, 0.1f);ObjectAnimator yObjectAnimator = ObjectAnimator.ofFloat(mTarget, &quot;y&quot;, 400f);AnimatorSet animatorSet = new AnimatorSet();animatorSet.playTogether(alphaObjectAnimator, yObjectAnimator);animatorSet.start();\nPropertyValuesHolder + ObjectAnimator\n123PropertyValuesHolder alphaPropertyValuesHolder = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 1.0f, 0.1f);PropertyValuesHolder yPropertyValuesHolder = PropertyValuesHolder.ofFloat(&quot;y&quot;, 400f);ObjectAnimator.ofPropertyValuesHolder(mTarget, alphaPropertyValuesHolder, yPropertyValuesHolder).start();\nViewPropertyAnimator\n123456ViewPropertyAnimator viewPropertyAnimator = mTarget.animate();viewPropertyAnimator.alpha(0.1f);viewPropertyAnimator.y(400f);//也可以写成一句：mTarget.animate().alpha(0.1f).y(400f);\nPropertyValuesHolder\n细心的同学可能会注意到，ValueAnimator、ObjectAnimator除了这些创建Animator实例的方法以外，都还有一个方法：\n12345678/** * valueAnimator的 */public static ValueAnimator ofPropertyValuesHolder(PropertyValuesHolder... values) /** * ObjectAnimator的 */public static ObjectAnimator ofPropertyValuesHolder(Object target,PropertyValuesHolder... values)\nPropertyValuesHolder这个类的意义就是，它其中保存了动画过程中所需要操作的属性和对应的值。我们通过ofFloat(Object target, String propertyName, float… values)构造的动画，ofFloat()的内部实现其实就是将传进来的参数封装成PropertyValuesHolder实例来保存动画状态。在封装成PropertyValuesHolder实例以后，后期的各种操作也是以PropertyValuesHolder为主的。\n使用举例：\n123456PropertyValuesHolder rotationHolder = PropertyValuesHolder.ofFloat(&quot;Rotation&quot;, 60f, -60f, 40f, -40f, -20f, 20f, 10f, -10f, 0f);PropertyValuesHolder colorHolder = PropertyValuesHolder.ofInt(&quot;BackgroundColor&quot;, 0xffffffff, 0xffff00ff, 0xffffff00, 0xffffffff);ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(mTextView, rotationHolder, colorHolder);animator.setDuration(3000);animator.setInterpolator(new AccelerateInterpolator());animator.start();\n参考\n\nhttps://developer.android.com/reference/android/animation/Animator\nhttps://carsonho.blog.csdn.net/article/details/72909894\nhttps://blog.csdn.net/harvic880925/article/details/50752838\nhttps://juejin.cn/post/6844903798687678478#heading-34\n\n","plink":"https://blog.ixin.run/posts/1614527870/"},{"title":"Android开发之玩转Android帧动画","date":"2021-02-28T04:25:24.000Z","date_formatted":{"ll":"2021年2月28日","L":"2021/02/28","MM-DD":"02-28"},"updated":"2021-03-10T01:15:14.487Z","content":"帧动画有着极其广泛的应用，也非常容易理解，其实就是简单的由N张静态图片收集起来，然后我们通过控制依次显示这些图片，因为人眼&quot;视觉残留&quot;的原因，会让我们造成动画的&quot;错觉&quot;，跟放电影的原理一样！Android中展示这种形式一般有两种方式，一种用AnimationDrawable实现，另外一种直接引用GIF实现。本文就给阐述一下如何通过AnimationDrawable实现帧动画。\n\nAndroid动画系列：\n\n《Android开发之玩转Android补间动画》\n《Android开发之玩转Android帧动画》\n《Android开发之玩转Android属性动画》\n\n帧动画本质\n将动画拆分为 帧 的形式，且定义每一帧 = 每一张图片，然后按序播放一组预先定义好的图片。\n准备工作\n既然是帧动画肯定需要一组图片，类似幻灯片一样，我们把每一张图片定义一个专属“组”内特定的名字，然后将这组图片资源放到drawable中。\n实现方式\n这里我给大家介绍两种实现方法：\n\n在XML中定义然后代码中调用\n直接在代码中定义调用\n\n其中xml创建的xml动画文件要放在res/drawable/目录下。\n在XML中定义然后代码中调用\n1.在 /res/drawable 文件夹下建立一个名为 abunation_list.xml 的文件\n12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:oneshot=&quot;true&quot;&gt;    &lt;item        android:drawable=&quot;@drawable/iron_1&quot;        android:duration=&quot;200&quot;/&gt;    &lt;item        android:drawable=&quot;@drawable/iron_2&quot;        android:duration=&quot;200&quot;/&gt;    &lt;item        android:drawable=&quot;@drawable/iron_3&quot;        android:duration=&quot;200&quot;/&gt;    &lt;item        android:drawable=&quot;@drawable/iron_4&quot;        android:duration=&quot;200&quot;/&gt;    &lt;item        android:drawable=&quot;@drawable/iron_5&quot;        android:duration=&quot;200&quot;/&gt;    &lt;item        android:drawable=&quot;@drawable/iron_6&quot;        android:duration=&quot;200&quot;/&gt;    &lt;item        android:drawable=&quot;@drawable/iron_7&quot;        android:duration=&quot;200&quot;/&gt;    &lt;item        android:drawable=&quot;@drawable/iron_8&quot;        android:duration=&quot;200&quot;/&gt;&lt;/animation-list&gt;\n其中oneshot属性，用于设置是否需要循环播放，true为仅播放一次，false 为连续的循环播放。\n2.将其添加到ImageView中并启动动画\n1234imageView = findViewById(R.id.image);imageView.setImageResource(R.drawable.abunation_list);AnimationDrawable animationDrawable = (AnimationDrawable) imageView.getDrawable();animationDrawable.start();\n直接在代码中定义调用\n在代码中添加顾名思义，就是将要播放的图片集合，一张一张的添加到一个 AnimationDrawable 对象中去，接着再将其添加到 imageView 中，调用 start() 方法便能开始播放。AnimationDrawable同样也有一个OneShot()方法，用于设置是否需要循环播放。\n12345678910111213imageView = findViewById(R.id.image);AnimationDrawable animationDrawable1 = new AnimationDrawable();animationDrawable1.addFrame(getResources().getDrawable(R.drawable.iron_1 ),200);animationDrawable1.addFrame(getResources().getDrawable(R.drawable.iron_2 ),200);animationDrawable1.addFrame(getResources().getDrawable(R.drawable.iron_3 ),200);animationDrawable1.addFrame(getResources().getDrawable(R.drawable.iron_4 ),200);animationDrawable1.addFrame(getResources().getDrawable(R.drawable.iron_5 ),200);animationDrawable1.addFrame(getResources().getDrawable(R.drawable.iron_6 ),200);animationDrawable1.addFrame(getResources().getDrawable(R.drawable.iron_7 ),200);animationDrawable1.addFrame(getResources().getDrawable(R.drawable.iron_8 ),200);animationDrawable1.setOneShot(true);imageView_2.setImageDrawable(animationDrawable1);animationDrawable1.start();\n总结\nAndroid帧动画相对简单一些，开发过程中可能有多个地方使用相同的帧动画，建议采用XML定义的形式去实现，可用于文件共享，当然也可以通过代码进行封装，另外如果动画相对比较复杂，可以采用GIF加载更简单一些。无论是通过一组图片定义的帧动画还是GIF引入都需要注意内存哦，可通过一些手段进行压缩处理一下。\n","plink":"https://blog.ixin.run/posts/1614486338/"},{"title":"Android开发之玩转Android补间动画","date":"2021-02-27T14:05:15.000Z","date_formatted":{"ll":"2021年2月27日","L":"2021/02/27","MM-DD":"02-27"},"updated":"2021-03-10T01:15:14.487Z","content":"提起动画，无论是哪种语言哪种系统框架，比如说android、iOS、H5、Flash等，动画在其之中都扮演着举足轻重的角色。Android系统中最常用的动画方式有三种：\n\n补间动画（Tween Animation）\n帧动画（Frame Animation）\n属性动画（Property Animation）\n\n本文就总结一下补间动画的相关玩法。\n\nAndroid动画系列：\n\n《Android开发之玩转Android补间动画》\n《Android开发之玩转Android帧动画》\n《Android开发之玩转Android属性动画》\n\n什么是补间动画\n\nCreates an animation by performing a series of transformations on a single image with an Animation.\n\nTween Animation，通过 Animation 对象在图像上执行一系列的变换而形成的动画。举例来说，就是 Tween Animation 可以改变界面上显示控件的状态，如 Button 的显示、隐藏，ImageView 的尺寸缩放等等。\n补间动画分类\n补间动画包括五类动画，分别是：\n\nAlphaAnimation，主要用于控制 View 的可见性（显示|隐藏）。\nScaleAnimation，主要用于缩放 View 大小。\nTranslateAnimation，主要用于移动 View 的位置。\nRotateAnimation，主要用于旋转 View。\nAnimationSet，某些场景仅靠上面单一类型的动画是无法实现的，需要多个类型的动画组合才能达到最终的效果，AnimationSet 的主要作用就是组合各类 Tween Animation。\n\n补间动画的实现形式\n补间动画的实现形式有两种：xml创建和code实现。其中xml创建的xml动画文件要放在res/anim/目录下。\n\nres/anim/\n目录下放的是视图动画的XML实现和布局动画（LayoutAnimation）\nres/animations/\n目录下存放的是属性动画的XML实现\nres/drawable/\n目录下存放的是帧动画的XML实现\n\nAlphaAnimation\n通过XML创建\n语法\n12345678910&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:duration=&quot;integer&quot;    android:fillAfter=&quot;true|false&quot;    android:fillBefore=&quot;true|false&quot;    android:fillEnabled=&quot;true|false&quot;    android:interpolator=&quot;@[package:]anim/interpolator_resource&quot;    android:repeatCount=&quot;infinite|integer&quot;    android:repeatMode=&quot;reverse|restart&quot;    android:fromAlpha=&quot;float&quot;    android:toAlpha=&quot;float&quot; /&gt;\n\n示例\n12345678910111213141516171819//XML定义&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:duration=&quot;@integer/integer_one_thousand_and_two_hundred&quot;    android:fillAfter=&quot;true&quot;    android:fromAlpha=&quot;@integer/integer_one&quot;    android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;    android:repeatCount=&quot;infinite&quot;    android:repeatMode=&quot;reverse&quot;    android:toAlpha=&quot;@integer/integer_zero&quot; /&gt;...//代码调用Button mButton = (Button) findViewById(R.id.Button);// 创建动画对象，并传入设置的动画效果xml文件Animation alphaAnimation = AnimationUtils.loadAnimation(this, R.anim.view_animation_alpha);// 播放动画mButton.startAnimation(alphaAnimation);\n其他动画XML定义形式在代码调用这部分也是类似。\n通过代码实现\n语法\n1234AlphaAnimation alphaAnimation = new AlphaAnimation(float fromAlpha, float toAlpha);alphaAnimation.setInterpolator(Interpolator i);alphaAnimation.setDuration(long durationMillis);AnimationTarget.startAnimation(alphaAnimation);\n示例\n12345AlphaAnimation alphaAnimation = new AlphaAnimation(1.0f, 0.1f);alphaAnimation.setInterpolator(new AccelerateInterpolator());alphaAnimation.setFillAfter(mIsSaveAnimationState);alphaAnimation.setDuration(800);mTarget.startAnimation(alphaAnimation);\nScaleAnimation\n通过XML创建\n语法\n123456789101112131415&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:duration=&quot;integer&quot;    android:fillAfter=&quot;true|false&quot;    android:fillBefore=&quot;true|false&quot;    android:fillEnabled=&quot;true|false&quot;    android:interpolator=&quot;@[package:]anim/interpolator_resource&quot;    android:repeatCount=&quot;infinite|integer&quot;    android:repeatMode=&quot;reverse|restart&quot;    android:fromXScale=&quot;float&quot;    android:fromYScale=&quot;float&quot;     android:toXScale=&quot;float&quot;    android:toYScale=&quot;float&quot;     android:pivotX=&quot;float&quot;    android:pivotY=&quot;float&quot;    /&gt;\n\n示例\n12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:duration=&quot;@integer/integer_one_thousand_and_two_hundred&quot;    android:fillAfter=&quot;true&quot;    android:fromXScale=&quot;@fraction/percent_one_hundred&quot;    android:fromYScale=&quot;@fraction/percent_one_hundred&quot;    android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;    android:pivotX=&quot;@fraction/percent_fifty&quot;    android:pivotY=&quot;@fraction/percent_fifty&quot;    android:repeatCount=&quot;infinite&quot;    android:repeatMode=&quot;reverse&quot;    android:toXScale=&quot;@fraction/percent_two_hundred&quot;    android:toYScale=&quot;@fraction/percent_two_hundred&quot; /&gt;\n通过代码实现\n语法\n1234ScaleAnimation scaleAnimation = new ScaleAnimation(float fromX, float toX, float fromY, float toY, int pivotXType, float pivotXValue, int pivotYType, float pivotYValue);scaleAnimation.setInterpolator(Interpolator i);scaleAnimation.setDuration(long durationMillis);AnimationTarget.startAnimation(scaleAnimation); \n示例\n12345ScaleAnimation scaleAnimation = new ScaleAnimation(1f, 2f, 1f, 2f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);scaleAnimation.setInterpolator(new AccelerateInterpolator());scaleAnimation.setFillAfter(mIsSaveAnimationState);scaleAnimation.setDuration(800);mTarget.startAnimation(scaleAnimation);\nTranslateAnimation\n通过XML创建\n语法\n12345678910111213&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:duration=&quot;integer&quot;    android:fillAfter=&quot;true|false&quot;    android:fillBefore=&quot;true|false&quot;    android:fillEnabled=&quot;true|false&quot;    android:interpolator=&quot;@[package:]anim/interpolator_resource&quot;    android:repeatCount=&quot;infinite|integer&quot;    android:repeatMode=&quot;reverse|restart&quot;    android:fromXDelta=&quot;float&quot;    android:fromYDelta=&quot;float&quot;     android:toXDelta=&quot;float&quot;    android:toYDelta=&quot;float&quot;     /&gt;\n\n示例\n123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:duration=&quot;1200&quot;    android:fillAfter=&quot;true&quot;    android:fromXDelta=&quot;0&quot;    android:fromYDelta=&quot;0&quot;    android:interpolator=&quot;@anim/overshoot_interpolator&quot;    android:toXDelta=&quot;0&quot;    android:toYDelta=&quot;50%p&quot; /&gt;\n通过代码实现\n语法\n1234TranslateAnimation translateAnimation = new TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta);translateAnimation.setInterpolator(Interpolator i);translateAnimation.setDuration(long durationMillis);AnimationTarget.startAnimation(translateAnimation); \n示例\n12345TranslateAnimation translateAnimation = new TranslateAnimation(0f, 200f, 0f, 200f);translateAnimation.setInterpolator(new AccelerateInterpolator());translateAnimation.setFillAfter(mIsSaveAnimationState);translateAnimation.setDuration(800);mTarget.startAnimation(translateAnimation);\nRotateAnimation\n通过XML创建\n语法\n12345678910111213&lt;rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:duration=&quot;integer&quot;    android:fillAfter=&quot;true|false&quot;    android:fillBefore=&quot;true|false&quot;    android:fillEnabled=&quot;true|false&quot;    android:interpolator=&quot;@[package:]anim/interpolator_resource&quot;    android:repeatCount=&quot;infinite|integer&quot;    android:repeatMode=&quot;reverse|restart&quot;    android:fromDegrees=&quot;float&quot;    android:toDegrees=&quot;float&quot;     android:pivotX=&quot;float&quot;    android:pivotY=&quot;float&quot;     /&gt;\n\n示例\n1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:duration=&quot;1200&quot;    android:fillAfter=&quot;true&quot;    android:fromDegrees=&quot;0&quot;    android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;    android:toDegrees=&quot;360&quot; /&gt;\n通过代码实现\n语法\n1234RotateAnimation rotateAnimation = new RotateAnimation(float fromDegrees, float toDegrees, int pivotXType, float pivotXValue, int pivotYType, float pivotYValue);rotateAnimation.setInterpolator(Interpolator i);rotateAnimation.setDuration(long durationMillis);AnimationTarget.startAnimation(rotateAnimation); \n示例\n1234RotateAnimation rotateAnimation = new RotateAnimation(float fromDegrees, float toDegrees, int pivotXType, float pivotXValue, int pivotYType, float pivotYValue);rotateAnimation.setInterpolator(Interpolator i);rotateAnimation.setDuration(long durationMillis);AnimationTarget.startAnimation(rotateAnimation); \nAnimationSet\n通过XML创建\n语法\n1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:interpolator=&quot;@[package:]anim/interpolator_resource&quot;    android:shareInterpolator=[&quot;true&quot; | &quot;false&quot;] &gt;    &lt;alpha        android:fromAlpha=&quot;float&quot;        android:toAlpha=&quot;float&quot; /&gt;    &lt;scale        android:fromXScale=&quot;float&quot;        android:toXScale=&quot;float&quot;        android:fromYScale=&quot;float&quot;        android:toYScale=&quot;float&quot;        android:pivotX=&quot;float&quot;        android:pivotY=&quot;float&quot; /&gt;    &lt;translate        android:fromXDelta=&quot;float&quot;        android:toXDelta=&quot;float&quot;        android:fromYDelta=&quot;float&quot;        android:toYDelta=&quot;float&quot; /&gt;    &lt;rotate        android:fromDegrees=&quot;float&quot;        android:toDegrees=&quot;float&quot;        android:pivotX=&quot;float&quot;        android:pivotY=&quot;float&quot; /&gt;    &lt;set&gt;        ...    &lt;/set&gt;&lt;/set&gt;\n\n示例\n1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:duration=&quot;@integer/integer_three_thousand&quot;    android:fillAfter=&quot;true&quot;    android:shareInterpolator=&quot;true&quot;&gt;    &lt;translate        android:fromXDelta=&quot;@integer/integer_zero&quot;        android:fromYDelta=&quot;@integer/integer_zero&quot;        android:toXDelta=&quot;@integer/integer_zero&quot;        android:toYDelta=&quot;@integer/integer_two_hundred&quot; /&gt;    &lt;alpha        android:fromAlpha=&quot;@integer/integer_one&quot;        android:toAlpha=&quot;@fraction/scale_smaller&quot; /&gt;    &lt;rotate        android:fromDegrees=&quot;@integer/integer_zero&quot;        android:pivotX=&quot;@fraction/percent_fifty&quot;        android:pivotY=&quot;@fraction/percent_fifty&quot;        android:toDegrees=&quot;@integer/integer_seven_hundred_and_five&quot; /&gt;&lt;/set&gt;\n通过代码实现\n语法\n1234AnimationSet animationSet = new AnimationSet(boolean shareInterpolator);animationSet.addAnimation(Animation a)...AnimationTarget.startAnimation(animationSet);\n示例\n123456789101112131415161718192021AlphaAnimation alphaAnimation = new AlphaAnimation(1.0f, 0.5f);alphaAnimation.setInterpolator(new AccelerateInterpolator());alphaAnimation.setFillAfter(mIsSaveAnimationState);alphaAnimation.setDuration(800);ScaleAnimation scaleAnimation = new ScaleAnimation(1f, 2f, 1f, 2f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);scaleAnimation.setInterpolator(new AccelerateInterpolator());scaleAnimation.setFillAfter(mIsSaveAnimationState);scaleAnimation.setDuration(800);RotateAnimation rotateAnimation = new RotateAnimation(0f, 360f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);rotateAnimation.setInterpolator(new AccelerateInterpolator());rotateAnimation.setFillAfter(mIsSaveAnimationState);rotateAnimation.setDuration(800);AnimationSet animationSet = new AnimationSet(false);animationSet.setFillAfter(true);animationSet.addAnimation(alphaAnimation);animationSet.addAnimation(scaleAnimation);animationSet.addAnimation(rotateAnimation);mTarget.startAnimation(animationSet);\n动画监听\nAnimation类通过监听动画开始 / 结束 / 重复时刻可以进行一系列自定义操作，如跳转页面等等。通过在 Java 代码里setAnimationListener()方法设置：\n123456789101112131415161718192021Animation.addListener(new AnimatorListener() &#123;    @Override    public void onAnimationStart(Animation animation) &#123;        //动画开始时执行    &#125;     @Override    public void onAnimationRepeat(Animation animation) &#123;        //动画重复时执行    &#125;   @Override    public void onAnimationCancel()(Animation animation) &#123;        //动画取消时执行    &#125;        @Override    public void onAnimationEnd(Animation animation) &#123;        //动画结束时执行    &#125;&#125;);\n采取上述方法监听动画，每次监听都必须重写4个方法，有些时候我们只需要实现其中一个，因此其余的很累赘，我们可以采用动画适配器AnimatorListenerAdapter来针对化的实现：\n1234567// 向addListener()方法中传入适配器对象AnimatorListenerAdapter()anim.addListener(new AnimatorListenerAdapter() &#123;      @Override      public void onAnimationStart(Animator animation) &#123;      // 如想只想监听动画开始时刻，就只需要单独重写该方法就可以    &#125;  &#125;);  \n插值器\n细心的同学观察到以上动画属性中几乎都存在一个插值器属性。插值器是动画执行速率调节器，主要用来控制动画的变化率。\n常用的插值器汇总\n\n自定义插值器\n自定义插值器同样可以有两种方式：XML和CODE。\n通过XML自定义\n通过 XML 自定义插值器的时候，限制性比较大，因为系统只提供了部分插值器的自定义，如 AccelerateInterpolator，有些插值器是不支持自定义的，如 AccelerateDecelerateInterpolator。\n我们看看AccelerateInterpolator如何自定义，AccelerateInterpolator中可以自定义的属性只有：android:factor，表示加速的比率（The acceleration rate），默认值为 1。\n1234567891011121314151617&lt;!-- custom accelerateInterpolator --&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;accelerateInterpolator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:factor=&quot;4.0&quot; /&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:duration=&quot;1200&quot;    android:fillAfter=&quot;true&quot;    android:fillBefore=&quot;false&quot;    android:fillEnabled=&quot;false&quot;    android:fromXDelta=&quot;0&quot;    android:fromYDelta=&quot;0&quot;    android:interpolator=&quot;@android:anim/custom_accelerate_interpolator&quot;    android:toXDelta=&quot;40%p&quot;    android:toYDelta=&quot;0&quot; /&gt;\n可以通过 XML 自定义插值器，除了 AccelerateInterpolator，还有很多，以下是具体列表：\n\n通过代码自定义\n通过 CODE 自定义插值器就没有那么多限制， 也很简单，只要实现 Interpolator 接口，并实现其中的方法（getInterpolation）就好了。接下来，我们先看下 Google 官方是如何实现插值器的。\n1234567891011121314151617181920212223242526272829303132333435//AccelerateDecelerateInterpolatorpackage android.view.animation;import android.content.Context;import android.util.AttributeSet;import com.android.internal.view.animation.HasNativeInterpolator;import com.android.internal.view.animation.NativeInterpolatorFactory;import com.android.internal.view.animation.NativeInterpolatorFactoryHelper;/** * An interpolator where the rate of change starts and ends slowly but * accelerates through the middle. */@HasNativeInterpolatorpublic class AccelerateDecelerateInterpolator extends BaseInterpolator        implements NativeInterpolatorFactory &#123;    public AccelerateDecelerateInterpolator() &#123;    &#125;    @SuppressWarnings(&#123;&quot;UnusedDeclaration&quot;&#125;)    public AccelerateDecelerateInterpolator(Context context, AttributeSet attrs) &#123;    &#125;    public float getInterpolation(float input) &#123;        return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f;    &#125;    /** @hide */    @Override    public long createNativeInterpolator() &#123;        return NativeInterpolatorFactoryHelper.createAccelerateDecelerateInterpolator();    &#125;&#125;\n通过代码可知，AccelerateDecelerateInterpolator 是通过余弦函数实现的。在 AccelerateDecelerateInterpolator 中，加速的过程是函数曲线斜率逐渐增大的过程，减速的过程是函数曲线斜率逐渐减小的过程。\n\n明白了AccelerateDecelerateInterpolator插值器原理之后，我们用正切函数实现一个 DecelerateAccelerateInterpolator。（快-慢-快）\n\n1.Interpolator 接口中 getInterpolation 方法中 input 的取值范围为 [0,1]，而蓝色框圈出的 X 的取值范围为 [-π/4,π/4]，所以，需要将 [0,1] 转换为 [-π/4,π/4]：\n1π&#x2F;2 * input - π&#x2F;4\n2.正切函数在 [-π/4,π/4] 取值范围内，相应的函数值的取值范围为[-1,1]，而 getInterpolation 最终返回值的取值范围为 [0,1]，所以，需要将 [-1,1] 转换为 [0,1]：\n1(tan(π/2 * input - π/4) + 1)/2\n所以代码实现过程：\n123456789101112131415//自定义public class DecelerateAccelerateInterpolator implements Interpolator &#123;    @Override    public float getInterpolation(float input) &#123;        return (float) ((Math.tan(Math.PI/2 * input - Math.PI/4) + 1)/2);    &#125;&#125;//调用TranslateAnimation translateAnimation = new TranslateAnimation(0f, 0f, 0f, 800f);translateAnimation.setInterpolator(new DecelerateAccelerateInterpolator());translateAnimation.setFillAfter(mIsSaveAnimationState);translateAnimation.setDuration(1800);mTarget.startAnimation(translateAnimation);\n使用场景\n补间动画常用于视图View的一些标准动画效果：平移、旋转、缩放，透明度等，除了常规的动画使用，补间动画还有一些特殊的应用场景，例如Activity和Fragment的切换动效以及视图组（ViewGroup）中子元素的出场效果。\nActivity 的切换效果\n页面进入动画：\n12345Intent intent = new Intent (this,Acvtivity.class);startActivity(intent);// enter_anim（b页面的进场动画），exit_anim（a页面的消失动画）// 特别注意：overridePendingTransition（）必须要在startActivity(intent)后被调用才能生效overridePendingTransition(R.anim.enter_anim,R.anim.exit_anim);\n页面退出动画：\n123456@Overridepublic void finish()&#123;    super.finish();    // 特别注意: overridePendingTransition（）必须要在finish()后被调用才能生效    overridePendingTransition(R.anim.enter_anim,R.anim.exit_anim);&#125;\n系统自带的效果android.R.anim.xxx：\n12345// 淡入淡出的动画效果      overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out);// 从左向右滑动的效果overridePendingTransition(android.R.anim.slide_in_left, android.R.anim.slide_out_right);\nFragment 切换效果\n系统自带的切换效果：\n12345678FragmentTransaction fragmentTransaction = mFragmentManager.beginTransaction();// 通过setTransition(int transit)进行设置// transit参数说明// 1. FragmentTransaction.TRANSIT_NONE：无动画// 2. FragmentTransaction.TRANSIT_FRAGMENT_OPEN：标准的打开动画效果// 3. FragmentTransaction.TRANSIT_FRAGMENT_CLOSE：标准的关闭动画效果// 标准动画设置好后，在Fragment添加和移除的时候都会有。fragmentTransaction.setTransition(int transit);\n自定义动画效果：\n123FragmentTransaction fragmentTransaction = mFragmentManager.beginTransaction();// 采用`FragmentTransavtion`的 `setCustomAnimations（）`进行设置fragmentTransaction.setCustomAnimations(R.anim.in_from_right,R.anim.out_to_left);\n视图组（ViewGroup）中子元素的出场效果\n有些时候我们想为ViewGroup中的子元素的出场统一动画规则，那么我们可以这样做：\n1.定义子元素统一出场动画：\n123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;// 此处采用了组合动画&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;    android:duration=&quot;3000&quot;    &lt;alpha        android:duration=&quot;1500&quot;        android:fromAlpha=&quot;1.0&quot;        android:toAlpha=&quot;0.0&quot; /&gt;    &lt;translate        android:fromXDelta=&quot;500&quot;        android:toXDelta=&quot;0&quot;         /&gt;&lt;/set&gt;\n2.定义视图组（ViewGroup）动画管理规则：\n1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;// 采用LayoutAnimation标签&lt;layoutAnimation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    // 子元素开始动画的时间延迟    // 如子元素入场动画的时间总长设置为300ms    // 那么 delay = &quot;0.5&quot; 表示每个子元素都会延迟150ms才会播放动画效果    // 第一个子元素延迟150ms播放入场效果；第二个延迟300ms，以此类推    android:delay=&quot;0.5&quot;       // 表示子元素动画的顺序    // 可设置属性为：    // 1. normal ：顺序显示，即排在前面的子元素先播放入场动画    // 2. reverse：倒序显示，即排在后面的子元素先播放入场动画    // 3. random：随机播放入场动画    android:animationOrder=&quot;normal&quot;        // 设置入场的具体动画效果    // 将步骤1的子元素出场动画设置到这里    android:animation=&quot;@anim/view_animation&quot;    /&gt;\n3.为视图组（ViewGroup）指定andorid:layoutAnimation属性，这里有两种方式：xml设置和code设置。\n方式1：在 XML 中指定：\n1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:background=&quot;#FFFFFF&quot;    android:orientation=&quot;vertical&quot; &gt;    &lt;ListView        android:id=&quot;@+id/listView1&quot;        android:layoutAnimation=&quot;@anim/anim_layout&quot;        // 指定layoutAnimation属性用以指定子元素的入场动画        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot; /&gt;&lt;/LinearLayout&gt;\n方式2：在Java代码中指定【这样就不用额外设置res/ anim /anim_layout.xml该xml文件了】:\n123456789ListView lv = (ListView) findViewById(R.id.listView1);// 加载子元素的出场动画Animation animation = AnimationUtils.loadAnimation(this,R.anim.anim_item);// 设置LayoutAnimation的属性LayoutAnimationController controller = new LayoutAnimationController(animation);controller.setDelay(0.5f);controller.setOrder(LayoutAnimationController.ORDER_NORMAL);// 为ListView设置LayoutAnimation的属性lv.setLayoutAnimation(controller);\n参考\n\nhttps://developer.android.google.cn/guide/topics/resources/animation-resource#Tween\nhttps://juejin.cn/post/6844903793713233927#heading-64\nhttps://blog.csdn.net/carson_ho/article/details/72827747\n\n","plink":"https://blog.ixin.run/posts/1614434754/"},{"title":"你知道ImageView的ScaleType怎么用吗","date":"2021-02-27T11:18:34.000Z","date_formatted":{"ll":"2021年2月27日","L":"2021/02/27","MM-DD":"02-27"},"updated":"2021-03-03T05:20:37.289Z","content":"如果你像我一样很容易健忘，那么你也应该像我一样有一个好习惯——“好记性不如赖笔头”。Android开发中ImageView的ScaleType属性就有很多选择，说实话我是真的记不住这么多类型的用法，所以只有用笔记下来咯，用的时候直接翻看一下，2分钟搞定。你知道ImageView的ScaleType怎么用吗？\n\nScaleType概述\nImageView 的 ScaleType 一共八种类型，分别是：\n\nCENTER\nCENTER_CROP\nCENTER_INSIDE\nFIT_CENTER\nFIT_END\nFIT_START\nFIT_XY\nMATRIX\n\n由于不同类型的 ScaleType 最终展示的 ImageView 不一样，再加上 ImageView 的使用频率非常高，因此，了解不同类型的 ScaleType 的作用是十分有必要的。\n下面是ScaleType并排放置的所有不同屏幕截图，来自thoughtbot：\n\nScaleType详解\n1. CENTER\n\nCenter the image in the view, but perform no scaling.\n\n在不缩放的前提下，将 Image 的中间显示在 ImageView 的中间。\n\nImage 尺寸比 ImageView 尺寸大\n只显示 Image 中间与 ImageView 尺寸相等的部分\nImage 尺寸与 ImageView 尺寸相等\n完整显示\nImage 尺寸比 ImageView 尺寸小\nImage 完整地显示在 ImageView 中间\n\n2. CENTER_CROP\n\nScale the image uniformly (maintain the image’s aspect ratio) so that both dimensions (width and height) of the image will be equal to or larger than the corresponding dimension of the view (minus padding).\n\nImage Width Height 等比例缩放至至少一个方向上 Image 与 ImageView 尺寸一样（Image 短边缩放至与 ImageView 对应边相等（Width 对应 Width，Height 对应 Height）），之后将缩放后的 Image 的中间显示在 ImageView 的中间。\n\nImage 尺寸比 ImageView 尺寸大\nImage 短边缩小至与 ImageView 对应边相等，Image 长边根据相应的缩放系数进行缩放，之后将 Image 中间显示在 ImageView 中间。\nImage 尺寸与 ImageView 尺寸相等\n完整显示\nImage 尺寸比 ImageView 尺寸小\nImage 短边放大至与 ImageView 对应边相等，Image 长边根据相应的缩放系数进行缩放，之后将 Image 中间显示在 ImageView 中间。\n\n3. CENTER_INSIDE\n\nScale the image uniformly (maintain the image’s aspect ratio) so that both dimensions (width and height) of the image will be equal to or less than the corresponding dimension of the view (minus padding).\n\n完整地将 Image 显示在 ImageView 中间。如果 Image 比 ImageView 尺寸大，则将长边缩放至与 ImageView 对应边相等，同时，短边根据缩放系数缩放。之后，将缩放后的 Image 完整地显示在 ImageView 上；如果 Image 比 ImageView 尺寸小，直接将 Image 显示在 ImageView 中间。\n\nImage 尺寸比 ImageView 尺寸大\nImage 长边缩小至与 ImageView 对应边相等，Image 短边根据相应的缩放系数进行缩放，之后将 Image 显示在 ImageView 中间。\nImage 尺寸与 Image View 尺寸相等\n完整显示\nImage 尺寸比 ImageView 尺寸小\nImage 不进行任何处理，直接显示在 ImageView 中间。\n\n4. FIT_CENTER\n\nCompute a scale that will maintain the original src aspect ratio, but will also ensure that src fits entirely inside dst. At least one axis (X or Y) will fit exactly. The result is centered inside dst.\n\n完整地将 Image 显示在 ImageView 中间。如果 Image 比 ImageView 尺寸大，则将长边缩放至与 ImageView 对应边相等，同时，短边根据缩放系数缩放，之后将缩放后的 Image 完整地显示在 ImageView 上；如果 Image 比 ImageView 尺寸小，则将长边放大至与 ImageView 对应边相等，之后将缩放后的 Image 完整地显示在 ImageView 上。总之，在保证 Image 完整显示在 ImageView 里面的前提下，保证在一个方向上，Image 与 ImageView 是相等的。\n\nImage 尺寸比 ImageView 尺寸大\nImage 长边缩小至与 ImageView 对应边相等，Image 短边根据相应的缩放系数进行缩放，之后将 Image 显示在 ImageView 中间。\nImage 尺寸与 ImageView 尺寸相等\n完整显示\nImage 尺寸比 ImageView 尺寸小\nImage 长边放大至与 ImageView 对应边相等，Image 短边根据相应的缩放系数进行缩放，之后将 Image 显示在 ImageView 中间。\n\n5. FIT_END\n\nCompute a scale that will maintain the original src aspect ratio, but will also ensure that src fits entirely inside dst. At least one axis (X or Y) will fit exactly. END aligns the result to the right and bottom edges of dst.\n\n完整地将 Image 显示在 ImageView 右边或下边。如果 Image 比 ImageView 尺寸大，则将长边缩放至与 ImageView 对应边相等，同时，短边根据缩放系数缩放，之后将缩放后的 Image 完整地显示在 ImageView 右边或下边；如果 Image 比 ImageView 尺寸小，则将长边放大至与 ImageView 对应边相等，之后将缩放后的 Image 完整地显示在 ImageView 右边或下边。总之，在保证 Image 完整显示在 ImageView 里面的前提下，保证在一个方向上，Image 与 ImageView 是相等的。\n\nImage 尺寸比 ImageView 尺寸大\nImage 长边缩小至与 ImageView 对应边相等，Image 短边根据相应的缩放系数进行缩放，之后将 Image 显示在 ImageView 右边或下边。\nImage 尺寸与 ImageView 尺寸相等\n完整显示\nImage 尺寸比 ImageView 尺寸小\nImage 长边放大至与 ImageView 对应边相等，Image 短边根据相应的缩放系数进行缩放，之后将 Image 显示在 ImageView 右边或下边。\n\n6. FIT_START\n\nCompute a scale that will maintain the original src aspect ratio, but will also ensure that src fits entirely inside dst. At least one axis (X or Y) will fit exactly. START aligns the result to the left and top edges of dst.\n\n完整地将 Image 显示在 ImageView 左边或上边。如果 Image 比 ImageView 尺寸大，则将长边缩放至与 ImageView 对应边相等，同时，短边根据缩放系数缩放，之后将缩放后的 Image 完整地显示在 ImageView 左边或上；如果 Image 比 ImageView 尺寸小，则将长边放大至与 ImageView 对应边相等，之后将缩放后的 Image 完整地显示在 ImageView 左边或上边。总之，在保证 Image 完整显示在 ImageView 里面的前提下，保证在一个方向上，Image 与 ImageView 是相等的。\n\nImage 尺寸比 ImageView 尺寸大\nImage 长边缩小至与 ImageView 对应边相等，Image 短边根据相应的缩放系数进行缩放，之后将 Image 显示在 ImageView 左边或上边。\nImage 尺寸与 ImageView 尺寸相等\n完整显示\nImage 尺寸比 ImageView 尺寸小\nImage 长边放大至与 ImageView 对应边相等，Image 短边根据相应的缩放系数进行缩放，之后将 Image 显示在 ImageView 左边或上边。\n\n7. FIT_XY\n\nScale in X and Y independently, so that src matches dst exactly. This may change the aspect ratio of the src.\n\n完整地将 Image 显示在 ImageView 里面。Image X、Y 方向上分别缩放至与 ImageView 对应边相等，Image 的 Width 和 Height 缩放系数可以不一致。\n\nImage 尺寸比 ImageView 尺寸大\nImage 的 Width、Height 分别缩放至与 ImageView 对应边相等，之后将 Image 完整地显示在 ImageView 里面。\nImage 尺寸与 ImageView 尺寸相等\n完整显示\nImage 尺寸比 ImageView 尺寸小\nImage 的 Width、Height 分别缩放至与 ImageView 对应边相等，之后将 Image 完整地显示在 ImageView 里面。\n\n8. MATRIX\n\nCompute a scale that will maintain the original src aspect ratio, but will also ensure that src fits entirely inside dst. At least one axis (X or Y) will fit exactly. START aligns the result to the left and top edges of dst.\n\n将 Image 从 ImageView 左上角开始显示。\n\nImage 尺寸比 ImageView 尺寸大\nImageView 只显示 Image 中从左上角开始与 ImageView 尺寸相等的部分，多余的地方不显示。\nImage 尺寸与 ImageView 尺寸相等\n完整显示\nImage 尺寸比 ImageView 尺寸小\nImage 显示在 ImageView 的左上角。\n\n参考\n\nhttps://developer.android.com/reference/android/widget/ImageView.ScaleType.html\nhttps://thoughtbot.com/blog/android-imageview-scaletype-a-visual-guide\n\n","plink":"https://blog.ixin.run/posts/1614424714/"},{"title":"极度干货——GitHub受欢迎的Android UI Library整理","date":"2021-02-25T06:37:58.000Z","date_formatted":{"ll":"2021年2月25日","L":"2021/02/25","MM-DD":"02-25"},"updated":"2021-03-03T05:20:37.288Z","content":"Android开发者福音，极度干货，以下是安卓UI相关开源项目库集合整理，开发必备，欢迎收藏，点赞。\n\n抽屉菜单\n\nMaterialDrawer ★7582 - 安卓抽屉效果实现方案\nSide-Menu.Android ★3979 - 创意边侧菜单\nFlowingDrawer ★1784 - 向右滑动流动抽屉效果\nSlidingRootNav ★1589 - 仿DrawerLayout的ViewGroup\nFantasySlide ★1084 - 单手势滑出侧边栏与选择菜单\nFloating-Navigation-View ★806 - 浮动菜单显示锚导航视图\nmaterial-drawer ★538 - MD风格的自定义抽屉实现\nSwipeMenuDemo ★533 - 侧滑菜单动画效果库\nArcNavigationView ★353 - 具有曲线边缘的NavigationView\nQQSliddingMenu ★111 - 与QQ5.0 完全一模一样的侧滑菜单\nSlideSideMenu ★69 - 滑动侧菜单的布局部件\n\nListView\n\nbaseAdapter ★2685 - Android 万能的Adapter\nPinned Section Listview ★2393 - 便于使用的ListView\nAsymmetricGridView ★1410 - Android自定义列表视图\nRenderers ★1036 - 创建适配器的Android库\nCalendarListView ★766 - 可互动的ListView+CalendarView\nAndroidExpandingViewLibrary ★528 - 创建Android动画折叠视图\nListItemView ★501 - 基于MD风格的列表item实现\nWheelView ★462 - 基于ListView实现的Android滚轮控件\nYLListView ★216 - 仿IOS弹簧效果的ListView\nSearchListView ★152 - 带搜索栏的 listview\nScollZoomListView ★40 - 优雅的漫画阅读器插件\n\nWebView\n\nJsBridge ★3073 - Android的Java和JavaScript桥接\nAndroidChromium ★1532 - 谷歌浏览器安卓版源码项目\nFinestWebView-Android ★1478 - 可自定义webview\nVideoEnabledWebView ★622 - Android的WebView和WebChromeClint类扩展\nAgentWeb ★455 - 一个高度封装的 WebView\nCollapsingToolbar-With-Webview ★190 - 带有可折叠toolbar的Webview\nDSBridge-Android ★162 - 目前地球上最好的IOS及Android javascript bridge\nDSBridge-IOS ★135 - 目前地球上最好的IOS javascript bridge\nWebViewNativeBridge ★29 - 从WebView向Java通过url发送数据\nClickableWebView ★22 - 检测图片上的点击\n\nSwitchButton\n\nToggleButton ★1770 - Android上类似iOS的开关控件\nAndroid-SwitchIcon ★1470 - Switch图标的Google启动器风格实现\nmaterial-animated-switch ★974 - 带有图标动画和颜色转换的Switch\nIconSwitch ★580 - 自定义切换部件\nSwitchButton ★399 - 优美的轻量级自定义样式的Switch按钮\nSHSwitchView ★322 - iOS7风格的Switch开关\nSwitchButton ★284 - 安卓开关按钮\nswitchView ★19 - 带有文字的switch\n\n按钮\n\nFancyButtons ★1148 - 创建花式按钮\nArrowDownloadButton ★790 - 超酷的下载按钮\nAnimShopButton ★788 - 带伸缩位移旋转动画的购物车按钮\nGoodView ★774 - Android点赞+1效果\nStateButton ★768 - 不必为每种类型的button写一个drawable\nfab ★764 - 浮动按钮\nJellyToggleButton ★706 - 果冻动态效果及缓动类型开关按钮\nSparkButton ★693 - 创建一个带动画效果的按钮\nFabButton ★671 - 带有进度条指示器的环形浮动动作按钮\nProgressRoundButton ★634 - 显示进度的流畅下载按钮\nHoldingButton ★471 - 控制录音状态的按钮\nSubmitButton ★356 - 实用酷炫又优雅的提交按钮\nButtonProgressBar ★329 - 下载按钮进度条\nMultiChoicesCircleButton ★312 - 带3d视差效果的多选按钮\nRaiflatButton ★290 - 凸起的按钮\nCProgressButton ★255 - 仿iOS环形进度按钮\nroundbutton ★243 - 可设置圆角背景边框的的按钮\nPlayPauseButton ★233 - 制作动画播放状态的视图\nswipe-button ★216 - swipe button\nSubmitButton ★189 - 带有进度动画的自定义提交按钮\nAndroid-DivergeView ★170 - 仿美拍直播的点赞动画\nTriStateToggleButton ★134 - 完全可自定义3态切换按钮\nSegmentedButton ★107 - 类似IOS的带动画分割按钮\nDxLoadingButton ★83 - 带有动画的Android加载按钮\nSuspendButtonLayout ★73 - 带浮动按钮的布局\nfloating-text-button ★49 - 带动作文本的简单浮动按钮\nPentagonFloatingActionButton ★43 - 浮动点击动画按钮\nFreeRadioGroup ★33 - 类似于苹果的虚拟辅助按钮\nHamburger-Button ★32 - 完全定制的汉堡按钮\nBadgeRadioButton ★25 - 仿QQ底部Tab切换RadioButton\nOrderButton ★21 - 仿饿了么下单按钮\n\n点赞按钮\n\nShineButton ★2533 - 安卓闪光UI库\nLikeButton ★1897 - 仿Twitter点赞时的的heart\nGoodView ★774 - Android点赞+1效果\nSparkButton ★693 - 创建一个带动画效果的按钮\nThumbUp ★559 - 精致的点赞控件\nMagicFloatView ★232 - 自定义拓展漂浮路径的MagicFlyLinearLayout 控件\nAndroid-DivergeView ★170 - 仿美拍直播的点赞动画\nLikeView ★34 - 仿即刻APP点赞桃心的效果\nTumblrLikeAnimView ★15 - 仿Tumblr点赞动画效果\n\n进度条\n\nAVLoadingIndicatorView ★5055 - 安卓载入动画合集\nNumberProgressBar ★4026 - 多彩进度条\nAndroid-SpinKit ★3305 - Android加载动画\nLoadingDrawable ★2630 - 安卓工具动画集合\nCircleProgress ★2415 - 三种圆形进度视图\nProgressWheel ★2260 - 圆形旋转效果\nCircularReveal ★2034 - 创建加载动画效果\nLoadingView ★1719 - 简单的带有动画效果的加载控件\nAndroidFillableLoaders ★1603 - 有趣的填充型进程视图\nElasticDownload ★1442 - 下载动画效果\nMetaballLoading ★1352 - 一个2d圆球加载\nandroid-shapeLoadingView ★1321 - 高仿新版58 加载动画\nAndroid-RoundCornerProgressBar ★1252 - Android圆角进度条库\nMaterialProgressBar ★1213 - MD风格的进度条\nWaveLoadingView ★1176 - 仿真波浪加载效果\nWaveLoading ★1094 - 能够提供波浪动画的Drawable\nmkloader ★1028 - 优美又流畅的自定义加载视图\nGifLoadingView ★978 - webpage中的简单动画方法\nArcProgressStackView ★938 - arc模式进度条\nAnimatedCircleLoadingView ★937 - 加载视图动画\nLoading ★912 - 多个Android加载效果\nCircularFillableLoaders ★871 - 精致的环形填充加载效果\nprogress-activity ★793 - 进度条空视图及错误视图库\nKProgressHUD ★757 - 安卓ProgressHUD实现\nCatLoadingView ★756 - Android猫头像加载视图\nCircleProgress ★755 - 带旋转动画的环形进度视图\nCircleView ★708 - 动画环形视图\nCircular Music ProgressBar ★627 - Android环形音乐进度条\nColorArcProgressBar ★616 - 可定制的圆形进度条\nspots-dialog ★612 - Android提示对话框\nCircularProgressView ★605 - 环形进度条安卓视图\nSlackLoadingView ★604 - 模仿Slack加载动画\nDilatingDotsProgressBar ★598 - 自定义模糊进度条\nRingProgressBar ★546 - MD风格的环形进度条\nMagicProgressWidget ★501 - 圆形进度条与横向进度条\nFAB-Loading ★482 - 浮动加载动画\nCircleView ★480 - 包含标题和子标题的环形视图\nRingProgress ★472 - 带效果的环形进度条\nCoolAndroidAnim ★472 - 酷炫的android loading效果\nAndroid-SVProgressHUD ★464 - 精仿iOS的提示库 SVProgressHUD\nFlickerProgressBar ★444 - 安卓仿应用宝下载进度条\npageloader ★346 - 轻松自定义加载页面\nCircleAlarmTimerView ★306 - 圆形进度条\nSquareLoading ★292 - 一个方形动画加载器\nAdhesiveLoadingView ★262 - 具有粘性的滑动小球loading\nOverWatchLoading ★250 - 守望先锋的加载动画效果\nSwipeCoordinator ★218 - 简化动画滑动视图进程\nMarkView ★208 - 彩色圆弧的环形进度条\nLikeSinaSportProgress ★204 - 仿新浪体育客户端的进度条\nsnackprogressbar ★180 - 带有ProgressBar的增强型Snackbar\nBounceLoadingView ★173 - 模仿饿了么加载效果\nProgressView ★156 - 多种样式的进度条\nLoadingProgress ★148 - 加载进度条\nSlidingSquaresLoader ★147 - 简单的进度加载\nCutoLoadingView ★127 - 自定义加载视图\nAwesomeProgressbar ★108 - 支持左右两边同时滚动的进度条\nLoadingDialog ★95 - 简单好用的LoadingDialog\nZYDownloading ★94 - 一个蛮酷的加载进度条\nLazyLoadingViews ★81 - Adapter视图中子视图加载效果\nand_cube_progress ★74 - 正方体样式的loadingView\nGradeProgressView ★67 - 用来评估移动电话的进度条视图\nProProgressViews ★56 - Android精致进度视图收集库\nOverwatchProgress ★50 - 模仿Overwatch的进度条\nCircleProgressView ★44 - 显示百分比进度的安卓组件\nCircleProgressBar ★36 - 带载入动画的环形进度条\nBGAProgressBar-Android ★31 - 安卓进度条\nVideoLoadingView ★30 - 加载界面\nLovelyProgressBar ★27 - 漂亮的加载动画\nBaiduProgressBar ★23 - 仿百度加载动画\ncustomprogressbar ★19 - 自定义ProgressBar\nDataLoadingLayoutAndroid ★15 - 展示当前数据加载状态的库\n\nTabLayout\n\nSmartTabLayout ★4416 - 在用户滚动时给出连续的反馈\nFlycoTabLayout ★4126 - Android的TabLayout库\nMagicIndicator ★2310 - 强大易扩展的ViewPager指示器框架\nCoordinatorTabLayout ★2021 - 自定义组合控件\nNavigationTabStrip ★1413 - 平滑可交互导航标签条\nDachshund-Tab-Layout ★568 - 增强型Android标签布局\nAdvancedPagerSlidingTabStrip ★318 - 安卓导航控件\nChangeTabLayout ★185 - 模仿乐视LIVEApp主界面TabLayout效果\nSlidingTabWithColorIcons ★22 - 带彩色图标的滑动标签\nPagerSlidingTabStrip ★21 - 指示器TabLayout、PagerSlidingTabStrip\n\n图标\n\nMaterial design icons ★30013 - 谷歌官方图标\nandroid-iconify ★2966 - 多个图标供应商的图标整合\nAndroid-Iconics ★2825 - 在应用中使用图标字体或矢量\nmaterial-icon-lib ★1947 - 1500个MD风格矢量图标\nAnimated-Icons ★144 - 安卓动画图标\nDroidAwesome ★25 - 视图或者菜单中显示FontAwesome图标\n\n下拉刷新\n\nandroid-Ultra-Pull-To-Refresh ★7947 - 下拉刷新项目的替代方案\nPhoenix ★3296 - 可自定义滑动刷新实现\nBGARefreshLayout-Android ★2998 - 多种下拉刷新和上拉加载插件\nFlyRefresh ★2762 - 最有特色的下拉刷新\nTwinklingRefreshLayout ★2111 - 下拉刷新和上拉加载的RefreshLayout\nWaveSwipeRefreshLayout ★1595 - Android刷新控件\nSwipeToLoadLayout ★1522 - 可重用下拉刷新及上拉加载更多组件\nTaurus ★1441 - 简单和可定制的下拉刷新实现\nRecyclerRefreshLayout ★1391 - 通过垂直滑动手势刷新当前view内容\npull-to-make-soup ★1254 - 自定义动画下拉刷新\nFunGameRefresh ★1098 - 有趣好玩的下拉刷新库\nPullLoadMoreRecyclerView ★962 - 上拉刷新加载\nXRefreshView ★902 - android下拉上拉刷新框架\nCommonPullToRefresh ★884 - 下拉刷新\nSwipyRefreshLayout ★832 - 在两个方向上滑动的SwipeRefreshLayout扩展\nChromeLikeSwipeLayout ★636 - 执行更多事件的下拉事件\nJellyRefreshLayout ★608 - 下拉刷新布局\nAnimRefreshRecyclerView ★534 - 下拉刷新和上拉加载更多的RecyclerView\nPullToRefresh ★516 - 下拉刷新实现\nSmartisanPull ★506 - 最优雅的下拉控件\nLoadingViewFinal ★269 - 实现了下拉刷新/加载更多的android组件\nShootRefreshView ★263 - 快手Android客户端刷新动画\nPullRefreshView ★241 - 为滑动控件添加上拉刷新下拉加载等功能\nSmileRefresh ★191 - 微笑下拉刷新\nRecyclerRefresh ★172 - 仿简书安卓端\nCoolRefreshView ★128 - 安卓刷新视图库\nEasyRefreshLayout ★116 - 轻松实现下拉刷新和上拉加载\nRefreshLayout ★77 - 实现下拉刷新和上拉加载\nVRefreshLayout ★67 - 竖直方向的下拉刷新控件\nTLRLoadRefresh ★63 - 下拉刷新和上拉加载的UI组件\nRefreshLayout ★48 - 下拉刷新、上拉加载，支持回弹效果\nPowerRefresh ★36 - 实现嵌套滑动机制的通用下拉刷新和加载更多\nHorizontalRefreshLayout ★36 - 实现左右刷新\nDxWaveRefresh ★34 - 波浪效果的下拉刷新\nTypewriter ★28 - 打印机效果的下拉刷新控件\nUltimateRefreshView ★25 - 下拉刷新组件\nDonkeyRefresh ★16 - 仿赶集下拉刷新\n\nViewPager\n\nMaterialViewPager ★6124 - 安卓选项卡插件\nInfiniteCycleViewPager ★3807 - 无限循环的视图页\nRecyclerViewPager ★2372 - 基于RecyclerView的ViewPager替代品\nViewPagerCards ★2297 - 视图页卡片\nCircleIndicator ★2283 - 轻量级ViewPager指示器\nPageIndicatorView ★1971 - 能够指示选定页的ViewPage\nUltraViewPager ★1833 - 封装多种特性的ViewPager\nZoomHeader ★1797 - 模仿饿了么详情页的例子\nandroid-page-transition ★1641 - 带有垂直滑动效果和Activity过渡的ViewPager\nViewPagerIndicator ★1586 - 布局插件\nViewPagerTransforms ★1542 - 包含视图页滚动常见动画的库\nExpandingPager ★1489 - 卡片peek及pop控件\nAndroid-ParallaxHeaderViewPager ★1307 - 带标题头的左右滑动\nMultiViewPager ★855 - 支持V4库的ViewPager的扩展\nDecentBanner ★812 - 基于安卓Banner的ViewPager\nExpandablePager ★684 - 两个状态（展开和滑动）间的垂直滑动切换\nPdfViewPager ★590 - 在Activities或Fragments中显示PDF文档\nInfiniteViewPager ★587 - 环绕实现首页末页跳转\nParallaxViewPager ★497 - 安卓视差视图页\nBezierViewPager ★494 - 触摸贝塞尔圆球式图片展示\nInfiniteIndicator ★469 - 视图回收适配器\nMagicViewPager ★420 - 单页ViewPager炫酷切换效果\nHeaderViewPager ★341 - 具有共同头部的 ViewPager\nYViewPagerDemo ★247 - 水平竖直方向上滑动\nViewPagerAnimator ★240 - ViewPager动画库\nExpandableViewpager ★232 - 可展开缩小的Viewpager\nPianoView ★230 - 有趣的类似钢琴键盘的 ViewPager Indicator\nGalleryLayoutManager ★151 - Android中Gallery或ViewPager控件的效果\nJPagerSlidingTabStrip ★90 - 修改自astuetz/PagerSlidingTabStrip的tablayout\nInkeVerticalViewPagerLive ★83 - 仿映客上下滑动切换直播demo\nParallaxViewPager ★63 - 带视差效果的简单ViewPager\nArcPageIndicator ★40 - 全自定义超简单的页面指示器\n\n图表(Chart)\n\nMPAndroidChart ★16070 - 安卓图表解决方案\nhellocharts-android ★4332 - Android图表库\nWilliamChart ★3145 - 在应用程序中实现图表的Android库\nGraphView ★1630 - 通过编程创建灵活好看的图表\nJgraph ★1063 - 可自定义图表\nAndroidCharts ★935 - 一个简单的Android图表库\nandroid-DecoView-charting ★780 - 实现高度可配置动画环形图表\nspark ★651 - 将任何规模xy点绘制为sparkline图表\nSuitLines ★650 - 小巧且高效的线性图表组件\nRadarChartView ★419 - 渲染径向图的Android视图\nCharter ★198 - 简易图表\nRadarChart ★195 - 自由定制旋转交互的Android雷达图\nAndroidChart ★157 - 简单的安卓分时行情页\ncandybar-library ★107 - Android图表包装材料面板\nSlimChart ★80 - 轻量级便于使用的图表库\nBarChart-master ★26 - 自动伸缩的chart\nPianoChartView ★21 - 显示钢琴和弦比例尺图\n\n菜单(Menu)\n\nAwesomeMenu ★5086 - 与Path的故事菜单具有相同外观的菜单\nContext-Menu.Android ★2965 - 独特的动画内容菜单\nDropDownMenu ★2010 - 多条件筛选菜单\nFlyoutMenus ★821 - Android简易MD风格弹出菜单\nTapBarMenu ★803 - Tap Bar菜单布局\nCircleMenu ★723 - 具有设计感的菜单\nSpinMenu ★656 - 轮播样式的Fragment菜单选择空间\nDropDownMenu ★632 - 完整的筛选器解决方案\nBlurredGridMenu ★470 - 酷炫网格菜单\nThumbnailMenu ★422 - 简单而精致的Fragment菜单控件\nTopRightMenu ★349 - 仿手机QQ界面右上角的弹出菜单\nCycleMenu ★251 - 圆形菜单\nCircleProgressMenu ★108 - 带有进度效果的简单环形菜单\nPopupMenuView ★67 - iOS中弹框气泡菜单的控件\nInfinityMenu ★66 - 实现手风琴样式菜单的Android库\nFloatingMusicMenu ★57 - 用于音乐播放器的悬浮菜单按钮\nCircleMenuView ★44 - 自定义圆形菜单\nSlidMenu ★29 - 轮盘样式的Fragment菜单选择控件\nSectorMenu ★18 - 炫酷的扇形菜单\n\n浮动菜单\n\nBoomMenu ★3617 - 具有炸裂效果的菜单按钮\nCircularFloatingActionMenu ★1995 - 自定义圆形浮动动画菜单\nTapBarMenu ★803 - Tap Bar菜单布局\nCircleMenu ★649 - 简单的优雅的菜单\nExpandableSelector ★578 - 动画的折叠或展开按钮列表\nRelativePopupWindow ★554 - 轻松对锚视图相对定位\nMultiChoicesCircleButton ★312 - 带3d视差效果的多选按钮\nSpringFloatingActionMenu ★282 - 点击FAB弹出菜单\nFloatMenuSample ★264 - android 悬浮窗菜单\nfloatingMenu ★196 - 一个像orbit的action button\nSmartMenu ★179 - 一个优美的浮动菜单\nWeiboPopupMenu ★20 - 仿微博添加按钮弹出菜单\n\n对话框\n\nMaterial Dialogs ★9911 - 安卓Material风格对话框\ndialogplus ★3217 - 对话框动画\nNiftyDialogEffects ★2054 - Nifty模式对话框效果\nandroid-adDialog ★1734 - 简单强大的广告活动弹窗控件\nBlurDialogFragment ★1539 - 背景模糊效果的DialogFragment\nAndroid-AlertView ★879 - 仿iOS的AlertViewController\nMaryPopup ★817 - 无忧扩展视图\nMaterialStyledDialogs ★804 - 显示优美可定制的Android对话框\nBottomDialog ★756 - 底部弹窗布局\nSwipeAwayDialog ★703 - 实现滑动取消对话框\nLovelyDialog ★646 - 帮助你轻松的创建流行的MD风格对话框\nEasyDialog ★549 - Android轻量级提示对话框\nDialogUtil ★401 - 任意界面弹出框\nfancyDialog ★310 - Android自定义提示框\nNormalSelectDialog ★237 - 常见布局封装\nHintPopupWindow ★222 - 仿qq弹出方式\nIndicatorDialog ★211 - 使用箭头指示器和不同位置的对话框\nBottomDialogDemo ★206 - 使用 DialogFragment 实现底部弹窗布局\nPlaceSearchDialog ★161 - 位置自动搜索对话框\njjdxm_dialogui ★122 - 多种弹出框样式\nLemonHello4Android ★93 - 内置多种主题提示框\nAndroid-PromptDialog ★79 - 正在加载中确认对话框轻量View\npanter-dialog ★71 - 丰富样式的Android对话框\nflickabledialog ★52 - 通过轻滑实现取消效果\nWheelDialogFragment ★17 - 用于时间选择城市选择的对话框\nBottomSheetPopupDialog ★8 - 底部弹出框\n\n空白页\n\nprogress-activity ★793 - 进度条空视图及错误视图库\nMultiStateView ★779 - 基于状态显示不同内容的Android视图\nStatefulLayout ★610 - 显示最常见的状态模板\nMultipleStatusView ★604 - 支持多种状态的自定义View\nStatusView ★574 - Android自定义状态视图\nErrorView ★521 - 显示错误信息的自定义视图\nLoadingLayoutDemo ★510 - 加载中/无网络/无数据/出错四种情况效果封装\nTEmptyView ★428 - 更简单地设置EmptyView\nstateLayout ★359 - 快速switch布局\nloadinglayout ★321 - 简单实用的页面多状态布局\nFlowLayout ★219 - 非常常见的安卓视图流\nLoadDataLayout ★186 - 加载数据Layout\nMultiStateView ★179 - 用于切换不同View的各种状态\nProgressLayout ★98 - 展示加载布局空白布局和error布局\nPageStateManager ★89 - 页面状态管理\nHHEmptyView ★35 - 网络加载提示进度封装View\nDataLoadingLayoutAndroid ★15 - 展示当前数据加载状态的库\n\n滑动删除\n\nAndroidSwipeLayout ★8066 - 安卓滑动出现子菜单\nSwipeRecyclerView ★1742 - RecyclerView侧滑菜单\nSwipeable-Cards ★1375 - 提供类似Tinder卡片效果\nRecyclerViewUndoSwipe ★1276 - 本地ItemTouch助手\nSwipeStack ★1142 - 安卓纸质视图栈\nSwipeDelMenuLayout ★1033 - 仿IOS侧滑Item删除菜单\nitemtouchhelper-extension ★814 - 添加滑动条目处理\nSwipeMenu ★662 - 滑动菜单\nAndroidSwipeableCardStack ★563 - 流畅的纸质卡片组件\nSwipeRevealLayout ★517 - 通过swipe及slide显示另一个布局\nQQTipsView ★482 - 仿QQ消息未读拖拽清除\nSwipeCardsView ★370 - Android高仿秒拍热榜的卡片滑动和左右飞出效果\nSwipeCardRecyclerView ★238 - 炫酷滑动卡片\nCardSwipeLayout ★199 - RecyclerView卡片滑动布局\nSlideLayout ★182 - 全方向完美滑动处理侧滑控件\naccordion-swipe-layout ★71 - Android手风琴滑动布局\n\n手势操作\n\nsensey ★1953 - 手势交互Android库\nGestureViews ★1243 - 手势控制和位置动画\nInboxLayout ★648 - 仿谷歌下拉返回效果\nSwipper ★47 - 控制亮度的自定义视图\n\nRecyclerView\n\nBaseRecyclerViewAdapterHelper ★7640 - 强大灵活的RecyclerAdapter\nrecyclerview-animators ★6236 - 轻松创建动画RecyclerView\nUltimateRecyclerView ★5544 - 功能强大的Recyclerview\nvlayout ★4665 - 布局方案和布局间的组件复用\nandroid-advancedrecyclerview ★3304 - 提供高级特性的RecyclerView扩展\nXRecyclerView ★2972 - 下拉刷新和加载更多\nepoxy ★2896 - Airbnb安卓视图架构\nbaseAdapter ★2685 - Android 万能的Adapter\nDiscreteScrollView ★2494 - 基于RecyclerView的滚动列表实现\nSuperRecyclerView ★2463 - 轻松制作可使用的RecyclerView\nRecyclerViewPager ★2372 - 基于RecyclerView的ViewPager替代品\nMultiType ★1998 - 快速清晰的开发复杂列表页面\nSwipeRecyclerView ★1742 - RecyclerView侧滑菜单\nFastAdapter ★1612 - 简化RecyclerView配置过程\nEasyRecyclerView ★1476 - 常用的RecyclerView的各种需求封装\nandroid-parallax-recyclerview ★1460 - Android 视差 RecycleView\nRecyclerViewCardGallery ★1443 - RecyclerView实现Card Gallery效果\nLRecyclerView ★1366 - 多功能RecyclerView\nexcelPanel ★1305 - 仿Excel表格的RecyclerView\nRecyclerViewUndoSwipe ★1276 - 本地ItemTouch助手\nShimmerRecyclerView ★1175 - 展现视图加载中的视图\noverscroll-decor ★1100 - Android的仿iOS滚动效果\nRecyclerViewHeader ★1094 - 为安卓RecyclerView创建header\ndrag-select-recyclerview ★1036 - 实现GooglePhoto样式多选择\nRenderers ★1036 - 创建适配器的Android库\nPullLoadMoreRecyclerView ★962 - 上拉刷新加载\nRecyclerViewFastScroller ★887 - 连接到RecyclerView实现快速滚动\nIndexRecyclerView ★869 - 使用Recyclerview实现的联系人列表\nSimpleRecyclerView ★859 - 轻松创建列表的RecyclerView扩展\ngroupie ★848 - 显示并管理复杂的RecyclerView布局\nStickyHeaders ★784 - 安卓RecyclerView的适配器和布局管理器\nRecyclerViewEnhanced ★774 - 条目滑动点击安卓库\nWaveSideBar ★750 - 快速跳跃分组的侧边栏控件\nRecyclerView-FastScroll ★730 - 简单的FastScroller\nExpandableRecyclerview ★716 - ExpandableRecycler适配器\nAndroidRecyclerViewDemo ★632 - 安卓RecyclerView 示例\nDragRecyclerView ★573 - 在RecyclerView中拖拽的简单实现\nGraywater ★544 - 改进RecyclerView布局的库\nSectionedRecyclerView ★540 - 安卓RecyclerView 适配器\nRecyclerViewWithHeaderNewPractice ★537 - 结合HeaderView的RecyclerView新实现\nAnimRefreshRecyclerView ★534 - 下拉刷新和上拉加载更多的RecyclerView\nFastScroll ★532 - 类似列表视图的FastScroller\nandroid-data-binding-recyclerview ★489 - 配有Android数据绑定的RecyclerView\nBGAAdapter-Android ★454 - 通用的Adapter和ViewHolder\nCircleRecyclerView ★435 - 一个循环RecyclerView\nFamiliarRecyclerView ★357 - RecyclerView类库\nMultiTypeView ★316 - 复杂界面分多个模块开发\nClassifyView ★306 - 拖拽合并的RecyclerView\nSuspensionBar ★276 - Android轻松实现RecyclerView悬浮条\nRecyclerStickyHeaderView ★259 - RecyclerView的悬浮视图\nSwipeCardRecyclerView ★238 - 炫酷滑动卡片\nDragSelectRecyclerView ★227 - 简单的触摸监听类\nSmart-HeaderFooter-RecyclerView ★214 - 将Recyclerview添加HeaderView和FooterView\nAlphabetIndex-Fast-Scroll-RecyclerView ★180 - 强大的AlphabetIndex FastScroller\nRecyclerRefresh ★172 - 仿简书安卓端\nRecyclerTreeView ★167 - 安卓的TreeView实现\nPracticalRecyclerView ★156 - RecyclerView的一个封装\nARecyclerView ★112 - 一个库搞定recyclerview\nSpringRecyclerView ★90 - 具有弹簧效果的RecyclerView\nStickyItemDecoration ★83 - RecyclerView粘性头部\nInifiniteRecyclerView ★65 - 实现无尽加载列表\nSectioned-RecyclerView ★57 - 带header和item的RecyclerView的简单实现方式\nStickyRecyclerSettingView ★48 - 快速在Android上建立SettingActivity\nRecyclerAnimations ★47 - item滑动时的循环动画\nNoAdapter ★45 - 使用RecyclerView实现一个列表\nEasyHeaderFooterAdapter ★34 - 在RecyclerView中添加header或者footer\nRecyclerViewDivider ★29 - 为RecyclerView设置分频器\nSwipeCardsRecyclerView ★22 - 基于RecyclerView的Android组件\nGlideScrollRecyclerView ★21 - RecyclerView优先加载可见item\nRecyclerAdapter ★15 - 简化封装RecyclerView.Adapter\n\nCard\n\nfolding-cell-android ★2670 - 安卓FoldingCell\nViewPagerCards ★2297 - 视图页卡片\nRecyclerViewCardGallery ★1443 - RecyclerView实现Card Gallery效果\nSwipeable-Cards ★1375 - 提供类似Tinder卡片效果\nSwipeStack ★1142 - 安卓纸质视图栈\nSwipeCardView ★1027 - 基于Diolor的Swipecards控件改进实现\nCardStackView ★962 - 以三种动画效果像卡片一样展示内容\nNineGridView ★886 - 展示图片的九宫格控件\nAndroid-InfiniteCards ★669 - 可自定义动效的卡片切换视图\nSlidingCard ★623 - 画廊效果的幻灯片卡片\nGiftCard ★580 - Android漂亮的礼物卡片\nAndroidSwipeableCardStack ★563 - 流畅的纸质卡片组件\nTinderStack ★536 - 一叠类似Tinder的卡片\nSwipeCardsView ★370 - Android高仿秒拍热榜的卡片滑动和左右飞出效果\nCardView ★220 - 类似小票效果的卡片列表\nCardSwipeLayout ★199 - RecyclerView卡片滑动布局\nStackCardsView ★50 - 堆叠滑动控件\nturncardlistview ★33 - 上下翻页的卡片列表\nSwipeCardsRecyclerView ★22 - 基于RecyclerView的Android组件\n\nColor\n\nInstagramLikeColorTransitionAndroid ★367 - 创建类似渐变颜色过渡的Instagram\nColorPickerView ★290 - 从图片中获取颜色\nMaterialDesignColor ★281 - 谷歌官方MaterialDesign颜色代码\ncolorpreference ★209 - 建立优秀的颜色选择器\nDrawableColorChange ★85 - drawable颜色修改工具\nColorPicker ★79 - android取色器\nMaterialDesignColors ★55 - 提供MD风格的Android库\n\nDrawable\n\nDividerDrawable ★376 - 在存在的View上布局和画分割线\nOneDrawable ★215 - 为View设置具有按下效果的背景\nSelectorDrawable ★26 - 为按钮设置selector\n\nSpinner\n\nnice-spinner ★1015 - Android spinner的重新实现\nBetterSpinner ★544 - 好用的Spinner\nMemorySpinner ★129 - 可以记住历史选项的spinner\n\n布局\n\nflexbox-layout ★8115 - Android盒式布局功能库\nAndroidAutoLayout ★5164 - Android屏幕适配方案\nvlayout ★4665 - 布局方案和布局间的组件复用\nFlowLayout ★2390 - Android流式布局\nDiagonalLayout ★1860 - MD风格的新的样式和方法\nFanLayoutManager ★1477 - 扇形水平列表视图\nsmooth-app-bar-layout ★1434 - 视图布局\nFlexLayout ★1377 - 强大的Android布局视图\nFlowLayoutManager ★1152 - 利用自定义LayoutManager 的一些实战实例\nTextLayoutBuilder ★1124 - Facebook出品的在Android中轻松实现文字布局\nExpandableLayout ★1041 - 带有各种动画的扩展布局\nFlowLayout ★952 - 让子视图自动浮动到下一行\nArcLayout ★864 - 使用ArcLayout探索新的MD风格的样式和方法\nExpandableLayout ★818 - 实现动画扩展和子视图折叠\nFlowTag ★579 - Android流式布局\nExpandableLayout ★414 - 节省空间的可扩展布局\nHiveLayoutManager ★373 - 蜂巢布局管理器\nThreeDLayout ★366 - 让任何view拥有3D效果\nILayoutAnimationController ★256 - 一行代码搞定布局动画\nStickyNavLayout ★254 - 悬浮控件\nLiveLayout ★227 - 关于直播布局与礼物特效的Demo\nRippleLayout ★208 - 实现波纹效果的布局\nAssembleEssay ★75 - 自定义LayoutManager实现流动布局\nFlowLayoutDemo ★23 - 自定义View实现流式布局\nLikeELMLeftLoad ★17 - 仿饿了么左滑跳转\n\n模糊效果\n\nAndroid StackBlur ★2784 - 图片模糊效果\nBlurry ★2624 - Android简易模糊库\nblurkit-android ★1992 - 类似iOS上的实时模糊效果\n500px-android-blur ★1966 - Android模糊视图\nBlurView ★1652 - Android底层视图动态仿iOS模糊\nImageBlurring ★1104 - 通过 Java 与 JNI 分别进行图片模糊\nRealtimeBlurView ★938 - 仿UIVisualEffectView实时模糊覆盖\nBlurredView ★857 - Android图片视图动态模糊\nBlurLockView ★857 - 毛玻璃效果的解锁界面\nDali ★787 - Android图像模糊库\nRxBlur ★519 - 毛玻璃（高斯模糊）效果\nEtsyBlur ★514 - 在Etsy应用添加仿玻璃模糊效果\nGaussianBlur ★306 - 对图片应用高斯模糊\nCrazyShadow ★226 - 为 View 添加阴影效果\n\nTabBar\n\nSpaceTabLayout ★1002 - RelativeLayout的自定义实现方式\nRecyclerTabLayout ★883 - 高效TabLayout库\nZuiMeiTAG ★242 - 仿最美应用的底栏\nAlphaIndicatorView ★218 - 仿微信底部tab标签\n\nAppBar\n\nsmooth-app-bar-layout ★1434 - 视图布局\nappbarlayout-spring-behavior ★756 - 实现滚动弹簧效果\nTestAppBar ★272 - AppBar动画效果\nsimple-view-behavior ★255 - 简单视图行为\n\n选择器(Picker)\n\nAndroid-PickerView ★4321 - 精仿iOS的PickerView控件\nandroid-betterpickers ★2488 - 选择器DialogFragments库\nAndroidPicker ★2207 - 安卓选择器类库\nSublimePicker ★1795 - 提供选择器的自定义视图\nAndroid-FilePicker ★1103 - 灵活选择图片和视频的文件选择器\nTimePickerDialog ★1031 - Android时间选择器\nCityPicker ★955 - 仿美团等选择城市列表demo\nBottomSheetPickers ★843 - ndroid的新的数据和时间选择器库\nPickView ★814 - 选择日期或者省份的辅助库\nMultiType-FilePicker ★769 - 轻量级Android文件选择库\nNumberPickerView ★652 - 灵活的安卓NumberPicker组件\nandroid-spinnerwheel ★627 - 安卓轮式旋转部件\nCharacterPickerView ★626 - 仿iOS的PickerView控件\nCarouselPicker ★475 - 轮播图选择器\nandroid-pickers ★303 - 安卓选择器类库\nHorizontalPicker ★300 - 支持文本和图标的水平选择器\nSingleDateAndTimePicker ★294 - 在一个部件内选择一个数据和一个时间\nTwo-Step-Picker-Dialog ★241 - 两步选择器对话框\nEasyPickerView ★194 - Android轻量级PickerView\nLFilePicker ★178 - 轻量级的文件选择器\nSimpleNumberPicker ★157 - 十进制和十六进制选择器视图\nHorizontalPicker ★131 - 一个简单的自定义的和容易使用的的picker\nAwesomeImagePicker ★123 - 使用精致的接口选择images和gifs\nPickTime ★118 - 日期选择控件\nPickImage ★95 - 带有Camera和Gallery选项的DialogFragment\nClickNumberPicker ★79 - 从给定范围内使用点击按钮或者触摸选定一个值\nAndroid-PickerView-Library ★78 - 高仿 IOS PickerView 控件的库\nJDSelector ★75 - 仿京东的地址多级选择器\nNumberPicker ★41 - Android数字选择器视图\nCityPickerWebView ★38 - JS实现的省市县三级联动\nPhotoPicker ★24 - Android 照片选择器\nCityPicker ★20 - 一个仿大众点评的城市快速选择器\n\n跑马灯\n\nMarqueeView ★1635 - 垂直翻页公告\nMarqueeViewDemo ★951 - 跑马灯View\nMarqueeLayoutLibrary ★395 - 支持四个方向循环滚动的自定义控件\nnoticeview ★257 - 滚动播放的公告控件\nVerticalBannerView ★211 - 安卓自定义控件\nAdvancedTextSwitcher ★199 - 卡片上滚动显示最新评论\nVerticalMarqueeView ★13 - 新闻向上不断滚动跑马灯效果\n\n日历时间\n\nandroid-times-square ★3764 - 从日历视图选择一个单独日期\nmaterial-calendarview ★2944 - MD风格的日历视图\nMaterialDateTimePicker ★2540 - MD风格日期时间选择器\nAndroid-Week-View ★2390 - 在Android应用中显示日历\nCountdownView ★1327 - 安卓倒计时控件\nCaldroid ★1289 - 以月为单位的日历控件\nTimePickerDialog ★1031 - Android时间选择器\nCompactCalendarView ★967 - 简单的日历视图\nAgendaCalendarView ★944 - 仿Outloo和Google日历\nMaterialDateRangePicker ★860 - 日期选择控件库\nBottomSheetPickers ★843 - ndroid的新的数据和时间选择器库\nCalendarListView ★766 - 可互动的ListView+CalendarView\nWeekCalendar ★564 - 提供星期日历的库\nHorizontalCalendar ★527 - MD风格的水平日历视图\nCalendarExaple ★503 - 高仿钉钉和小米的日历控件\nEasyCalendar ★379 - 快捷自定义日历UI\nandroid-calendar-view ★332 - 易扩展的andorid日历控件库\nCadar ★314 - 可以显示事件的日历视图\nTimerView ★314 - 解耦良好的计时控件\nSingleDateAndTimePicker ★294 - 在一个部件内选择一个数据和一个时间\nCalendarView ★211 - 高度定制的日期选择器\nMiClockView ★194 - 高仿小米时钟\nMaterialCalendar ★171 - 一个MD风格的日历\nGregorianLunarCalendar ★160 - 农历+公历的日期选择模式\nCalendarView ★130 - 简单的自定义日历视图\nCalendarView ★117 - 优雅且性能高效的日历控件\nGAHonorClock ★117 - 时钟动画\nMNCalendar ★100 - 一个简单的日历控件\nAndroid-SwitchDateTimePicker ★97 - 日期时间选择器库\nweek-month-Calendar ★75 - 周月切换的日历\nRetainedDateTimePickers ★68 - 在手机方向改变时保持日期时间选择器\nWeekViewSwipeable ★62 - 以周格式显示数据的Android视图\nDateRangePicker ★50 - 带数据选择器的Dialogo fragment\nTimelyView ★42 - 时间动画视图\nNubiaTimer ★36 - 高仿Nubia 定时器的自定义view\nAndroid-CalendarView-master ★30 - Android自定义日历日期选择控件\n\n主题样式\n\nMagicaSakura ★1931 - Android多主题库\nAndroid-skin-support ★1619 - 用心的Android 换肤框架\nColorful ★1523 - 轻松改变app的配色方案\naesthetic ★994 - 一个快速容易的即插即用的动态主题引擎\nScoops ★686 - 动态改变应用主题\nThemeDemo ★386 - 日夜间模式切换\nThemeSkinning ★273 - Android 主题换肤的开源库\nBlackbulb ★158 - MD风格的夜间屏幕Android 应用\nAndroidSkinAnimator ★150 - 仿网易云音乐换肤框架\nChangeMode ★69 - Android动态切换夜间模式的实现库\nQSkinLoader ★37 - QSkinLoader换肤框架\n\nImageView\n\nRoundedImageView ★3976 - 支持圆角的快速ImageView。\nsubsampling-scale-image-view ★2964 - 安卓自定义图片视图\nPanoramaImageView ★1526 - 可以随设备旋转自动滚动的imageView\nCustomShapeImageView ★1412 - 自定义使用SVG和填充图的ImageView\nFrescoImageViewer ★1159 - 简单的自定义全屏图片视图\nLargeImage ★1067 - Android加载大图\nShadowImageView ★965 - 更加细腻的阴影效果\nCrescento ★902 - 图像视图和相关布局的下面添加曲线\nCircularImageView ★895 - 以简单的方法实现环形ImageView\nNineGridImageView ★876 - 仿微信朋友圈或微博的九宫格图片\nDragPhotoView ★871 - 高仿微信可拖拽返回PhotoView\nImageTransition ★561 - Activity视图过渡\nCaptchaImageView ★504 - 生成验证码图片的自定义ImageView\nandroid-combination-avatar ★503 - 模仿QQ讨论组组合头像\nOblique ★414 - 探索新的显示图片样式\nPaletteImageView ★404 - 动态提取图片的主要颜色\nScrollParallaxImageView ★402 - 滚动视差效果\nFrisson ★320 - 在图片上提供时髦的剪裁\nDiagonalify ★283 - 创建图像视图的对角线切割\navatar-view ★208 - 带有用户名字的第一个字母的图片视图\nAnchorImageView ★197 - Android锚点定位ImageView\nCircleImageView ★167 - 环形ImageView\nWiv ★160 - 窗口图片显示器\nIdentityImageView ★135 - 带进度条的图片框架\nSImageView ★121 - 设置一个网址即可显示图片的控件\nLQRNineGridImageView ★51 - 仿微信群头像九宫格控件\nCoolImageView ★51 - 可以上下移动的imageView\nBlaze ★41 - 提供移动图像和缩放图像的视图\nHDImageView ★34 - 加载高清大图支持缩放的控件\nGridImageView ★21 - 根据图片数量自动适配加载\nRoundImageView ★13 - Android自定义圆角图片\n\n通知\n\nAlerter ★2816 - 克服Toast和Snackbar的限制\nNotifyUtil ★947 - 高仿淘宝微信等热门APP通知视图\nPugnotification ★691 - 通过一行代码实现通知功能\nNotifyUtil ★140 - notification工具类\nCarousel-Notification ★78 - 轮播框通知\nNotificationUtil ★44 - 全新的Android通知栏\n\n聊天视图\n\naurora-imui ★1703 - 通用的即时通讯UI 库\nChatKit ★1032 - 简化UI开发\nChatMessageView ★559 - 快速创建聊天信息视图\nChatMessageView ★268 - Android聊天UI视图\nChatDemo ★129 - 实现聊天界面\n\nHeader\n\nStickyHeaderListView ★1899 - 基于实际需求做出的灵活可定制的UI功能\nZoomHeader ★1797 - 模仿饿了么详情页的例子\nAndroid-ParallaxHeaderViewPager ★1307 - 带标题头的左右滑动\nStickyHeaders ★784 - 安卓RecyclerView的适配器和布局管理器\nRecyclerViewWithHeaderNewPractice ★537 - 结合HeaderView的RecyclerView新实现\nStickyNavLayout ★254 - 悬浮控件\nSmart-HeaderFooter-RecyclerView ★214 - 将Recyclerview添加HeaderView和FooterView\n\n引导图(Intro)\n\nAppIntro ★6281 - 制作一个很酷的app介绍页\nShowcaseView ★4788 - 向用户突出app的特定部分\nWoWoViewPager ★1949 - 优化App介绍/引导页面\nmaterial-intro-screen ★1882 - MD风格的介绍页面\nGuideView ★1724 - 创建遮罩式导航页\nOnboarding ★1402 - 以一种漂亮的方式向用户介绍应用\npaper-onboarding-android ★1340 - MD风格的onboarding\nMaterialIntroTutorial ★769 - MD风格介绍导航\nFancyShowCaseView ★740 - 易于使用的自定义显示案例视图\nahoy-onboarding ★528 - 可自定义背景的引导页面\nHighLightGuideView ★359 - 用于 app 新功能高亮引导的库\nMaterial-ViewPagerIndicator ★338 - 超级简单的页面指示器\nVertical-Intro ★243 - 在你的应用程序中整合material vertical\nUserGuideView ★205 - 用户指引view\nMaterial-Onboarding ★182 - 轻松实现引导图\nStepDialog ★125 - ofo应用首次注册时的步骤控件\nSlidingIntoView ★64 - 简单的滑动介绍视图\n\n图片\n\nglide ★15851 - 媒体管理和图片加载框架\nAndroid-Universal-Image-Loader ★15309 - 异步图像加载程序\npicasso ★13542 - 安卓图片缓存库\nfresco ★12823 - 在Android应用中显示图片\nPhotoView ★10275 - 简单可用的放大安卓ImageView实现\nCircleImageView ★7172 - 圆形介绍头像\nuCrop ★5243 - 极限且灵活的图像裁剪体验\nglide-transformations ★3803 - 图像转换类库\nandroid-crop ★3602 - 简单的图片裁剪功能的Android库项目\nMatisse ★3015 - Android本地图像选择器\nTakePhoto ★2896 - Android设备上获取裁剪压缩图片\nAndroid-Image-Cropper ★2362 - Android图片裁剪库\nMultiImageSelector ★2325 - 仿微信实现多图选择\nPhotoPicker ★1905 - 仿Wechat图片选择器\nboxing ★1772 - 基于MVP模式的Android多媒体选择器\nKenBurnsView ★1761 - 身临其境的动画拖拽\nImagePicker ★1696 - Android仿微信UI自定义相册\nBigImageViewer ★1664 - 支持平移和缩放的大图像缩放器\nscissors ★1650 - Android图片裁剪库\nAndroidPhotoFilters ★1644 - 快速强大灵活的图片处理器\nSimpleCropView ★1640 - Android图片裁剪库\nPictureSelector ★1537 - 多图选择上传\nImageViewZoom ★1489 - 支持超大图片流畅缩放\ncropiwa ★1363 - 实现图片剪裁的多配置部件\nTiny ★1307 - 图像压缩框架\nPhotoView ★1296 - 图片浏览缩放控件\nRxGalleryFinal ★1115 - android图片/视频文件选择器\nBlurImageView ★1086 - 逐步加载图像\nTransferImage ★1051 - 仿qq 点击缩略图后预览高清图\nTelegramGallery ★1044 - 快速高效低耗相册选择器\nandroid-square-progressbar ★976 - 围绕图片的进度条\nEasyImage ★912 - 从gallery，相机或者文件中获取图片\nPinchImageView ★906 - 安卓图片手势控件\nNineGridView ★886 - 展示图片的九宫格控件\nAdvancedLuban ★861 - 方便简约的 Android 图片压缩工具库\nalbum ★857 - Android轻量级相册\nPhotoEditDemo ★828 - 图片处理sdk\nSimpleTagImageView ★822 - 安卓中带有标签的ImageView\nBGAPhotoPicker-Android ★771 - Android图片选择\nStyleImageView ★724 - 图片相关视图的风格添加及亮度对比度设置\nImageEditor-Android ★688 - 编辑图片\nImagePicker ★687 - 图片选择控件\nimage-chooser-library ★660 - 以很少的代码捕获图片/视频\nZoomy ★648 - 缩放Android库\nCropImageView ★588 - 支持不同类型裁剪的ImageView\nImageGallery ★555 - 用于放置图像数组的gallery\nImageSelector ★554 - Android图片选择器\nDragScaleCircleView ★485 - 能够拖拽和缩放及裁剪图片的环形窗口\nwqgallery ★387 - 微信样式相册选择器\nAvatarImageView ★376 - 电话本联系人头像\nRapidInterpolator ★371 - 动态调整interpolator的Java库\nLouvre ★361 - 自定义图片选择器\nMediaPickerInstagram ★344 - 仿Instagram的MediaPicker\nIPicker ★304 - Material Design 风格的图片选择器\nRxPicker ★296 - 基于RxJava的Android图片选择器.\nInstaCropper ★294 - 仿Instagram图片裁剪\nPickPhotoSample ★277 - 帮助你选择图片的库\nFishBun ★273 - Android图片选择器\nAndroid-BitherCompress ★272 - Android图片压缩目前最优解决方案\nXLowPoly ★242 - low poly图片的安卓实现\nAlbumSelector ★222 - 图片选择库\nimagepickerdemo ★216 - 图片选择器\nHotImg ★211 - 图片不规则区域点击事件处理\nGalleryPick ★207 - Android 自定义相册\nJigsawDemo ★206 - Android的拼图Demo\nPullDownView ★198 - 下拉展示大图\ncollageview ★181 - 创建简单照片拼贴\nFrescoUtils ★147 - 图片处理\ncroperino ★146 - 简单的图像裁剪工具\nImageCropper ★143 - 图片裁剪库\nFrescoImageView ★141 - Android平台的图像控件\nMutiPhotoChoser ★139 - 支持多选的图片选择器\nandroid-image-picker ★112 - 选择图像的简单的库\nImageLoaderUtil ★96 - ImageLoaderUtil实现的图集功能\nImageLoader ★90 - 基于Glide的二次封装\nSnappyImageViewer ★80 - 安卓图片视图\nlitho-picasso ★79 - 仿Picasso的图片组件兼容\nImageLoader ★74 - 图片加载框架的api封装\nPicCrop ★68 - 对ucrop的封装工具类\nImageZoom ★52 - 仿Instagram的视图缩放功能\nImagePickerWithCrop ★51 - 指定选择图片的库\nMultimager ★49 - 多图片选择器和多图片捕获\nImageFrame ★48 - 高效省内存的播放序列帧控件\nLQRImagePicker ★42 - 完全仿微信的图片选择\nIKNinePhotoView ★42 - 开源的Android九宫格控件\nImageSelector ★33 - 支持多图选择和图片预览的图片选择器\nPictureSelectorLight ★26 - 多图选择器\nKrGallery ★26 - 图片处理库\nAlxPicassoProgress ★26 - 图片下载进度实时显示\nImageEditor ★16 - 仿QQ图片编辑器\n\n徽章(Badge)\n\nBGABadgeView-Android ★1680 - Android 徽章控件\nBadgeView ★1375 - 自由定制的BadgeView\nAndroid-ActionItemBadge ★1094 - 为ActionItem添加标识\nMaterialBadgeTextView ★891 - 展示新的信息标识和新的特色标识\nBadger ★722 - 添加徽章\nBadge ★640 - 一系列徽章图片\nBadgeView ★473 - 基于Android的BadeView\nbadgebutton ★347 - 带有徽标(数字，小红点)的按钮\nNotificationBadge ★84 - 带有动画的通知标记\nBadgeRadioButton ★25 - 仿QQ底部Tab切换RadioButton\nSuperBadge ★19 - 消息红点计数解决方案\n\nRatingView\n\nMaterialRatingBar ★830 - 性能更好的MD风格的RatingBar\nSimpleRatingBar ★639 - 简单但功能强大的RatingBar\nSmileyRating ★638 - Android简单的评级栏\nSpiderWebScoreView ★574 - 蛛网评分控件\nSimpleRatingBar ★370 - 一个简单的自定义动画的评分组件\nSimpleRatingView ★167 - Android的评价切换\nAndroidCustomView ★127 - 简单的投票排名对比图\nrating-request ★24 - 简单的Android对话框\n\n滚动效果(Scroll)\n\nAndroid-ObservableScrollView ★7579 - 观察滚动事件和滚动视图的Android库\nAndroidScrollingImageView ★1208 - 安卓视差动画效果\nScrollable ★892 - 封装实现滚动条的滚动逻辑\nmaterial-scrolling ★580 - MD风格的滚动效果安卓库\nMaterialScrollBar ★568 - 为MD5.1之前的版本带来MD5.1的滚动条\nScrollLayout ★215 - 场景抽屉拖拽效果\nHVScrollView ★46 - 配置水平和垂直滚动的HVScrollView\n\n时间轴\n\nTimeline-View ★1220 - 时间线视图库\nTimelineView ★888 - 在应用程序添加时间轴的安卓视图\nTimelineView ★409 - Android自定义时间线视图\nUnderLineLinearLayout ★276 - 一个简单的时间轴实现\nTimeLine ★254 - 安卓时间轴\n\nTreeView\n\nAndroidTreeView ★1692 - 安卓的目录视图\nRecyclerTreeView ★167 - 安卓的TreeView实现\nTreeView ★102 - 树形结构组件\n\nSearchView\n\nMaterialSearchView ★2230 - 以MD风格实现SearchView\nfloatingsearchview ★2074 - 带有搜索建议的浮动搜索栏\nJJSearchViewAnim ★1968 - 炫酷的SearchView搜索动画库\nSearchView ★1535 - 类似Play Store的SearchView\nFloatingSearchView ★1215 - 浮动的搜索视图实现\nMaterialSearchBar ★1014 - 安卓MD风格搜索栏\nSearch-View-Layout ★891 - Lollipop+ Dialer和Google Maps的实现\nMaterialSearchView ★731 - 基于MD风格的Android搜索视图\nMaterial-SearchTransition ★324 - 展示如何过渡到搜索的示例项目\nQueryHighlighter ★254 - 在文本中突出搜索字词\nsearch-dialog ★188 - 快速和自定义的搜索对话框\nsearchablespinner ★97 - 搜索器\nMsvSearch ★94 - Material Design风格搜索视图\nSearchDialog ★89 - 仿bilibili搜索框效果\nLSearchView ★30 - Android L设计搜索视图\n\nTagView\n\nChipsLayoutManager ★1716 - 自定义RecyclerView布局管理器\nFlowLayout ★952 - 让子视图自动浮动到下一行\nSimpleTagImageView ★822 - 安卓中带有标签的ImageView\nAndroidTagView ★798 - Android TagView库\nmaterialChipView ★684 - MD风格的Chip视图\nAutoLabelUI ★591 - 将标签并排放置的Android库\nandroid-tagview ★580 - 云标签控件\nTriangleRectangleLabelView ★448 - 标签视图\nTagViewGroup ★434 - Android 仿小红书图片标签\nEasyTagDragView ★228 - 仿网易新闻app下拉标签选择菜单\nChannelTagView ★51 - 一个频道管理view\nFlowLayoutDemo ★23 - 自定义View实现流式布局\nLaybelLayout ★22 - 标签布局\n\nTextView\n\nHTextView ★3129 - 支持自定义字体的TextView动画效果\nandroid-autofittextview ★2785 - 自动改变文字大小完美适应边界\nticker ★2463 - 显示滚动文本\nExpandableTextView ★2298 - 展开/折叠TextView\nTextJustify-Android ★1490 - 文本处理库\nRichText ★1472 - Android富文本解析器\nSuperTextView ★1335 - 功能强大的TextView\nSlantedTextView ★1258 - 倾斜的TextView\nAndroid-TextView-LinkBuilder ★1165 - 创建可点击的链接\nTextLayoutBuilder ★1124 - Facebook出品的在Android中轻松实现文字布局\nReadMoreTextView ★1053 - 装饰文本的自定义TextView\nSuperTextView ★1000 - 提高构建项目的效率\nTokenAutoComplete ★999 - 安卓Gmail风格的MultiAutoCompleteTextView\nhtml-textview ★929 - 扩展的安卓TextView组件\nFadingTextView ★866 - 自动改变其内容的TextView\nRotatingText ★845 - 周期性文本更新库\nAutoLinkTextView ★835 - 自动检测并处理点击事件\nAndroid-RobotoTextView ★760 - TextView及其直接间接子类的实现\nAutoFitTextView ★674 - 自动适应字体和行计数的TextView\nBabushkaText ★659 - 通过Spannables设置文本样式\nFloatingText ★626 - 执行漂浮效果动画的控件\nTriangleLabelView ★587 - 显示三角视图\nandroid-justifiedtextview ★580 - 基于原生TextView实现合理的textview\nTrestle ★542 - 在TextView上桥接span\nandroid-chips ★531 - 基于Google的内部chip库的简易库\nExpandableTextView ★493 - 展开折叠TextView\nMarkdown ★485 - Android原生Markdown解析器\nhtml-builder ★435 - 为Android TextView建立有效的HTML\nAvatarLabelView ★424 - 可配置的迷你版轻量级 Label 辅助类\nSimpleText ★422 - 简化spannable字符串的创建\ndante ★419 - 文本解析器\ncornerlabelview ★396 - 视图角标\nNumberAnimTextView ★381 - 数字增加动画的 TextView\ntext-decorator ★367 - 轻松装饰TextView\nUnderLineLinkTextView ★327 - 使关键词带有可点击的下划线TextView\nXRichText ★279 - 显示Html富文本的TextView\nPinchZoomTextView ★272 - 用手势缩放字体大小\nBetter-Link-Movement-Method ★231 - 在TextView中处理RUL\nColorTextView ★214 - 用颜色标记一些短语\nFlexibleRichTextView ★200 - 自行定义大部分标签\nCompoundIconTextView ★183 - 带有icon的TextView\nGetWordTextView ★168 - 通过点击获得词语\nMoreTextView ★129 - TextView的“展开”和“收起”\nRandomTextView ★116 - 滚动显示TextView的数字\nTagEditText ★115 - 显示类似微博中的活动标签\nCharCountTextView ★114 - 仿Twitter剩余长度计数器\nRickText ★98 - 类似微博的编辑框\nnachos ★59 - 输入文本并创建MD风格的chip\nZaman ★54 - 将timestamp转化为时间String\nSpanEZ ★39 - 从Spannable API完成提取\nTextViewDrawable ★37 - 仿大众点评的购买须知\nRichTextView ★37 - 富文本textview\nTextViewSpanLink ★30 - TextView上展示超链接\nSpanBuilder ★19 - TextView可以生成的span样式\n\nEditText\n\nMaterialEditText ★4215 - MD风格的EditText\nAndroid Form EditText ★1234 - 为edittext带来数据有效性工具\nMaterialTextField ★1029 - 与众不同的漂亮的浮动可编辑文本框\nBufferTextInputLayout ★818 - 简单的TextImputLayout定制化服务\nBiuEditText ★600 - 一个有趣的EditText\nMentionEditText ★352 - 为提及的字符串添加一些有用的功能特色\nAndroidEdit ★334 - EditText的撤销和恢复撤销操作\nTyperEditText ★314 - 打字机效果\nAnFQNumEditText ★251 - 自定义EditText实现右下角计数控件\nAutoFillEmailEditText ★247 - 自动对EditText添加自定义email\nPowerfulViewLibrary ★155 - 输入框功能\nLineHeightEditText ★141 - 修复文本编辑行高和光标效果\nEditCard ★78 - 输入信用卡号码的自定义EditText\nFloatingEditText ★62 - TextInputLayout和TextInputEditText合并成一个类\nEasyMoney-Widgets ★32 - 支持货币显示的部件\nRichEditText ★24 - 仿微博富文本编辑框\nPhoneMask ★22 - 添加手机号可读性的EditText\nEditTextTools ★13 - 输入整数小数位数限制自动加逗号\n\nSliding\n\nAndroidSlidingUpPanel ★6303 - 通过向上拖动添加额外面板\nSlideUp-Android ★1263 - 对任何视图添加边侧效果\nDiscreteSlider ★542 - 让用户在指定的刻度线上选择一个值的滑块\nslideview ★485 - 简单独特的Android滑动按钮\nSlidingLayout ★384 - 安卓平台View控件\nSlidingBall ★199 - 仿QQ身边的人的效果\n\n表单\n\nandroid-saripaar ★2292 - 基于规则的AndroidUI输入验证库\nhover ★2025 - Android浮动菜单实现\nMaterialLogin ★1525 - MD风格的登录效果\nMaterialChipsInput ★1502 - MD风格chip组件的实现\nGridPasswordView ★1262 - Android密码视图\nAndroidKeyboardWatcher ★770 - Android可开闭输入键盘\nAwesomeValidation ★747 - 实现对Android的验证\nMaterialLogin ★695 - MD风格的登录注册视图\nmaterial-code-input ★668 - MD样式的编码输入\npasswordview ★666 - Android密码视图\nPasswordLoadingView ★537 - 当完成密码时显示一个动画\nOnePageSigninSignup ★447 - 单页面实现注册登录\nSwipeCaptcha ★403 - Android 平台的滑动验证码\ndata-binding-validator ★226 - 使验证字段变得简单而快速\nRatifier ★114 - Android表单验证库\nValidationUtilsLibrary ★92 - 实现表单验证\nAutoInputAuthCode ★41 - 自动填写验证码功能库\nsocial-login-helper ★33 - 将社交登录整合到应用中\n\n分段控件\n\nandroid-segmented-control ★1363 - Android自定义视图\nSHSegmentControl ★471 - 一个简单的SegmentControl部件\nsegmentedview ★31 - ios 风格的分段控件\nSegmentedControl ★16 - 分段选择控件\n\n轮播图\n\nAndroid-ConvenientBanner ★2733 - 通用的广告栏控件\nbanner ★2694 - Android广告图片轮播控件\nBGABanner-Android ★1773 - 引导界面滑动导航\nandroid-pile-layout ★1210 - 堆叠滑动控件\ncarouselview ★608 - Android轮播框库\nCarouselPicker ★475 - 轮播图选择器\nSuperIndicator ★397 - 首页推荐位轮播图\nXBanner ★358 - 自定义图片无限轮播的控件\nBannerLayout ★280 - 简洁实用的android广告栏\nbannerview ★200 - 横幅广告图片轮播控件\nMZBannerView ★193 - 仿魅族BannerView\nRecyclerViewBanner ★159 - 使用RecyclerView做的轮播图\nAndroidCarrouselLayout ★115 - 安卓轮播框布局\nBanner-Slider ★66 - 在Android应用中便于使用的精致滑块\nMaterialBanner ★58 - MD风格的banner\nFlare ★56 - 简单的循环指示器实现\nRecyclerBanner ★28 - 使用RecyclerView 实现的轮播图\nsimplebanner ★16 - 基于adapter的轮播图实现\n\n文件操作\n\nAndroid Upload Service ★1218 - 轻松实现后台上传文件\nAmazeFileManager ★1209 - 好用的文件管理源代码\nAndroid-FilePicker ★1103 - 灵活选择图片和视频的文件选择器\nMaterialFilePicker ★613 - MD风格文件选择器库\nThinDownloadManager ★603 - Android下载文件库\nNoNonsense-FilePicker ★539 - 文件选择器库\nAndroidPDF ★62 - PDF文件打开方法\nAndroid-FileBrowser-FilePicker ★27 - Android文件浏览器文件选择器\n\n启动页\n\nWelcome ★1300 - 安卓欢迎屏效果\nParticle ★1063 - 酷炫动画效果\nWowSplash ★731 - 铁塔融云闪屏页\nAwesomeSplash ★584 - 令人叫绝的可自定义的飞溅效果屏幕\nWelcomeVideoPager ★93 - Android酷炫欢迎页播放视频\n\nMD\n\nMaterialDesignLibrary ★8213 - Material Design 安卓库\nRippleEffect ★4235 - MD风格的点击涟漪效果实现\nmaterial-ripple ★1832 - Android视图的纹波效果封装\nCarbon ★1654 - Android的MD风格实现案例\nJFoenix ★1312 - 使用Java组件实现Google的MD风格\nMaterialShadows ★981 - 支持 convex material阴影库\nMaterialValues ★711 - 将Material Design指南中的所有值在资源中定义\nRippleDrawable ★498 - Android效果端口\nMaterialMasterDetail ★242 - 实现Master及Detail模式\nRippleLayout ★208 - 实现波纹效果的布局\nmaterial-element ★163 - MD风格动画示例APP\nMaterialTransitionAnimation ★102 - MD风格动画实践\n\nBottomNavigation\n\nBottomBar ★6349 - 自定义视图组件\nNavigationTabBar ★3088 - 带有色彩交互的导航标签栏\nahbottomnavigation ★2098 - 实现MD风格的按钮导航组件库\nBottomNavigation ★2047 - 从GooglePlay商店获取示例apk\nSpace-Navigation-View ★1305 - 仿GoogleSpaces的导航完全整合\nMaterial-BottomNavigation ★907 - 轻量级底部导航库组件\nLuseenBottomNavigation ★851 - 底部导航视图\nAdaptableBottomNavigation ★528 - 又一个Bottom Navigation实现\nAlphaTabsIndicator ★492 - 高仿微信底部状态栏的轻量级库\nBottomNavigationViewEx ★437 - 增强BottomNavigationView的安卓库\nJPTabBar ★412 - 安卓标签栏\nBottomNavigationBar ★257 - MD更新的BottomNavigationbar的开源实现\nBottomNavBar ★141 - 轻松添加四个选项卡的导航栏\nBottomTabView ★27 - 自定义实现主流底部 Tab 菜单 View\n\nToast\n\nToasty ★2703 - 通常的Toast\nSuperToasts ★2300 - 增强并创建立Android Toast库\nTastyToast ★1493 - 精致的原生安卓toast\nloadtoast ★1254 - Android可自定义toast\nStyleableToast ★1124 - 标准安卓Toast\nSneaker ★430 - 自定义alert的轻量级安卓库\nSweetTips ★59 - 快意灵动的提示库\nLovelyToast ★36 - 使你的Toast变得灵活而生动\n\nCreditCard\n\nCreditSesameRingView ★939 - 仿Ali芝麻信用新老环形界面\nCreditCardView ★717 - 支付系统信用卡和签账卡视图\nSwipeableCard ★592 - 仿StreetView磁卡实现\nCreditCardView ★590 - 仿真信用卡UI安卓库\nCreditCardEntry ★456 - 进行信用卡输入的表单\nandroid-sumbit-credit-card-flow ★415 - MD风格的信用卡格式实现\nEditCard ★78 - 输入信用卡号码的自定义EditText\nCardForm ★23 - Android信用卡借记卡互动表单\n\nActionSheet\n\nSlideBottomPanel ★687 - 实现知乎日报β版底部划出视图\nandroid-ActionSheet ★664 - 仿照iOS UIActionSheet组件\nTedBottomPicker ★596 - 简单的图片选择器\nBottomSheet ★508 - 安卓BottomSheet风格的对话框\nBottomSheets ★334 - BottomSheets控件的使用\nBottomDialogDemo ★206 - 使用 DialogFragment 实现底部弹窗布局\n\nWave\n\nWaveLoading ★1094 - 能够提供波浪动画的Drawable\nWaveView ★1010 - Android波浪视图\nWaveView ★957 - 显示波浪效果的视图\nMusicWave ★283 - 音乐的波纹\nWaveView ★108 - 有趣的水波纹效果的界面\nRippleLayout ★61 - 使用 drawBitmapMesh 实现仿真水波纹效果\nDxWaveRefresh ★34 - 波浪效果的下拉刷新\nDiffuseView ★30 - 自定义的圆形扩散View\nBitmapWaveView ★17 - 在bitmap中显示进度波浪\n\nSnackbar\n\nTSnackBar ★620 - 从顶部显示一个Snackbar\nSnackbarUtils ★379 - Snackbar工具类\nCookieBar ★354 - 屏幕的底部或者顶部显示短信息\nSnacky ★336 - 在布局中添加Snackbar\nLight ★180 - 更好的Snackbar实现\nSweetTips ★59 - 快意灵动的提示库\n\n用户引导\n\nTapTargetView ★2663 - 用户引导功能的实现\nTourGuide ★2075 - 应用使用方法指导视图\nAndroidPdfViewer ★1978 - Android中显示PDF文档的库\nSlidingTutorial-Android ★1894 - Android滑动引导页库\nHighlight ★1854 - app指向性功能高亮的库\nMaterialShowcaseView ★1793 - MD主题的ShowcaseView\nMaterialIntroView ★1732 - 给 Android 应用添加用户引导\nmaterial-intro ★1178 - 简单的MD风格的应用介绍页\nTutors ★75 - 种显示用户界面教程\nXAnimLayout ★18 - 轻松实现引导页动画\n\nPopup\n\nBubbleLayout ★548 - 气泡文字框\nBubbleView ★494 - 带箭头的Android气泡控件/容器类\nCustomPopwindow ★243 - PopupWindow 的常用API封装\n\n滑动返回\n\nSlidr ★1437 - 滑动消失功能\nSwipeBack ★1095 - 使用手势完成Activity\nSwipeBackHelper ★993 - 仿微信下级activity联动效果\nand_swipeback ★752 - 利用滑动手势退出当前Activity\nBGASwipeBackLayout-Android ★676 - 实现滑动返回布局\nSlideBack ★676 - 高仿微信视差手势滑动返回库\nSwipeBack ★608 - 滑动回退功能\nSwipeBackFragment ★329 - 滑动Fragment或Activity边缘拖动返回\nKugouLayout ★295 - 模仿酷狗播放器滑动返回的layout\nEdgeSlidingBack ★116 - 一个仿ios边缘右滑返回的库\n\nTV组件\n\nTVSample ★541 - 仿泰捷视频最新TV版 Metro UI\nLivePlayback ★468 - Android TV直播电视节目\nTvWidget ★293 - tv常用效果控件\nCustomTvRecyclerView ★43 - 针对Android Tv Launcher页的recyclerView\nEpisodeListView ★24 - Android剧集列表控件\n\n软键盘\n\nJKeyboardPanelSwitch ★2111 - 键盘面板冲突及布局闪动处理方案\nInputMethodHolder ★281 - 监听系统软键盘的状态\nHideKeyboard ★210 - 自动隐藏软键盘\nFloatingKeyboard ★89 - 浮动可拖拽的KeyboardView\nSmoothInputLayout ★50 - 仿微信式平滑输入面板\nSoftKeyboardUtil ★44 - 一行代码实现Android软键盘和EditText各种交互\nKeyHide ★33 - 隐藏Android键盘的简单方法\nkeyboard-dismisser ★32 - 点击任何键盘外的部分来取消键盘\nKeyboardView ★22 - 自定义安全键盘\n\n状态栏\n\nStatusBarUtil ★3326 - 为Android应用设置状态栏\nStatusBarCompat ★1297 - Android 沉浸式状态栏\nFlycoSystemBar ★857 - SystemBar助手\nImmersionBar ★853 - android沉浸式实现\n\nStepView\n\nStepView ★2502 - 步骤指示器\nstepper-indicator ★1039 - 引导步骤指示器\nandroid-material-stepper ★974 - 在Android应用中使用MD步进\nSteppers ★714 - Android步骤视图库\nBreadcrumbsView ★565 - 显示给定序列的当前步骤\nAndroid-SnappingStepper ★198 - 漂亮的增减数字控制UI控件\nStepView ★170 - 横向版和竖向版步骤视图\nStateProgressView ★12 - 显示网购物流信息等进度的android view\n\n表格(Table)\n\nexcelPanel ★1305 - 仿Excel表格的RecyclerView\nScrollablePanel ★1265 - 二维RecyclerView\nAdaptiveTableLayout ★1144 - 读取和写入CSV文件\nSortableTableView ★730 - 提供TableView和SortableTableView的安卓库\nTableFixHeaders ★665 - 带有标题的表格的安卓部件\nBiDirTable ★31 - 可双向滑动的表格\nLockTableView ★19 - Android自定义表格\nHVScrollListView ★6 - 实现横纵滑动的列表控件\n\n滚动视差(Parallex)\n\nParallax-Layer-Layout ★761 - Android分层视差效果\nParallaxEverywhere ★620 - 视差效果的另类Android视图库\nScrollParallaxImageView ★402 - 滚动视差效果\nlinkScrollMsky ★65 - 仿知乎个人主页渐隐嵌套滑动\nParallaxViewPager ★63 - 带视差效果的简单ViewPager\n\nSideBar\n\nRecyclerViewFastScroller ★887 - 连接到RecyclerView实现快速滚动\nSideBar ★764 - 全新的快速索引导航栏\nWaveSideBar ★750 - 快速跳跃分组的侧边栏控件\nWaveSideBar ★700 - 波浪效果索引侧边栏\nFastScroll ★532 - 类似列表视图的FastScroller\nAndroid-QuickSideBar ★399 - 快速查阅对应分组的侧边栏\n\n关于页面\n\nAboutLibraries ★1780 - 提供库信息的库\nAndroid About Page ★1257 - 快速创建独一无二的About页面\nMaterialAbout ★829 - 显示一个MD风格的about页面\nmaterial-about-library ★769 - 为app轻松创建关于页面\nabout-page ★95 - 基于MultiType的about页面\nLSettingView ★48 - 设置界面条目封装\n\n详情页\n\nSlideDetailsLayout ★264 - 上拉加载图文详情功能\nDragScrollDetailsLayout ★248 - 仿淘宝京东蘑菇街商品详情页\nGoodsInfoPage ★206 - 仿京东天猫app的商品详情页\nLongPressPopup ★193 - 长按显示详细信息\narticle-android ★91 - 以可读格式显示web文章\nNewsDetail ★66 - 仿今日头条详情页实现\nWdjAppDetail ★45 - 仿豌豆荚应用列表跳转详情界面特效\nTwoPageLayout ★15 - 仿淘宝商品详情页\n\nFAB\n\nFloatingActionButton ★3237 - 浮动动作按钮\nmaterial-sheet-fab ★1259 - 实现浮动操作按钮的库\nFabOptions ★820 - 多功能自定义FAB组件\nFloating-Navigation-View ★806 - 浮动菜单显示锚导航视图\nFabTransitionLayout ★429 - 浮动操作按钮转换\nSquareMenu ★406 - 可自定义的浮动动作按钮\nCounterFab ★374 - 在右上角显示一个计数器的标记\n\nIndicator\n\nSpringIndicator ★1879 - 仿MorningRoutine引导的指示器\nAndroidRubberIndicator ★1405 - ViewPager的rubber指示器\nMusicIndicator ★268 - Music indicator\nEasyIndicator ★51 - 简单的tab指示器\n\n分享组件\n\nShareUtil ★851 - 综合性的分享及登录工具库\nShareButton ★452 - 一个具有流畅动画的分享按钮\nGeneratePicture ★133 - 选取页面内容生成精美分享图片\n\n升级更新\n\nupdate ★936 - 清晰灵活简单易用的应用更新库\nUpdatePlugin ★698 - 自由定制的app更新组件\nandroid-auto-update ★544 - 安卓应用自动更新库\nAppUpdate ★106 - Android 检查更新库\nBGAUpdate-Android ★93 - 应用更新功能\nCheckUpdateLibrary ★76 - Android专用检查软件更新的库\nBackgroundUpdate ★36 - 后台更新APP\n\nToolbar\n\nFloatingToolbar ★1143 - FloatingActionButton变形而来的工具栏\nmorphy-toolbar ★968 - 切换fragments的精致过渡动画\nmaterial-cab ★759 - 自定义的灵活上下文活动栏\nByeBurger ★746 - 极其简便的快速实现隐藏标题栏和导航栏\nandroid-animated-menu-items ★696 - toolbar中动画菜单条目的示例\nAwesomeBar ★504 - 优美的侧边工具菜单\nCollapsingToolbar-With-Webview ★190 - 带有可折叠toolbar的Webview\nSlideshowToolbar ★188 - 安卓Slideshow Toolbar\nCustomTitileBar ★38 - 通用Android标题栏控件\n\nSort&amp;Drag\n\nDynamicGrid ★805 - Android可拖拽GridView\nSortableTableView ★730 - 提供TableView和SortableTableView的安卓库\nClassifyView ★306 - 拖拽合并的RecyclerView\nandroid-drag-square ★213 - 编辑个人资料及图片可拖拽排序\n\nEmoji\n\nemojicon ★2767 - Android中实现emojis表情\nEmojiRain ★510 - 小巧的Android掉emoji表情包实现\nandroid-EmojiCompat ★313 - EmojiCompat支持库使用样例\n\nLabel\n\nlabelview ★1366 - 轻松实现视图之上的标签\nTriangleLabelView ★587 - 显示三角视图\nAvatarLabelView ★424 - 可配置的迷你版轻量级 Label 辅助类\nLabelLayout ★38 - 在另一个视图顶部显示标签文本\n\nWheelView\n\nWheelView-Android ★875 - 具有轮视图的选择器\nHorizontalWheelView ★815 - 供用户输入的模型水平轮控制器\nWheelView ★705 - 实现一个可旋转的轮盘\nandroidWheelView ★611 - 仿照iOS的滚轮控件\nCursorWheelLayout ★497 - 把视图放到一个可旋转轮子中\n\nPinCode\n\nPatternLockView ★1236 - MD风格的Android解锁视图\nLolliPin ★1159 - MD风格的Android的PIN码库\nPinLockView ★801 - PIN锁自定义视图\nPinview ★414 - Android的Pinview库\nPasscodeView ★203 - Android查看视图\nPasscodeView ★150 - 轻松安全的验证用户\nEasyGestureUnlock ★26 - 轻量级手势解锁视图\n\nCoordinatorLayout\n\nCoordinatorBehaviorExample ★2037 - 仿Hangouts4简介动画\nTabbedCoordinatorLayout ★668 - 演示CoordinatorLayout的示例项目\nandroid-ConstraintLayoutExamples ★376 - 展示ContraintLayout的特性和使用\nSharePanel ★49 - 显示分享按钮面板\ncollapsingtoolbarlayout ★15 - 可滑动悬浮式顶部导航栏\n\n页面切换\n\nTransitionPlayer ★1147 - 控制过渡动画的Android库\nandroid-PageFlip ★1126 - 3D风格页面翻页\nEasyFlipView ★663 - 快速而简单的翻转视图\nmagellan ★350 - 最简单的Android导航库\nTranslationCompat ★150 - 动画过渡兼容库\n\n悬浮窗\n\nFloatUtil ★157 - 简单的浮窗工具\nNetSpeed ★35 - 悬浮窗网速显示计\n\n地图\n\nMapView ★493 - 室内地图视图\nDrawRouteMaps ★161 - 路线地图功能\nThemedGoogleMap ★160 - 创建带自定义主题的GoogleMap的实用类\nandroid-togetherMap ★32 - 高德地图的marker聚合功能\n\n编辑器\n\nMarkdownView ★725 - Android的Markdown\nMarkdownView ★578 - 显示Markdown文本的Android库\nSortRichEditor ★285 - 图文混合编辑的富文本编辑器\nCodeView ★130 - Android 代码高亮\n\nSeekBar\n\nPreviewSeekBar ★1915 - 显示视频预览的SeekBar\nBubbleSeekBar ★911 - 自定义SeekBar\nRangeSeekBar ★121 - 可双向范围选择的SeekBar\nHueSeekBar ★45 - 来自Philips Hue app灵感的SeekBar\nRangeSeekBar ★26 - 定值范围选择控件\n\nDownloadView\n\nGADownloading ★733 - 创意下载进度条\nFreshDownloadView ★618 - 显示一个动画下载进程\n360DownLoadView ★30 - 仿360市场下载按钮\n\n其他\n\nShimmer ★7857 - 闪光效果插件\nAndroid Bootstrap ★5987 - Bootstrap风格安卓主题\nlitho ★3481 - 创建Android高效UI\nflow ★2269 - 命名UI状态\nENViews ★1464 - 华丽丽的动效控件库\nQuickReturn ★1464 - 展示QuickReturn UI 模块\nFloatingView ★1186 - 使目标视图漂浮在锚视图上\nSmoothCheckBox ★1073 - Android带动画的自定义CheckBox\nArcLayout ★1033 - 非常简单的arc布局库\nandroid-PictureInPicture ★1017 - 演示手持设备画中画模式\nCouponView ★1009 - 优惠券效果\nCrescento ★902 - 图像视图和相关布局的下面添加曲线\nBigBang ★902 - 仿了Smartisan OS 的 BigBang 功能\nScratchView ★868 - 仿刮刮卡视图\nChromeLikeTabSwitcher ★781 - 标签切换器\nParticleTextView ★774 - 用粒子动画显示文字的 Android 自定义 View\nAndroid-ExpandIcon ★739 - Google风格上下箭头的简单自定义实现\nandroid-snowfall ★728 - 安卓Snowfall View的全自定义实现\nStickerView ★724 - 贴纸视图的缩放拖动翻转删除\nQQBubbleView ★723 - 仿QQ空间直播礼物冒泡特效\nFloatingView ★714 - 显示悬浮窗效果\nIsometric ★703 - 安卓图形库\nMathView ★689 - 在Android应用中显示数学公式\nPathAnimView ★675 - 用于做Path动画的自定义View\n3dTagCloudAndroid ★668 - 将一组View展示为一个3D球形集合\nSquint ★639 - 提供视图的对角线裁剪\nGABottleLoading ★635 - 贝塞尔风暴\nFogView_Library ★586 - 安卓雾气视图库\nTangram-Android ★585 - 动态化构建Native页面的框架\nDepth ★571 - 在fragments中添加Depth\nLoopRotarySwitch ★561 - 3d旋转切换view\nScrollNumber ★554 - 简单优雅易用的滚动数字控件\nDrawView ★548 - 提供涂鸦功能\ntooltips ★532 - 在任何视图上添加工具提示\nPolygonDrawingUtil ★527 - 在canvas上绘制规则多边形\nAndroid-Coverflow ★507 - 漂亮的Android封面浏览\nandroid-combination-avatar ★503 - 模仿QQ讨论组组合头像\nAndroid-DragDismissActivity ★495 - 滑动取消Activity\nLyricViewDemo ★494 - 强大灵活的歌词视图\nZDepthShadow ★487 - MD风格的安卓拉直深入阴影\nEasyCountDownTextureView ★453 - 使用TextureView轻松实现倒计时\nTContributionsView ★436 - 显示类似github贡献度的View\nLayoutSwitch ★429 - 列表布局与网格布局的切换\nAppIconNameChanger ★397 - 动态的改变安卓应用Icon和名称\nFreeDrawView ★365 - 一个可以自由涂鸦的视图\nImageCoverFlow ★340 - 图片封面浏览效果\nWJMagicCurveView ★307 - 神奇的魔法曲线\nAndroidShortcuts ★302 - 快捷方式示例app\nVerificationCodeView ★301 - 动态生成验证码\nShimmerLayout ★296 - 高效的闪光效果\nLBehavior ★290 - 简单实现标题栏导航栏滑动动画\nLemniscate ★290 - 制作别致的进度视图\ntab-digit ★279 - 一个Flip Clock 库\nEdgeTranslucent ★278 - 任意View边沿渐变透明\nFallingView ★252 - 实现碎片飘落效果的控件\nClearScreenHelper ★250 - 清屏相关的需求\nDashboardView ★247 - 安卓自定义仪表盘View\nGooView ★245 - 一个自定义粘性控件\nCrazyShadow ★226 - 为 View 添加阴影效果\njellyball ★226 - 高仿 path下拉小球\nCompositionAvatar ★221 - 仿QQ讨论组头像\nChanelView ★202 - 说明手势的简单用例\nFloatingViewService ★201 - 一个服务开启悬浮球\nSimpleOneStep ★190 - 仿OneStep\nShoppingCart ★184 - 仿饿了么购物车效果\nFreeView ★181 - 浮动视图\nFloatView ★172 - 类似来电秀的效果\nEasyTransition ★169 - 一个轻量级的共享元素迁移库\nUnifiedContactPicker ★153 - 统一用户联系人\nDragFooterView ★144 - 向左拖拽跳转至更多页面\nFloatBall ★144 - 高仿flyme悬浮球\nAndroidGpsStatus ★139 - 显示GPS状态和信号强度\nWindView ★135 - 显示天气风速和压力状态\nAttributesDispatcher ★111 - 创建一个自定义视图\nSnapHelperExample ★104 - SnapHelper的Android示例\nXyzInfo ★92 - 自定义Switch和Ruler控件\nMagicLine ★85 - 简单的规律绘制直线构造神奇的视觉效果\nLamp ★81 - 简单的Android工艺灯控件\nWaitView ★80 - 显示等待加载状态的View\nVibes ★76 - 安卓的径向传播背景\nVerificationCodeInput ★72 - 简洁验证码输入框\nPayUI ★70 - 支付密码弹出层\nAndroid-RadarView ★64 - 仿支付宝芝麻分解读\nFlipperView ★61 - 使用翻转过渡改变不同状态\nHorizontalNumberView ★61 - 简单的Android滑动缩放视图\nShelfView ★59 - 显示书架上的书的自定义视图\nGithubContributionsWidget ★56 - github贡献的Android部件\nElasticViews ★49 - 触摸动画Android视图\nEasyFeedback ★47 - 收集Android应用程序的反馈\nPixelSlide ★47 - 上下的展开箭头扩展示例\nRuleView ★47 - 自定义刻度尺控件\nPaintView ★43 - 在图片上涂鸦\nNetMonitor ★43 - 使用广播监听网络变化\nStickyDemo ★41 - 三步实现控件悬浮\nDigitSpeedView ★39 - 独特的安卓数字测速仪\ncheckview ★37 - 动画check标记\nFlipLayout ★36 - 容易的对ViewGroup的子View进行交换\nParticle ★33 - 一个android萤火虫飞舞的粒子效果\nBubbleView ★30 - 模仿QQ水泡拖拽效果\nCircleRangeView ★29 - 自定义圆形仪表盘View\nStatusBarFits ★25 - Android状态栏\nHoverView ★23 - 仿知乎的底部抽屉\nAndroidHeatMap ★23 - 易于使用的热点图控件\nVerificationCodeView ★22 - Android简单的验证码控件\nMultiShapeView ★20 - 支持圆角矩形圆形自定义View\nWeekView ★18 - 安卓周视图\nLetterView ★12 - 选中字母完成单词\n\n以上资料来自GitHub开源分享，感谢opendigg的辛苦整理。\n","plink":"https://blog.ixin.run/posts/1614235078/"},{"title":"认识LRU经典算法","date":"2021-02-24T10:59:45.000Z","date_formatted":{"ll":"2021年2月24日","L":"2021/02/24","MM-DD":"02-24"},"updated":"2021-02-24T13:42:02.353Z","content":"LRU算法是不是听着很耳熟，当然面试经常问到。本文带你了解LRU算法相关经典的实现方式以及为什么采用，至少在面试的时候不至于一问三不知而栽跟头，接下来就看看LRU到底是个啥东西吧。\n\nLRU算法系列：\n\n《认识LRU经典算法》\n《手撸LRU算法基本思路》\n\nLRU是什么\n\nLRU是Least Recently Used的缩写，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。 ————《百度百科》\n\n在计算机中，所有的文件操作都要放在内存中进行，然而计算机内存大小是固定的，所以我们不可能把所有的文件都加载到内存，因此我们需要制定一种策略对加入到内存中的文件进项选择。\n常见的页面置换算法有如下几种：\n\nOPT 最佳置换算法 （理想中存在的）\nFIFO 先进先出置换算法\nLRU 最近最久未使用算法\nLFU 最少使用置换算法\nNRU 最近未使用算法\n\nLRU的面向场景\n是一种计算机中内存不够的场景下，淘汰旧内容的策略。LRU（Least Recently Used），淘汰掉最不经常使用的。可以稍微多补充两句，因为计算机体系结构中，最大的最可靠的存储是硬盘，它容量很大，并且内容可以固化，但是访问速度很慢，所以需要把使用的内容载入内存中；内存速度很快，但是容量有限，并且断电后内容会丢失，并且为了进一步提升性能，还有CPU内部的 L1 Cache，L2 Cache等概念。因为速度越快的地方，它的单位成本越高，容量越小，新的内容不断被载入，旧的内容肯定要被淘汰，所以就有这样的使用背景。\nLRU的实现方式\n在一般标准的操作系统教材里，会用下面的方式来演示 LRU 原理，假设内存只能容纳3个页大小，按照 7 0 1 2 0 3 0 4 的次序访问页。假设内存按照栈的方式来描述访问时间，在上面的，是最近访问的，在下面的是，最远时间访问的，LRU就是这样工作的。\n\n但是如果让我们自己设计一个基于 LRU 的缓存，这样设计可能问题很多，这段内存按照访问时间进行了排序，会有大量的内存拷贝操作，所以性能肯定是不能接受的。\n那么如何设计一个LRU缓存，使得放入和移除都是 O(1) 的，我们需要把访问次序维护起来，但是不能通过内存中的真实排序来反应，有一种方案就是使用双向链表。\n基于HashMap和双向链表实现【经典】\n整体的设计思路是，可以使用HashMap&lt;key,value&gt;，key存储双向链表的数值，这样可以做到 save 和 get key的时间都是 O(1)，而 HashMap 的 Value 指向双向链表实现的 LRU 的 Node 节点，如图所示。\n\n其中 head 代表双向链表的表头，tail 代表尾部。首先预先设置 LRU 的容量，如果存储满了，可以通过 O(1) 的时间淘汰掉双向链表的尾部，每次新增和访问数据，都可以通过 O(1)的效率把新的节点增加到对头，或者把已经存在的节点移动到队头。\n总结如下：\n\n在链表头的是最新使用的。\n在尾部的是最旧的，也是下次要清除的。\n如果加入的值是链表内存在的则要移动到头部。\n\nHashMap是来配合双向链表，用于减少时间复杂度的。它是可以快速的（O(1)的时间）定位，链表中某个值是否存在。（要不然需要遍历双向链表，时间复杂度为O(n) n为链表长度），定位到某个值存在后能马上获得他的node节点，因为是双向链表，直接用此节点的父节点，指向此节点的子节点（跳出、入栈），在将此节点放到头部就可以了，免除了遍历查找。\nRedis的LRU实现\n如果按照HashMap和双向链表实现，需要额外的存储存放next和prev指针，牺牲比较大的存储空间，显然是不划算的。所以Redis采用了一个近似的做法，就是随机取出若干个key，然后按照访问时间排序后，淘汰掉最不经常使用的。\nRedis会基于server.maxmemory_samples配置选取固定数目的key，然后比较它们的lru访问时间，然后淘汰最近最久没有访问的key，maxmemory_samples的值越大，Redis的近似LRU算法就越接近于严格LRU算法，但是相应消耗也变高，对性能有一定影响，样本值默认为5。\nRedis的LRU实现是使用一种近似的算法来模拟LRU淘汰的效果实现，可以节约内存，降低代码复杂性。\n为什么要用HashMap和双链表\n上文已经说明HashMap和双链表的各自分工，这里再抛出两个问题：\n1)用队列行不行？\n不行，队列只能做到先进先出，但是重复用到中间的数据时无法把中间的数据移动到顶端。\n2)就用单链表行不行？\n也不太行，单链表能实现新来的放头部，最久不用的在尾部删除。但删除的时候需要遍历到尾部，因为单链表只有头指针，在用到已经用到过的数据时，还要遍历整合链表，来确定是否用过，然后再遍历到相应的位置来定位需要跳出的那个节点，并重新放在头部。这效率可想而知。\n这时hashmap的作用就出来了，他可以在单位1的时间判断value的值是否存在，key直接存储节点对象，能直接定位到需要跳出的那个节点。\n要通过一个节点直接获得父节点的话，单链表（单向性，只能指向下一个）是不行的。这时双向链表的作用也提现出来了，能同时定位到父节点和子节点，使两个节点挂钩，自己快速移到头部挂钩，这效率就很高了。而且由于双向链表有尾指针，所以剔除最后的尾节点也十分方便和快捷。\n最后\n本文重点针对经典的LUR实现（HashMap和双向链表）进行探秘，帮助自己，时常温故。感兴趣的同学可以看我另外一篇文章《手撸LRU算法基本思路》进一步通过代码视角学习。\n参考\n\nhttps://zhuanlan.zhihu.com/p/34133067\nhttps://my.oschina.net/zjllovecode/blog/1634410\n\n","plink":"https://blog.ixin.run/posts/1614164385/"},{"title":"Stream流式编程实现原理","date":"2021-02-17T17:09:06.000Z","date_formatted":{"ll":"2021年2月18日","L":"2021/02/18","MM-DD":"02-18"},"updated":"2021-02-24T13:38:29.600Z","content":"上一篇《Stream流式编程知识总结》我们主要针对Stream流式编程的具体使用方法进行了深入的探讨，但是如果再来一个一问三连what?-why?-then?是不是又开始懵比了，哈哈，本文就运用一问三连的形式来进行争取不那么麻烦的解释Stream流式编程的实现原理。\n\nJava8新特性系列：\n\n《Lambda表达式你会吗》\n《Stream流式编程知识总结》\n《Stream流式编程实现原理》\n\nStream怎么用\n其实上篇已经讲过，Stream没用之前我们针对集合的便利帅选等操作更多的是for-loop/while-loop，用了Stream后发现原来代码可以如此简洁，并且越发形似SQL语句。甚至可以做很多复杂的动作：\n12345678ap&lt;Integer, List&lt;String&gt;&gt; lowCaloricDishesNameGroup =     dishes.parallelStream() // 开启并行处理          .filter(d -&gt; d.getCalories() &lt; 400) // 按照热量值进行筛选          .sorted(comparing(Dish::getCalories)) // 按照热量进行排序          .collect(Collectors.groupingBy( // 将菜品名按照热量进行分组              Dish::getCalories,               Collectors.mapping(Dish::getName, Collectors.toList())          ));\n\nStream的操作分类\nStream使用一种类似SQL语句的方式，提供对集合运算的高阶抽象，可以将其处理的元素集合看做一种数据流，流在管道中传输，数据在管道节点上进行处理，比如筛选、排序、聚合等。\n数据流在管道中经过中间操作(intermediate operation)处理，由终止操作(terminal operation)得到前面处理的结果。这些也在《Stream流式编程知识总结》有相应的说明。\nStream操作分为两类：\n\n\n中间操作：将流一层层的进行处理，并向下一层进行传递，如 filter map sorted等。\n中间操作又分为有状态(stateful)及无状态(stateless)\n\n有状态：必须等上一步操作完拿到全部元素后才可操作，如sorted\n无状态：该操作的数据不收上一步操作的影响，如filter map\n\n\n\n终止操作：触发数据的流动，并收集结果，如collect findFirst forEach等。终止操作又分为短路操作(short-circuiting)及非短路操作(non-short-circuiting)\n\n短路操作：会在适当的时刻终止遍历，类似于break，如anyMatch findFirst等\n非短路操作：会遍历所有元素，如collect max等\n\n\n\n\nStream的实现过程\nStream的实现使用流水线（pipelining）的方式巧妙的避免了多次迭代，其基本思想是在一次迭代中尽可能多的执行用户指定的操作。\nStream采用某种方式记录用户每一步的操作，中间操作会返回流对象，多个操作最终串联成一个管道，管道并不直接操作数据，当用户调用终止操作时将之前记录的操作叠加到一起，尽可能地在一次迭代中全部执行掉，面对如此简洁高效的API不由得使我们有所疑问：\n\n用户的操作如何记录？\n操作如何叠加？\n叠加后的操作如何执行？\n执行后的结果（如果有）在哪里？\n\n操作如何记录\nStream中使用Stage的概念来描述一个完整的操作，并用某种实例化后的PipelineHelper来代表Stage，将各Pipeline按照先后顺序连接到一起，就构成了整个流水线。\n与Stream相关类和接口的继承关系如下图，其中蓝色表示继承关系，绿色表示接口实现：\n\nHead用于表示第一个Stage，该Stage不包含任何操作。StatelessOp和StatefulOp分别表示无状态和有状态的Stage。\n\n其中：\n\nHead记录Stream起始操作，将包装为Spliterator的原始数据存放在Stage中\nStatelessOp记录无状态的中间操作\nStatefulOp记录有状态的中间操作\nTerminalOp用于触发数据数据在各Stage间的流动及处理，并收集最终数据(如果有)\n\n使用Collection.stream、Arrays.stream或Stream.of等接口会生成Head，其内部均采用StreamSupport.stream方法，将原始数据包装为Spliterator存放在Stage中。\nHead、StatelessOp、StatefulOp三个操作实例化会指向其父类AbstractPipeline。\n对于Head：\n12345678910111213141516171819/** * Constructor for the head of a stream pipeline. * * @param source &#123;@code Spliterator&#125; describing the stream source * @param sourceFlags the source flags for the stream source, described in * &#123;@link StreamOpFlag&#125; * @param parallel &#123;@code true&#125; if the pipeline is parallel */AbstractPipeline(Spliterator&lt;?&gt; source, int sourceFlags, boolean parallel) &#123;    this.previousStage = null;    this.sourceSpliterator = source;    this.sourceStage = this;    this.sourceOrOpFlags = sourceFlags &amp; StreamOpFlag.STREAM_MASK;    // The following is an optimization of:    // StreamOpFlag.combineOpFlags(sourceOrOpFlags, StreamOpFlag.INITIAL_OPS_VALUE);    this.combinedFlags = (~(sourceOrOpFlags &lt;&lt; 1)) &amp; StreamOpFlag.INITIAL_OPS_VALUE;    this.depth = 0;    this.parallel = parallel;&#125;\nHead操作会将包装为Spliterator的原始数据存放在该Stage中，将自身存放sourceStage中，并把串并行操作也记录在内。Head的前期功能就是记录这些源数据。\n对于StatelessOp及StatefulOp：\n12345678910111213141516171819202122/** * Constructor for appending an intermediate operation stage onto an * existing pipeline. * * @param previousStage the upstream pipeline stage * @param opFlags the operation flags for the new stage, described in * &#123;@link StreamOpFlag&#125; */AbstractPipeline(AbstractPipeline&lt;?, E_IN, ?&gt; previousStage, int opFlags) &#123;    if (previousStage.linkedOrConsumed)        throw new IllegalStateException(MSG_STREAM_LINKED);    previousStage.linkedOrConsumed = true;    previousStage.nextStage = this;    this.previousStage = previousStage;    this.sourceOrOpFlags = opFlags &amp; StreamOpFlag.OP_MASK;    this.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags);    this.sourceStage = previousStage.sourceStage;    if (opIsStateful())        sourceStage.sourceAnyStateful = true;    this.depth = previousStage.depth + 1;&#125;\n中间操作通过previousStage及nextStage，将各Stage串联为一个双向链表，使得每一步都知道上一步与下一步的操作。\n每一个中间操作Stage中的sourceStage都指向前一个Stage的soureStage，如此递归，最终指向Head。卧槽，似乎是不是明白些啥了，接着往下看吧，现在仅仅是第一阶段。\n\n操作如何叠加\n上一个问题解决了每一步操作数据源以及内部实现是怎么记录的，此时并没有执行，Stage只是保存了当前的操作，并不能确定下一个Stage需要何种操作，所以想要让pipeline运行起来，需要一种将所有操作叠加到一起的方案。\nStream类库采用了Sink接口来协调各Stage之间的关系：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051interface Sink&lt;T&gt; extends Consumer&lt;T&gt; &#123;    /**     * Resets the sink state to receive a fresh data set.  This must be called     * before sending any data to the sink.  After calling &#123;@link #end()&#125;,     * you may call this method to reset the sink for another calculation.     * @param size The exact size of the data to be pushed downstream, if     * known or &#123;@code -1&#125; if unknown or infinite.     *     * &lt;p&gt;Prior to this call, the sink must be in the initial state, and after     * this call it is in the active state.     *     * 开始遍历前调用，通知Sink做好准备     */    default void begin(long size) &#123;&#125;    /**     * Indicates that all elements have been pushed.  If the &#123;@code Sink&#125; is     * stateful, it should send any stored state downstream at this time, and     * should clear any accumulated state (and associated resources).     *     * &lt;p&gt;Prior to this call, the sink must be in the active state, and after     * this call it is returned to the initial state.     *     * 所有元素遍历完成后调用，通知Sink没有更多元素了     */    default void end() &#123;&#125;        /**     * Indicates that this &#123;@code Sink&#125; does not wish to receive any more data.     *     * @implSpec The default implementation always returns false.     *     * @return true if cancellation is requested     *     * 是否可以结束操作，可以让短路操作尽早结束     */    default boolean cancellationRequested() &#123;&#125;    /**     * Accepts a value.     *     * @implSpec The default implementation throws IllegalStateException.     *     * @throws IllegalStateException if this sink does not accept values     *     * 遍历时调用，接收的一个待处理元素，并对元素进行处理。     * Stage把自己包含的操作和回调方法封装到该方法里，前一个Stage只需要调用当前     * Stage.accept方法即可     */    default void accept(T value) &#123;&#125;&#125;\n其实Stream的各种操作实现的本质，就是如何重载Sink的这四个接口方法，各个操作通过Sink接口accept方法依次向下传递执行。\n下面结合具体源码来理解Stage是如何将自身的操作包装成Sink，以及Sink是如何将处理结果转发给下一个Sink的。\n无状态Stage（Stream.map）：\n123456789101112131415161718// Stream.map 将生成一个新Streampublic final &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super P_OUT, ? extends R&gt; mapper) &#123;    Objects.requireNonNull(mapper);    return new StatelessOp&lt;P_OUT, R&gt;(this, StreamShape.REFERENCE,                                 StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123;        // 该方法将回调函数(处理逻辑)包装成Sink        @Override        Sink&lt;P_OUT&gt; opWrapSink(int flags, Sink&lt;R&gt; sink) &#123;            return new Sink.ChainedReference&lt;P_OUT, R&gt;(sink) &#123;                @Override                public void accept(P_OUT u) &#123;                    // 接收数据，使用当前包装的回调函数处理数据，并传递给下游Sink                    downstream.accept(mapper.apply(u));                &#125;            &#125;;        &#125;    &#125;;&#125;\n有状态Stage（Stream.sorted）：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546private static final class RefSortingSink&lt;T&gt; extends AbstractRefSortingSink&lt;T&gt; &#123;    // 存放用于排序的元素    private ArrayList&lt;T&gt; list;    RefSortingSink(Sink&lt;? super T&gt; sink, Comparator&lt;? super T&gt; comparator) &#123;        super(sink, comparator);    &#125;    @Override    public void begin(long size) &#123;        if (size &gt;= Nodes.MAX_ARRAY_SIZE)            throw new IllegalArgumentException(Nodes.BAD_SIZE);        // 创建用于存放排序元素的列表        list = (size &gt;= 0) ? new ArrayList&lt;T&gt;((int) size) : new ArrayList&lt;T&gt;();    &#125;    @Override    public void end() &#123;        // 只有在接收到所有元素后才开始排序        list.sort(comparator);        downstream.begin(list.size());        // 排序完成后，将数据传递给下游Sink        if (!cancellationWasRequested) &#123;            // 下游Sink不包含短路操作，将数据依次传递给下游Sink            list.forEach(downstream::accept);        &#125;        else &#123;            // 下游Sink包含短路操作            for (T t : list) &#123;                // 对于每一个元素，都要询问是否可以结束处理                if (downstream.cancellationRequested()) break;                // 将元素传递给下游Sink                downstream.accept(t);            &#125;        &#125;        // 告知下游Sink数据传递完毕        downstream.end();        list = null;    &#125;    @Override    public void accept(T t) &#123;        // 依次将需要排序的元素加入到临时列表中        list.add(t);    &#125;&#125;\nStream.sorted会在接收到所有元素之后再进行排序，之后才开始将数据依次传递给下游Sink。\n两个操作之间通过Sink接口的accept方法进行挂钩，此时如果从第一个Sink开始执行accept方法便可以把整个管道流动起来，但是这个“如果”怎么实现呢？另外记着每一个操作中的opWrapSink是用于包装Sink的，也就是说只有包装后的Sink才具有条件使得整个管道流动起来。\n叠加后的操作如何执行\n终止操作(TerminalOp)之后不能再有别的操作，终止操作会创建一个包装了自己操作的Sink，这个Sink只处理数据而不会将数据传递到下游Sink（没有下游了）。\n在调用Stream的终止操作时，会执行AbstractPipeline.evaluate：\n1234567891011121314151617/** * Evaluate the pipeline with a terminal operation to produce a result. * * @param &lt;R&gt; the type of result * @param terminalOp the terminal operation to be applied to the pipeline. * @return the result */final &lt;R&gt; R evaluate(TerminalOp&lt;E_OUT, R&gt; terminalOp /* 各种终止操作 */) &#123;    assert getOutputShape() == terminalOp.inputShape();    if (linkedOrConsumed)        throw new IllegalStateException(MSG_STREAM_LINKED);    linkedOrConsumed = true;    return isParallel()           ? terminalOp.evaluateParallel(this, sourceSpliterator(terminalOp.getOpFlags())) /* 并发执行 */           : terminalOp.evaluateSequential(this, sourceSpliterator(terminalOp.getOpFlags())); /* 串行执行 */&#125;\n最终会根据并行还是串行执行TerminalOp中不同的的evaluate方法。如果是串行执行，接下来在TerminalOp的evaluate方法中会调用wrapAndCopyInto来包装、串联各层Sink，触发pipeline，并获取最终结果。\n1234final &lt;P_IN, S extends Sink&lt;E_OUT&gt;&gt; S wrapAndCopyInto(S sink /* TerminalSink */, Spliterator&lt;P_IN&gt; spliterator) &#123;    copyInto(wrapSink(Objects.requireNonNull(sink)), spliterator);    return sink;&#125;\n其中wrapSink（包装）实现：\n12345678910final &lt;P_IN&gt; Sink&lt;P_IN&gt; wrapSink(Sink&lt;E_OUT&gt; sink) &#123;    Objects.requireNonNull(sink);    // AbstractPipeline.this，最后一层Stage    for ( @SuppressWarnings(&quot;rawtypes&quot;) AbstractPipeline p=AbstractPipeline.this; p.depth &gt; 0; p=p.previousStage) &#123;        // 从下游向上游遍历，不断包装Sink        sink = p.opWrapSink(p.previousStage.combinedFlags, sink /* 下一层Stage的Sink */);    &#125;    return (Sink&lt;P_IN&gt;) sink;&#125;\nwrapSink方法通过下游Stage的“opWrapSink”方法不断将下游Stage的Sink从下游向上游遍历包装，最终得到上文我说的第一个Sink。\n\n有了第一个Sink，如何执行呢，还记的wrapAndCopyInto中的copyInto吧：\n12345678910111213141516171819202122232425262728293031323334final &lt;P_IN&gt; void copyInto(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator) &#123;    Objects.requireNonNull(wrappedSink);    if (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;        // 不包含短路操作                // 1. begin        wrappedSink.begin(spliterator.getExactSizeIfKnown());        // 2. 遍历调用 sink.accept        spliterator.forEachRemaining(wrappedSink);        // 3. end        wrappedSink.end();    &#125;    else &#123;        // 包含短路操作        copyIntoWithCancel(wrappedSink, spliterator);    &#125;&#125;final &lt;P_IN&gt; void copyIntoWithCancel(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator) &#123;    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)    AbstractPipeline p = AbstractPipeline.this;    while (p.depth &gt; 0) &#123;        p = p.previousStage;    &#125;    // 1. begin    wrappedSink.begin(spliterator.getExactSizeIfKnown());    // 2. 遍历调用 sink.accept    //    每一次遍历都询问cancellationRequested结果    //    如果cancellationRequested为true，则中断遍历    p.forEachWithCancel(spliterator, wrappedSink);    // 3. end    wrappedSink.end();&#125;\ncopyInto会根据不同的情况依次调用：\n\nsink.bigin\nsink.accept（遍历调用，如果包含短路操作，则每次遍历都需要询问cancellationRequested，适时中断遍历）\nsink.end\n\n执行结果在哪儿\n每一种TerminalSink中均会提供一个获取最终结果的方法：\n\nTerminalOp通过调用TerminalSink中的对应方法，获取最终的数据并返回，如ReduceOp中：\n12345@Overridepublic &lt;P_IN&gt; R evaluateSequential(PipelineHelper&lt;T&gt; helper,                                   Spliterator&lt;P_IN&gt; spliterator) &#123;    return helper.wrapAndCopyInto(makeSink(), spliterator).get();&#125;\nStream并行执行原理\n使用Collection.parallelStream或Stream.parallel等方法可以将当前的Stream流标记为并行执行。\n上文提到在调用Stream的终止操作时，会执行AbstractPipeline.evaluate方法，根据paraller标识是执行并行操作还是串行操作：\n1234...return isParallel()           ? terminalOp.evaluateParallel(this, sourceSpliterator(terminalOp.getOpFlags())) /* 并发执行 */           : terminalOp.evaluateSequential(this, sourceSpliterator(terminalOp.getOpFlags())); /* 串行执行 */\n如果被标记为sequential，则会调用TerminalOp.evaluateSequential，evaluateSequential的调用过程上文已经讲述的很清楚。\n如果被标记为parallel，则会调用TerminalOp.evaluateParallel，对于该方法不同的TerminalOp会有不同的实现，但都使用了ForkJoin框架，将原始数据不断拆分为更小的单元，对每一个单元做上述evaluateSequential类似的动作，最后将每一个单元计算的结果依次整合，得到最终结果。\nForkJoin在《Stream流式编程知识总结》有所说明。默认情况下，ForkJoin的线程数即为机器的CPU核数，如果想自定义Stream并行执行的线程数，可以参考Custom Thread Pools In Java 8 Parallel Streams\n最后\n本文详细讲述了Stream流的实现原理，刚开始研究的时候也是云里雾里，弄懂后才知道原来是“一波三折”，用这个词再合适不过了:\n\nHead包装最初的数据源，它不属于Stream流中的任何操作，并且Stream流中每一个操作都会指向Head，用于将来数据源便捷取出。\n每一个操作都是一个Stage，每一个Stage都有上下游指针，使得每一个Stage进行挂钩，形成双链表。\n每一个Stage都会通过Sink接口协议使得两个Stage之间的操作进行挂钩，上游执行下游。\n终止操作根据“从下游向上游”原则依次包装Sink，最终得到第一个Sink。\n从第一个Sink执行使得整个管道的流动，得到最终结果。\n\n本文参考了各路大佬的博文，总结不易，喜欢的点个赞加个关注喽，谢谢。\n参考\n\nhttps://segmentfault.com/a/1190000018919146\nhttps://www.cnblogs.com/Dorae/p/7779246.html\nhttps://segmentfault.com/a/1190000019143092#\n\n","plink":"https://blog.ixin.run/posts/1613581746/"},{"title":"Stream流式编程知识总结","date":"2021-02-17T15:19:29.000Z","date_formatted":{"ll":"2021年2月17日","L":"2021/02/17","MM-DD":"02-17"},"updated":"2021-02-24T13:38:31.281Z","content":"本篇继上一篇《Lambda表达式你会吗》又一篇Java8新特性——流式编程，上篇文章中并没有采用Stream例子来装饰Lambda表达式，害怕有同学看不懂，所以在文章末尾留个彩蛋，本篇文章重点讲一下对Java8中流式编程的运用学习。\n\nJava8新特性系列：\n\n《Lambda表达式你会吗》\n《Stream流式编程知识总结》\n《Stream流式编程实现原理》\n\n什么是Stream\nStream它并不是一个容器，它只是对容器的功能进行了增强，添加了很多便利的操作,例如查找、过滤、分组、排序等一系列的操作。并且有串行、并行两种执行模式，并行模式充分的利用了多核处理器的优势，使用fork/join框架进行了任务拆分，同时提高了执行速度。简而言之，Stream就是提供了一种高效且易于使用的处理数据的方式。\n特点：\n\nStream自己不会存储元素。\nStream操作不会改变源对象。相反，他们会返回一个持有结果的新Stream。\nStream操作是延迟执行的。它会等到需要结果的时候才执行。也就是执行终端操作的时候。\n\n图解：\n\n一个Stream的操作就如上图，在一个管道内，分为三个步骤：\n\n第一步是创建Stream，从集合、数组中获取一个流；\n第二步是中间操作链，对数据进行处理；\n第三步是终端操作，用来执行中间操作链，返回结果；\n\n为什么需要流式操作\n集合API是Java API中最重要的部分。基本上每一个java程序都离不开集合。尽管很重要，但是现有的集合处理在很多方面都无法满足需要。\n一个原因是，许多其他的语言或者类库以声明的方式来处理特定的数据模型，比如SQL语言，你可以从表中查询，按条件过滤数据，并且以某种形式将数据分组，而不必需要了解查询是如何实现的——数据库帮你做所有的脏活。这样做的好处是你的代码很简洁。很遗憾，Java没有这种好东西，你需要用控制流程自己实现所有数据查询的底层的细节。\n其次是你如何有效地处理包含大量数据的集合。理想情况下，为了加快处理过程，你会利用多核架构。但是并发程序不太好写，而且很容易出错。\nStream API很好的解决了这两个问题。它抽象出一种叫做流的东西让你以声明的方式处理数据，更重要的是，它还实现了多线程：帮你处理底层诸如线程、锁、条件变量、易变变量等等。\n怎么创建Stream\n常用的Stream有三种创建方式：\n\n集合 Collection.stream()\n数组 Arrays.stream\n静态方法 Stream.of\n\n由集合创建\nJava8 中的 Collection 接口被扩展，提供了两个获取流的方法,这两个方法是default方法，也就是说所有实现Collection接口的接口都不需要实现就可以直接使用：\n\ndefault Stream stream() : 返回一个串行流。\ndefault Stream parallelStream() : 返回一个并行流。\n\n12345List&lt;Integer&gt; integerList = new ArrayList&lt;&gt;();integerList.add(1);integerList.add(2);Stream&lt;Integer&gt; stream = integerList.stream();Stream&lt;Integer&gt; stream1 = integerList.parallelStream();\n由数组创建\nJava8 中的 Arrays 的静态方法 stream() 可以获取数组流:\n12int[] array = &#123;1,2,3&#125;;Stream&lt;Integer&gt; stream = Arrays.stream(array);\n由静态方法Stream.of创建\n可以使用静态方法 Stream.of(), 通过显示值 创建一个流。它可以接收任意数量的参数。\n1Stream&lt;Integer&gt; integerStream = Stream.of(1, 2, 3, 4, 5, 6, 7, 8);\n准备数据\n1234567891011121314151617181920212223242526//计算机俱乐部private static List&lt;Student&gt; computerClub = Arrays.asList(        new Student(&quot;2015134001&quot;, &quot;小明&quot;, 15, &quot;1501&quot;),        new Student(&quot;2015134003&quot;, &quot;小王&quot;, 14, &quot;1503&quot;),        new Student(&quot;2015134006&quot;, &quot;小张&quot;, 15, &quot;1501&quot;),        new Student(&quot;2015134008&quot;, &quot;小梁&quot;, 17, &quot;1505&quot;));//篮球俱乐部private static List&lt;Student&gt; basketballClub = Arrays.asList(        new Student(&quot;2015134012&quot;, &quot;小c&quot;, 13, &quot;1503&quot;),        new Student(&quot;2015134013&quot;, &quot;小s&quot;, 14, &quot;1503&quot;),        new Student(&quot;2015134015&quot;, &quot;小d&quot;, 15, &quot;1504&quot;),        new Student(&quot;2015134018&quot;, &quot;小y&quot;, 16, &quot;1505&quot;));//乒乓球俱乐部private static List&lt;Student&gt; pingpongClub = Arrays.asList(        new Student(&quot;2015134022&quot;, &quot;小u&quot;, 16, &quot;1502&quot;),        new Student(&quot;2015134021&quot;, &quot;小i&quot;, 14, &quot;1502&quot;),        new Student(&quot;2015134026&quot;, &quot;小m&quot;, 17, &quot;1504&quot;),        new Student(&quot;2015134027&quot;, &quot;小n&quot;, 16, &quot;1504&quot;));private static List&lt;List&lt;Student&gt;&gt; allClubStu = new ArrayList&lt;&gt;();allClubStu.add(computerClub);allClubStu.add(basketballClub);allClubStu.add(pingpongClub);\n以上数据用于下边的Stream的中间操作和终止操作实例说明。\nStream中间操作\n如果Stream只有中间操作是不会执行的，当执行终端操作的时候才会执行中间操作，这种方式称为延迟加载或惰性求值。多个中间操作组成一个中间操作链，只有当执行终端操作的时候才会执行一遍中间操作链，下面看下Stream有哪些中间操作。\ndistinct\ndistinct: 对于Stream中包含的元素进行去重操作（去重逻辑依赖元素的equals方法），新生成的Stream中没有重复的元素；\n\n123List&lt;String&gt; list = Arrays.asList(&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;);list.forEach(System.out::print); //bbcalist.stream().distinct().forEach(System.out::print);//bca\nfilter\nfilter: 对于Stream中包含的元素使用给定的过滤函数进行过滤操作，新生成的Stream只包含符合条件的元素；\n\n1234//筛选1501班的学生computerClub.stream().filter(e -&gt; e.getClassNum().equals(&quot;1501&quot;)).forEach(System.out::println);//筛选年龄大于15的学生List&lt;Student&gt; collect = computerClub.stream().filter(e -&gt; e.getAge() &gt; 15).collect(Collectors.toList());\nmap\nmap: 对于Stream中包含的元素使用给定的转换函数进行转换操作，新生成的Stream只包含转换生成的元素。\n这个方法有三个对于原始类型的变种方法，分别是：mapToInt，mapToLong和mapToDouble。这三个方法也比较好理解，比如mapToInt就是把原始Stream转换成一个新的Stream，这个新生成的Stream中的元素都是int类型。之所以会有这样三个变种方法，可以免除自动装箱/拆箱的额外消耗；\n\n123456789//篮球俱乐部所有成员名 + 暂时住上商标^_^,并且获取所有队员名List&lt;String&gt; collect1 = basketballClub.stream()        .map(e -&gt; e.getName() + &quot;^_^&quot;)        .collect(Collectors.toList());collect1.forEach(System.out::println);//小c^_^^_^//小s^_^^_^//小d^_^^_^//小y^_^^_^\nflatMap\nflatMap：和map类似，不同的是其每个元素转换得到的是Stream对象，会把子Stream中的元素压缩到父集合中；\n\n1234567891011//获取年龄大于15的所有俱乐部成员List&lt;Student&gt; collect2 = Stream.of(basketballClub, computerClub, pingpongClub)        .flatMap(e -&gt; e.stream().filter(s -&gt; s.getAge() &gt; 15))        .collect(Collectors.toList());collect2.forEach(System.out::println);//用双层list获取所有年龄大于15的俱乐部成员List&lt;Student&gt; collect3 = allClubStu.stream()        .flatMap(e -&gt; e.stream().filter(s -&gt; s.getAge() &gt; 15))        .collect(Collectors.toList());collect3.forEach(System.out::println);\npeek\npeek: 生成一个包含原Stream的所有元素的新Stream，同时会提供一个消费函数（Consumer实例），新Stream每个元素被消费的时候都会执行给定的消费函数；\n\n123456789//篮球俱乐部所有成员名 + 赞助商商标^_^,并且获取所有队员详细内容List&lt;Student&gt; collect = basketballClub.stream()        .peek(e -&gt; e.setName(e.getName() + &quot;^_^&quot;))        .collect(Collectors.toList());collect.forEach(System.out::println);//Student&#123;idNum=&#x27;2015134012&#x27;, name=&#x27;小c^_^&#x27;, age=13, classNum=&#x27;1503&#x27;&#125;//Student&#123;idNum=&#x27;2015134013&#x27;, name=&#x27;小s^_^&#x27;, age=14, classNum=&#x27;1503&#x27;&#125;//Student&#123;idNum=&#x27;2015134015&#x27;, name=&#x27;小d^_^&#x27;, age=15, classNum=&#x27;1504&#x27;&#125;//Student&#123;idNum=&#x27;2015134018&#x27;, name=&#x27;小y^_^&#x27;, age=16, classNum=&#x27;1505&#x27;&#125;\nlimit\nlimit: 对一个Stream进行截断操作，获取其前N个元素，如果原Stream中包含的元素个数小于N，那就获取其所有的元素；\n\n1234List&lt;String&gt; list = Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//获取list中top2即截断取前两个List&lt;String&gt; collect1 = list.stream().limit(2).collect(Collectors.toList());collect1.forEach(System.out::print);//ab\nskip\nskip: 返回一个丢弃原Stream的前N个元素后剩下元素组成的新Stream，如果原Stream中包含的元素个数小于N，那么返回空Stream；\n\n1234List&lt;String&gt; list = Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//获取list中top2即截断取前两个List&lt;String&gt; collect1 = list.stream().skip(2).collect(Collectors.toList());collect1.forEach(System.out::print);//c\nsorted\nsorted有两种形式存在：\n\nsorted(Comparator): 指定比较规则进行排序。\nsorted(): 产生一个新流，按照自然顺序排序。\n\n1234List&lt;String&gt; list = Arrays.asList(&quot;b&quot;,&quot;c&quot;,&quot;a&quot;);//获取list中top2即截断取前两个List&lt;String&gt; collect1 = list.stream().sorted().collect(Collectors.toList());collect1.forEach(System.out::print);//abc\nStream的终端操作\n如果说Stream中间操作返回的是Stream，那么终端操作返回的就是最终转换需要返回的结果。\n汇聚操作：\n\nforeach(Consumer c) 遍历操作\ncollect(Collector) 将流转化为其他形式\n\n其中Collectors具体方法有：\n\ntoList List 把流中元素收集到List\ntoSet Set 把流中元素收集到Set\ntoCollection Coolection 把流中元素收集到Collection中\ngroupingBy Map&lt;K,List&gt; 根据K属性对流进行分组\npartitioningBy Map&lt;boolean, List&gt; 根据boolean值进行分组\n\n栗子：\n123456789101112131415161718192021222324//此处只是演示 此类需求直接用List构造器即可List&lt;Student&gt; collect = computerClub.stream().collect(Collectors.toList());Set&lt;Student&gt; collect1 = pingpongClub.stream().collect(Collectors.toSet());//注意key必须是唯一的 如果不是唯一的会报错而不是像普通map那样覆盖Map&lt;String, String&gt; collect2 = pingpongClub.stream()        .collect(Collectors.toMap(Student::getIdNum, Student::getName));//分组 类似于数据库中的group byMap&lt;String, List&lt;Student&gt;&gt; collect3 = pingpongClub.stream()        .collect(Collectors.groupingBy(Student::getClassNum));//字符串拼接 第一个参数是分隔符 第二个参数是前缀 第三个参数是后缀String collect4 = pingpongClub.stream().map(Student::getName).collect(Collectors.joining(&quot;,&quot;, &quot;【&quot;, &quot;】&quot;)); //【小u,小i,小m,小n】//三个俱乐部符合年龄要求的按照班级分组Map&lt;String, List&lt;Student&gt;&gt; collect5 = Stream.of(basketballClub, pingpongClub, computerClub)        .flatMap(e -&gt; e.stream().filter(s -&gt; s.getAge() &lt; 17))        .collect(Collectors.groupingBy(Student::getClassNum));//按照是否年龄&gt;16进行分组 key为true和falseConcurrentMap&lt;Boolean, List&lt;Student&gt;&gt; collect6 = Stream.of(basketballClub, pingpongClub, computerClub)        .flatMap(Collection::stream)        .collect(Collectors.groupingByConcurrent(s -&gt; s.getAge() &gt; 16));\n匹配操作\n\nbooelan allMatch(Predicate) 都符合\nboolean anyMatch(Predicate) 任一元素符合\nboolean noneMatch(Predicate) 都不符合\n\n123boolean b = basketballClub.stream().allMatch(e -&gt; e.getAge() &lt; 20);boolean b1 = basketballClub.stream().anyMatch(e -&gt; e.getAge() &lt; 20);boolean b2 = basketballClub.stream().noneMatch(e -&gt; e.getAge() &lt; 20);\n寻找操作\n\nfindFirst——返回第一个元素\nfindAny——返回当前流中的任意元素\n\n12345678910111213Optional&lt;Student&gt; first = basketballClub.stream().findFirst();if (first.isPresent()) &#123;    Student student = first.get();    System.out.println(student);&#125;Optional&lt;Student&gt; any = basketballClub.stream().findAny();if (any.isPresent()) &#123;    Student student2 = any.get();    System.out.println(student2);&#125;Optional&lt;Student&gt; any1 = basketballClub.stream().parallel().findAny();System.out.println(any1);\n计数和极值\n\ncount 返回流中元素的总个数\nmax(Comparator) 返回流中最大值\nmin(Comparator) 返回流中最小值\n\n123456789long count = basketballClub.stream().count();Optional&lt;Student&gt; max = basketballClub.stream().max(Comparator.comparing(Student::getAge));if (max.isPresent()) &#123;    Student student = max.get();&#125;Optional&lt;Student&gt; min = basketballClub.stream().min(Comparator.comparingInt(Student::getAge));if (min.isPresent()) &#123;    Student student = min.get();&#125;\nFork/Join框架\n上面我们提到过，说Stream的并行模式使用了Fork/Join框架，这里简单说下Fork/Join框架是什么？Fork/Join框架是java7中加入的一个并行任务框架，可以将任务拆分为多个小任务，每个小任务执行完的结果再合并成为一个结果。在任务的执行过程中使用工作窃取（work-stealing）算法，减少线程之间的竞争。\nFork/Join图解：\n\n工作窃取图解:\n\n什么是工作窃取算法？说白了就是多线程同步执行，当一个线程把自己队列任务完成后去“窃取”其他线程队列任务继续干。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。\n最后\n本篇文章大量的图片示例采用了RxJava图示说明，其实RxJava编程思想虽然是响应式编程，但是其操作符转换和流式编程如出一辙，本篇文章主要讲述Stream流式编程的认识和运用，有兴趣的小伙伴可以继续深入了解一下Stream的工作原理。\n","plink":"https://blog.ixin.run/posts/1613575203/"},{"title":"Lambda表达式你会吗","date":"2021-02-17T06:57:18.000Z","date_formatted":{"ll":"2021年2月17日","L":"2021/02/17","MM-DD":"02-17"},"updated":"2021-02-24T13:38:32.879Z","content":"Lambda表达式是Java8的一个新特性，使得Java也能进行简单的函数式编程。臃肿的代码轻量化，实现逻辑突出化，可以取代大部分的匿名内部类，写出更优雅的Java代码，尤其在集合的遍历和其他集合操作中，可以极大地优化代码结构。\n举个简单栗子：\n12345678910//常规匿名写法new Thread(new Runnable() &#123;    @Override    public void run() &#123;        System.out.println(&quot;runnable实现常规写法!&quot;);    &#125;&#125;).start();//Lambda表达式写法new Thread(() -&gt; System.out.println(&quot;runnable实现lambda写法!&quot;)).start();\n怎么样？简单吧，一行搞定！下边我就带着大家一起揭开Lambda表达式神秘的面纱。\n\nJava8新特性系列：\n\n《Lambda表达式你会吗》\n《Stream流式编程知识总结》\n《Stream流式编程实现原理》\n\n为什么用Lambda表达式\n大家知道Java的开山就是OOP思想，即面向对象，无论干什么事总要产生一个对象来调用相应的方法，而Java中有很多匿名内部类，其实现同样离不开OOP思想，所以也避免不了new出来一个对象实现一个方法这样固定的框架，然而匿名内部类使用的主要目的是方法内部逻辑的实现，那些多写几行的框架似乎对于我们这些猴子来说并不想关心。。。\nLambda表达式正式为解决此类问题而生，Lambda表达式属于函数式编程，以往我们函数的入参需要传递一个对象，现在我们可以直接传入一段逻辑，这就直接省去了生成一个对象的不必要写法，简单到一行代码几个字符就可以搞定一个匿名内部类的实现。\n什么时候可以使用Lambda表达式\n虽然使用 Lambda 表达式可以对某些接口进行简单的实现，但并不是所有的接口都可以使用 Lambda 表达式来实现。\n说到这引申出一个概念——“Function Interface（函数式接口）”。函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口，Lambda表达式只能出现在目标类型为函数式接口的上下文中！\n说白了Lambda表达式的目的就是只做一件事，其他花里胡哨的东西不关心，甚至连方法名都不管。\nJDK 1.8 之前已有的函数式接口:\n12345678910java.lang.Runnablejava.util.concurrent.Callablejava.security.PrivilegedActionjava.util.Comparatorjava.io.FileFilterjava.nio.file.PathMatcherjava.lang.reflect.InvocationHandlerjava.beans.PropertyChangeListenerjava.awt.event.ActionListenerjavax.swing.event.ChangeListener\nJDK 1.8 新增了一个库包：java.util.function，里面包含很多常用的函数式接口：\n\nJDK1.8新增函数式接口场景如下：\n12345Consumer: 消费某个对象Predicate: 判断对象是否符合某个条件Function: 实现一个”一元函数“，即传入一个值经过函数的计算返回另一个值Supplier: 接口仅包含一个无参的方法: T get()，用来获取一个泛型参数指定类型的对象数据UnaryOperator: UnaryOperator继承了Function，与Function作用相同，不过UnaryOperator，限定了传入类型和返回类型必需相同。\nLambda表达式的基本组成\nLambda表达式由三部分组成：\n\n形参列表。形参列表允许省略形参类型。如果形参列表中只有一个参数，甚至连形参列表的圆括号也可以省略；\n箭头（-&gt;）。必须通过英文中画线和大于符号组成，读作（goes to）；\n代码块。如果代码块只包含一条语句，Lambda表达式允许省略代码块的花括号；Lambda代码块只有一条return语句，可以省略return关键字；\n\nLambda表达式基础语法\n下边写六个函数式接口来描述Lambda的基础写法\n123456789101112131415161718192021222324252627282930313233343536/**无参无返回值*/@FunctionalInterfacepublic interface NoReturnNoParam &#123;    void method();&#125;/**一个参数无返回*/@FunctionalInterfacepublic interface NoReturnOneParam &#123;    void method(int a);&#125;/**多参数无返回*/@FunctionalInterfacepublic interface NoReturnMultiParam &#123;    void method(int a, int b);&#125;/*** 无参有返回*/@FunctionalInterfacepublic interface ReturnNoParam &#123;    int method();&#125;/**一个参数有返回值*/@FunctionalInterfacepublic interface ReturnOneParam &#123;    int method(int a);&#125;/**多个参数有返回值*/@FunctionalInterfacepublic interface ReturnMultiParam &#123;    int method(int a, int b);&#125;\n下边是Lambda表达式的基本实现：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Test1 &#123;    public static void main(String[] args) &#123;        //无参无返回        NoReturnNoParam noReturnNoParam = () -&gt; &#123;            System.out.println(&quot;NoReturnNoParam&quot;);        &#125;;        noReturnNoParam.method();        //一个参数无返回        NoReturnOneParam noReturnOneParam = (int a) -&gt; &#123;            System.out.println(&quot;NoReturnOneParam param:&quot; + a);        &#125;;        noReturnOneParam.method(6);        //多个参数无返回        NoReturnMultiParam noReturnMultiParam = (int a, int b) -&gt; &#123;            System.out.println(&quot;NoReturnMultiParam param:&quot; + &quot;&#123;&quot; + a +&quot;,&quot; + + b +&quot;&#125;&quot;);        &#125;;        noReturnMultiParam.method(6, 8);        //无参有返回值        ReturnNoParam returnNoParam = () -&gt; &#123;            System.out.print(&quot;ReturnNoParam&quot;);            return 1;        &#125;;        int res = returnNoParam.method();        System.out.println(&quot;return:&quot; + res);        //一个参数有返回值        ReturnOneParam returnOneParam = (int a) -&gt; &#123;            System.out.println(&quot;ReturnOneParam param:&quot; + a);            return 1;        &#125;;        int res2 = returnOneParam.method(6);        System.out.println(&quot;return:&quot; + res2);        //多个参数有返回值        ReturnMultiParam returnMultiParam = (int a, int b) -&gt; &#123;            System.out.println(&quot;ReturnMultiParam param:&quot; + &quot;&#123;&quot; + a + &quot;,&quot; + b +&quot;&#125;&quot;);            return 1;        &#125;;        int res3 = returnMultiParam.method(6, 8);        System.out.println(&quot;return:&quot; + res3);    &#125;&#125;\nLambda表达式语法简化\n上边的六个例子是lambda的基本实现，当然还不够精简，接下来由浅入深通过四种简化方式简化一下：\n123456789101112131415161718192021222324252627public class Test2 &#123;    public static void main(String[] args) &#123;        //1.简化参数类型，可以不写参数类型，但是必须所有参数都不写        NoReturnMultiParam lamdba1 = (a, b) -&gt; &#123;            System.out.println(&quot;简化参数类型&quot;);        &#125;;        lamdba1.method(1, 2);        //2.简化参数小括号，如果只有一个参数则可以省略参数小括号        NoReturnOneParam lambda2 = a -&gt; &#123;            System.out.println(&quot;简化参数小括号&quot;);        &#125;;        lambda2.method(1);        //3.简化方法体大括号，如果方法条只有一条语句，则可以省略方法体大括号        NoReturnNoParam lambda3 = () -&gt; System.out.println(&quot;简化方法体大括号&quot;);        lambda3.method();        //4.如果方法体只有一条语句，并且是 return 语句，则可以省略方法体大括号和return关键字        ReturnOneParam lambda4 = a -&gt; a+3;        System.out.println(lambda4.method(5));        ReturnMultiParam lambda5 = (a, b) -&gt; a+b;        System.out.println(lambda5.method(1, 1));    &#125;&#125;\nLambda表达式方法引用简化\n方法引用简化\n有时候已经有其他方法实现了函数接口的方法了，那么我们可以直接引用此方法代替函数接口的实现方法，常见的引用形式有以下语法：\n123静态方法引用：ClassName::methodName实例方法引用：object::methodName超类方法引用：super::methodName\n例如：\n1234567891011121314151617181920212223242526272829public class Exe1 &#123;    public static void main(String[] args) &#123;        ReturnOneParam lambda1 = a -&gt; doubleNum(a);        System.out.println(lambda1.method(3));        //lambda2 引用了已经实现的 doubleNum 方法        ReturnOneParam lambda2 = Exe1::doubleNum;        System.out.println(lambda2.method(3));        Exe1 exe = new Exe1();        //lambda4 引用了已经实现的 addTwo 方法        ReturnOneParam lambda4 = exe::addTwo;        System.out.println(lambda4.method(2));    &#125;    /**     * 要求     * 1.参数数量和类型要与函数接口中定义的一致     * 2.返回值类型要与函数接口中定义的一致     */    public static int doubleNum(int a) &#123;        return a * 2;    &#125;    public int addTwo(int a) &#123;        return a + 2;    &#125;&#125;\nExe1中有两个方法，方法的入参和返回值均和函数接口中定义一直，那么这些方法我们可以直接拿来引用，使用形式方法归属者::方法名，入参和返回都不需要显式展现。\n构造方法简化\n一般我们需要声明接口，该接口作为对象的生成器，通过 类名::new 的方式来实例化对象，然后调用方法返回对象。构造方法简化的语法形式和方法引用简化一样：\n12构造方法引用：ClassName::new数组构造引用：TypeName[]::new\n例如：\n12345678910111213141516171819interface ItemCreatorBlankConstruct &#123;    Item getItem();&#125;interface ItemCreatorParamContruct &#123;    Item getItem(int id, String name, double price);&#125;public class Exe2 &#123;    public static void main(String[] args) &#123;        ItemCreatorBlankConstruct creator = () -&gt; new Item();        Item item = creator.getItem();        ItemCreatorBlankConstruct creator2 = Item::new;        Item item2 = creator2.getItem();        ItemCreatorParamContruct creator3 = Item::new;        Item item3 = creator3.getItem(112, &quot;鼠标&quot;, 135.99);    &#125;&#125;\n最后\n相信看到这基本上对Lambda的使用有一定了解了吧，至于网上说Lambda的几个用法：\n\n集合迭代\n集合元素删除\n集合排序\nmap转换\nfilter过滤\n\n等等，这些其实不属于Lambda的范畴，更多的是java函数属性高级使用，或者是java8新特性的一些高级使用，只不过通过Lambda表达式更加逼格化而已，好了，Lambda深入就到此为止，有时间大伙可以了解以下Java8的流式编程再结合本篇你将受益更多。\n参考\n\nhttps://www.runoob.com/java/java8-functional-interfaces.html\nhttps://www.runoob.com/java/java8-method-references.html\nhttps://segmentfault.com/a/1190000012269548\nhttps://www.cnblogs.com/haixiang/p/11029639.html\n\n","plink":"https://blog.ixin.run/posts/1613545058/"},{"title":"玩转响应式编程RxJava【更新中...】","date":"2021-02-17T02:37:38.000Z","date_formatted":{"ll":"2021年2月17日","L":"2021/02/17","MM-DD":"02-17"},"updated":"2021-02-24T10:27:30.308Z","content":"","plink":"https://blog.ixin.run/posts/1613529505/"},{"title":"属于我们的0214","date":"2021-02-14T06:56:32.000Z","date_formatted":{"ll":"2021年2月14日","L":"2021/02/14","MM-DD":"02-14"},"updated":"2021-03-03T05:20:37.289Z","content":"我是个俗人，爱吃火锅，爱喝奶茶，你呢？\n\n\nU2FsdGVkX199Libx2BN3CCoFDujAHdXQgWojJg0QHfopdL9aRs+WYHYdwuugY4nT+KgRrD3xnEr5WejZmkN2KqUrkt7ghwL/Md10YsFjh1U=","thumbnail":"https://i.pinimg.com/originals/8f/b9/fb/8fb9fbf71e8b86930ffd81f6982479c0.gif","plink":"https://blog.ixin.run/posts/1613285792/"},{"title":"Java多态小记","date":"2021-02-07T16:14:49.000Z","date_formatted":{"ll":"2021年2月8日","L":"2021/02/08","MM-DD":"02-08"},"updated":"2021-02-24T10:27:30.305Z","content":"Java三大特性：封装、继承和多态，随口就能说出，至于封装和继承太简单了，多态似乎有点迷糊，可以说多态就是封装和继承的组合体，今天回顾一下多态的知识。\n\n多态解释\n多态是同一个行为具有多个不同表现形式或形态的能力。\n\n实现形式\n\n实现同一个接口，不同的实例，相同的动作，干不一样的事。\n继承同一个父类，重写父类方法，干不同的事。\n\n多态的优点\n\n消除类型之间的耦合关系\n可替换性\n可扩充性\n接口性\n灵活性\n简化性\n\n直接的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。\n多态存在的三个必要条件\n\n继承\n重写\n父类引用指向子类对象：Parent p = new Child();\n\n多态注意点\n当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。\n一个栗子\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Test &#123;\tstatic class A &#123;\t\tpublic String show(D obj) &#123;\t\t\treturn (&quot;A and D&quot;);\t\t&#125;    \t\tpublic String show(A obj) &#123;\t\t\treturn (&quot;A and A&quot;);\t\t&#125;\t&#125;    \tstatic class B extends A &#123;\t\tpublic String show(B obj) &#123;\t\t\treturn (&quot;B and B&quot;);\t\t&#125;\t\tpublic String show(A obj) &#123;\t\t\treturn (&quot;B and A&quot;);\t\t&#125;\t&#125;\tstatic class C extends B &#123;\t&#125;\tstatic class D extends B &#123;\t&#125;\tpublic static void main(String[] args) &#123;\t\tA a1 = new A();          A a2 = new B();          B b = new B();          C c = new C();           D d = new D();         System.out.println(a1.show(b));           System.out.println(a1.show(c));            System.out.println(a1.show(d));            System.out.println(a2.show(b));            System.out.println(a2.show(c));            System.out.println(a2.show(d));            System.out.println(b.show(b));             System.out.println(b.show(c));             System.out.println(b.show(d));       \t&#125;&#125;\n结果：\n123456789A and AA and AA and DB and AB and AA and DB and BB and BA and D\n对于上边的例子，我们只需要记住两点即可：\n\n对于A a2 = new B()；必须是A父B子或者A接口B实现类，意思是生成一个具有A性质的B。方法的调用也是只能调用A里面的方法，除非B中重写的该方法，则可以调用B中的该方法。变量的引用也是只能引用A中的变量。\n对于B b = new B()；则可以理解就是生成一个B对象，等同于直接new B()。方法的调用则是父类A中有所调用的方法就调用A的，B中有所调用的方法则调用B的，B中有重写A中的方法还是调用B中的。变量的引用也如此，只要是公有的都可以引用。\n\n","plink":"https://blog.ixin.run/posts/1612714489/"},{"title":"Jenkins自动化构建（一）玩转Android项目自动化打包","date":"2021-01-31T12:56:15.000Z","date_formatted":{"ll":"2021年1月31日","L":"2021/01/31","MM-DD":"01-31"},"updated":"2021-02-02T12:27:34.089Z","content":"早些年Eclipse时代Android打包采用的ant，现在AndroidStudio时代采用的Gradle，目前的开发模式都是采用敏捷开发，如果仍采用手动打包给QA提测未免太耽误事了，目前众多公司采用的是自动化打包策略+自动化测试，本文是Jenkins自动化构建的第一篇，玩转Android项目的自动化打包，来自早些时候个人整理的有道云笔记，不对之处请指出。前方高能，巨图众多！\n\njenkins工作流程\n\njenkins安装\n一般公司自动化构建都会将jenkins配置到Tomcat下，无论是jenkins还是tomcat都需要jdk。\n准备工作\n1.Java jdk下载\njava jdk下载、安装、配置环境变量，安装过程忽略。\n2.Tomcat下载\ntomcat下载，安装，配置环境变量，安装过程忽略。\n需要注意，tomcat默认端口8080，此端口很容易被其他服务占用，可根据自己需求修改tomcat端口号。\n3.jenkins下载\njenkins下载有多种类型，主要看当前的系统环境。一般我们选war包形式下载，后续结合tomcat进行安装。\n\njenkins安装\n这里还是以war包结合tomcat来说，安装过程很简单，直接放到tomcat根目录webapps下，tomcat启动时会自动解压出一个jenkins文件夹。\njenkins home位置修改\njenkins安装后默认在C盘User下会生成个工作区（.jenkins），将来的插件、配置，以及创建的jobo都在此文件夹下，默认是不需要环境变量的，但是有些时候我们需要将此文件夹放到一个安全的位置，防止系统损坏或者重装系统这些配置丢失。这个时候就要修改工作区的环境变量了。\n\njenkins启动\n启动tomcat， 输入jenkins的服务器地址http://xxx.xxx.xxx.xxx:8080/jenkins/，一路下来按照提示进行操作，设置root用户信息，安装相关插件（刚开始不建议完全安装推荐的插件，可以选择跳过，你也可以看一下推荐的插件有哪些，选择性安装），然后就回到主页了：\n\n安装插件\n汉化: Localization: Chinese (Simplified)\n问题：jenkins无法安装插件\n找到插件管理最后一项：\n\n滑到最下边找到Upload Site，将默认的https改为http，保存修改：http://updates.jenkins-ci.org/update-center.json\n\n如果一直下载失败，可全局开启vpn（个人建议），当然也可以将上边的地址切换为国内镜像：\nhttp://mirror.xmission.com/jenkins/updates/current/update-center.json\njenkins角色配置\n1. 添加用户\n路径：Manage Jenkins-&gt;Manage Users\n\n默认是你自己的超级用户root，你可以在此处添加第二个，第三个用户。\n2. 设置用户权限\n2.1 安装插件\nRole-based Authorization Strategy\n2.2 授权策略\n路径：Manage Jenkins-&gt;Configure Global Security\n\n保存。\n2.3 角色管理和分配角色\n路径：Manage Jenkins-&gt;Manage and Assign Roles\n\n\n管理角色：就是把角色分一下类，例如超级管理员有哪些、QA有哪些、普通用户有哪些。\n分配角色：就是把上边的角色分配到个人。\n\n2.3.1 管理角色\n\n这里配置三种权限角色：管理员模式、普通模式和匿名模式（Anonymous），配置项如上，将来普通模式可以分配给QA供打包测试，匿名模式可以分配给不登录模式下查看项目，当然如果有别的角色需要我们还可以再进行添加。\n2.3.2 分配角色\n\n这一步就是将权限分配到个人，Anonymous分配匿名模式下的权限。\n以上只是基本的，我们还可以实现某人可以看到某些项目，或者针对某个项目有固定的权限等，这里就不说了。\n简单了解系统设置\n使用Html展示消息\n1.安装插件\nOWASP Markup Formatter Plugin\n2.标记格式器\n路径：Manage Jenkins-&gt;Configure Global Security\n\n3.添加Html通知体\n\n创建项目\n安装插件：\n\nGit，因为我们的代码是git管理的。\nGradle\n\n配置构建环境\n配置JDK、Git、Gradle相关变量，路径：Manage Jenkins-&gt;Global Tool Configuration\n\n准备创建项目\n1.创建项目\n\n2.设置源码源\n\n这里的凭据，如果项目地址在域里面，并且登录人是域用户，可以不用设置凭据了。\n3.设置Gradle构建\n\n主要关注两点:\n\ngradle版本：建议和项目gradle版本保持一致。\n设置gradle打包命令，图上给的只是简单的。\n\n123clean：每次构建前clean一下项目；assembleDebug：构建debug包-stacktrace-debug：输出日志栈，打印日志信息。\n更多gradle打包命令，可以进行百度，这里就不多说了。\n4.构建后操作\n\n构建后主要用于打包产物的输出、存档。\n\n选择Archive the artifacts，匹配构建后的输出产物。\n打包后我们会在项目首页看到最后一次构建成功后产物的归档。\n\n5.项目构建\n回到项目首页，点击Build Now，即可看到构建过程：\n\n点击构建条，进到项目中可以查看日志输出：\n\n6.自动清除历史构建\n\n参数化构建\n下载插件：\n\nBuild With Parameters\nPersistent Parameter\n\n说明：安装Build With Parameters Plugin为了实现参数化构建，安装Persistent Parameter Plugin为了实现构建时默认参数值取自上次构建的参数(当然如果要实现该功能，应该需要添加该插件对应的参数)\n\n1. 设置构建类型\n选择Choice Parameter\n\n在gradle构建类型地方进行替换\n\n2. 设置构建分支\n选择Git Parameter\n\n在源码管理的地方进行替换\n\n当然你也可以选择Choice Parameter，类似设置构建类型一样，自己发挥咯。我自己就是用这种方式实现的。\n放一张主页的截图：\n\n展示二维码\n为了展示二维码，需要知道二维码存放的具体路径，然后二维码的扫描出来的结果必须是apk的具体路径，所以需要经过以下几步：\n\n将构建后的apk重命名，方便生成二维码（明确将来的apk存放地址）\n将构建生成的apk，拷贝到服务器具体路径下，我这里的服务器就是我本机。\n根据apk的服务器路径生成二维码，并存放在服务器某个位置。\n\n生成二维码需要用到二维码生成库包，我这里分享一个：\nQRCode.jar\n生成二维码的命令：\n1java -jar [存放生成jar包的路径&#x2F;QRCode.jar] url&#x3D;[二维码扫描结果字符串] image&#x3D;[二维码的名字.jpg] save&#x3D;[二维码存放的位置]\nwindow脚本\n1.我们按照上边的过程将其写成window脚本命令，打开window batch command窗口\n\n2.输入脚本内容：\n12345678910set buildApk=app\\build\\outputs\\apk\\%BuildFlavor%\\%BuildType%\\*.apkset apkName=ehistore_%BuildBranch%_%BuildFlavor%_%BuildType%_%BUILD_ID%set jenkinsBuildDir=F:\\Workspaces\\project_other\\tomcat-8.5.39\\webapps\\jenkins_buildset jenkinsBuildResDir=%jenkinsBuildDir%\\resset jenkinsBuildApkDir=%jenkinsBuildDir%\\apksset apkDownLoadUrl=http://192.xxx.x.xxx:8080/jenkins_build/apks/%apkName%.apkren %buildApk% %apkName%.apkcopy %buildApk% %jenkinsBuildApkDir%java -jar %jenkinsBuildResDir%\\QRCode.jar url=%apkDownLoadUrl% image=%apkName%.jpg save=%jenkinsBuildApkDir%\n3.下载插件：Build Name and Description Setter\n该插件主要用于修改构建名字和构建描述展示，利用描述内容我们来展示二维码。\n添加插件部件：\n\nChanges build description添加描述内容：\n1&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;192.xxx.x.xxx:8080&#x2F;jenkins_build&#x2F;apks&#x2F;ehistore_$&#123;BuildBranch&#125;_$&#123;BuildFlavor&#125;_$&#123;BuildType&#125;_$&#123;BUILD_ID&#125;.jpg&quot; height&#x3D;&quot;180&quot; width&#x3D;&quot;180&quot;&#x2F;&gt;\n4.具体设置如下\n\n生成效果如下：\n\n最后\n本文主要带你玩转Jenkins中实现Android项目自动化打包，这是第一篇，后续还有二、三篇，如果喜欢顺便点赞+关注哦\n","plink":"https://blog.ixin.run/posts/1612097829/"},{"title":"GitHub Pages你了解多少","date":"2021-01-31T09:14:14.000Z","date_formatted":{"ll":"2021年1月31日","L":"2021/01/31","MM-DD":"01-31"},"updated":"2021-02-01T11:34:21.322Z","content":"自建Blog的小朋友估计都知道GitHub Pages吧，因为据我了解程序员第一次自建博客都选的是GitHub，因为可以撸免费的空间、撸免费的GitHub专属域名，还可以提高一些GitHub的活跃度，毕竟这里才是我们真男人的天堂，哈哈，这些羊毛足够暖和一阵子了。但是我发现大部分小朋友的站点仅仅停留在xxx.github.io这个链接下，本篇文章我就带你简单了解一下GitHub Pages多余的认识，同样是来自早期的一篇个人笔记。\n\n第一次接触GitHub Pages\n开篇说过，如果你是自建Blog新手，极其想建一个自己的网站，哪怕只有一篇文章，只要通过一个链接能打开就行，那你就选GitHub就对了。\n我们在GitHub上新建一个仓库，仓库名必须是xxx.github.io，其中的xxx是你的github的用户名，例如我的就是ixinrun.github.io（打不开哦，因为我没有建这个项目），然后此项目下放置一个index.html，随便写上一些话我要向xxx表白，对，是那个女孩，我喜欢她好久了...。好了现在你的个人网站已经搭建好了，现在只需要在该仓库Settings找到Github Pages将其开启即可：\n\n然后悄悄的把xxx.github.io这个链接发给你的那个女孩，其他话都不要说了哦，慢慢等消息咯，嘿嘿😘\n上边仓库名为什么一定要写成xxx.github.io呢，因为这是你GitHub网站的门户，相当于一级域名下的首页。其实每个仓库下都可以开启GitHub Pages，但是其他仓库Github Pages的链接都是xxx.github.io的子页面，例如现在再有一个仓库projects，那么开启GitHub Pages后的链接地址就是xxx.github.io/projects。\nGithub Pages种类\nUserPage: 用户的整个站点下的门户，创建一个形如username.github.io的项目就可以了。\nProjectPage: 用户创建出来的其他项目也可以创建站点。\nUserPage默认域名\n用户站点的默认域名是username.github.io,\n比如笔者的早期的站点就是ixinrun.github.io\nProjectPage默认域名\n项目的默认域名,是使用UserPage域名加上二级目录实现的, 比如笔者有个项目叫blog，那么该项目的站点就是访问ixinrun.github.io/blog。\nUserPage自定义域名\n我有自己的域名, 如何绑定到UserPage? 比如用www.ixin.run替代ixinrun.github.io，这里使用CNAME技术来实现的。\n具体步骤:\n去域名注册商那里, 做一个CNAME指向, 将www.ixin.run 指向 ixinrun.github.io,\n在ixinrun/ixinrun.github.io这个项目(也就是page项目)根目录下建一个CNAME文件, 里面填写www.ixin.run, 然后提交到仓库;\n等10分钟\nCNAME指向之后, 当浏览器访问www.ixin.run的时候浏览器就知道实际上是访问ixinrun.github.io这个地址。\n添加CNAME文件之后, 当GithubPage服务器接收到访问www.ixin.run的http请求, 就知道, 对应的是这个工程了。\nProjectPage自定义域名\n比如用blog.ixin.run替代ixinrun.github.io/blog\n同样的, 去域名注册商那里, 做一个CNAME指向, 将blog.ixin.run 指向 ixinrun.github.io, 如果以后会有很多二级域名都指过来, 其实可以做一个模糊二级指过来, 比如*.ixin.run\n在ixinrun/blog这个项目(也就是page项目)根目录下建一个CNAME文件, 里面填写blog.ixin.run, 然后提交到仓库;\n等10分钟\n最后\nGitHub Pages非常适合新手练手，常用于流量小的个人博客或者笔记建设，如果建大站，吸引大流量的话还是不建议了，毕竟GitHub在国外，慢不用说，还禁止某度的蜘蛛爬取，所以需要另谋塔门，阿里云、腾讯云是不错的选择。最后，欢迎访问个人小站：https://ixin.run\n","plink":"https://blog.ixin.run/posts/1612084454/"},{"title":"Android组件化全面掌握【转载】","date":"2021-01-30T18:23:07.000Z","date_formatted":{"ll":"2021年1月31日","L":"2021/01/31","MM-DD":"01-31"},"updated":"2021-02-01T11:34:21.321Z","content":"门店项目从我来公司的MVC都不是的模式到如今的组件化实现，服务着全国4千多家门店使用，中间开发过程也是摸索着不断学习不断调优，一直想写一篇项目重构到组件化的过程，前天偶然看到鸿洋大佬公众号转载的由胡飞洋写的一篇《“终于懂了” 系列：Android组件化，全面掌握！》这篇文章，与门店重构过程不谋而合，这里我就做一个拿来主义转载一下，记录一下相关的知识点。\n\n\n本文转载自胡飞洋同学的《“终于懂了” 系列：Android组件化，全面掌握！》，文章原文地址：https://juejin.cn/post/6881116198889586701\n\n1 背景\n随着项目逐渐扩展，业务功能越来越多，代码量越来越多，开发人员数量也越来越多。此过程中，你是否有过以下烦恼？\n\n项目模块多且复杂，编译一次要5分钟甚至10分钟？太慢不能忍？\n改了一行代码 或只调了一点UI，就要run整个项目，再忍受一次10分钟？\n合代码经常发生冲突？很烦？\n被人偷偷改了自己模块的代码？很不爽？\n做一个需求，发现还要去改动很多别人模块的代码？\n别的模块已实现的类似功能，自己要用只能去复制一份代码再改改？\n“这个不是我负责的，我不管”，代码责任范围不明确？\n只做了一个模块的功能，但改动点很多，所以要完整回归测试？\n做了个需求，但不知不觉导致其他模块出现bug？\n\n如果有这些烦恼，说明你的项目需要进行 组件化 了。\n\n上半年，我所在项目进行了大重构，也完成了组件化改造。所以终于学习实践了这样一个“高端知识”，也看了一些文章，于是就有了这篇文章来作为总结和分享~\n\n2 组件化的理解\n2.1 模块化\n在介绍组件化之前，先说说模块化。我们知道在Android Studio中，新建工程默认有一个App module，然后还可以通过File-&gt;New-&gt;New Module新建module。那么这里的“module” 实际和我们说的“模块”基本是一个概念了。\n也就是说，原本一个App模块承载了所有的功能，而模块化就是拆分成多个模块放在不同的Module里面，每个功能的代码都在自己所属的 module 中添加。\n已京东为例，大致可以分为“首页”、“分类”、“发现”、“购物车”、“我的”、“商品详情” 六个模块。\n\n项目结构如下：\n\n这是一般项目都会采用的结构。另外通常还会有一个通用基础模块module_common，提供BaseActivity/BaseFragment、图片加载、网络请求等基础能力，然后每个业务模块都会依赖这个基础模块。\n那么业务模块之间有没有依赖呢？很显然是有的。例如“首页”、“分类”、“发现”、“购物车”、“我的”，都是需要跳转到“商品详情”的，必然是依赖“商品详情”；而“商品详情”是需要能添加到“购物车”能力的；而“首页”点击搜索显然是“分类”中的搜索功能。所以这些模块之间存在复杂的依赖关系。\n\n模块化 在各个业务功能比较独立的情况下是比较合理的，但多个模块中肯定会有页面跳转、数据传递、方法调用等情况，所以必然存在以上这种依赖关系，即模块间有着高耦合度。\n高耦合度加上代码量大，就极易出现上面提到的那些问题了，严重影响了团队的开发效率及质量。\n为了解决模块间的高耦合度问题，就要进行组件化了。\n2.2 组件化介绍 — 优势及架构\n组件化，去除模块间的耦合，使得每个业务模块可以独立当做App存在，对于其他模块没有直接的依赖关系。 此时业务模块就成为了业务组件。\n而除了业务组件，还有抽离出来的业务基础组件，是提供给业务组件使用，但不是独立的业务，例如分享组件、广告组件；还有基础组件，即单独的基础功能，与业务无关，例如 图片加载、网络请求等。这些后面会详细说明。\n组件化带来的好处 就显而易见了：\n\n加快编译速度：每个业务功能都是一个单独的工程，可独立编译运行，拆分后代码量较少，编译自然变快。\n提高协作效率：解耦使得组件之间彼此互不打扰，组件内部代码相关性极高。团队中每个人有自己的责任组件，不会影响其他组件；降低团队成员熟悉项目的成本，只需熟悉责任组件即可；对测试来说，只需重点测试改动的组件，而不是全盘回归测试。\n功能重用：组件 类似我们引用的第三方库，只需维护好每个组件，一建引用集成即可。业务组件可上可下，灵活多变；而基础组件，为新业务随时集成提供了基础，减少重复开发和维护工作量。\n\n下图是我们期望的组件化架构：\n\n\n组件依赖关系是上层依赖下层，修改频率是上层高于下层。\n基础组件是通用基础能力，修改频率极低，作为SDK可共公司所有项目集成使用。\ncommon组件，作为支撑业务组件、业务基础组件的基础（BaseActivity/BaseFragment等基础能力），同时依赖所有的基础组件，提供多数业务组件需要的基本功能，并且统一了基础组件的版本号。所以 业务组件、业务基础组件 所需的基础能力只需要依赖common组件即可获得。\n业务组件、业务基础组件，都依赖common组件。但业务组件之间不存在依赖关系，业务基础组件之间不存在依赖关系。而 业务组件 是依赖所需的业务基础组件的，例如几乎所有业务组件都会依赖广告组件 来展示Banner广告、弹窗广告等。\n最上层则是主工程，即所谓的“壳工程”，主要是集成所有的业务组件、提供Application唯一实现、gradle、manifest配置，整合成完备的App。\n\n2.3 组件化开发的问题点\n我们了解了组件化的概念、优点及架构特点，那么要想实施组件化，首先要搞清楚 要解决问题点有哪些？\n核心问题是 业务组件去耦合。那么存在哪些耦合的情况呢？前面有提到过，页面跳转、方法调用、事件通知。而基础组件、业务基础组件，不存在耦合的问题，所以只需要抽离封装成库即可。所以针对业务组件有以下问题：\n\n业务组件，如何实现单独运行调试？\n业务组件间 没有依赖，如何实现页面的跳转？\n业务组件间 没有依赖，如何实现组件间通信/方法调用？\n业务组件间 没有依赖，如何获取fragment实例？\n业务组件不能反向依赖壳工程，如何获取Application实例、如何获取Application onCreate()回调（用于任务初始化）？\n\n下面就来看看如何解决这些问题。\n3 组件独立调试\n每个业务组件都是一个完整的整体，可以当做独立的App，需要满足单独运行及调试的要求，这样可以提升编译速度提高效率。\n如何做到组件独立调试呢？有两种方案：\n\n\n单工程方案，组件以module形式存在，动态配置组件的工程类型；\n\n\n多工程方案，业务组件以library module形式存在于独立的工程，且只有这一个library module。\n\n\n3.1 单工程方案\n3.1.1 动态配置组件工程类型\n单工程模式，整个项目只有一个工程，它包含：App module 加上各个业务组件module，就是所有的代码，这就是单工程模式。如何做到组件单独调试呢？\n我们知道，在AndroidStudio开发Android项目时，使用的是Gradle 来构建，Android Gradle中提供了两种插件，在开发中可以通过配置不同的插件来配置不同的module类型。\n\nApplication插件，id: com.android.application\nLibrary插件，id: com.android.library\n\n区别比较简单，Application插件来配置一个Android App工程，项目构建后输出一个APK安装包，Library插件来配置一个Android Library工程，构建后输出AAR包。\n\n\n显然我们的 App module配置的就是Application插件，业务组件module 配置的是Library插件。想要实现业务组件的独立调试，这就需要把配置改为 Application插件；而独立开发调试完成后，又需要变回Library 插件进行集成调试。\n我们知道用AndroidStudio创建一个Android项目后，会在根目录中生成一个gradle.properties文件。在这个文件定义的常量，可以被任何一个build.gradle读取。\n所以我们可以在gradle.properties中定义一个常量值 isModule，true为即独立调试；false为集成调试。然后在业务组件的build.gradle中读取isModule，设置成对应的插件即可。代码如下：\n1234567891011//gradle.properties#组件独立调试开关, 每次更改值后要同步工程isModule = false复制代码//build.gradle//注意gradle.properties中的数据类型都是String类型，使用其他数据类型需要自行转换if (isModule.toBoolean())&#123;    apply plugin: &#x27;com.android.application&#x27;&#125;else &#123;    apply plugin: &#x27;com.android.library&#x27;&#125;\n3.1.2 动态配置ApplicationId 和 AndroidManifest\n我们知道一个App是需要一个ApplicationId的 ，而组件在独立调试时也是一个App，所以也需要一个ApplicationId，集成调试时组件是不需要ApplicationId的；另外一个APP也只有一个启动页， 而组件在独立调试时也需要一个启动页，在集成调试时就不需要了。\n所以ApplicationId、AndroidManifest也是需要isModule来进行配置的。\n123456789101112131415161718192021222324//build.gradle (module_cart)android &#123;...    defaultConfig &#123;...        if (isModule.toBoolean()) &#123;            // 独立调试时添加 applicationId ，集成调试时移除            applicationId &quot;com.hfy.componentlearning.cart&quot;        &#125;...    &#125;    sourceSets &#123;        main &#123;            // 独立调试与集成调试时使用不同的 AndroidManifest.xml 文件            if (isModule.toBoolean()) &#123;                manifest.srcFile &#x27;src/main/moduleManifest/AndroidManifest.xml&#x27;            &#125; else &#123;                manifest.srcFile &#x27;src/main/AndroidManifest.xml&#x27;            &#125;        &#125;    &#125;...&#125;\n可见也是使用isModule分别设置applicationId、AndroidManifest。其中独立调试的AndroidManifest是新建于目录moduleManifest，使用 manifest.srcFile 即可指定两种调试模式的AndroidManifest文件路径。\n\nmoduleManifest中新建的manifest文件 指定了Application、启动activity：\n12345678910111213141516//moduleManifest/AndroidManifest.xml&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    package=&quot;com.hfy.module_cart&quot; &gt;    &lt;application android:name=&quot;.CartApplication&quot;        android:allowBackup=&quot;true&quot;        android:label=&quot;Cart&quot;        android:theme=&quot;@style/Theme.AppCompat&quot;&gt;        &lt;activity android:name=&quot;.CartActivity&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;&#125;\n原本自动生成的manifest，未指定Application、启动activity：\n1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    package=&quot;com.hfy.module_cart&quot;&gt;    &lt;application&gt;        &lt;activity android:name=&quot;.CartActivity&quot;&gt;&lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;\n独立调试、集成调试 ，分别使用“assembleDebug”构建结果如下：\n\n3.2 多工程方案\n3.2.1 方案概述\n多工程方案，业务组件以library module形式存在于独立的工程。独立工程 自然就可以独立调试了，不再需要进行上面那些配置了。\n例如，购物车组件就是新建的工程Cart的module_cart模块，业务代码就写在module_cart中即可。app模块是依赖module_cart。app模块只是一个组件的入口，或者是一些demo测试代码。\n\n那么当所有业务组件都拆分成独立组件时，原本的工程就变成一个只有app模块的壳工程了，壳工程就是用来集成所有业务组件的。\n3.2.1 maven引用组件\n那么如何进行集成调试呢？使用maven引用组件：\n\n发布组件的aar包 到公司的maven仓库。\n然后在壳工程中就使用implemention依赖就可以了，和使用第三方库一毛一样。\n\n另外aar包 分为 快照版本（SNAPSHOT）和正式版本（Realease），快照版本是开发阶段调试使用，正式版本是正式发版使用。具体如下：\n首先，在module_cart模块中新建maven_push.gradle文件，和build.gradle同级目录\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455apply plugin: &#x27;maven&#x27;configurations &#123;    deployerJars&#125;repositories &#123;    mavenCentral()&#125;//上传到Maven仓库的taskuploadArchives &#123;    repositories &#123;        mavenDeployer &#123;            pom.version = &#x27;1.0.0&#x27; // 版本号            pom.artifactId = &#x27;cart&#x27; // 项目名称（通常为类库模块名称，也可以任意）            pom.groupId = &#x27;com.hfy.cart&#x27; // 唯一标识（通常为模块包名，也可以任意）            //指定快照版本 maven仓库url， todo 请改为自己的maven服务器地址、账号密码            snapshotRepository(url: &#x27;http://xxx/maven-snapshots/&#x27;) &#123;                authentication(userName: &#x27;***&#x27;, password: &#x27;***&#x27;)            &#125;            //指定正式版本 maven仓库url， todo 请改为自己的maven服务器地址、账号密码            repository(url: &#x27;http://xxx/maven-releases/&#x27;) &#123;                authentication(userName: &#x27;***&#x27;, password: &#x27;***&#x27;)            &#125;        &#125;    &#125;&#125;// type显示指定任务类型或任务, 这里指定要执行Javadoc这个task,这个task在gradle中已经定义task androidJavadocs(type: Javadoc) &#123;    // 设置源码所在的位置    source = android.sourceSets.main.java.sourceFiles&#125;// 生成javadoc.jartask androidJavadocsJar(type: Jar) &#123;    // 指定文档名称    classifier = &#x27;javadoc&#x27;    from androidJavadocs.destinationDir&#125;// 打包main目录下代码和资源的task，生成sources.jartask androidSourcesJar(type: Jar) &#123;    classifier = &#x27;sources&#x27;    from android.sourceSets.main.java.sourceFiles&#125;//配置需要上传到maven仓库的文件artifacts &#123;    archives androidSourcesJar    archives androidJavadocsJar&#125;\nmaven_push.gradle主要就是发布组件AAR的配置：AAR的版本号、名称、maven仓地址账号等。\n然后，再build.gradle中引用：\n12&#x2F;&#x2F;build.gradleapply from: &#39;maven_push.gradle&#39;\n接着，点击Sync后，点击Gradle任务uploadArchives，即可打包并发布aar到maven仓。\n\n最后，壳工程要引用组件AAR，需要先在壳工程的根目录下build.gradle中添加maven仓库地址：\n12345678910allprojects &#123;    repositories &#123;        google()        jcenter()        //私有服务器仓库地址        maven &#123;            url &#x27;http://xxx&#x27;        &#125;    &#125;&#125;\n接着在app的build.gradle中添加依赖即可：\n12345dependencies &#123;    ...    implementation &#x27;com.hfy.cart:cart:1.0.0&#x27;    //以及其他业务组件&#125;\n可见，多工程方案 和我们平时使用第三方库是一样的，只是我们把组件AAR发布到公司的私有maven仓而已。\n实际上，我个人比较建议 使用多工程方案的:\n\n单工程方案没法做到代码权限管控，也不能做到开发人员职责划分明确，每个开发人员都可以对任意的组件进行修改，显然还是会造成混乱。\n多工程把每个组件都分割成单独的工程，代码权限可以明确管控。集成测试时，通过maven引用来集成即可。并且业务组件和业务基础组件也可以 和 基础组件一样，可以给公司其他项目复用。\n\n4 页面跳转\n4.1 方案—ARouter\n前面说到，组件化的核心就是解耦，所以组件间是不能有依赖的，那么如何实现组件间的页面跳转呢？\n例如在首页模块点击购物车按钮需要跳转到购物车模块的购物车页面，两个模块之间没有依赖，也就说不能直接使用显示启动来打开购物车Activity，那么隐式启动呢？\n隐式启动是可以实现跳转的，但是隐式 Intent 需要通过 AndroidManifest 配置和管理，协作开发显得比较麻烦。这里我们采用业界通用的方式—路由。\n比较著名的路由框架 有阿里的ARouter、美团的WMRouter，它们原理基本是一致的。\n\nhttps://github.com/alibaba/ARouter\nhttps://github.com/meituan/WMRouter\n\n这里我们采用使用更广泛的ARouter：“一个用于帮助 Android App 进行组件化改造的框架 —— 支持模块间的路由、通信、解耦”。\n4.2 ARouter实现路由跳转\n前面提到，所有的业务组件都依赖了 Common 组件，所以我们在 Common 组件中使用关键字“api”添加的依赖，业务组件都能访问。我们要使用 ARouter 进行界面跳转，需要Common组件添加Arouter的依赖（另外，其它组件共同依赖的库也要都放到 Common 中统一依赖）。\n4.2.1 引入依赖\n因为ARouter比较特殊，“arouter-compiler ” 的annotationProcessor依赖 需要所有使用到 ARouter 的组件中都单独添加，不然无法在 apt 中生成索引文件，就无法跳转成功。\n并且在每个使用到 ARouter 的组件的 build.gradle 文件中，其 android{} 中的 javaCompileOptions 中也需要添加特定配置。然后壳工程需要依赖业务组件。如下所示：\n1234567//common组件的build.gradledependencies &#123;    ...    api &#x27;com.alibaba:arouter-api:1.4.0&#x27;    annotationProcessor &#x27;com.alibaba:arouter-compiler:1.2.1&#x27;    //业务组件、业务基础组件 共同依赖的库（网络库、图片库等）都写在这里~&#125;\n123456789101112131415161718//业务组件的build.gradleandroid &#123;    ...    defaultConfig &#123;        ...        javaCompileOptions &#123;            annotationProcessorOptions &#123;                arguments = [AROUTER_MODULE_NAME: project.getName()]            &#125;        &#125;    &#125;...&#125;dependencies &#123;...    annotationProcessor &#x27;com.alibaba:arouter-compiler:1.2.1&#x27;    implementation &#x27;com.github.hufeiyang:Common:1.0.0&#x27;//业务组件依赖common组件&#125;\n1234567891011//壳工程app module的build.gradledependencies &#123;    ...    //这里没有使用私有maven仓，而是发到JitPack仓，一样的意思~//    implementation &#x27;com.hfy.cart:cart:1.0.0&#x27;    implementation &#x27;com.github.hufeiyang:Cart:1.0.1&#x27; //依赖购物车组件    implementation &#x27;com.github.hufeiyang:HomePage:1.0.2&#x27; //依赖首页组件    //壳工程内 也需要依赖Common组件，因为需要初始化ARouter    implementation &#x27;com.github.hufeiyang:Common:1.0.0&#x27;&#125;\n4.2.2 初始化\n依赖完了，先要对ARouter初始化，需要在Application内完成：\n1234567891011121314151617public class MyApplication extends Application &#123;    @Override    public void onCreate() &#123;        super.onCreate();        // 这两行必须写在init之前，否则这些配置在init过程中将无效        if (BuildConfig.DEBUG) &#123;            // 打印日志            ARouter.openLog();            // 开启调试模式(如果在InstantRun模式下运行，必须开启调试模式！线上版本需要关闭,否则有安全风险)            ARouter.openDebug();        &#125;        // 尽可能早，推荐在Application中初始化        ARouter.init(this);    &#125;&#125;\n4.2.3 路由跳转\n好了，准备工作都完成了。并且知道首页组件是没有依赖购物车组件的，下面就来实现前面提到的 首页组件 无依赖 跳转到 购物车组件页面。\n而使用ARouter进行简单路由跳转，只有两步：添加注解路径、通过路径路由跳转。\n1、在支持路由的页面上添加注解@Route(path=&quot;/xx/xx&quot;)，路径需要注意的是至少需要有两级——/xx/xx。这里就是购物车组件的CartActivity：\n123456789@Route(path = &quot;/cart/cartActivity&quot;)public class CartActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_cart);    &#125;&#125;\n2、然后在首页组件的HomeActivity 发起路由操作—点击按钮跳转到购物车，调用ARouter.getInstance().build(&quot;/xx/xx&quot;).navigation()即可：\n123456789101112131415161718192021@Route(path = &quot;/homepage/homeActivity&quot;)public class HomeActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_home);        findViewById(R.id.btn_go_cart).setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                //通过路由跳转到 购物车组件的购物车页面（但没有依赖购物车组件）                ARouter.getInstance()                        .build(&quot;/cart/cartActivity&quot;)                        .withString(&quot;key1&quot;,&quot;value1&quot;)//携带参数1                        .withString(&quot;key2&quot;,&quot;value2&quot;)//携带参数2                        .navigation();            &#125;        &#125;);    &#125;&#125;\n另外，注意在HomeActivity上添加了注解和路径，这是为了壳工程的启动页中直接打开首页。还看到路由跳转可以像startActivity一样待参数。\n最后，壳工程的启动页中通过路由打开首页（当然这里也可以用startActivity()，毕竟壳工程依赖了首页组件）：\n12345678910111213//启动页public class SplashActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        //通过路由直接打开home组件的HomeActivity，        ARouter.getInstance().build(&quot;/homepage/homeActivity&quot;).navigation();        finish();    &#125;&#125;\n我们run壳工程 最后看下效果：\n\n到这里，组件间页面跳转的问题也解决了。\n5 组件间通信\n组件间没有依赖，又如何进行通信呢？\n例如，首页需要展示购物车中商品的数量，而查询购物车中商品数量 这个能力是购物车组件内部的，这咋办呢？\n5.1 服务暴露组件\n平时开发中 我们常用 接口 进行解耦，对接口的实现不用关心，避免接口调用与业务逻辑实现紧密关联。这里组件间的解耦也是相同的思路，仅依赖和调用服务接口，不会依赖接口的实现。\n可能你会有疑问了：既然首页组件可以访问购物车组件接口了，那就需要依赖购物车组件啊，这俩组件还是耦合了啊，那咋办啊？答案是组件拆分出可暴露服务。见下图：\n\n左侧是组件间可以调用对方服务但是有依赖耦合。右侧，发现多了export_home、export_cart，这是对应拆分出来的专门用于提供服务的暴露组件。操作说明如下：\n\n暴露组件只存放服务接口、服务接口相关的实体类、路由信息、便于服务调用的util等。\n服务调用方只依赖服务提供方的露组件，如module_home依赖export_cart，而不依赖module_cart。\n组件 需要依赖 自己的暴露组件，并实现服务接口，如module_cart依赖export_cart并实现其中的服务接口。\n接口的实现注入依然是由ARouter完成，和页面跳转一样使用路由信息。\n\n下面按照此方案来实施首页调用购物车服务来获取商品数量，更好地说明和理解。\n5.2 实施\n5.2.1 新建export_cart\n首先，在购物车工程中新建module即export_cart，在其中新建接口类ICartService并定义获取购物车商品数量方法，注意接口必须继承IProvider，是为了使用ARouter的实现注入：\n12345678910111213/** * 购物车组件对外暴露的服务 * 必须继承IProvider * @author hufeiyang */public interface ICartService extends IProvider &#123;    /**     * 获取购物车中商品数量     * @return     */    CartInfo getProductCountInCart();&#125;\nCartInfo是购物车信息，包含商品数量：\n123456789101112/** * 购物车信息 * @author hufeiyang */public class CartInfo &#123;    /**     * 商品数量     */    public int productCount;&#125;\n接着，创建路由表信息，存放购物车组件对外提供跳转的页面、服务的路由地址：\n123456789101112131415161718/** * 购物车组件路由表 * 即 购物车组件中 所有可以从外部跳转的页面 的路由信息 * @author hufeiyang */public interface CartRouterTable &#123;    /**     * 购物车页面     */    String PATH_PAGE_CART = &quot;/cart/cartActivity&quot;;    /**     * 购物车服务     */    String PATH_SERVICE_CART = &quot;/cart/service&quot;;&#125;\n前面说页面跳转时是直接使用路径字符串进行路由跳转，这里是和服务路由都放在这里统一管理。\n然后，为了外部组件使用方便新建CartServiceUtil：\n12345678910111213141516171819202122232425262728293031323334353637/** * 购物车组件服务工具类 * 其他组件直接使用此类即可：页面跳转、获取服务。 * @author hufeiyang */public class CartServiceUtil &#123;    /**     * 跳转到购物车页面     * @param param1     * @param param2     */    public static void navigateCartPage(String param1, String param2)&#123;        ARouter.getInstance()                .build(CartRouterTable.PATH_PAGE_CART)                .withString(&quot;key1&quot;,param1)                .withString(&quot;key2&quot;,param2)                .navigation();    &#125;    /**     * 获取服务     * @return     */    public static ICartService getService()&#123;        //return ARouter.getInstance().navigation(ICartService.class);//如果只有一个实现，这种方式也可以        return (ICartService) ARouter.getInstance().build(CartRouterTable.PATH_SERVICE_CART).navigation();    &#125;    /**     * 获取购物车中商品数量     * @return     */    public static CartInfo getCartProductCount()&#123;        return getService().getProductCountInCart();    &#125;&#125;\n注意到，这里使用静态方法分别提供了页面跳转、服务获取、服务具体方法获取。其中服务获取 和页面跳转同样是使用路由，并且服务接口实现类也是需要添加@Route注解指定路径的。\n到这里，export_cart就已经准备完毕，我们同样发布一个export_cart的AAR（“com.github.hufeiyang.Cart:export_cart:xxx”）。\n再来看看module_cart对服务接口的实现。\n5.2.2 module_cart的实现\n首先，module_cart需要依赖export_cart：\n123456789//module_cart的Build.gradledependencies &#123;    ...    annotationProcessor &#x27;com.alibaba:arouter-compiler:1.2.1&#x27;    implementation &#x27;com.github.hufeiyang:Common:1.0.0&#x27;    //依赖export_cart    implementation &#x27;com.github.hufeiyang.Cart:export_cart:1.0.5&#x27;&#125;\n点击sync后，接着CartActivity的path改为路由表提供：\n123456789@Route(path = CartRouterTable.PATH_PAGE_CART)public class CartActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_cart);    &#125;&#125;\n然后，新建服务接口的实现类来实现ICartService，添加@Route注解指定CartRouterTable中定义的服务路由：\n123456789101112131415161718192021/** * 购物车组件服务的实现 * 需要@Route注解、指定CartRouterTable中定义的服务路由 * @author hufeiyang */@Route(path = CartRouterTable.PATH_SERVICE_CART)public class CartServiceImpl implements ICartService &#123;    @Override    public CartInfo getProductCountInCart() &#123;        //这里实际项目中 应该是 请求接口 或查询数据库        CartInfo cartInfo = new CartInfo();        cartInfo.productCount = 666;        return cartInfo;    &#125;    @Override    public void init(Context context) &#123;        //初始化工作，服务注入时会调用，可忽略    &#125;&#125;\n这里的实现是直接实例化了CartInfo，数量赋值666。然后发布一个AAR（“com.github.hufeiyang.Cart:module_cart:xxx”）。\n5.2.3 module_home中的使用和调试\nmodule_home需要依赖export_cart：\n12345678910//module_home的Build.gradledependencies &#123;    ...    annotationProcessor &#x27;com.alibaba:arouter-compiler:1.2.1&#x27;    implementation &#x27;com.github.hufeiyang:Common:1.0.0&#x27;    //注意这里只依赖export_cart（module_cart由壳工程引入）    implementation &#x27;com.github.hufeiyang.Cart:export_cart:1.0.5&#x27;&#125;\n在HomeActivity中新增TextView，调用CartServiceUtil获取并展示购物车商品数量：\n1234567891011121314151617181920212223242526272829@Route(path = &quot;/homepage/homeActivity&quot;)public class HomeActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_home);        //跳转到购物车页面        findViewById(R.id.btn_go_cart).setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                //通过路由跳转到 购物车组件的购物车页面（但没有依赖购物车组件）//                ARouter.getInstance()//                        .build(&quot;/cart/cartActivity&quot;)//                        .withString(&quot;key1&quot;,&quot;param1&quot;)//携带参数1//                        .withString(&quot;key2&quot;,&quot;param2&quot;)//携带参数2//                        .navigation();                CartServiceUtil.navigateCartPage(&quot;param1&quot;, &quot;param1&quot;);            &#125;        &#125;);        //调用购物车组件服务：获取购物车商品数量        TextView tvCartProductCount = findViewById(R.id.tv_cart_product_count);        tvCartProductCount.setText(&quot;购物车商品数量:&quot;+ CartServiceUtil.getCartProductCount().productCount);    &#125;&#125;\n看到 使用CartServiceUtil.getCartProductCount()获取购物车信息并展示，跳转页面也改为了CartServiceUtil.navigateCartPage()方法。\n到这里home组件的就可以独立调试了：页面跳转和服务调用，独立调试ok后 再集成到壳工程。先让HomePage工程的app模块依赖Common组件、module_cart 以及本地的module_home:\n123456789//HomePage工程,app模块的Build.gradledependencies &#123;    ...    //引入本地Common组件、module_cart、module_home，在app module中独立调试使用    implementation &#x27;com.github.hufeiyang:Common:1.0.0&#x27;    implementation &#x27;com.github.hufeiyang.Cart:module_cart:1.0.6&#x27;    implementation project(path: &#x27;:module_home&#x27;)&#125;\n然后新建MyApplication初始化ARouter、在app的MainActivity中使用ARouter.getInstance().build(&quot;/homepage/homeActivity&quot;).navigation()打开首页，这样就可以调试了。\n调试ok后接着就是集成到壳工程。\n5.2.4 集成到壳工程\n壳工程中的操作和独立调试类似，区别是对首页组件引入的是AAR：\n12345678910dependencies &#123;    ...    //这里没有使用私有maven仓，而是发到JitPack仓，一样的意思~//    implementation &#x27;com.hfy.cart:cart:1.0.0&#x27;    implementation &#x27;com.github.hufeiyang.Cart:module_cart:1.0.6&#x27;    implementation &#x27;com.github.hufeiyang:HomePage:1.0.4&#x27;    //壳工程内 也需要依赖Common组件，因为需要初始化ARouter    implementation &#x27;com.github.hufeiyang:Common:1.0.0&#x27;&#125;\n最后run壳工程来看下效果：\n\n获取数量是666、跳转页面成功。\n\n另外，除了export_xxx这种方式，还可以添加一个 ComponentBase 组件，这个组件被所有的Common组件依赖，在这个组件中分别添加定义了业务组件可以对外提供访问自身数据的抽象方法的 Service。相当于把各业务组件的export整合到ComponentBase中，这样就只添加了一个组件而已。但是这样就不好管理了，每个组件对外能力的变更都要改ComponentBase。\n\n另外，除了组件间方法调用，使用EventBus在组件间传递信息也是ok的（注意Event实体类要定义在export_xxx中）。\n好了，到这里组件间通信问题也解决了。\n6 fragment实例获取\n上面介绍了Activity 的跳转，我们也会经常使用Fragment。例如常见的应用主页HomeActivity 中包含了多个属于不同组件的Fragment、或者有一个Fragment多个组件都需要用到。通常我们直接访问具体Fragment类来new一个Fragment实例，但这里组件间没有直接依赖，那咋办呢？答案依然是ARouter。\n先在module_cart中创建CartFragment：\n12345678910111213141516171819//添加注解@Route，指定路径@Route(path = CartRouterTable.PATH_FRAGMENT_CART)public class CartFragment extends Fragment &#123;    ...    public CartFragment() &#123;    &#125;    @Override    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        ...    &#125;    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container,                             Bundle savedInstanceState) &#123;        //显示“cart_fragment&quot;        return inflater.inflate(R.layout.fragment_cart, container, false);    &#125;&#125;\n同时是fragment添加注解@Route，指定路由路径，路由还是定义在export_cart的CartRouterTable中，所以export_cart需要先发一个AAR，module_cart来依赖，然后module_cart发布AAR。\n然后再module_home中依赖export_cart，使用ARouter获取Fragment实例：\n123456789101112131415161718@Route(path = &quot;/homepage/homeActivity&quot;)public class HomeActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_home);        ...        FragmentManager manager = getSupportFragmentManager();        FragmentTransaction transaction= manager.beginTransaction();        //使用ARouter获取Fragment实例 并添加        Fragment userFragment = (Fragment) ARouter.getInstance().build(CartRouterTable.PATH_FRAGMENT_CART).navigation();        transaction.add(R.id.fl_test_fragment, userFragment, &quot;tag&quot;);        transaction.commit();    &#125;&#125;\n可以先独立调试，然后集成到壳工程——依赖最新的module_cart 、HomePage，结果如下：\n\n绿色部分就是引用自cart组件的fragment。\n7 Application生命周期分发\n我们通常会在Application的onCreate中做一些初始化任务，例如前面提到的ARouter初始化。而业务组件有时也需要获取应用的Application，也要在应用启动时进行一些初始化任务。\n你可能会说，直接在壳工程Application的onCreate操作就可以啊。但是这样做会带来问题：因为我们希望壳工程和业务组件 代码隔离（虽然有依赖），并且 我们希望组件内部的任务要在业务组件内部完成。\n那么如何做到 各业务组件 无侵入地获取 Application生命周期 呢？——答案是 使用AppLifeCycle插件，它专门用于在Android组件化开发中，Application生命周期主动分发到组件。具体使用如下：\n1.common组件依赖applifecycle-api\n首先，common组件通过 api 添加 applifecycle-api 依赖 并发布AAR：\n123456//common组件 build.gradledependencies &#123;    ...    //AppLifecycle    api &#x27;com.github.hufeiyang.Android-AppLifecycleMgr:applifecycle-api:1.0.4&#x27;&#125;\n2.业务组件依赖applifecycle-compiler、实现接口+注解\n各业务组件都要依赖最新common组件，并添加applifecycle-compiler的依赖：\n123456//业务组件 build.gradle...    //这里Common:1.0.2内依赖了applifecycle-api    implementation &#x27;com.github.hufeiyang:Common:1.0.2&#x27;    annotationProcessor &#x27;com.github.hufeiyang.Android-AppLifecycleMgr:applifecycle-compiler:1.0.4&#x27;\nsync后，新建类来实现接口IApplicationLifecycleCallbacks用于接收Application生命周期，且添加@AppLifecycle注解。\n例如Cart组件的实现：\n1234567891011121314151617181920212223242526272829303132333435363738394041/** * 组件的AppLifecycle * 1、@AppLifecycle * 2、实现IApplicationLifecycleCallbacks * @author hufeiyang */@AppLifecyclepublic class CartApplication implements IApplicationLifecycleCallbacks &#123;    public  Context context;    /**      * 用于设置优先级，即多个组件onCreate方法调用的优先顺序      * @return     */    @Override    public int getPriority() &#123;        return NORM_PRIORITY;    &#125;    @Override    public void onCreate(Context context) &#123;        //可在此处做初始化任务，相当于Application的onCreate方法        this.context = context;        Log.i(&quot;CartApplication&quot;, &quot;onCreate&quot;);    &#125;    @Override    public void onTerminate() &#123;    &#125;    @Override    public void onLowMemory() &#123;    &#125;    @Override    public void onTrimMemory(int level) &#123;    &#125;&#125;\n实现的方法 有onCreate、onTerminate、onLowMemory、onTrimMemory。最重要的就是onCreate方法了，相当于Application的onCreate方法，可在此处做初始化任务。并且还可以通过getPriority()方法设置回调多个组件onCreate方法调用的优先顺序，无特殊要求设置NORM_PRIORITY即可。\n3.壳工程引入AppLifecycle插件、触发回调\n壳工程引入新的common组件、业务组件，以及 引入AppLifecycle插件：\n123456789101112131415161718//壳工程根目录的 build.gradlebuildscript &#123;    repositories &#123;        google()        jcenter()        //applifecycle插件仓也是jitpack        maven &#123; url &#x27;https://jitpack.io&#x27; &#125;    &#125;    dependencies &#123;        classpath &#x27;com.android.tools.build:gradle:3.6.1&#x27;        //加载插件applifecycle        classpath &#x27;com.github.hufeiyang.Android-AppLifecycleMgr:applifecycle-plugin:1.0.3&#x27;    &#125;&#125;\n1234567891011121314151617//app module 的build.gradleapply plugin: &#x27;com.android.application&#x27;//使用插件applifecycleapply plugin: &#x27;com.hm.plugin.lifecycle&#x27;...dependencies &#123;    ...    //这里没有使用私有maven仓，而是发到JitPack仓，一样的意思~//    implementation &#x27;com.hfy.cart:cart:1.0.0&#x27;    implementation &#x27;com.github.hufeiyang.Cart:module_cart:1.0.11&#x27;    implementation &#x27;com.github.hufeiyang:HomePage:1.0.5&#x27;    //壳工程内 也需要依赖Common组件，因为要 触发生命周期分发    implementation &#x27;com.github.hufeiyang:Common:1.0.2&#x27;&#125;\n最后需要在Application中触发生命周期的分发：\n1234567891011121314151617181920212223242526272829303132333435//壳工程 MyApplicationpublic class MyApplication extends Application &#123;    @Override    public void onCreate() &#123;        super.onCreate();        ...        ApplicationLifecycleManager.init();        ApplicationLifecycleManager.onCreate(this);    &#125;    @Override    public void onTerminate() &#123;        super.onTerminate();        ApplicationLifecycleManager.onTerminate();    &#125;    @Override    public void onLowMemory() &#123;        super.onLowMemory();        ApplicationLifecycleManager.onLowMemory();    &#125;    @Override    public void onTrimMemory(int level) &#123;        super.onTrimMemory(level);        ApplicationLifecycleManager.onTrimMemory(level);    &#125;&#125;\n首先在inCreate方法中调用ApplicationLifecycleManager的init()方法，用于收集组件内实现了IApplicationLifecycleCallbacks且添加了@AppLifecycle注解的类。然后在各生命周期方法内调用对应的ApplicationLifecycleManager的方法，来分发到所有组件。\n这样 组件 就能接收到Application的生命周期了。 新增组件的话，只需要 实现IApplicationLifecycleCallbacks并添加了@AppLifecycle注解 即可，无需修改壳工程，也不用关心。\n\nAppLifecycle插件是使用了APT技术、gradle插件技术+ASM动态生成字节码，在编译阶段就已经完成了大部分工作，无性能问题、且使用方便。\n\n到这里，组件化开发的5个问题点都已经解决了。下面来看看针对老项目如何实现组件化改造。\n8 老项目组件化\n通常情况 我们去做组件化，都是为了改造已有老项目。可能老项目内部的模块之间耦合严重，没有严格的业务模块划分，并且组件化改造是大工作量的事情，且要全量回归测试，总体来说，是需要全员参与、有较大难度的事情。\n8.1 方案\n8.1.1 组件划分\n根据前面介绍的组件化架构图，组件分为 基础组件、业务基础组件、业务组件。\n\n基础组件，不用多说，就是基础功能，例如网络请求、日志框架、图片加载，这些与业务毫无关联，可用于公司所有项目，是底层最稳定的组件。这里就比较容易识别和拆分。\n业务基础组件，主要是供业务组件依赖使用，例如 分享、支付组件，通常是一个完整的功能，是较为最稳定的组件。这部分通常也是比较容易识别的。\n业务组件，完整的业务块，例如前面提到京东的“首页”、“分类”、“发现”、“购物车”、“我的”。业务组件是日常需求开发的主战场。\n\n8.1.2 组件拆分：基础组件、Common组件\n基础组件最容易拆分，它依赖最少，功能单一纯粹。把基础组件依赖的东西，从老工程中抽取出来，放在单独的工程，做成单独的组件，发布AAR到公司maven仓。注意不能存在任何业务相关代码。\n新建Common组件，使用 “api” 依赖 所有基础组件，这样依赖 Common组件的组件 就能使用所有基础组件的功能了。接着，就是前面提到的 ARouter、AppLifeCycle、以及其他第三方库的依赖。\n另外，Common组件，还有一个重要部分：提供BaseActivity、BaseFragment，这里Base需要完成基础能力的添加，例如页面进入、退出的埋点上报、统一页面标题样式、打开关闭EventBus等等。\n8.1.3 组件拆分：业务基础组件、业务组件\n业务基础组件 基本上只依赖common，功能也是单一纯粹。同样是把依赖的东西抽取出来，放在单独的工程，做成单独的组件，发布AAR到公司maven仓。\n业务组件，首先要识别组件的边界，可以按照页面入口和出口作为判断。然后，需要识别对 业务基础组件的依赖；以及 最重要的，对其他 业务组件的依赖。\n可以先把代码抽离到单独的工程，然后依赖common组件、需要的业务基础组件，此时依然报错的地方就是对其他业务组件的依赖了。这时就可以给对应组件负责人提需求，在export_xxx中提供跳转和服务。然后你只需要依赖export_xxx使用即可。\n\n老项目组件化改造需要循序渐进，除非有专门的时间。一般是需求开发和改造并行。要先完成一个组件，之后有了经验，后面其他业务组件陆续实施，这样就会比较简单。\n\n8.2 常见问题\n8.2.1 组件中butterknife报错—R2\n在Library中，ButterKnife注解中使用R.id会报错，例如common组件 module_common中新建Activity，并依赖butterknife：\n12345678910111213android &#123;  ...  // Butterknife requires Java 8.  compileOptions &#123;    sourceCompatibility JavaVersion.VERSION_1_8    targetCompatibility JavaVersion.VERSION_1_8  &#125;&#125;dependencies &#123;  implementation &#x27;com.jakewharton:butterknife:10.2.3&#x27;  annotationProcessor &#x27;com.jakewharton:butterknife-compiler:10.2.3&#x27;&#125;\n报错如下：\n\n解决方法：需要添加ButterKnife插件，然后使用R2：\n123456789buildscript &#123;  repositories &#123;    mavenCentral()    google()  &#125;  dependencies &#123;    classpath &#x27;com.jakewharton:butterknife-gradle-plugin:10.2.3&#x27;  &#125;&#125;\n12apply plugin: &#x27;com.android.library&#x27;apply plugin: &#x27;com.jakewharton.butterknife&#x27;\n然后ButterKnife注解中使用 R2 就ok了:\n\n到这里，Android组件化的知识全部讲完。\n9 总结\n本文介绍了 组件化开发的背景、架构、优势、要解决的问题 以及详细解决方案，独立调试、页面跳转、组件通信等，最后介绍的老项目组件化方案。\n其中涉及的最重要的工具是ARouter，专门用于Android组件化解耦。ARouter还有很多进阶用法，有机会我也针对ARouter写一篇全面分析。还有一个重要知识点AppLifecycle插件，它的原理涉及APT、ASM插入字节码、gradle插件等技术，后续也会专门去分析这块知识。\nAndroid开发组件化，是在项目发展到一定规模后必定要使用的技术，学习至完全掌握非常必要。\nDemo的GitHub地址：\n壳工程ComponentLearning\nhttps://github.com/hufeiyang/ComponentLearning\nCommon组件\nhttps://github.com/hufeiyang/Common\nHomePage组件\nhttps://github.com/hufeiyang/HomePage\nCart组件\nhttps://github.com/hufeiyang/Cart\nAppLifecycle插件\nhttps://github.com/hufeiyang/Android-AppLifecycleMgr\n参考与感谢:\n《Android 组件化最佳实践》\nhttps://juejin.cn/post/6844903649102004231\n《Android组件化开发实践系列》\nhttps://www.jianshu.com/p/d0f5cf304fa4\n","plink":"https://blog.ixin.run/posts/1612031065/"},{"title":"Android开发弹性布局FlexboxLayout知识总结","date":"2021-01-27T12:47:25.000Z","date_formatted":{"ll":"2021年1月27日","L":"2021/01/27","MM-DD":"01-27"},"updated":"2021-02-01T11:34:21.321Z","content":"今天分享一下弹性布局FlexboxLayout的使用总结，又是一篇个人有道云笔记转移系列。早些年我们实现一个换行的标签云、实现一个不规则的九宫格、实现一个不规整瀑布流等等这些“嘿嘿嘿”设计总是要思索半天，FlexboxLayout的出现面对这些问题将为你节省几亿个脑细胞不在话下。我第一次接触这个布局方式还是从早前一个前端写H5的小哥嘴里得到的，我顺便举一反三搜了一下发现我们Android上也有，还是google官方出品，看来知识都是相通的。好了，废话不多说，直接淦！\n\nGitHub\n官方地址： https://github.com/google/flexbox-layout\n接入依赖：\n123dependencies &#123;    implementation &#x27;com.google.android:flexbox:2.0.1&#x27;&#125;\n值得注意的是从1.1.0开始，该库直接对接AndroidX，如果想要使用1.1.0及以上版本尽快升级到AndroidX咯。\n简单使用方式\nXML\n12345678910111213141516171819202122232425262728&lt;com.google.android.flexbox.FlexboxLayout    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    app:flexWrap=&quot;wrap&quot;    app:alignItems=&quot;stretch&quot;    app:alignContent=&quot;stretch&quot; &gt;    &lt;TextView        android:id=&quot;@+id/textview1&quot;        android:layout_width=&quot;120dp&quot;        android:layout_height=&quot;80dp&quot;        app:layout_flexBasisPercent=&quot;50%&quot;/&gt;    &lt;TextView        android:id=&quot;@+id/textview2&quot;        android:layout_width=&quot;80dp&quot;        android:layout_height=&quot;80dp&quot;        app:layout_alignSelf=&quot;center&quot;/&gt;    &lt;TextView        android:id=&quot;@+id/textview3&quot;        android:layout_width=&quot;160dp&quot;        android:layout_height=&quot;80dp&quot;        app:layout_alignSelf=&quot;flex_end&quot;/&gt;&lt;/com.google.android.flexbox.FlexboxLayout&gt;\nFrom Code\n12345678FlexboxLayout flexboxLayout = (FlexboxLayout) findViewById(R.id.flexbox_layout);flexboxLayout.setFlexDirection(FlexDirection.ROW);View view = flexboxLayout.getChildAt(0);FlexboxLayout.LayoutParams lp = (FlexboxLayout.LayoutParams) view.getLayoutParams();lp.setOrder(-1);lp.setFlexGrow(2);view.setLayoutParams(lp);\nFlexboxLayoutManager (within RecyclerView)\n123456789101112131415&#x2F;&#x2F; 针对所有itemRecyclerView recyclerView &#x3D; (RecyclerView) context.findViewById(R.id.recyclerview);FlexboxLayoutManager layoutManager &#x3D; new FlexboxLayoutManager(context);layoutManager.setFlexDirection(FlexDirection.COLUMN);layoutManager.setJustifyContent(JustifyContent.FLEX_END);recyclerView.setLayoutManager(layoutManager);&#x2F;&#x2F; 针对单个itemmImageView.setImageDrawable(drawable);ViewGroup.LayoutParams lp &#x3D; mImageView.getLayoutParams();if (lp instanceof FlexboxLayoutManager.LayoutParams) &#123;    FlexboxLayoutManager.LayoutParams flexboxLp &#x3D; (FlexboxLayoutManager.LayoutParams) lp;    flexboxLp.setFlexGrow(1.0f);    flexboxLp.setAlignSelf(AlignSelf.FLEX_END);&#125;\n相关属性\n\n下边我直接介绍相关属性使用方法\n父布局属性\n以下五种是父布局中所使用的，也是最常用的。\nflexDirection\nflexDirection属性是决定主轴的方向。好比LinearLayout的vertical(垂直) 和 horizontal(水平)方向。\n\nrow：一般为默认值，主轴为水平方向，起点在左端。\nrow-reverse: 主轴为水平方向，起点在右端。\ncolumn：主轴为垂直方向，起点在上沿。\ncolumn-reverse：主轴为垂直方向，起点在下沿。\n\nflexWrap\nflexWrap属性是决定是否换行排列，默认情况下是不支持换行排列。\n\nnowrap：不换行。\nwrap: 正常方向换行。\nwrap-reverse: 反方向换行。\n\njustifyContent\njustifyContent指定了项目在主轴上的对齐方式。\n\nflex-start: 默认值为左对齐。\nflex-end:   右对齐。\ncenter:     居中。\nspace-between: 两端对齐，其间间距相等。\nspace-around:  两侧间距相等。\n\n\nalignltems\nalignltems指定项目在副轴（交叉轴，和主轴垂直）上的对齐方式。\n\nflex-start: 交叉轴的起点对齐。(上)\nflex-end:   交叉轴的终点对齐。(下)\ncenter:     交叉轴的中点对齐。(中间线)\nbaseline:   第一行文字的基线对齐。()\nstretch:    默认值是占满整个容器的高度，在未设置高度或者为auto。\n\n\nalignContent\nalignContent指定多根轴线的对齐方式，如果只有一条轴，该属性不起任何作用。\n\nflex-start: 与交叉轴的起点对齐。\nflex-end:   与交叉轴的终点对齐。\ncenter:     与交叉轴的中点对齐。\nspace-between:  与交叉轴的两端对齐，轴线之间的间隔分布均匀。\nspace-around:   每根轴线两侧的间隔相等。\nstretch: 默认值为轴线占满整个交叉轴。\n\n\n分割线\n水平分割线\n采用showDividerHorizontal和dividerDrawableHorizontal属性设置水平分割线\n\nshowDividerHorizontal\n控制显示水平方向的分割线，值为none | beginning | middle | end其中的一个或者多个。\ndividerDrawableHorizontal\n设置Flex 轴线之间水平方向的分割线。\n\n垂直分割线\n采用showDividerVertical和dividerDrawableVertical属性设置垂直分割线\n\nshowDividerVertical\n控制显示垂直方向的分割线，值为none | beginning | middle | end其中的一个或者多个。\ndividerDrawableVertical\n设置子元素垂直方向的分割线。\n\n水平垂直分割线\n采用showDivider和dividerDrawable属性同时设置水平垂直分割线\n\nshowDivider\n控制显示水平和垂直方向的分割线，值为none | beginning | middle | end其中的一个或者多个。\ndividerDrawable\n设置水平和垂直方向的分割线，但是注意，如果同时和其他属性使用，比如为Flex轴、子元素设置了justifyContent=“space_around” 、alignContent=“space_between” 等等。可能会看到意料不到的结果，因此应该避免和这些值同时使用。\n\n子布局属性\nlayout_order\n这个属性可以改变布局子视图的顺序。默认情况下，子元素的显示和布局顺序与布局XML中的顺序相同。如果没有指定，则将1设置为默认值( CSS 中默认值为 0) ，数值越小，排列越靠前。\nlayout_flexGrow\n放大比例。这个属性类似于 LinearLayout 中的 layout_weight 属性，如果没有指定，则将 0 设置为默认值。如果果同一 flex 行中的多个子 View 有正的 layout_flexGrow 值，那么剩余的空闲空间将根据它们声明的 layout_flexGrow 值的比例分布。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;com.google.android.flexbox.FlexboxLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    android:layout_width=&quot;300dp&quot;    android:layout_height=&quot;300dp&quot;    android:background=&quot;@android:color/black&quot;&gt;    &lt;!--         flex-grow（放大比例，剩余空间怎么分配) : 权重         float FLEX_GROW_DEFAULT = 0f;         剩余宽度 = 300 - (0 +  0 + 0) = 300         tv1宽度 = 0 + 300 * (2 / 4) = 150         tv2宽度 = 0 + 300 * (1 / 4) = 75         tv3宽度 = 0 + 300 * (1 / 4) = 75    --&gt;    &lt;TextView        android:id=&quot;@+id/tv1&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:background=&quot;@android:color/holo_purple&quot;        android:gravity=&quot;center&quot;        android:padding=&quot;5dp&quot;        android:text=&quot;tv1&quot;        android:textColor=&quot;@android:color/white&quot;        app:layout_flexGrow=&quot;2&quot; /&gt;    &lt;TextView        android:id=&quot;@+id/tv2&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:background=&quot;#FFC107&quot;        android:gravity=&quot;center&quot;        android:padding=&quot;5dp&quot;        android:text=&quot;tv2&quot;        app:layout_flexGrow=&quot;1&quot; /&gt;    &lt;TextView        android:id=&quot;@+id/tv3&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:background=&quot;#00BCD4&quot;        android:gravity=&quot;center&quot;        android:padding=&quot;5dp&quot;        android:text=&quot;tv3&quot;        app:layout_flexGrow=&quot;1&quot; /&gt;&lt;/com.google.android.flexbox.FlexboxLayout&gt;\nlayout_flexShrink\n缩小比例。如果所有子 View 的 layout_flexShrink 属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的 layout_flexShrink 属性为0，其他子View都为 1，则空间不足时，layout_flexShrink 属性为 0 的不缩小。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;com.google.android.flexbox.FlexboxLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    android:layout_width=&quot;300dp&quot;    android:layout_height=&quot;500dp&quot;    android:background=&quot;@android:color/black&quot;&gt;    &lt;!--        flex-shrink （缩小比例，超出空间怎么压缩）        默认： float FLEX_SHRINK_DEFAULT = 1f;        计算方法：        孩子宽度和 = 150 * 3 = 450        450 - 300 = 150 即超出父布局宽度150        tv1最终宽度 = 自身宽度150 - 超出宽度所占比例的宽度150 * (2 / 4)  = 75        tv2最终宽度 = 自身宽度150 - 超出宽度所占比例的宽度150 * (1 / 4)  = 112.5        tv3最终宽度 = 自身宽度150 - 超出宽度所占比例的宽度150 * (1 / 4)  = 112.5    --&gt;    &lt;TextView        android:id=&quot;@+id/tv1&quot;        android:layout_width=&quot;150dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:background=&quot;@android:color/holo_purple&quot;        android:gravity=&quot;center&quot;        android:padding=&quot;5dp&quot;        android:text=&quot;tv1&quot;        android:textColor=&quot;@android:color/white&quot;        app:layout_flexShrink=&quot;2&quot; /&gt;    &lt;TextView        android:id=&quot;@+id/tv2&quot;        android:layout_width=&quot;150dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:background=&quot;#FFC107&quot;        android:gravity=&quot;center&quot;        android:padding=&quot;5dp&quot;        android:text=&quot;tv2&quot;        app:layout_flexShrink=&quot;1&quot; /&gt;    &lt;TextView        android:id=&quot;@+id/tv3&quot;        android:layout_width=&quot;150dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:background=&quot;#00BCD4&quot;        android:gravity=&quot;center&quot;        android:padding=&quot;5dp&quot;        android:text=&quot;tv3&quot;        app:layout_flexShrink=&quot;1&quot; /&gt;&lt;/com.google.android.flexbox.FlexboxLayout&gt;\nlayout_alignSelf\n子元素对齐。对齐方式，取值和align相同，覆盖align-items。\nlayout_alignSelf 属性可以给子元素设置对齐方式，这个属性的功能和alignItems一样，\n只不过alignItems作用于所有子元素，而 layout_alignSelf 作用于单个子元素。\n默认值为auto, 表示继承alignItems属性，如果为auto以外的值，则会覆盖alignItems属性。有以下6种取值：\n\nauto (default)\nflex_start\nflex_end\ncenter\nbaseline\nstretch\n\nlayout_flexBasisPercent\n子元素占父元素百分比。layout_flexBasisPercent的值为一个百分比，表示设置子元素的长度为它父容器长度的百分比，如果设置了这个值，那么通过这个属性计算的值将会覆盖layout_width或者layout_height的值。\n但是需要注意，这个值只有设置了父容器的长度时才有效，默认值是-1。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;com.google.android.flexbox.FlexboxLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    android:layout_width=&quot;300dp&quot;    android:layout_height=&quot;300dp&quot;    android:background=&quot;@android:color/black&quot;&gt;    &lt;!--        layout_flexBasisPercent         决定了在分配多余空间之前，子元素占据的主轴空间的百分比。        默认为自身大小         --&gt;    &lt;TextView        android:id=&quot;@+id/tv1&quot;        android:layout_width=&quot;50dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:background=&quot;@android:color/holo_purple&quot;        android:gravity=&quot;center&quot;        android:padding=&quot;5dp&quot;        android:text=&quot;tv1&quot;        android:textColor=&quot;@android:color/white&quot;        app:layout_flexBasisPercent=&quot;40%&quot; /&gt;    &lt;TextView        android:id=&quot;@+id/tv2&quot;        android:layout_width=&quot;50dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:background=&quot;#FFC107&quot;        android:gravity=&quot;center&quot;        android:padding=&quot;5dp&quot;        android:text=&quot;tv2&quot;        app:layout_flexBasisPercent=&quot;30%&quot; /&gt;    &lt;TextView        android:id=&quot;@+id/tv3&quot;        android:layout_width=&quot;50dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:background=&quot;#00BCD4&quot;        android:gravity=&quot;center&quot;        android:padding=&quot;5dp&quot;        android:text=&quot;tv3&quot;        app:layout_flexBasisPercent=&quot;20%&quot; /&gt;&lt;/com.google.android.flexbox.FlexboxLayout&gt;\nlayout_minWidth / layout_minHeight\n这个属性设置了子 View 的最小的宽和高。在 layout_flexShrink 模式下，再怎么缩小也不会小于这个值\nlayout_maxWidth / layout_maxHeight\n这个属性设置了子 View 的最大的宽和高。在 layout_flexGrow 模式下，再怎么放大也不会大于这个值\nlayout_wrapBefore\n这个属性使得子 View 可以强制换行，不管在 main size 剩余空间有多少。这种对于类似 grid 网格布局中特殊设置某一个 item 布局特别有用。默认 false。\n参考\n\nhttps://github.com/google/flexbox-layout\nhttps://stackoverflow.com/questions/31250174/css-flexbox-difference-between-align-items-and-align-content\n\n","plink":"https://blog.ixin.run/posts/1611751645/"},{"title":"健康其实很简单","date":"2021-01-26T15:24:08.000Z","date_formatted":{"ll":"2021年1月26日","L":"2021/01/26","MM-DD":"01-26"},"updated":"2021-01-29T12:51:44.669Z","content":"健康其实很简单，甚至简单到每天一个微笑。我喜欢运动，以前我经常用这种方式锻炼自己或者解压，这两年生活被打乱了，今天翻阅笔记无意间发现自己早前写的一个习惯，还是想着给分享出来，借此来重拾自己。\n\n\n让运动变成一个习惯，而不是坚持。运动进行中以及运动后的感觉是开心的而不是痛苦的。\n\n1. 运动\n规则：\n天凉（1月、2月）：建议慢跑，全身运动，微微出汗即可。\n天热（7月、8月）：建议晚上出去散步，玩球，尽量少出汗。\n其他：即正常。\n运动表：\n一、三、五、七：跑步。\n二、四、六：散步或者溜车。\n运动前：跑步或者打球运动前热身，手腕，脚踝，伸腿拉伸一下肌肉两腿各5下，双手合十举臂伸展3下，左右扭腰各5下，下蹲5个，高抬腿5个。\n运动后：跑完步后稍微活动一下扭扭脖子，扭扭腰，拉拉腿。俯卧撑分两组，中间歇息3分钟（每组15个，以后酌情添加）；仰卧起坐分两组，中间歇息5分钟。（每组10个，以后酌情添加）\n2. 睡眠\n1.晚上12点前准时睡觉，早上7点起床。保证每天7~8个小时睡眠。\n2.夏季中午补个午觉15~20分钟。\n3. 饮食\n1.忌辛辣，少油腻。\n2.白酒少喝（夏季坚决不喝），茶水多喝。\n3.水果常吃且多样，蔬菜亦是。\n4.肉类也多补点，尽量煲汤最益。\n","thumbnail":"https://tse2-mm.cn.bing.net/th/id/OIP.HEHLhOkAp4E1FiGupZBajQHaDh?pid=Api&rs=1","plink":"https://blog.ixin.run/posts/1611674668/"},{"title":"带你玩转Hexo——网站收录","date":"2021-01-24T08:50:02.000Z","date_formatted":{"ll":"2021年1月24日","L":"2021/01/24","MM-DD":"01-24"},"updated":"2021-03-15T04:16:08.118Z","content":"本篇是带你玩转Hexo系列的第二篇，前边的一篇《带你玩转Hexo——网站搭建》已经达到的中级部署的基本要求，本篇将带你进入SEO的入门实现，将我们的站点被搜索引擎记录，别人能够在网上能够根据标题或者网站名称搜到我们的网站，而不再用繁琐的域名或链接来找，因为这确实不太好记。好了，废话不多说，接下来就拿谷歌收录和百度收录两个搜索引擎收录举例。\n\n收录验证\n无论是百度还是google搜索引擎，我们想要查看我们的网站是否被搜索引擎收录，只需要在搜索框中输入site:xxxx.com回车即可。\n如果你的网站已经收录了，则直接可以展示相关搜索的列表结果：\n\n如果你的网站没有收录，则展示结果如下：\n\n第一次你的站点不提交给搜索引擎，搜索引擎是不会收录的，搜索引擎收录一般需要经过三步：\n\n添加站点\n站点验证，检测站点是否是你自己的网站\n网址发给搜索引擎\n\n谷歌收录\n搜索Google Search Console并登录。\n1.添加站点资源\n\ngoogle给出了两种，第一种域名形式添加，添加成功后google会抓取所有该域名下的所有链接。第二种是以网址前缀形式添加，添加成功后google会抓取该网址下的所有链接。一般都是采用第一种，覆盖范围更广。\n2.站点验证\n\ngoogle推荐采用域名解析TXT的方式进行验证，只需按照上图复制TXT值在域名提供商DNS解析那里添加一条TXT记录即可，这条记录不要删除，一般google会隔一段时间进行验证一次的，免的站点挂了。\n3.推送网址链接\n\n推送网址链接有两种形式：\n\n单独逐条添加\n以站点地图添加，google会隔一段时间抓取站点地图中的网址链接\n\n建议采用站点地图的形式添加，一劳永逸，除非有些网址不在站点地图中，我们才采用单独添加。\n在blog根目录npm下载生成站点地图插件：\n1npm install hexo-generator-sitemap --save\n然后每次hexo g后都会在public根目录生成一个sitemap.xml文件，揪下来我们将该文件的网址链接提交给google站点，就ok了。\n百度收录\n搜索百度站长并登录，接下来还是三步走策略：\n1.添加站点资源\n\n个人中心-&gt;站点管理-&gt;添加网站\n2.站点验证\n\n百度验证比较灵活，可以采用三种方式，但是我们还是建议采用CNAME方式直接在域名提供商DNS解析中添加一条记录，按照图上的指示添加即可。\n3.推送网址链接\n等站点验证成功后，就会在站点管理那里呈现出你自己的网站，点击进去，选择普通收录\n\n百度给的收录方式同样也很多，我们还是建议采用sitemap形式添加，形式和google添加sitemap一样。\n最后\n网站添加到搜索引擎后，并不能立刻在搜索引擎中直接搜到我们的网站和文章，这是因为我们仅仅是把网站提交给google和百度了，接下来google和百度会对我们的站点地图中的网址进行抓取动作，这是一个过程，涉及到验证网页的可渲染性等（404，会被搜索引擎抛弃），一般这个过程会持续一周，Google可能会快一点，我们静候佳音吧。\n","thumbnail":"https://pic4.zhimg.com/v2-41e1b825c51055f39c22b95777bc620b_1440w.jpg?source=172ae18b","plink":"https://blog.ixin.run/posts/1611478297/"},{"title":"Android各个版本新特性","date":"2021-01-23T17:54:15.000Z","date_formatted":{"ll":"2021年1月24日","L":"2021/01/24","MM-DD":"01-24"},"updated":"2021-01-29T12:51:44.622Z","content":"新特性？哈哈，很多Android开发者对这个词不陌生吧，尤其是在面试的时候很多面试官都喜欢问这个，本篇我简单罗列一些Android系统各个版本上的新特性，尤其是和开发相关的，持续更新中…\n\nAndroid 11.x\n\n黑暗模式、滚动长截屏、录屏；\n支持 HEIF 图像格式，相比 JPG 格式，在画质不变的情况下，可以节省 50% 手机存储空间；\n新增一次性的位置、麦克风、摄像头的权限许可：\n进一步强化了「有限权限许可」的功能，当应用程序请求诸如位置、麦克风、摄像头等有关用户隐私的权限时，将不再有「一直允许」的选项出现，取而代之的是「只允许这一次」、「只在程序使用时允许」、或者直接拒绝。\n通知历史，避免有用的通知划掉而无法找回；\n支持挖孔屏、瀑布屏；\n反向充电；\n\nAndroid 10.x\n\n折叠屏；\n5G网络；\nLive Caption，可以为正在播放的多媒体文件自动生成字幕。该功能支持任何应用中的多媒体文件，包括视频、播客和语音信息；\n手势导航，这一功能启用后，原有的底部导航栏设计会消失，让应用真正实现全屏显示；\n用户隐私：\n\n设备ID不可随便获取（防止设备跟踪），包括设备IMEI，序列号和类似标识符，当应用连接至 Wi-Fi 网络时，设备的 MAC 地址将默认被随机化处理；\n分区存储；\n地理位置权限，用户可以通过新的权限选项更好地控制他们的位置数据，他们现在可以允许应用仅在应用实际使用时（在前台运行）访问位置；\n后台禁止启动Activity，谷歌官方建议将从后台启动的Activity改为显示通知。还可以选择提供全屏Intent；\nTLS 1.3默认开启，提高安全性、和隐私性；\n\n\n\nAndroid 9 Pie\n\n利用Wifi RTT 进行室内定位：\n在运行 Android 9 且具有硬件支持的设备上，应用可以使用 RTT API 来测量与附近支持 RTT 的 Wi-Fi 接入点 (AP) 的距离。 设备必须已启用位置服务并开启 Wi-Fi 扫描（在 Settings &gt; Location 下），同时您的应用必须具有 ACCESS_FINE_LOCATION 权限。\n显示屏缺口支持（刘海屏、凹凸屏）；\n多摄像头支持和摄像头更新；\n用于位图和 drawable 的 ImageDecoder：\nAndroid P 引入了一种更简单的方法来将图像解码为位图或 drawable，即用 ImageDecoder 替代了 BitmapFactory。ImageDecoder 允许您从字节缓冲区、文件或 URI 创建位图或 drawable。它比 BitmapFactory 多出了几个优势，包括对精确缩放的支持，单步解码至硬件存储器，对解码后处理的支持，以及对动画图像的解码。\n神经网络 API 1.1\n用于 NFC 支付和安全交易的 Open Mobile API\n\nAndroid 8 Oreo\n\n画中画：\nAndroid 8.0允许以画中画 (PIP) 模式启动操作组件。PIP 是一种特殊的多窗口模式，最常用于视频播放。目前，PIP模式可用于 Android TV，而Android 8.0 则让该功能可进一步用于其他 Android 设备。\n通知：\n\n引入了通知渠道用来让用户统一管理通知；\nAndroid O 还引入了通知角标，当一个应用的通知没有 dismiss 的时候，会在应用的图标上面显示一个角标，长摁这个应用的图标，也会显示通知的详情信息；\n引入了一个通知睡眠的功能，用户可以休眠一个通知，让它在指定的时候再出现，被休眠的时候仍然可以修改这个通知的设置，但是不会让这个通知立马出现。另外还可以设置一个通知的超时时间，用来让某个通知在一段时间之后被自动 cancel；\n其他的比如可以获取通知的清除方式，修改通知的背景颜色，修改通知的样式；\n\n\n自动填充（Auto-Fill），Android 8.0 通过引入自动填充框架，简化了登录和信用卡表单之类表单的填写工作；\n自适应图标（Adaptive icons）：\n如果你的手机默认应用程序图示形状是圆角正方形，那么所有应用程序的图标都将是这个形状（前提是开发人员使用了这一功能）。也就是说，你将不再看到系统主屏上方形图标和圆形图标混合在一起的现象。\n后台进程限制\n当应用被置入后台后，Android O将自动智能限制后台应用活动，主要会限制应用的广播、后台运行和位置，但应用的整体进程并没有被杀掉；\n运行时权限策略变化\n\n在 Android O 之前，如果应用在运行时请求权限并且被授予该权限，系统会错误地将属于同一权限组并且在清单中注册的其他权限也一起授予应用；\n对于针对Android O的应用，此行为已被纠正。系统只会授予应用明确请求的权限。然而一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准；\n\n\n\nAndroid 7.x\n\n通知栏快捷回复；\n加入原生分屏多任务功能，多任务快速切换；\n引入全新的JIT编译器（由配置文指导的JIT/AOT编译），提升运行时性能，节省存储空间，使得App安装速度快了75%，编译代码的规模减少了50%；\n随时随地低电耗模式：\n在 Android 7.0 中，低电耗模式又前进了一步，随时随地可以省电。只要屏幕关闭了一段时间，且设备未插入电源，低电耗模式就会对应用使用熟悉的 CPU 和网络限制。\n更安全的加密模式，可以对单独的文件进行加密，android系统启动加密；\nVR支持；\n\nAndroid 6.0\n\n运行时权限：\n用户可以直接在运行时管理应用权限。这种模式让用户能够更好的了解和控制权限。\n新增瞌睡模式（doze）和待机模式（app standby）：\n瞌睡模式：当不碰手机，手机自动关闭屏幕后，过一会，手机将进入瞌睡模式。在瞌睡模式下，设备只会定期的唤醒，然后继续执行等待中的任务接着又进入瞌睡；\n待机模式：假如用户一段时间不触碰手机，设备将进入待机模式。在这个模式下，系统会认为所有app是闲置的，这时系统会关闭网络，并且暂停app之前正在执行的任务。\n移除对Apache HTTP client的支持，建议使用HttpURLConnection。如果还是想用Apache HTTP client，那么需要在build.gradle中添加： 123android &#123;    useLibrary &#x27;org.apache.http.legacy&#x27;&#125;\n\n\nAndroid 5.x\n\nMaterial design；\n系统由以往的Dalvik模式改为采用ART（Android Runtime）模式：\nAndroid在全新的ART运行时上独占运行，这个全新开发的运行时支持混合使用预先编译（AOT）代码、即时编译（JIT）代码和解析代码。它支持 ARM、x86 和 MIPS 架构，并全面兼容 64 位。ART可改善应用性能和响应速度。\n改善通知栏，在锁屏状态下也能接收到通知，在来电状态下能出现在抬头通知中；\n屏幕采集和屏幕共享；\n\nAndroid 4.x\n\n截屏功能：\n同时按下电源键和音量“下”即可。\n增强对通知内容的获取，监听通知的服务可以获取通知的文本、图标、图片、进度、计时器等；\n改进WebView,更好的支持HTML5，CSS3以及JavaScript,支持使用Chrome开发工具远程调式移动设备中WebView 的内容；\n沉浸式模式；\n支持屏幕录制；\n\nAndroid 3.x及以下\n忽略！\n","plink":"https://blog.ixin.run/posts/1611424493/"},{"title":"Android Library如何在GitHub上开源","date":"2021-01-23T17:21:59.000Z","date_formatted":{"ll":"2021年1月24日","L":"2021/01/24","MM-DD":"01-24"},"updated":"2021-01-29T12:51:44.654Z","content":"平时我们在Android开发过程中引用了很多依赖，不乏有很多Github上开源的Library，例如JakeWharton的黄油刀依赖如下：\n1234dependencies &#123;  implementation &#x27;com.jakewharton:butterknife:10.2.3&#x27;  annotationProcessor &#x27;com.jakewharton:butterknife-compiler:10.2.3&#x27;&#125;\n独乐乐不如众乐乐，那么我们怎样如何将我们自己写的Library发布到Github上开源供别人使用呢？下边我就用我自己的Library简单说一下。\n\n简单介绍AAtools\n我之前写了一个小工具——AATools，Github地址是：https://github.com/ixinrun/AATools\n\n也是我开发过程中使用的一个小工具，主要功能是Android开发过程中帮助开发调试和QA进行测试的，目前功能有上图六个模块，功能上只是初步，先拿来用，后边有时间再完善。接下来发布Library我们只需要三步。\n1. 创建Library\nandroid studio创建library，这个很简单，项目上直接new Module即可，创建好如下图所示：\n\n2.GitHub上进行生成Release包\n我们将上边的项目提交到GitHub，然后点击Release，生成最新Release包，并填写最新版本号：\none:\n\ntwo:\n\nthree:\n\n3.JitPack上发布依赖\nJitPack是发布GitHub依赖常用的开源托管仓库，常见托管仓库有以下几种：\n\nMaven Central\njCenter\n自建私服\n\n将仓库地址提交到JitPack（https://jitpack.io/） ：\n\n点击Git it，下边马上就会生成我们插件的依赖地址：\n\n到这里就结束了，就这么简单。\n最后\n欢迎大家使用AATools，后边会不定期更新这个小工具，好用的话别忘了github上star哦。\n","plink":"https://blog.ixin.run/posts/1611422519/"},{"title":"Markdown基本使用方法","date":"2021-01-10T20:37:54.000Z","date_formatted":{"ll":"2021年1月11日","L":"2021/01/11","MM-DD":"01-11"},"updated":"2021-01-29T12:51:44.667Z","content":"最初接触Markdown编辑法是从上大学开始的，至今有八九年了，特点就是简洁、简洁还是简洁，这里是我个人总结的一些Markdown基本使用技巧，共日常参考。\n\n1.大标题\n在文字下方画几个等号，个数大于0即可：\n大标题\n2.二级标题\n在文字下方画几个短横线，个数大于0即可：\n你好\n3.换行\n一句话末尾敲两个空格，然后折行：\n例如这样\n4.字体大小分6级：\n#：一级字体和大标题大小一样\n##：二级字体和二级标题大小一样\n###：三级字体\n。。。\n######：最小字体\n注意：#号结束后空一格才能产生效果。\n5.加粗\n加粗：文字两边各两个*\n斜体：文字两边各一个*\n引用：&gt; 你好（中间有空格）\n二级引用：&gt;&gt; 你好（中间有空格）\n注意：如果确实想成&quot;**你好**&quot;,可用“\\”进行转义。\n6.无序列表\n- 您好\n- 您好\n或者\n* 您好\n* 您好\n再或者\n+ 您好\n注意：这之间有空格才会有效果。\n7.有序列表\n\n你好\n我好\n\n注意：这之间有空格才会有效果。\n不论是无序还是无序如果面对复杂的列表建议还是不要用markdown表示，例如有序列表item下同时有两个代码块则下个item不按照顺序来显示的，此时也可以在第二个代码块前边打一个tab键。\n8.分段\n上一段末尾用&lt;br/&gt;, 或者直接空一行即可。\n9.插入链接\n直接在文字后面写上链接地址：www.baidu.com\n超链接：\n\n采用Html标签：&lt;a href=“http://www.baidu.com” target=“blank”&gt;百度\n[百度](http://www.baidu.com)\n[百度](http://www.baidu.com, “这是百度的链接”)\n内部引用:[百度][1]、[谷歌][2]\n在文章末尾写上：\n[1]:http://www.baidu.com “这是百度的链接”\n[2]:http://www.google.com\n\n10.插入横线\n—或者***\n三个以上就可以了\n11.插入图片\n\n采用Html标签：&lt;img src=“html://helloxinrun/1.png” width=“320” hight=“480”&gt;\n此种方式相对灵活，可以对图片大小限制，也可以设置图片指示器说明。\n采用内联样式：![加载显示的文字](http://helloxinrun/1.png “这是一张图片”)\n采用引用方式：\n![加载失败显示的文字][1]\n这种方式和超链接一样，参展超链接引用方式。\n\n12.代码块\n\n\n大块代码写法：\n``` java\n这里写相关代码，注意这里的三个点曲子esc键下边的那个键，三个点后边的java表示此代码块属于那种格式。\n```\n\n\n小块代码写法：\n`这里写相关代码`\n可用于部分文字添加背景\n\n\n13.表格：\n\n第一种：\n\n12345项目        |价格  ------------|-------------  computer    |$1600  phone       |$12\n\n第二种：\n\n1234|项目    |价格     |数量   ||:-------|:-------:|------:||computer|$1600    |1      |  \n注意:冒号是英文输入法下的。且冒号的作用是设置内容对齐方式的。复杂的表格建议采用html标签或者图片取代。\n14.分类\n12345678项目1  : 定义A: 定义B  项目2: 定义C: 定义D\n注意：项目2上方有一行空行，另外冒号后边有空格。\n15.生成目录\n生成目录用[toc]，会将以一级标题到六级标题分级列出来并设置锚点。不过在部分环境下不起作用，通常下载插件或者采用html标签来实现。\n16.流程图\nhttps://www.jianshu.com/p/02a5a1bf1096\n","plink":"https://blog.ixin.run/posts/1610311108/"},{"title":"带你玩转Hexo——网站搭建","date":"2021-01-10T16:28:31.000Z","date_formatted":{"ll":"2021年1月11日","L":"2021/01/11","MM-DD":"01-11"},"updated":"2021-03-15T04:16:08.117Z","content":"我的博客用的是Hexo框架，有一段时间没有倒腾它了，最近浏览官网发现hexo版本已经到5.3.0了，我自己的还是4.0时代，瞅了一下5.0版本的升级日志是各种牛逼，我也看不懂，是时候升级一波体验一下，顺便总结一下自己对hexo的玩法。\n\nHexo是什么\n一个静态博客生成框架，推荐看Hexo官方文档\nHexo搭建准备工作\n首先电脑上需要安装以下两个程序：\n\nGit\nNode.js\n\ngit是为了部署生成的博客；Node.js为博客生成创造编译环境，类比java的jvm。\nHexo下载\n打开CMD，采用node.js的npm命令下载官网hexo依赖，npm下载依赖有两种方法：\n12345&#x2F;&#x2F; 系统全局下载，默认安装在C:\\Users\\PC用户名\\AppData\\Roaming\\npm目录下$ npm install hexo-cli -g&#x2F;&#x2F; 文件根目录下载，指定目录下执行，下载当前目录$ npm install hexo --save\nhexo下载采用第一种，后续博客中用到的插件可以定位到博客项目目录下采用第二种下载。\nHexo初始化\n本地随便一个地方建一个文件夹例如blog，cmd命令行指示到该文件夹下进行hexo的初始化：\n1hexo init\n稍等片刻，hexo初始化完成，即我们的博客雏形已经有了，此时我们执行以下两个命令后渲染博客进行预览：\n12hexo ghexo s\n复制命令行给出地址http://localhost:4000到浏览器预览即可。\n添加文章\n生成的博客发现空空如也，我们添加一篇文吧：\n1hexo n 我的第一篇博客\nhexo默认管理的文章都在blog\\source\\_posts路径下，我们在此路径下找到刚才生成的md文件，用vscode编辑器随便写点东西，保存。\n然后接着执行刚才渲染博客的命令：\n12hexo ghexo s\n然后刷新博客首页，马上多出来一篇文章。\n主题更换\nHexo初始化后默认自带的主题是不是很丑，哈哈，别急，我们到Hexo主题市场下载一个主题，hexo博客项目的主题存放在根目录themes文件夹下，把刚才下载的主题复制到此文件夹并解压，然后修改项目根目录_config.yml的主题指向即可。\n_config.yml是博客的配置项，有两种：\n\n上边所说博客项目根目录下的，控制博客整体的配置，例如网站名称，主题指向等等。\n每个主题theme根目录下的，控制主题的配置，用于博客美化，例如背景色，头像，字体等等。\n\n插件安装\nhexo初始化后至少需要安装一个git插件，用于引导系统安装的git发布博客到服务器。\n1npm install hexo-deployer-git --save\n注意此时的插件是安装在博客项目根目录下的node_modules中了，上文已经讲过。\n有些主题采用markdown-itapi渲染md文本，然而Hexo框架默认采用的是&quot;hexo-renderer-marked&quot;插件来渲染的，好多文章指出替换默认的渲染插件（删除、替换），其实我建议直接安装即可，爱用哪个用哪个，谁知道哪种主题抽什么风呢。\n1npm i hexo-renderer-markdown-it --save\n其他插件可自行研究，更多插件见：https://hexo.io/plugins/\n博客发布\n以上只能看到博客在本地的预览，如何把博客发布到服务器上随时随地预览呢？这里涉及到域名购买，服务器购买，域名解析，CDN加速，网站备案等等诸多技术限制，当然个人博客简单起见可以部署到github pages上进行练手。github上建立一个特殊仓库【github用户名】.github.io。\n修改本地博客项目根目录下的_config.yml文件中的deploy项：\n1234deploy:  type: git  repo: git@github.com:xxx&#x2F;xxx.github.io.git  branch: master\n好了，万事具备，开始发布，继续执行CMD命令：\n1hexo d\n稍等几分钟，打开浏览器输入【github用户名】.github.io, 激动吧\n五个常用命令\n以下是发布博客的五个常用CMD命令：\n\nhexo g 完整命令为hexo generate，用于生成静态文件。\nhexo s 完整命令为hexo server，用于启动服务器，主要用来本地预览。\nhexo d 完整命令为hexo deploy，用于将本地文件发布到github上。\nhexo n 完整命令为hexo new，用于新建一篇文章。\nhexo clean, 有些时候可能有冲突，所以在生成静态页面前先clean,然后生成、发布，一切都很自然。\n\n高级用法\n自定义首页\n原理：github pages有两种：\n\ngithub全局：xxx.github.io\n其他仓库：每个仓库都有一个开启github pages的选项，用于描述该仓库的相关说明。生成的连接是xxx.github.io/仓库名/。\n\n自定义首页部署在第一个，博客部署在第二个，利用他们共有的域名xxx.github.io建立上下级联系。\n将来我们购买过域名后，例如 xxxx.com， 那么我们的首页就是www.xxx.com，那么第二个仓库的page地址就是www.xxx.com/仓库名/。我们也可以采用二级域名形式，这个以后再讲咯。\n修改根目录_config.yml的url:\n1234# URL## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;url: https:&#x2F;&#x2F;xxx.github.ioroot: &#x2F;\n接下来将首页（xxx.github.io）中进入博客的入口超链接到子库的page地址即可。\n注意：将新仓库的setting里的Git page打开。（这步很重要）\n添加RSS订阅\n安装RSS订阅插件，根目录执行CMD命令：\n1npm install hexo-generator-feed\n然后根目录下的_config.yml按照官方文档配置如下：\n1234feed:  type: atom  path: atom.xml  limit: 20\n详情请看：https://www.npmjs.com/package/hexo-generator-feed\n急速搭建\n有时候更换电脑或者换了个工作环境，以上繁琐的搭建步骤还要要走一遍，感觉有点心累啊，为了简单起见，我建议把上边安装的所有插件和主题设置一同打包push到远程仓库中，除了把每次hexo g产生的冗余文件忽略掉。博客项目下有个.gitignore，hexo默认忽略了很多，包含初始化的node_modules，这个不能忽略，我们自己安装的插件都在这里面，以下是我自己项目中.gitignore的内容:\n123456.DS_StoreThumbs.db*.logpublic&#x2F;.deploy*&#x2F;&#x2F;db.json\n下次我们换电脑，只需要安装git和node.js，项目clong下来就可以发布文章了。\nHexo升级\n文初说的Hexo升级，到结束了才说，我日😂。\nHexo升级先看官方说明，一般是以下几步：\n\n检查是否需要升级node.js，需要的话进行升级\n升级hexo-cli: 1npm install hexo-cli -g  #全局升级hexo-cli(Hexo框架生成器)\n\n其他命令 1234567&#x2F;&#x2F;以下命令分别执行即可npm install -g npm-check     &#x2F;&#x2F;安装npm-checknpm-check                    &#x2F;&#x2F;查看系统插件是否需要升级npm install -g npm-upgrade   &#x2F;&#x2F;安装npm-upgradenpm-upgrade        &#x2F;&#x2F;更新package.jsonnpm update -g      &#x2F;&#x2F;更新全局插件npm update --save  &#x2F;&#x2F;更新系统插件\n\n\n最后hexo -v查看以下hexo的版本信息情况，注意该指令在系统目录执行时只能看到hexo-cli的版本情况，只有在博客根目录执行才能看到博客hexo的版本信息，我们说的hexo升级主要指的就是博客hexo框架版本的升级。\n最后\n本文注重过程，细节不明之处详看官方文档：https://hexo.io/zh-cn/docs/\n🤞谢谢各位看官🤞\n","thumbnail":"https://tommy.net.cn/2020/07/07/upgrade-hexo-to-v4-2-1/hexo.png","plink":"https://blog.ixin.run/posts/1610308156/"},{"title":"Alibaba插件代码质量检测问题归总","date":"2020-05-15T05:50:57.000Z","date_formatted":{"ll":"2020年5月15日","L":"2020/05/15","MM-DD":"05-15"},"updated":"2021-01-29T12:51:44.656Z","content":"前段时间针对公司老项目做了一次代码规范质量检查，采用的是阿里巴巴代码检测插件进行检测，检查结果并不理想，老项目比较重，开发迭代人员比较多，本文就是对这些检查点做一个记录，方便之后回顾。\n\nAlibaba代码检测插件是2017年开发的，无论是IDEA还是Android Studio都可以安装使用，深受开发者好评。androidstudio可以直接搜索插件Alibaba Java Coding Guidelines进行安装使用。\nBlocker\n\n\nif、for语句必须采用闭包形式，不允许采用无括号形势编写。\n\n\n在使用正则表达式时，利用好其预编译功能，可以有效加快编译速度。\n说明：不要在方法体内定义：Pattern pattern = Pattern.compile(规则);\n 123456789public class XxxClass &#123;        // Use precompile        private static Pattern NUMBER_PATTERN = Pattern.compile(&quot;[0-9]+&quot;);        public Pattern getNumberPattern() &#123;            // Avoid use Pattern.compile in method body.            Pattern localPattern = Pattern.compile(&quot;[0-9]+&quot;);            return localPattern;        &#125;    &#125;\n\n\n线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n说明：Executors返回的线程池对象的弊端如下：\n 1234a. FixedThreadPool和SingleThreadPool:允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。b. CachedThreadPool:允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。\n个人开发建议，全局封装一个ThreadPoolExecutor线程池工具类，统一管理线程池申请。\n\n\nCritical\n\n\nMap/Set的key为自定义对象时，必须重写hashCode和equals。\n关于hashCode和equals的处理，遵循如下规则：\n 123a. 只要重写equals，就必须重写hashCode。b. 因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须重写这两个方法。 c. 如果自定义对象做为Map的键，那么必须重写hashCode和equals。\n\n\nObject的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。\n\n\n不能使用过时的类或方法。\n\n\n创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。创建线程池的时候请使用带ThreadFactory的构造函数，并且提供自定义ThreadFactory实现或者使用第三方实现。\n 123456789101112131415ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()    .setNameFormat(&quot;demo-pool-%d&quot;).build();ExecutorService singleThreadPool = new ThreadPoolExecutor(1, 1,    0L, TimeUnit.MILLISECONDS,    new LinkedBlockingQueue&lt;Runnable&gt;(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());singleThreadPool.execute(()-&gt; System.out.println(Thread.currentThread().getName()));singleThreadPool.shutdown();            public class TimerTaskThread extends Thread &#123;    public TimerTaskThread()&#123;    super.setName(&quot;TimerTaskThread&quot;); …&#125;\n个人开发建议，全局封装一个ThreadPoolExecutor线程池工具类，暴露初始化线程名称定义。\n\n\n在一个switch块内，每个case要么通过break/return等来终止，要么注释说明程序将继续执行到哪一个case为止；在一个switch块内，都必须包含一个default语句并且放在最后，即使它什么代码也没有。\n\n\n常量命名应该全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。\n\n\n异常类命名使用Exception结尾。\n\n\n所有枚举类型字段必须要有注释，说明每个数据项的用途。\n\n\n所有编程相关的命名均不能以下划线或者美元符号命名。\n\n\n抽象类命名使用Abstract或Base开头，抽象类一般需要被继承使用的。\n\n\n方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase，必须遵从小驼峰形式\n\n\n浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用equals来判断。 浮点数采用“尾数+阶码”的编码方式，类似于科学计数法的“有效数字+指数”的表示方式。二进制无法精确表示大部分的十进制小数，具体原理参考《码出高效》。\n改进方式:\n12345678910111213141516171819202122232425262728293031323334351）指定一个误差范围，两个浮点数的差值在此范围之内，则认为是相等的    float a = 1.0f - 0.9f;    float b = 0.9f - 0.8f;    float diff = 1e-6f;    if (Math.abs(a - b) &lt; diff) &#123;        System.out.println(&quot;true&quot;);    &#125;2) 使用BigDecimal来定义值，再进行浮点数的运算操作    BigDecimal a = new BigDecimal(&quot;1.0&quot;);    BigDecimal b = new BigDecimal(&quot;0.9&quot;);    BigDecimal c = new BigDecimal(&quot;0.8&quot;);    BigDecimal x = a.subtract(b);    BigDecimal y = b.subtract(c);    if (x.equals(y)) &#123;        System.out.println(&quot;true&quot;);    &#125;            Negative example:        float g = 0.7f-0.6f;        float h = 0.8f-0.7f;        if (g == h) &#123;            System.out.println(&quot;true&quot;);        &#125;   Positive example:        double dis = 1e-6;        double d1 = 0.0000001d;        double d2 = 0d;        System.out.println(Math.abs(d1 - d2) &lt; dis);    \n\n\n线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。\n说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。\n\n\nMajor\n\n不允许任何魔法值（即未经定义的常量）直接出现在代码中。 12345678910111213Negative example:    //Magic values, except for predefined, are forbidden in coding.    if (key.equals(&quot;Id#taobao_1&quot;)) &#123;            //...    &#125;                         Positive example:    String KEY_PRE = &quot;Id#taobao_1&quot;;    if (KEY_PRE.equals(key)) &#123;            //...    &#125;\n\n中括号是数组类型的一部分，数组定义如下：String[] args\n\n123Negative example:        String extArrayString[] = &#123; &quot;.amr&quot;, &quot;.ogg&quot;, &quot;.mp3&quot;, &quot;.aac&quot;, &quot;.ape&quot;,\t\t\t\t&quot;.flac&quot;, &quot;.wma&quot;, &quot;.wav&quot;, &quot;.mp2&quot;, &quot;.mid&quot;, &quot;.3gpp&quot; &#125;;\n\n\n包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。\n个人建议，如果遇到包名必须用两个或以上的单词才能表达，可以采用Spring的命名方式，两个单词用点分割；开发过程中我们尽量采用一个单词进行表达。\n\n\n单个方法的总行数不超过80行。\n说明：除注释之外的方法签名、结束右大括号、方法内代码、空行、回车及任何不可见字符的总行数不超过80行。\n\n\n及时清理不再使用的代码段或配置信息。\n说明：对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余。\n\n\n循环体内，字符串的联接方式，使用StringBuilder的append方法进行扩展。\n说明：反编译出的字节码文件显示每次循环都会new出一个StringBuilder对象，然后进行append操作，最后通过toString方法返回String对象，造成内存资源浪费。\n 1234567891011121314Negative example:        String result;        for (String string : tagNameList) &#123;            result = result + string;        &#125;            Positive example:        StringBuilder stringBuilder = new StringBuilder();        for (String string : tagNameList) &#123;            stringBuilder.append(string);        &#125;        String result = stringBuilder.toString();\n\n\n所有的抽象方法（包括接口中的方法）必须要用javadoc注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。\n说明：如有实现和调用注意事项，请一并说明。\n\n\n方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/* */注释。注意与代码对齐。\n 123456789public void method() &#123;    // Put single line comment above code. (Note: align &#x27;//&#x27; comment with code)    int a = 3;    /**    * Some description about follow code. (Note: align &#x27;/**&#x27; comment with code)    */    int b = 4;&#125;\n\n\n类、类属性、类方法的注释必须使用javadoc规范，使用/*内容/格式，不得使用//xxx方式和/xxx/方式。 说明：在IDE编辑窗口中，javadoc方式会提示相关注释，生成javadoc可以正确输出相应注释；在IDE中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。\n 123456789101112131415161718192021222324252627/** *  * XXX class function description. * */public class XxClass implements Serializable &#123;    private static final long serialVersionUID = 113323427779853001L;    /**     * id     */    private Long id;    /**     * title     */    private String title;    /**     * find by id     *      * @param ruleId rule id     * @param page start from 1     * @return Result&lt;Xxxx&gt;     */    public Result&lt;Xxxx&gt; funcA(Long ruleId, Integer page) &#123;        return null;    &#125;&#125;\n\n\n类名使用UpperCamelCase风格，必须遵从驼峰形式，但以下情形例外：（领域模型的相关命名）DO / BO / DTO / VO / DAO\n\n\n除常用方法（如getXxx/isXxx）等外，不要在条件判断中执行复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量，以提高可读性。\n说明：很多if语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？\n12345678910111213Negative example:        if ((file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...)) &#123;            // ...        &#125;\t\t\t\t\t\t\t\t\tPositive example:        boolean existed = (file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...);        if (existed) &#123;            //...        &#125;\n\n\n集合初始化时，指定集合初始值大小。\n说明：HashMap使用如下构造方法进行初始化，如果暂时无法确定集合大小，那么指定默认值（16）即可。\n1234567Negative example:     Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();         Positive example:   Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(16);\n\n","plink":"https://blog.ixin.run/posts/1589521857/"},{"title":"针对极光推送送达率的探究","date":"2020-04-22T09:27:41.000Z","date_formatted":{"ll":"2020年4月22日","L":"2020/04/22","MM-DD":"04-22"},"updated":"2021-02-03T02:09:08.597Z","content":"前段时间内部一个应用对接了极光推送，开发人当然是我咯，根据多年对极光的认可这块对接还是很有信心的。毕竟是内部系统，送达率要求还是很高的，业务实时性需要，所以产品这块非常看重送达率，我对他说极光的实时送达率很客观的，有实验室数据，但是他还是希望我帮他提供一个可靠的数据，下边是我对实时送达率的一个分析。\n当然，针对推送作为开发的我更关注整体送达率（准确送达率），文中也有提到，最简单可靠的方式就是提高app的存活率。\n\n先了解三个概念\n\n目标数：一个月内与极光服务器有过连接的用户（设备）。\n\n这部分数据包含：app卸载的，app在线的，app离线的（未启动或者未开启推送的）\n所以数据量非常庞大，我们的业务受节假日影响，有相关波动，所以这个维度比较虚。\n\n在线数：消息推送时目标用户在线。\n\n这部分数据指得是实时与极光服务器保持常连接的用户或设备数。\n\n送达数：消息发送到达客户端的数量。\n\n这部分数据包含：在线消息数和离线消息数，其中离线消息是默认保存一天的，也就是说一天只内只要启动应用开启推送都可以接收到的。\n准确的测算方式\n最准确的测算极光送达率方法应该按照在“某个时间段”并且“单一发送消息”和“大量用户”支撑，遵循以下公式：\nrate = （在线接收数+离线接收数）/ 有效目标数\n有效目标数指的是一天之内启动应用的用户数，目前极光推送官方没有离线接收数和有效目标数这两维度，并且我们的消息是零零散散发送的，这就给我们测算造成了一定困难。\n之前也是因为没有离线接收这个数据，当时用的是送达数/目标数，测算出主项目那边大概是30%，内部项目我测算了一下占到55%，内部项目虽然客观，但这个数据不是我们想要的。\n根据目前极光给出的数据维度，只能按照某个短时间内测算实时送达率，即：送达数/在线数，忽略掉离线的那部分。\n实例\n前段时间内部项目有新版本需要上线，推送了一条消息给全国门店：\n\n第一部分是瞬间全国的推送（包含干扰部分），第二部分是相邻时间段其他零星消息的干扰情况，大概一分钟是接收30条。\n针对全国的推送上图第一部分分析得知大概一次推送分三批完成，这是我们后端对接极光的一种推送方案，具体情况如下：\n瞬间推送第一批：\n\n瞬间推送第二批：\n\n瞬间推送第三批：\n\n因此根据全国推送并去除干扰消息，得出实时极光送达率：\nrate = （510+479+357-30-零星离线接收的）/ (483+466+334)  约=  100%\n目前是测算实时在线到达率结果是可观的，离线推送的部分后边可以看看能否通过其他渠道去了解。\n这里也有人有相关的提问：https://community.jiguang.cn/question/35820\n","plink":"https://blog.ixin.run/posts/1587547661/"},{"title":"WebView高度自适应方案探究","date":"2020-04-14T15:59:52.000Z","date_formatted":{"ll":"2020年4月14日","L":"2020/04/14","MM-DD":"04-14"},"updated":"2021-01-29T12:51:44.650Z","content":"Android项目开发中针对webview避免不了混合开发模式，可Android上的webview又很不争气，几乎每个Android版本都有webvie的改动，在国内这种鱼龙混杂环境下出乎意料的问题又很多，这次就谈谈webview高度自适应的问题。\n\n问题\n在Android开发生涯中想必大家都遇到过，webview在有些时候展示不完整，在某些时候底部有一片空白，有些时候始终又滑不到底。。。导致这个问题的原因常见有以下三种：\n\n网页高度不固定\n嵌套布局导致webview的高度无法自适应\n系统原因导致webview在某种特殊情况下不能兼容当前应用的屏幕分辨率\n\n下边就分别说说这三种情况引起的原因以及解决方法。\n针对网页高度不固定问题\n这部分原因和H5编写方法有很大关系，例如Ajax异步处理结果过慢，webview的高度不能及时更新；也有可能H5编写时预留了一个资源展示区等待将来资源展示，结果资源没有加载出来。这个和H5开发人员说明一下情况，检查一下代码结构。\n针对嵌套布局导致webview高度不固定问题\n这个是Android开发最常见的事，很多时候是混合开发模式，不得已采用scrollview嵌套webview,但是我们知道scrollview中嵌套其他view常常使某些view的高度（match_parent）失效，当然你可以采用android:fillViewport=&quot;true&quot;强制让其撑满，但是似乎其内部的webview又不听话了，这个道理很明显，毕竟webview渲染的是网页，也即是我们能够准确固定webview高度这个问题就迎刃而解了。\n针对webview兼容当前应用屏幕密度问题\n首先我们要处理的是避免系统字体的缩放影响webview缩放，我们可以用webview.getSettings().setTextZoom(100)来避免。其余的支持自适应即可，在应用屏幕密度设定之后webiview可自动匹配，当然也有一些奇葩设备（被应用商修改过），这部分我们可以忽略了。\n针对高度不固定问题解决方案\n我这里给出两种解决方案。\n布局结构调整\n按照官方建议webiview父布局高度采用match_parent。\nWebView根据网页的高度自动扩展自身高度：\n我们按照步骤走：\n第一步：本地定义Js交互接口，通常H5需要明确这个接口标识，Android端才能回调相关内容给H5。\n1mWebView.addJavascriptInterface(this, &quot;App&quot;);\n第二步：本地实现接口方法，H5通过上边的“APP”接口标识能调用本地该接口里面的方法。\n123456789101112131415161718/** * js回调，重新计算webview的高度。 */@JavascriptInterfacepublic void resize(final float clientWidth, final float scrollHeight) &#123;    if (mActivity == null || mWebView == null || clientWidth == 0) &#123;        return;    &#125;    mActivity.runOnUiThread(new Runnable() &#123;        @Override        public void run() &#123;            float rate = mWebView.getWidth() / clientWidth;            Log.i(&quot;TAG&quot;, &quot;webview---------clientWidth:&quot; + clientWidth + &quot;---------scrollHeight:&quot; + scrollHeight + &quot;---------rate:&quot; + rate);            mWebView.setLayoutParams(new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT,                    (int) (scrollHeight * rate)));        &#125;    &#125;);&#125;\n第三步：本地调用H5的js方法，告诉H5：“我，大Android，需要你H5现在的宽和高”，然后H5乖乖的把界面上宽高回调给本地，就是第二步的方法。但是！我今天说的这个是通用方式，是针对所有的H5的，不可能让每个H5都定义一个js方法供Android端调用，怎么办呢？好办，直接让H5回调本地方法：\n1mWebView.loadUrl(&quot;javascript:App.resize(document.documentElement.clientWidth, document.documentElement.scrollHeight)&quot;);\n这里的“App”其实就是“this”，那么js回调时机是什么时候呢，我是希望这个页面加载结束的时候告诉我，所以重写WebViewClient里面的onPageFinished方法。由于有些H5采用异步加载的方式，我不知道他到底什么时候完全加载出来，所以这里我分多次让H5帮我回调：\n123456789101112131415161718192021222324252627282930class DefaultWebViewClient extends WebViewClient &#123;    //页面内跳转    @Override    public boolean shouldOverrideUrlLoading(WebView webView, String s) &#123;        webView.loadUrl(s);        return true;    &#125;    @Override    public void onPageFinished(WebView webView, String s) &#123;        super.onPageFinished(webView, s);        //执行网页高度获取，不断获取网页高度        mHandler.post(new Runnable() &#123;            //执行最大次数            int times = 5;            @Override            public void run() &#123;                if (times &gt; 0) &#123;                    mWebView.loadUrl(&quot;javascript:App.resize(document.documentElement.clientWidth, document.documentElement.scrollHeight)&quot;);                    mHandler.postDelayed(this, 1000);                    times--;                &#125;            &#125;        &#125;);    &#125;&#125;\n总结\n以上是我针对该类问题想到的一些处理方案，大家有更好的处理方式不妨也分享一下，集思广路，一同进步。\n","plink":"https://blog.ixin.run/posts/1586879992/"},{"title":"Android开机启动的那些事","date":"2020-04-12T10:46:00.000Z","date_formatted":{"ll":"2020年4月12日","L":"2020/04/12","MM-DD":"04-12"},"updated":"2021-01-29T12:51:44.641Z","content":"以前知道AMS、PMS这些概念及其功能，开发的过程中也会用到，就是不知道其来源，好奇心害死猫，扒着扒着扒到系统开机启动这个知识层面上来了，好吧，那今天就说说这个吧！\n\n系统开机启动过程\nAndroid系统的启动，主要是指Android手机关机后，长按电源键后，Android手机开机的过程。从系统角度看，Android的启动程序可分为：\n\nbootloader引导\n装载与启动Linux内核\n启动Android系统\n\n其中启动Android系统过程又有以下过程：\n\n启动Init进程\n启动Zygote\n启动SystemServer\n启动Launcher\n\nandroid启动过程图示：\n\nzygote\n我们知道，Android系统是基于Linux内的。而在Linux系统中，所有的进程都是init进程的子孙进程，也就是说，所有的进程都是直接或者间接地由init进程fork出来的。\n系统启动的时候执行系统启动脚本system/core/rootdir/init.rc文件，进而触发app_process程序（system/bin/app_process，它的源代码位于frameworks/base/cmds/app_process/app_main.cpp文件中，入口函数是main）创建Zygote进程，Zygote进程负责后续Android应用程序框架层的其它进程的创建和启动工作。\nZygote进程最大意义是作为一个Socket的Server端，接收着四面八方的进程创建请求。Android中所有的应用进程的创建都是通过Binder机制请求SystemServer进程，SystemServer进程发送socket消息给Zygote进程，统一由Zygote进程创建出来的。\n\nSystemServer\nSystemServer也是一个进程，而且是由zygote进程fork出来的。SystemServer主要用于开启系统重要的一些相关服务，例如：ActivityManagerService（AMS）、PackageManagerService（PMS）、WindowManagerService（WMS）等等，是不是都很熟悉呢？所以SystemServer和Zygote重要级别可以说是平分秋色了。\n什么时候开启SystemServer\n在zygote开启的时候，会调用ZygoteInit.main()进行初始化：\n12345678910111213141516171819202122232425262728public static void main(String argv[]) &#123;         ...ignore some code...        //在加载首个zygote的时候，会传入初始化参数，一旦捕获到参数是“start-system-server”，即可开启fork SystemServer指令     boolean startSystemServer = false;     for (int i = 1; i &lt; argv.length; i++) &#123;                if (&quot;start-system-server&quot;.equals(argv[i])) &#123;                    startSystemServer = true;                &#125; else if (argv[i].startsWith(ABI_LIST_ARG)) &#123;                    abiList = argv[i].substring(ABI_LIST_ARG.length());                &#125; else if (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());                &#125; else &#123;                    throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]);                &#125;            &#125;                        ...ignore some code...                     //开始fork我们的SystemServer进程     if (startSystemServer) &#123;                startSystemServer(abiList, socketName);         &#125;     ...ignore some code...&#125;\n接下来看一下startSystemServer具体做了什么\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Prepare the arguments and fork for the system server process. */private static boolean startSystemServer(String abiList, String socketName)        throws MethodAndArgsCaller, RuntimeException &#123;         ...ignore some code...        //上面ZygoteInit.main(String argv[])里面的argv就是通过这种方式传递进来的    /* Hardcoded command line to start the system server */    String args[] = &#123;        &quot;--setuid=1000&quot;,        &quot;--setgid=1000&quot;,        &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1032,3001,3002,3003,3006,3007&quot;,        &quot;--capabilities=&quot; + capabilities + &quot;,&quot; + capabilities,        &quot;--runtime-init&quot;,        &quot;--nice-name=system_server&quot;,        &quot;com.android.server.SystemServer&quot;,    &#125;;    int pid;    try &#123;        parsedArgs = new ZygoteConnection.Arguments(args);        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);        //fork SystemServer        /* Request to fork the system server process */        pid = Zygote.forkSystemServer(                parsedArgs.uid, parsedArgs.gid,                parsedArgs.gids,                parsedArgs.debugFlags,                null,                parsedArgs.permittedCapabilities,                parsedArgs.effectiveCapabilities);    &#125; catch (IllegalArgumentException ex) &#123;        throw new RuntimeException(ex);    &#125;    /* For child process */    if (pid == 0) &#123;        if (hasSecondZygote(abiList)) &#123;            waitForSecondaryZygote(socketName);        &#125;        handleSystemServerProcess(parsedArgs);    &#125;    return true;&#125;\n这个方法主要是为了开启SystemServer，这里做了三件事：\n\n准备fork SystemServer相关参数，例如SystemServer进程的进程Id和组Id均为为1000，进程名称为system_server等。\nfork SystemServer，如果返回pid为0则创建成功，否者返回-1或者错误；\n调用handleSystemServerProcess()完成SystemServer进程的初始化工作；\n\nSystemServer进程初始化\n上边也说了SystemServer主要用于开启系统重要的一些相关服务，例如：ActivityManagerService（AMS）、PackageManagerService（PMS）、WindowManagerService（WMS）等等，我们看一下代码具体的内部走法：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public final class SystemServer &#123;    //zygote的主入口    public static void main(String[] args) &#123;        new SystemServer().run();    &#125;    public SystemServer() &#123;        // Check for factory test mode.        mFactoryTestMode = FactoryTest.getMode();    &#125;        private void run() &#123;                ...ignore some code...                //创建主线程looper 在当前线程运行        android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_FOREGROUND);        android.os.Process.setCanSelfBackground(false);        Looper.prepareMainLooper();                //加载本地系统服务库，并进行初始化         System.loadLibrary(&quot;android_servers&quot;);        nativeInit();                // 创建系统上下文        createSystemContext();                //初始化SystemServiceManager对象，下面的系统服务开启都需要调用SystemServiceManager.startService(Class&lt;T&gt;)，这个方法通过反射来启动对应的服务        mSystemServiceManager = new SystemServiceManager(mSystemContext);                //开启服务        try &#123;            startBootstrapServices();            startCoreServices();            startOtherServices();        &#125; catch (Throwable ex) &#123;            Slog.e(&quot;System&quot;, &quot;******************************************&quot;);            Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex);            throw ex;        &#125;               ...ignore some code...        &#125;    //初始化系统上下文对象mSystemContext，并设置默认的主题,mSystemContext实际上是一个ContextImpl对象。调用ActivityThread.systemMain()的时候，会调用ActivityThread.attach(true)，而在attach()里面，则创建了Application对象，并调用了Application.onCreate()。    private void createSystemContext() &#123;        ActivityThread activityThread = ActivityThread.systemMain();        mSystemContext = activityThread.getSystemContext();        mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar);    &#125;    //在这里开启了几个核心的服务，因为这些服务之间相互依赖，所以都放在了这个方法里面。    private void startBootstrapServices() &#123;                ...ignore some code...                //初始化ActivityManagerService        mActivityManagerService = mSystemServiceManager.startService(                ActivityManagerService.Lifecycle.class).getService();        mActivityManagerService.setSystemServiceManager(mSystemServiceManager);                //初始化PowerManagerService，因为其他服务需要依赖这个Service，因此需要尽快的初始化        mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);        // 现在电源管理已经开启，ActivityManagerService负责电源管理功能        mActivityManagerService.initPowerManagement();        // 初始化DisplayManagerService        mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);        //初始化PackageManagerService    mPackageManagerService = PackageManagerService.main(mSystemContext, mInstaller,       mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);           //开启消息循环    Looper.loop();        ...ignore some code...        &#125;&#125;\nSystemServer初始化过程中主要做了以下几个重大工作：\n\n加载本地系统服务库，系统底层初始化。\n创建消息循环体Looper，这个就是为什么我们在主线程里面不用写Looper，就可以处理UI视图，原来系统已经为我们做了这件事。\n创建系统级上下文，在这个过程中创建我们的主线程ActivityThread，获取系统上下文对象mSystemContext，并设置系统默认主题。\n创建SystemServiceManager对象，开启系统服务三连——引导服务、核心服务以及其他服务。\n\n系统级上下文和我们常用的Context是有区别的，主要是用于服务端（系统级主题和其他服务相关的引导），Context到底是个什么玩意？我在前边的一篇文章中也有总结，这里在阐述一遍，Context英文原意是上下文的意思，在平时开发中涉及到的四大组件及资源操作基本上都离不开Context对象。\n服务三连开发者我们最关心的就是引导服务，因为这里面开启的都是我们在日常开发中最容易用到的几个服务：\n\nActivityManagerService AMS在Android系统中扮演很重要的角色，主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似。\nPowerManagerService PowerManagerService主要服务Android系统电源管理工作，这样讲比较笼统，就具体细节上大致可以认为PowerManagerService集中处理用户活动（如点击屏幕，按电源键等）、电量变化、用户设置（如在Setting中设置省电模式，飞行模式）、插拔充电器（无线冲，有线冲）等。当发生以上事件时，PowerManagerService都要进行各种状态的更新。\nDisplayManagerService  DisplayManagerService用来管理显示的生命周期，它决定如何根据当前连接的物理显示设备控制其逻辑显示，并且在状态更改时，向系统和应用程序发送通知等等。\nPackageManagerService  PackageManagerService（简称PMS），是Android系统中核心服务之一，管理着所有跟package相关的工作，常见的比如安装、卸载应用。\nUserManagerService UserManagerService的主要功能是创建和删除用户，以及查询用户信息。Android可以支持多个用户使用系统，通常第一个在系统中注册的用户将默认成为系统管理员。不同用户的设置各不相同，并且不同用户安装的应用及应用数据也不相同。\n\nLauncher\nLauncher即桌面，是Android智能设备的窗口，用户使用最频繁的软件之一。Launhcer是Android所有应用的入口，也提供窗口小部件等功能。\nLauncher本身就是一个APP，一个提供桌面的APP，Laucher有很多和普通APP不同的地方：\n\nLauncher是顶部APP，即任何应用返回后都是到Launcher，不能再继续返回；\nLauncher是所有应用的入口，可以管理应用；\nLauncher是Android系统启动后就要显示给用户的应用。\n\nLauncher是由ActivityManagerService启动的，在SystemServer.java的startOtherServices()方法里面的调用 mActivityManagerService.systemReady()进行Launcher的启动之旅，在systemReady方法执行过程中调了用startHomeActivityLocked方法，方法内部通过getHomeIntent拿到Launcher对应的Intent，最后调用startHomeActivity来启动Launcher。\n12345678910111213141516171819202122232425262728boolean startHomeActivityLocked(int userId, String reason) &#123;    if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL            &amp;&amp; mTopAction == null) &#123;        // We are running in factory test mode, but unable to find        // the factory test app, so just sit around displaying the        // error message and don&#x27;t try to start anything.        return false;    &#125;    Intent intent = getHomeIntent();    ActivityInfo aInfo =        resolveActivityInfo(intent, STOCK_PM_FLAGS, userId);    if (aInfo != null) &#123;        intent.setComponent(new ComponentName(                aInfo.applicationInfo.packageName, aInfo.name));        // Don&#x27;t do this if the home app is currently being        // instrumented.        aInfo = new ActivityInfo(aInfo);        aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId);        ProcessRecord app = getProcessRecordLocked(aInfo.processName,                aInfo.applicationInfo.uid, true);        if (app == null || app.instrumentationClass == null) &#123;            intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);            mStackSupervisor.startHomeActivity(intent, aInfo, reason);        &#125;    &#125;    return true;&#125;\nActivityManagerService和PackageManagerService一样，都是在开机时由SystemServer组件启动，Launcher在启动的时候会通过PackageManagerServic把系统中已经安装好的应用程序以快捷图标的形式展示在桌面上，这样用户就可以使用这些应用程序了。另外程序安装的时候SystemServer组件会通过PackageManagerServic来安装应用程序，应用程序安装好了以后会以通知的形式通知launcher展示应用图标，卸载同理。\n总结\n本篇简单分析了一下系统从开机启动到桌面展示这个过程，这里简单总结一下：\n\n系统启动时init进程会创建Zygote进程，Zygote进程负责后续Android应用程序框架层的其它进程的创建和启动工作。\nZygote进程会首先创建一个SystemServer进程，SystemServer进程负责启动系统的关键服务（服务三连），例如ActivityThread、AMS、PMS等。\nAndroid中所有的应用进程的创建都是通过Binder机制请求SystemServer进程，SystemServer进程发送socket消息给Zygote进程，统一由Zygote进程创建出来的。\nAMS启动Launcher程序，Launcher展示系统相关应用快捷方式。\n\n开机启动我们重在了解过程，明确知道系统几个重要的服务，了解过程中虽然很枯燥但是对开发很有帮助，例如以后的插件化学习，下篇我会着重分析一下Launcher的构造以及Activity的启动过程，加油，期待。\n参考：\n\nhttps://blog.csdn.net/luoshengyang/article/details/6768304\nhttps://www.jianshu.com/p/327f583f970b\nhttps://www.jianshu.com/p/6037f6fda285\n\n","plink":"https://blog.ixin.run/posts/1618224360/"},{"title":"更好的人生一定要学会做减法","date":"2020-04-10T16:16:50.000Z","date_formatted":{"ll":"2020年4月11日","L":"2020/04/11","MM-DD":"04-11"},"updated":"2021-01-29T12:51:44.670Z","content":"最近看到一篇人民日报推的一碗鸡汤——《更好的人生，要学会做减法》，我平时很少看这类鸡汤文章，但是这篇却无意触动了我，没有讲述故事，短小的一篇，仅仅列了几点，但是这几点却是我在这将近一年中感触最深的：\n\n学会欲望极简\n学会物质极简\n学会社交极简\n学会信息极简\n学会心事极简\n学会生活极简\n\n越来越发现自己对生活的细小琐事记性不好，这里做一个笔录，也是为了提醒自己在日后的这么长时间里认真生活。\n\n原文：\n第一，学会欲望极简。\n很多时候，人的不快乐并非来源于欲望得不到满足，而是欲望太多，让我们身心俱疲。有许多东西都是没必要强求的，如果想要更好的生活，就要学会做减法。\n你慢慢就会明白，外在的虚名浮利并不能给你带来真正的快乐，反而可能会让你失去更多生命中重要的东西。\n健康安稳的生活，以及家人的平安和陪伴，才是我们奋斗的最终归宿，才会让我们真正感到满足和心安。\n第二，学会物质极简。\n很多人喜欢囤东西，尤其舍不得扔掉一些废弃的东西。其实人真正需要的东西并不多，一旦过量，反而会带来许多不必要的麻烦和负担。有时候，拥有的越多，可以选择的越多，越会陷入焦虑之中，越不知道该如何取舍。\n所以要学会断舍离，比如拒绝购买自己不需要的东西，精简日常生活中所需的物品等等。当你的生活越来越简洁，内心反而会越来越充实，也会感到越来越轻松。\n第三，学会社交极简。\n年轻时我们总以为，认识的人越多越好，于是花费大量的时间和精力去推杯换盏，去呼朋唤友。可有了一些阅历后你会发现，朋友其实并不在多，而在真心和交心；朋友也不必求锦上添花，若能雪中送炭才好。\n不必为了合群，勉强自己去走进不属于你的圈子；也不必为了讨好他人，勉强自己去参加不必要的应酬。\n余生，请多去珍惜那些与你志同道合的朋友，珍惜一路陪你历经风雨、真正值得信赖和深交的知己。\n第四，学会信息极简。\n如今有越来越多的人，每天大部分的闲暇时间都在看手机。无论是有用的还是无用的、真实的还是虚假的、积极的还是负能量的，我们每天都被无数信息包围，这就可能给你增加信息过量的负担和压力。\n所以，要学会删繁就简，把多余的信息去掉，定期远离手机和互联网。\n当你腾出了更多的时间，可以去读书学习，可以去锻炼身体，你的生活质量会随之提升，也会减少许多焦虑和浮躁。\n第五，学会心事极简。\n不知你是否发现，人的年龄越大、经历的越多，有些人，你总是忘不掉；有些事，你总是看不开；有些过往，你总是放不下。\n其实，过去的，无论是好的还是坏的，都已经过去了。你若总把过往纠结过的人和不开心的事放在心里，只会徒增烦恼。\n有句话说，人生不如意事十之八九。所以，不如把往事清零，轻装前行；让爱恨随风，笑泯恩仇。\n人这一生，有得必有失，有取必有舍。何不去珍惜拥有，忘掉那些不属于你的东西呢？学会与自己和解，不要总是纠缠不放，也不要总是为难自己。唯有放下更多的心事，才能让自己活得轻松惬意。\n第六，学会生活极简。\n曾经，我们总是渴望过热闹繁华的生活，总以为这样就可以摆脱孤单、摆脱无聊、摆脱平庸。但慢慢地你会发现，自己越来越渴望过简单朴素的平凡日子。\n你不再渴望扎到人堆里去，而是学会了在懂你的人群中散步；你不再渴望灯红酒绿的日子，而是在细水长流中学会了知足；你不再渴望非要得到他人的关注和肯定，而是学会了跟自己独处。\n平平淡淡才是真，简简单单才是福。一个人只有学会静下来，在平淡的日常中寻找细微的美好和感动，才能更加快乐和幸福。\n说给自己\n2019年，要学会心事极简，欲望极简，断舍离，保护自己。\n2020年，要学会生活极简，物质极简，多学习，简单工作，养精蓄锐，提升自己。\n","thumbnail":"https://www.fotor.com/images2/features/photo_effects/e_bw.jpg","plink":"https://blog.ixin.run/posts/1586535410/"},{"title":"Android开发View滑动冲突处理","date":"2020-04-10T16:05:51.000Z","date_formatted":{"ll":"2020年4月11日","L":"2020/04/11","MM-DD":"04-11"},"updated":"2021-01-29T12:51:44.629Z","content":"最近在重构一个老项目，遇到ScrollView嵌套WebView的场景，因为WebView加载的网页并不是自适应，所以导致在滑动网页的时候异常卡顿，很明显是滑动冲突了，解决方式也很常规，针对滑动冲突这里顺便做笔记吧。\n\n冲突场景\n滑动冲突场景可简单分为两种：\n\n外部和内部的滑动方向不一致\n外部和内部的滑动方向一致\n\n示图如下：\n\n其他情况的滑动冲突都是在这两种冲突的基础上延伸出来的，或者以上两种场景的嵌套，面对这种我们处理方式就是剥离成以上基础的冲突场景，逐个处理。\n处理规则\n面对场景1，它的处理规则是：当用户左右滑动时（父），需要让外部的View拦截点击事件；当用户上下滑动时（子），需要让内部View拦截点击事件。其实说白了，我们的主要目标是确定目标view的滑动方向。\n确定滑动方向，列举以下三种方式参考：\n\n根据垂直滑动和水平滑动的距离对比判断，哪个大就是哪个方向滑动。\n根据滑动路径与水平方向的夹角，大于45度认为是垂直滑动，否则是水平滑动。\n根据垂直滑动和水平滑动的速度对比判断，哪个大就是哪个方向滑动。\n\n面对场景2，因为滑动方向是一致的，所以我们只有根据业务来区分到底应该滑动哪一个view。核心点就是准确判断滑动区域的位置。\n解决方式\n从上边可以知道冲突的产生主要是不确定具体应该在哪一层滑动（内层、外层）,上边也说了相关的处理规则，接下就是我们按照规则主动把事件分发给相应的view。之前我写过一篇《Android开发之onTouch事件的分发拦截消费机制探究学习》，这里用到的知识点就是事件的拦截机制。\n针对滑动冲突，这里给出两种解决滑动冲突的方式：外部拦截法和内部拦截法。\n外部拦截法\n外部拦截法，就是处理父View的滑动事件时，父View主动把事件拦截下来自行消化，其他情况继续不拦截由子View消化处理。\n\n这里需要注意只在父View的ACTION_MOVE事件中判断是否进行拦截，其他事件不需要，因为一旦拦截事件就无法传递到子View了。\n内部拦截法\n内部拦截法，默认子View处理滑动事件，当判断某个位置或者某种情况下应该父View滑动时，主动告知父View开启事件拦截，由父View消化处理。这里用到一个parent.requestDisallowInterceptTouchEvent()方法。\n\nViewPager处理滑动冲突分析\n有同学可能会问，既然内外层都可以滑动，这样很容易出现冲突，但是为什么Viewpager中不存在滑动冲突呢。其实官方已经为我们处理了。\nViewPager也是一个ViewGroup，在ViewPager的initViewPager方法中生成Scroller对象，Scroller是Android内置的专门用于渐进式滑动的类，配合插值器可以产生立体的滑动感，既然ViewPager是一个容器并且可以滑动，那么也就避免不了内嵌view滑动冲突这一遭。\nViewPager只关注水平方向的手指滑动，根据水平方向的手指滑动来切换页面。在垂直方向上，ViewPager并不关心，因此，ViewPager很有必要解决一下滑动冲突，把竖直方向的滑动传递给子View来处理。\n我们知道，ViewGroup是在onInterceptTouchEvent函数中决定是否拦截触摸事件, 所以我们直接去查看ViewPager的onInterceptTouchEvent事件拦截，来分析ViewPager的滑动冲突处理方式：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123;    //1. 触摸动作    final int action = ev.getAction() &amp; MotionEventCompat.ACTION_MASK;    //2. 时刻要注意触摸是否已经结束    if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) &#123;        //3. Release the drag.        if (DEBUG) Log.v(TAG, &quot;Intercept done!&quot;);        //4. 重置一些跟判断是否拦截触摸相关变量        resetTouch();        //5. 触摸结束，无需拦截        return false;    &#125;    //6. 如果当前不是按下事件，我们就判断一下，是否是在拖拽切换页面    if (action != MotionEvent.ACTION_DOWN) &#123;        //7. 如果当前是正在拽切换页面，直接拦截掉事件，后面无需再做拦截判断        if (mIsBeingDragged) &#123;            if (DEBUG) Log.v(TAG, &quot;Intercept returning true!&quot;);            return true;        &#125;        //8. 如果标记为不允许拖拽切换页面，我们就&quot;放过&quot;一切触摸事件        if (mIsUnableToDrag) &#123;            if (DEBUG) Log.v(TAG, &quot;Intercept returning false!&quot;);            return false;        &#125;    &#125;    //9. 根据不同的动作进行处理    switch (action) &#123;        //10. 如果是手指移动操作        case MotionEvent.ACTION_MOVE: &#123;            //11. 代码能执行到这里，就说明mIsBeingDragged==false，否则的话，在第7个注释处就已经执行结束了            //12.使用触摸点Id，主要是为了处理多点触摸            final int activePointerId = mActivePointerId;            if (activePointerId == INVALID_POINTER) &#123;                //13.如果当前的触摸点id不是一个有效的Id，无需再做处理                break;            &#125;            //14.根据触摸点的id来区分不同的手指，我们只需关注一个手指就好            final int pointerIndex = MotionEventCompat.findPointerIndex(ev, activePointerId);            //15.根据这个手指的序号，来获取这个手指对应的x坐标            final float x = MotionEventCompat.getX(ev, pointerIndex);            //16.在x轴方向上移动的距离            final float dx = x - mLastMotionX;            //17.x轴方向的移动距离绝对值            final float xDiff = Math.abs(dx);            //18.同理，参照16、17条注释            final float y = MotionEventCompat.getY(ev, pointerIndex);            final float yDiff = Math.abs(y - mInitialMotionY);            if (DEBUG) Log.v(TAG, &quot;Moved x to &quot; + x + &quot;,&quot; + y + &quot; diff=&quot; + xDiff + &quot;,&quot; + yDiff);            //19.判断当前显示的页面是否可以滑动，如果可以滑动，则将该事件丢给当前显示的页面处理            //isGutterDrag是判断是否在两个页面之间的缝隙内移动            //canScroll是判断页面是否可以滑动            if (dx != 0 &amp;&amp; !isGutterDrag(mLastMotionX, dx) &amp;&amp;                    canScroll(this, false, (int) dx, (int) x, (int) y)) &#123;                mLastMotionX = x;                mLastMotionY = y;                //20.标记ViewPager不去拦截事件                mIsUnableToDrag = true;                return false;            &#125;            //21.如果x移动距离大于最小距离，并且斜率小于0.5，表示在水平方向上的拖动            if (xDiff &gt; mTouchSlop &amp;&amp; xDiff * 0.5f &gt; yDiff) &#123;                if (DEBUG) Log.v(TAG, &quot;Starting drag!&quot;);                //22.水平方向的移动，需要ViewPager去拦截                mIsBeingDragged = true;                //23.如果ViewPager还有父View，则还要向父View申请将触摸事件传递给ViewPager                requestParentDisallowInterceptTouchEvent(true);                //24.设置滚动状态                setScrollState(SCROLL_STATE_DRAGGING);                //25.保存当前位置                mLastMotionX = dx &gt; 0 ? mInitialMotionX + mTouchSlop :                        mInitialMotionX - mTouchSlop;                mLastMotionY = y;                //26.启用缓存                setScrollingCacheEnabled(true);            &#125; else if (yDiff &gt; mTouchSlop) &#123;//27.否则的话，表示是竖直方向上的移动                if (DEBUG) Log.v(TAG, &quot;Starting unable to drag!&quot;);                //28.竖直方向上的移动则不去拦截触摸事件                mIsUnableToDrag = true;            &#125;            if (mIsBeingDragged) &#123;                // 29.跟随手指一起滑动                if (performDrag(x)) &#123;                    ViewCompat.postInvalidateOnAnimation(this);                &#125;            &#125;            break;        &#125;        //30.如果手指是按下操作        case MotionEvent.ACTION_DOWN: &#123;            //31.记录按下的点位置            mLastMotionX = mInitialMotionX = ev.getX();            mLastMotionY = mInitialMotionY = ev.getY();            //32.第一个ACTION_DOWN事件对应的手指序号为0            mActivePointerId = MotionEventCompat.getPointerId(ev, 0);            //33.重置允许拖拽切换页面            mIsUnableToDrag = false;            //34.标记开始滚动            mIsScrollStarted = true;            //35.手动调用计算滑动的偏移量            mScroller.computeScrollOffset();            //36.如果当前滚动状态为正在将页面放置到最终位置，            //且当前位置距离最终位置足够远            if (mScrollState == SCROLL_STATE_SETTLING &amp;&amp;                    Math.abs(mScroller.getFinalX() - mScroller.getCurrX()) &gt; mCloseEnough) &#123;                //37. 如果此时用户手指按下，则立马暂停滑动                mScroller.abortAnimation();                mPopulatePending = false;                populate();                mIsBeingDragged = true;                //38.如果ViewPager还有父View，则还要向父View申请将触摸事件传递给ViewPager                requestParentDisallowInterceptTouchEvent(true);                //39.设置当前状态为正在拖拽                setScrollState(SCROLL_STATE_DRAGGING);            &#125; else &#123;                //40.结束滚动                completeScroll(false);                mIsBeingDragged = false;            &#125;            if (DEBUG) Log.v(TAG, &quot;Down at &quot; + mLastMotionX + &quot;,&quot; + mLastMotionY                    + &quot; mIsBeingDragged=&quot; + mIsBeingDragged                    + &quot;mIsUnableToDrag=&quot; + mIsUnableToDrag);            break;        &#125;        case MotionEventCompat.ACTION_POINTER_UP:            onSecondaryPointerUp(ev);            break;    &#125;    //41.添加速度追踪    if (mVelocityTracker == null) &#123;        mVelocityTracker = VelocityTracker.obtain();    &#125;    mVelocityTracker.addMovement(ev);    //42.只有在当前是拖拽切换页面时我们才会去拦截事件    return mIsBeingDragged;&#125;\n从源码上面看出，斜率小于0.5时，则要拦截，否则不拦截。越靠近y轴的直线，斜率越大，越靠近x轴直线斜率越小。因此，当手指滑动的倾斜度比0.5小时就去拦截事件，由ViewPager来响应切换页面。\n\n参考\n\n《Android开发艺术探索》，微信读书可以免费阅读。\nhttps://blog.csdn.net/huachao1001/article/details/51654692\n\n","plink":"https://blog.ixin.run/posts/1586534751/"},{"title":"Android开发约束布局ConstraintLayout学习总结","date":"2020-03-23T15:27:57.000Z","date_formatted":{"ll":"2020年3月23日","L":"2020/03/23","MM-DD":"03-23"},"updated":"2021-01-29T12:51:44.640Z","content":"小伙伴都知道Android开发有常用的五大布局：LinearLayout、RelateLayout、FrameLayout、AbsolutLayout和TableLayout，今天再总结一个比较牛掰的一个布局——ConstraintLayout，完全可以代替LinearLayout和RelateLayout，具体为什么要使用他和怎么用是接下来需要说的。\n\nConstraintLayout介绍\n约束布局ConstraintLayout是一个Support库，可以在Api9以上的Android系统使用它，它的出现主要是为了解决布局嵌套过多的问题，以灵活的方式定位和调整小部件。从Android Studio 2.3起，官方的模板默认使用ConstraintLayout。\nConstraintLayout使用缘由\n在开发过程中经常能遇到一些复杂的UI，可能会出现布局嵌套过多的问题，嵌套得越多，设备绘制视图所需的时间和计算功耗也就越多，遇到此情况我们更多的是采用RelativeLayout。\n既然用RelativeLayout可以解决问题，为什么还要使用ConstraintLayout呢？因为ConstraintLayout使用起来比RelativeLayout更灵活，性能更出色！还有一点就是ConstraintLayout可以按照比例约束控件位置和尺寸，能够更好地适配屏幕大小不同的机型。\nConstraintLayout用法\n添加依赖\n首先我们需要在app/build.gradle文件中添加ConstraintLayout的依赖：\n1implementation &#x27;com.android.support.constraint:constraint-layout:1.1.3&#x27;\n相对定位\n相对定位是部件对于另一个位置的约束，如图：\n\n相应的代码：\n123456789&lt;TextView    android:id=&quot;@+id/TextView1&quot;    ...    android:text=&quot;TextView1&quot; /&gt;&lt;TextView    android:id=&quot;@+id/TextView2&quot;    ...    app:layout_constraintLeft_toRightOf=&quot;@+id/TextView1&quot; /&gt;\n面代码中在TextView2里用到了app:layout_constraintLeft_toRightOf=&quot;@+id/TextView1&quot;这个属性，他的意思是把TextView2的左边约束到TextView1的右边\n相对定位的常用属性\n\nlayout_constraintLeft_toLeftOf\nview1左边对齐view2的左边\nlayout_constraintLeft_toRightOf\nview1左边对齐view2的右边\nlayout_constraintRight_toLeftOf\nview1右边对齐view2的左边\nlayout_constraintRight_toRightOf\nview1右边对齐view2的右边\nlayout_constraintTop_toTopOf\nview1顶部对齐view2的顶部\nlayout_constraintTop_toBottomOf\nview1顶部对齐view2的底部\nlayout_constraintBottom_toTopOf\nview1底部对齐view2的顶部\nlayout_constraintBottom_toBottomOf\nview1底部对齐view2的底部\nlayout_constraintBaseline_toBaselineOf\nview1基准线对齐view2的基准线\nlayout_constraintStart_toEndOf\nview1起始位置对齐view2的结束位置\nlayout_constraintStart_toStartOf\nview1起始位置view2的起始位置\nlayout_constraintEnd_toStartOf\nview1结束位置对齐view2的起始位置\nlayout_constraintEnd_toEndOf\nview1结束位置对齐view2的结束位置\n\n两个TextView的高度不一致，但是又希望他们文本对齐，这个时候就可以使用layout_constraintBaseline_toBaselineOf，代码如下：\n123456789&lt;TextView    android:id=&quot;@+id/TextView1&quot;    .../&gt;&lt;TextView    android:id=&quot;@+id/TextView2&quot;    ...    app:layout_constraintLeft_toRightOf=&quot;@+id/TextView1&quot;     app:layout_constraintBaseline_toBaselineOf=&quot;@+id/TextView1&quot;/&gt;\n效果如下:\n\n角度定位\n角度定位指的是可以用一个角度和一个距离来约束两个空间的中心。举例：\n123456789101112&lt;TextView    android:id=&quot;@+id/TextView1&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot; /&gt;&lt;TextView    android:id=&quot;@+id/TextView2&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    app:layout_constraintCircle=&quot;@+id/TextView1&quot;    app:layout_constraintCircleAngle=&quot;120&quot;    app:layout_constraintCircleRadius=&quot;150dp&quot; /&gt;\n上面例子中的TextView2用到了3个属性：\napp:layout_constraintCircle=“@+id/TextView1”\napp:layout_constraintCircleAngle=“120”（角度）\napp:layout_constraintCircleRadius=“150dp”（距离）\n指的是TextView2的中心在TextView1的中心的120度，距离为150dp，效果如下：\n\n边距\n常用margin\n\nandroid:layout_marginStart\nandroid:layout_marginEnd\nandroid:layout_marginLeft\nandroid:layout_marginTop\nandroid:layout_marginRight\nandroid:layout_marginBottom\n\n在使用margin的时候要注意两点：\n\n在ConstraintLayout里面要实现margin，必须先约束该控件在ConstraintLayout里的位置\nmargin只能大于等于0\n\ngoneMargin\ngoneMargin主要用于约束的控件可见性被设置为gone的时候使用的margin值，属性如下：\n\nlayout_goneMarginStart\nlayout_goneMarginEnd\nlayout_goneMarginLeft\nlayout_goneMarginTop\nlayout_goneMarginRight\nlayout_goneMarginBottom\n\n假设TextView2的左边约束在TextView1的右边，并给TextView2设一个app:layout_goneMarginLeft=“10dp”，代码如下：\n12345678910111213141516&lt;android.support.constraint.ConstraintLayout     android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;TextView        android:id=&quot;@+id/TextView1&quot;        .../&gt;    &lt;TextView        android:id=&quot;@+id/TextView2&quot;        ...        app:layout_constraintLeft_toRightOf=&quot;@+id/TextView1&quot;        app:layout_goneMarginLeft=&quot;10dp&quot;        /&gt;&lt;/android.support.constraint.ConstraintLayout&gt;\n效果图：\n\n这个时候把TextView1的可见性设为gone，效果如下：\n\nextView1消失后，TextView2有一个距离左边10dp的边距。\n居中\nConstraintLayout居中写法：\n1234app:layout_constraintBottom_toBottomOf=&quot;parent&quot;app:layout_constraintLeft_toLeftOf=&quot;parent&quot;app:layout_constraintRight_toRightOf=&quot;parent&quot;app:layout_constraintTop_toTopOf=&quot;parent&quot;\n水平居中：\n12app:layout_constraintLeft_toLeftOf=&quot;parent&quot;app:layout_constraintRight_toRightOf=&quot;parent&quot;\n垂直居中：\n12app:layout_constraintBottom_toBottomOf=&quot;parent&quot;app:layout_constraintTop_toTopOf=&quot;parent&quot;\n偏移\n居中后可采用margin进行适当偏移：\n123456&lt;TextView    android:id=&quot;@+id/TextView1&quot;    ...    android:layout_marginLeft=&quot;100dp&quot;    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;    app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt;\n\n除了这种偏移外，ConstraintLayout还提供了另外一种偏移的属性：\n\nlayout_constraintHorizontal_bias 水平偏移\nlayout_constraintVertical_bias 垂直偏移\n\n例子：\n123456&lt;TextView    android:id=&quot;@+id/TextView1&quot;    ...    app:layout_constraintHorizontal_bias=&quot;0.3&quot;    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;    app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt;\n\n解释：\n居中时layout_constraintHorizontal_bias默认为0.5即50%（左偏移50%右偏移50%），0.3(左偏移30%右偏移70%)\n尺寸约束\n控件的尺寸可以通过四种不同方式指定。\n使用指定的尺寸\n这个就不说了。\n使用wrap_content\n当控件的高度或宽度为wrap_content时，可以使用下列属性来控制最大、最小的高度或宽度：\n\nandroid:minWidth 最小的宽度\nandroid:minHeight 最小的高度\nandroid:maxWidth 最大的宽度\nandroid:maxHeight 最大的高度\n\n另外使用这些属性需要加上强制约束：\n\napp:constrainedWidth=”true”\napp:constrainedHeight=”true”\n\n使用0dp\n官方不推荐在ConstraintLayout中使用match_parent，可以设置 0dp (MATCH_CONSTRAINT) 配合约束代替match_parent，例如：\n12345678&lt;TextView    android:id=&quot;@+id/TextView1&quot;    android:layout_width=&quot;0dp&quot;    android:layout_height=&quot;wrap_content&quot;    android:layout_marginLeft=&quot;50dp&quot;    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;    app:layout_constraintRight_toRightOf=&quot;parent&quot;    android:visibility=&quot;visible&quot; /&gt;\n宽度设为0dp，左右两边约束parent的左右两边，并设置左边边距为50dp，效果如下:\n\n控件内宽高比\n当宽或高至少有一个尺寸被设置为0dp时，可以通过属性layout_constraintDimensionRatio设置宽高比，举个例子：\n1234567&lt;TextView    android:id=&quot;@+id/TextView1&quot;    android:layout_width=&quot;0dp&quot;    android:layout_height=&quot;wrap_content&quot;    app:layout_constraintDimensionRatio=&quot;1:1&quot;    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;    app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt;\n宽设置为0dp，宽高比设置为1:1，这个时候TextView1是一个正方形。\n除此之外，在设置宽高比的值的时候，还可以在前面加W或H，分别指定宽度或高度限制。 例如：\n12app:layout_constraintDimensionRatio=&quot;H,2:3&quot;指的是 高:宽=2:3app:layout_constraintDimensionRatio=&quot;W,2:3&quot;指的是 宽:高=2:3\n链\n如果两个或以上控件通过下图的方式约束在一起，就可以认为是他们是一条链。\n例如：\n123456789101112131415161718192021&lt;TextView    android:id=&quot;@+id/TextView1&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;    app:layout_constraintRight_toLeftOf=&quot;@+id/TextView2&quot; /&gt;&lt;TextView    android:id=&quot;@+id/TextView2&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    app:layout_constraintLeft_toRightOf=&quot;@+id/TextView1&quot;    app:layout_constraintRight_toLeftOf=&quot;@+id/TextView3&quot;    app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt;&lt;TextView    android:id=&quot;@+id/TextView3&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    app:layout_constraintLeft_toRightOf=&quot;@+id/TextView2&quot;    app:layout_constraintRight_toRightOf=&quot;parent&quot; /&gt;\n个TextView相互约束，两端两个TextView分别与parent约束，成为一条链，效果如下：\n\n链样式\n一条链的第一个控件是这条链的链头，我们可以在链头中设置 layout_constraintHorizontal_chainStyle来改变整条链的样式，提供有三种样式：\n\nspread\nspread_inside\npacked\n\n对应这三种样式的效果图如下：\n\n权重链\n可以留意到上面所用到的3个TextView宽度都为wrap_content，如果我们把宽度都设为0dp，这个时候可以在每个TextView中设置横向权重layout_constraintHorizontal_weight(constraintVertical为纵向)来创建一个权重链，如下所示：\n123456789101112131415161718192021222324&lt;TextView    android:id=&quot;@+id/TextView1&quot;    android:layout_width=&quot;0dp&quot;    android:layout_height=&quot;wrap_content&quot;    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;    app:layout_constraintRight_toLeftOf=&quot;@+id/TextView2&quot;    app:layout_constraintHorizontal_weight=&quot;2&quot; /&gt;&lt;TextView    android:id=&quot;@+id/TextView2&quot;    android:layout_width=&quot;0dp&quot;    android:layout_height=&quot;wrap_content&quot;    app:layout_constraintLeft_toRightOf=&quot;@+id/TextView1&quot;    app:layout_constraintRight_toLeftOf=&quot;@+id/TextView3&quot;    app:layout_constraintRight_toRightOf=&quot;parent&quot;    app:layout_constraintHorizontal_weight=&quot;3&quot; /&gt;&lt;TextView    android:id=&quot;@+id/TextView3&quot;    android:layout_width=&quot;0dp&quot;    android:layout_height=&quot;wrap_content&quot;    app:layout_constraintLeft_toRightOf=&quot;@+id/TextView2&quot;    app:layout_constraintRight_toRightOf=&quot;parent&quot;    app:layout_constraintHorizontal_weight=&quot;4&quot; /&gt;\n效果图如下：\n\n辅助工具\nOptimizer（约束优化）\n当我们使用 MATCH_CONSTRAINT 时，ConstraintLayout 将对控件进行 2 次测量，ConstraintLayout在1.1中可以通过设置 layout_optimizationLevel 进行优化，可设置的值有：\n\nnone：无优化\nstandard：仅优化直接约束和屏障约束（默认）\ndirect：优化直接约束\nbarrier：优化屏障约束\nchain：优化链约束\ndimensions：优化尺寸测量\n\nBarrier（屏障标准）\n假设有3个控件ABC，C在AB的右边，但是AB的宽是不固定的，这个时候C无论约束在A的右边或者B的右边都不对。当出现这种情况可以用Barrier来解决。Barrier可以在多个控件的一侧建立一个屏障，如下所示：\n\n这个时候C只要约束在Barrier的右边就可以了，代码如下：\n1234567891011121314151617181920212223&lt;TextView    android:id=&quot;@+id/TextView1&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot; /&gt;&lt;TextView    android:id=&quot;@+id/TextView2&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    app:layout_constraintTop_toBottomOf=&quot;@+id/TextView1&quot; /&gt;&lt;android.support.constraint.Barrier    android:id=&quot;@+id/barrier&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    app:barrierDirection=&quot;right&quot;    app:constraint_referenced_ids=&quot;TextView1,TextView2&quot; /&gt;&lt;TextView    android:id=&quot;@+id/TextView3&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    app:layout_constraintLeft_toRightOf=&quot;@+id/barrier&quot; /&gt;\n其中：\n\napp:barrierDirection为屏障所在的位置，可设置的值有：bottom、end、left、right、start、top\napp:constraint_referenced_ids为屏障引用的控件，可设置多个(用“,”隔开)\n\nGroup（组概念）\nGroup可以把多个控件归为一组，方便隐藏或显示一组控件：\n12345678910111213141516&lt;TextView    android:id=&quot;@+id/TextView1&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot; /&gt;&lt;TextView    android:id=&quot;@+id/TextView2&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    app:layout_constraintLeft_toRightOf=&quot;@+id/TextView1&quot; /&gt;&lt;TextView    android:id=&quot;@+id/TextView3&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    app:layout_constraintLeft_toRightOf=&quot;@id/TextView2&quot; /&gt;\n\n现在有3个并排的TextView，用Group把TextView1和TextView3归为一组，再设置这组控件的可见性，如下所示：\n\nPlaceholder（占位符）\nPlaceholder指的是占位符。在Placeholder中可使用setContent()设置另一个控件的id，使这个控件移动到占位符的位置：\n123456789101112131415161718&lt;android.support.constraint.Placeholder    android:id=&quot;@+id/placeholder&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    app:content=&quot;@+id/textview&quot;    app:layout_constraintLeft_toLeftOf=&quot;parent&quot;    app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;TextView    android:id=&quot;@+id/textview&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:background=&quot;#cccccc&quot;    android:padding=&quot;16dp&quot;    android:text=&quot;TextView&quot;    android:textColor=&quot;#000000&quot;    app:layout_constraintRight_toRightOf=&quot;parent&quot;    app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;\n新建一个Placeholder约束在屏幕的左上角，新建一个TextView约束在屏幕的右上角，在Placeholder中设置 app:content=“@+id/textview”，这时TextView会跑到屏幕的左上角。效果如下：\n\nGuideline（辅助线）\nGuildline像辅助线一样，在预览的时候帮助你完成布局（不会显示在界面上）。\nGuildline的主要属性：\n\nandroid:orientation 垂直vertical，水平horizontal\nlayout_constraintGuide_begin 开始位置\nlayout_constraintGuide_end 结束位置\nlayout_constraintGuide_percent 距离顶部的百分比(orientation = horizontal时则为距离左边)\n\n例如：\n12345678910111213&lt;android.support.constraint.Guideline    android:id=&quot;@+id/guideline1&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:orientation=&quot;horizontal&quot;    app:layout_constraintGuide_begin=&quot;50dp&quot; /&gt;&lt;android.support.constraint.Guideline    android:id=&quot;@+id/guideline2&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:orientation=&quot;vertical&quot;    app:layout_constraintGuide_percent=&quot;0.5&quot; /&gt;\nguideline1为水平辅助线，开始位置是距离顶部50dp，guideline2位垂直辅助线，开始位置为屏幕宽的0.5(中点位置)，效果如下：\n\n参考\n\nhttps://developer.android.google.cn/reference/android/support/constraint/ConstraintLayout\nhttps://www.jianshu.com/p/17ec9bd6ca8a\nhttps://blog.csdn.net/qq_38520096/article/details/80813994\n\n","plink":"https://blog.ixin.run/posts/1584977277/"},{"title":"View手势GestureDetector使用","date":"2020-03-21T15:06:05.000Z","date_formatted":{"ll":"2020年3月21日","L":"2020/03/21","MM-DD":"03-21"},"updated":"2021-01-29T12:51:44.649Z","content":"开发同学都知道自定义view的时候可以重写onTouch()方法，进而扩展按下、移动、松开这三个函数，这也是常用的形式。但是这个方法太过简单，如果需要处理一些复杂的手势，用这个接口就会很麻烦。Android其实有一个手势库——GestureDetector，已经为我们封装了一些常用的手势方法，接下来就总结一下GestureDetector的使用和总结。\n\nGestureDetector使用：\n1.实现方式\nGestureDetector的实现方式根据类别分有两种：\n\n实现两个接口的相关方法：OnGestureListener，OnDoubleTapListener\n继承一个内部类进而重写其相关方法：SimpleOnGestureListener\n\n其中OnGestureListener，OnDoubleTapListener，可视情况递增实现，即必须实现OnGestureListener接口，OnDoubleTapListener可根据情况追加。而SimpleOnGestureListener其实是OnGestureListener，OnDoubleTapListener这两个接口中所有函数的集成，它包含了这两个接口里所有必须要实现的函数。\n2.创建GestureDetector实例\n根据第一步的实现方式，创建GestureDetector实例，构造函数有下面三个，根据需要选择：\n123GestureDetector gestureDetector=new GestureDetector(GestureDetector.OnGestureListener listener);GestureDetector gestureDetector=new GestureDetector(Context context,GestureDetector.OnGestureListener listener);GestureDetector gestureDetector=new GestureDetector(Context context,GestureDetector.SimpleOnGestureListener listener);\n3.onTouch(View v, MotionEvent event)中拦截\n123public boolean onTouch(View v, MotionEvent event) &#123;\treturn mGestureDetector.onTouchEvent(event);   &#125;\n4.控件绑定\n假如我们在某个View上进行手势操作，那么需要绑定当前View的OnTouchListener监听。\n12TextView tv = (TextView)findViewById(R.id.tv);    tv.setOnTouchListener(this);\nGestureDetector.OnGestureListener\n基本方法\n1234567891011121314151617181920212223242526272829303132333435private class gesturelistener implements GestureDetector.OnGestureListener&#123;\tpublic boolean onDown(MotionEvent e) &#123;\t\t// TODO Auto-generated method stub\t\treturn false;\t&#125;\tpublic void onShowPress(MotionEvent e) &#123;\t\t// TODO Auto-generated method stub\t\t\t&#125;\tpublic boolean onSingleTapUp(MotionEvent e) &#123;\t\t// TODO Auto-generated method stub\t\treturn false;\t&#125;\tpublic boolean onScroll(MotionEvent e1, MotionEvent e2,\t\t\tfloat distanceX, float distanceY) &#123;\t\t// TODO Auto-generated method stub\t\treturn false;\t&#125;\tpublic void onLongPress(MotionEvent e) &#123;\t\t// TODO Auto-generated method stub\t\t\t&#125;\tpublic boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX,\t\t\tfloat velocityY) &#123;\t\t// TODO Auto-generated method stub\t\treturn false;\t&#125;\t&#125;\n这里总共重写了六个方法:\n1.OnDown(MotionEvent e)：\n用户按下屏幕就会触发；\n2.onShowPress(MotionEvent e)：\n如果是按下的时间超过瞬间，而且在按下的时候没有松开或者是拖动的，那么onShowPress就会执行。\n3.onLongPress(MotionEvent e)：\n长按触摸屏，超过一定时长，就会触发这个事件。触发顺序：onDown-&gt;onShowPress-&gt;onLongPress\n4.onSingleTapUp(MotionEvent e)：\n从名子也可以看出,一次单独的轻击抬起操作,也就是轻击一下屏幕，立刻抬起来，才会有这个触发，当然,如果除了Down以外还有其它操作,那就不再算是Single操作了,所以也就不会触发这个事件。触发顺序：\n点击一下非常快的（不滑动）Touchup：onDown-&gt;onSingleTapUp-&gt;onSingleTapConfirmed\n点击一下稍微慢点的（不滑动）Touchup：onDown-&gt;onShowPress-&gt;onSingleTapUp-&gt;onSingleTapConfirmed\n5.onFling(MotionEvent e1, MotionEvent e2, float velocityX,float velocityY)：\n滑屏，用户按下触摸屏、快速移动后松开，由1个MotionEvent ACTION_DOWN, 多个ACTION_MOVE, 1个ACTION_UP触发。参数解释：\n\ne1：第1个ACTION_DOWN MotionEvent\ne2：最后一个ACTION_MOVE MotionEvent\nvelocityX：X轴上的移动速度，像素/秒\nvelocityY：Y轴上的移动速度，像素/秒\n\n6.onScroll(MotionEvent e1, MotionEvent e2,float distanceX, float distanceY)：\n在屏幕上拖动事件。无论是用手拖动view，或者是以抛的动作滚动，都会多次触发,这个方法在ACTION_MOVE动作发生时就会触发。\n滑屏，手指触动屏幕后，稍微滑动后立即松开：onDown-----》onScroll----》onScroll----》onScroll----》………-----&gt;onFling\n拖动：onDown------》onScroll----》onScroll------》onFiling\n可见，无论是滑屏，还是拖动，影响的只是中间OnScroll触发的数量多少而已，最终都会触发onFling事件！\n例子\n结合我们开篇所讲的GestureDetector使用步骤，下边演示一个例子：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class MainActivity extends Activity implements OnTouchListener&#123;\tprivate GestureDetector mGestureDetector;   \t\t@Override\tprotected void onCreate(Bundle savedInstanceState) &#123;\t\tsuper.onCreate(savedInstanceState);\t\tsetContentView(R.layout.activity_main);\t\t      mGestureDetector = new GestureDetector(new gestureListener()); //使用派生自OnGestureListener              TextView tv = (TextView)findViewById(R.id.tv);      tv.setOnTouchListener(this);      tv.setFocusable(true);         tv.setClickable(true);         tv.setLongClickable(true); \t&#125;\t\t\t/*      * 在onTouch()方法中，我们调用GestureDetector的onTouchEvent()方法，将捕捉到的MotionEvent交给GestureDetector      * 来分析是否有合适的callback函数来处理用户的手势      */  \tpublic boolean onTouch(View v, MotionEvent event) &#123;\t\treturn mGestureDetector.onTouchEvent(event);   \t&#125;\t\tprivate class gestureListener implements GestureDetector.OnGestureListener&#123;\t\t// 用户轻触触摸屏，由1个MotionEvent ACTION_DOWN触发   \t\tpublic boolean onDown(MotionEvent e) &#123;\t\t\tLog.i(&quot;MyGesture&quot;, &quot;onDown&quot;);   \t        Toast.makeText(MainActivity.this, &quot;onDown&quot;, Toast.LENGTH_SHORT).show();   \t\t\treturn false;\t\t&#125;\t\t/*  \t     * 用户轻触触摸屏，尚未松开或拖动，由一个1个MotionEvent ACTION_DOWN触发  \t     * 注意和onDown()的区别，强调的是没有松开或者拖动的状态  \t     * \t     * 而onDown也是由一个MotionEventACTION_DOWN触发的，但是他没有任何限制，\t     * 也就是说当用户点击的时候，首先MotionEventACTION_DOWN，onDown就会执行，\t     * 如果在按下的瞬间没有松开或者是拖动的时候onShowPress就会执行，如果是按下的时间超过瞬间\t     * （这块我也不太清楚瞬间的时间差是多少，一般情况下都会执行onShowPress），拖动了，就不执行onShowPress。\t     */\t\tpublic void onShowPress(MotionEvent e) &#123;\t\t\tLog.i(&quot;MyGesture&quot;, &quot;onShowPress&quot;);   \t        Toast.makeText(MainActivity.this, &quot;onShowPress&quot;, Toast.LENGTH_SHORT).show();   \t\t&#125;\t\t// 用户（轻触触摸屏后）松开，由一个1个MotionEvent ACTION_UP触发   \t\t///轻击一下屏幕，立刻抬起来，才会有这个触发\t\t//从名子也可以看出,一次单独的轻击抬起操作,当然,如果除了Down以外还有其它操作,那就不再算是Single操作了,所以这个事件 就不再响应\t\tpublic boolean onSingleTapUp(MotionEvent e) &#123;\t\t\tLog.i(&quot;MyGesture&quot;, &quot;onSingleTapUp&quot;);   \t        Toast.makeText(MainActivity.this, &quot;onSingleTapUp&quot;, Toast.LENGTH_SHORT).show();   \t        return true;   \t\t&#125;\t\t// 用户按下触摸屏，并拖动，由1个MotionEvent ACTION_DOWN, 多个ACTION_MOVE触发   \t\tpublic boolean onScroll(MotionEvent e1, MotionEvent e2,\t\t\t\tfloat distanceX, float distanceY) &#123;\t\t\tLog.i(&quot;MyGesture22&quot;, &quot;onScroll:&quot;+(e2.getX()-e1.getX()) +&quot;   &quot;+distanceX);   \t        Toast.makeText(MainActivity.this, &quot;onScroll&quot;, Toast.LENGTH_LONG).show();   \t        \t        return true;   \t\t&#125;\t\t// 用户长按触摸屏，由多个MotionEvent ACTION_DOWN触发   \t\tpublic void onLongPress(MotionEvent e) &#123;\t\t\t Log.i(&quot;MyGesture&quot;, &quot;onLongPress&quot;);   \t\t     Toast.makeText(MainActivity.this, &quot;onLongPress&quot;, Toast.LENGTH_LONG).show();   \t\t&#125;\t\t// 用户按下触摸屏、快速移动后松开，由1个MotionEvent ACTION_DOWN, 多个ACTION_MOVE, 1个ACTION_UP触发   \t\tpublic boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX,\t\t\t\tfloat velocityY) &#123;\t\t\tLog.i(&quot;MyGesture&quot;, &quot;onFling&quot;);   \t        Toast.makeText(MainActivity.this, &quot;onFling&quot;, Toast.LENGTH_LONG).show();   \t\t\treturn true;\t\t&#125;\t&#125;;&#125;\nGestureDetector.OnDoubleTapListener\nOnDoubleTapListener接口主要用于实现双击手势拦截。\n基本方法\n1234567891011121314151617private class doubleTapListener implements GestureDetector.OnDoubleTapListener&#123;\tpublic boolean onSingleTapConfirmed(MotionEvent e) &#123;\t\t// TODO Auto-generated method stub\t\treturn false;\t&#125;\tpublic boolean onDoubleTap(MotionEvent e) &#123;\t\t// TODO Auto-generated method stub\t\treturn false;\t&#125;\tpublic boolean onDoubleTapEvent(MotionEvent e) &#123;\t\t// TODO Auto-generated method stub\t\treturn false;\t&#125;&#125;\n这里总共重写了三个方法：\n1.onSingleTapConfirmed(MotionEvent e)：\n单击事件。用来判定该次点击是SingleTap而不是DoubleTap，如果连续点击两次就是DoubleTap手势，如果只点击一次，系统等待一段时间后没有收到第二次点击则判定该次点击为SingleTap而不是DoubleTap，然后触发SingleTapConfirmed事件。\n触发顺序是：OnDown-&gt;OnsingleTapUp-&gt;OnsingleTapConfirmed\n关于onSingleTapConfirmed和onSingleTapUp的一点区别：\nOnGestureListener有这样的一个方法onSingleTapUp，和onSingleTapConfirmed容易混淆。二者的区别是：onSingleTapUp，只要手抬起就会执行，而对于onSingleTapConfirmed来说，如果双击的话，则onSingleTapConfirmed不会执行。\n2.onDoubleTap(MotionEvent e)：\n双击事件\n3.onDoubleTapEvent(MotionEvent e)：\n双击间隔中发生的动作。指触发onDoubleTap以后，在双击之间发生的其它动作，包含down、up和move事件；\n两点总结：\n\n在第二下点击时，先触发OnDoubleTap，然后再触发OnDown（第二次点击）\n其次在触发OnDoubleTap以后，就开始触发onDoubleTapEvent了。\n\n使用形式\n开篇我们也提到要想使用OnDoubleTapListener必须要使用OnGestureListener，因为创建GestureDetector实例的三个构造方法的入参根本没有OnDoubleTapListener的形式。以下有两种方式设置双击监听：\n1.新建一个类同时派生自OnGestureListener和OnDoubleTapListener\n12private class gestureListener implements GestureDetector.OnGestureListener,GestureDetector.OnDoubleTapListener&#123;&#125;\n2.使用GestureDetector::setOnDoubleTapListener()函数设置监听\n1234567891011//构建GestureDetector实例\tmGestureDetector = new GestureDetector(new gestureListener()); //使用派生自OnGestureListenerprivate class gestureListener implements GestureDetector.OnGestureListener&#123;\t&#125;//设置双击监听器mGestureDetector.setOnDoubleTapListener(new doubleTapListener());private class doubleTapListener implements GestureDetector.OnDoubleTapListener&#123;\t&#125;\n可以看到，在构造函数中，除了后面要讲的SimpleOnGestureListener 以外的其它两个构造函数都必须是OnGestureListener的实例。所以要想使用OnDoubleTapListener的几个函数，就必须先实现OnGestureListener。\nGestureDetector.SimpleOnGestureListener\n它与前两个不同的是，这个是一个类，我们可以采用继承的形式，然后重写合适的方法，更加灵活。这个也是我们平时在使用GestureDetector最常用的一种实现形式。另外开篇也讲到SimpleOnGestureListener是OnGestureListener和OnDoubleTapListener所有方法的集合。\n例子\n下面利用SimpleOnGestureListener类来重新实现上面的几个效果：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public class MainActivity extends Activity implements OnTouchListener &#123;\tprivate GestureDetector mGestureDetector;   \t\t@Override\tprotected void onCreate(Bundle savedInstanceState) &#123;\t\tsuper.onCreate(savedInstanceState);\t\tsetContentView(R.layout.activity_main);\t\t\t\tmGestureDetector = new GestureDetector(new simpleGestureListener());\t\t\t\tTextView tv = (TextView)findViewById(R.id.tv);\t    tv.setOnTouchListener(this);\t    tv.setFocusable(true);   \t    tv.setClickable(true);   \t    tv.setLongClickable(true); \t&#125;\t\tpublic boolean onTouch(View v, MotionEvent event) &#123;\t\t// TODO Auto-generated method stub\t\treturn mGestureDetector.onTouchEvent(event);   \t&#125;\tprivate class simpleGestureListener extends\t\t\tGestureDetector.SimpleOnGestureListener &#123;\t\t\t\t/*****OnGestureListener的函数*****/\t\tpublic boolean onDown(MotionEvent e) &#123;\t\t\tLog.i(&quot;MyGesture&quot;, &quot;onDown&quot;);\t\t\tToast.makeText(MainActivity.this, &quot;onDown&quot;, Toast.LENGTH_SHORT)\t\t\t\t\t.show();\t\t\treturn false;\t\t&#125;\t\tpublic void onShowPress(MotionEvent e) &#123;\t\t\tLog.i(&quot;MyGesture&quot;, &quot;onShowPress&quot;);\t\t\tToast.makeText(MainActivity.this, &quot;onShowPress&quot;, Toast.LENGTH_SHORT)\t\t\t\t\t.show();\t\t&#125;\t\tpublic boolean onSingleTapUp(MotionEvent e) &#123;\t\t\tLog.i(&quot;MyGesture&quot;, &quot;onSingleTapUp&quot;);\t\t\tToast.makeText(MainActivity.this, &quot;onSingleTapUp&quot;,\t\t\t\t\tToast.LENGTH_SHORT).show();\t\t\treturn true;\t\t&#125;\t\tpublic boolean onScroll(MotionEvent e1, MotionEvent e2,\t\t\t\tfloat distanceX, float distanceY) &#123;\t\t\tLog.i(&quot;MyGesture&quot;, &quot;onScroll:&quot; + (e2.getX() - e1.getX()) + &quot;   &quot;\t\t\t\t\t+ distanceX);\t\t\tToast.makeText(MainActivity.this, &quot;onScroll&quot;, Toast.LENGTH_LONG)\t\t\t\t\t.show();\t\t\treturn true;\t\t&#125;\t\tpublic void onLongPress(MotionEvent e) &#123;\t\t\tLog.i(&quot;MyGesture&quot;, &quot;onLongPress&quot;);\t\t\tToast.makeText(MainActivity.this, &quot;onLongPress&quot;, Toast.LENGTH_LONG)\t\t\t\t\t.show();\t\t&#125;\t\tpublic boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX,\t\t\t\tfloat velocityY) &#123;\t\t\tLog.i(&quot;MyGesture&quot;, &quot;onFling&quot;);\t\t\tToast.makeText(MainActivity.this, &quot;onFling&quot;, Toast.LENGTH_LONG)\t\t\t\t\t.show();\t\t\treturn true;\t\t&#125;\t\t\t\t/*****OnDoubleTapListener的函数*****/\t\tpublic boolean onSingleTapConfirmed(MotionEvent e) &#123;\t\t\tLog.i(&quot;MyGesture&quot;, &quot;onSingleTapConfirmed&quot;);\t\t\tToast.makeText(MainActivity.this, &quot;onSingleTapConfirmed&quot;,\t\t\t\t\tToast.LENGTH_LONG).show();\t\t\treturn true;\t\t&#125;\t\tpublic boolean onDoubleTap(MotionEvent e) &#123;\t\t\tLog.i(&quot;MyGesture&quot;, &quot;onDoubleTap&quot;);\t\t\tToast.makeText(MainActivity.this, &quot;onDoubleTap&quot;, Toast.LENGTH_LONG)\t\t\t\t\t.show();\t\t\treturn true;\t\t&#125;\t\tpublic boolean onDoubleTapEvent(MotionEvent e) &#123;\t\t\tLog.i(&quot;MyGesture&quot;, &quot;onDoubleTapEvent&quot;);\t\t\tToast.makeText(MainActivity.this, &quot;onDoubleTapEvent&quot;,\t\t\t\t\tToast.LENGTH_LONG).show();\t\t\treturn true;\t\t&#125;\t&#125;&#125;\nOnFling应用\nOnFling是用户执行抛操作之后的回调，MOVE事件之后手松开（UP事件）那一瞬间的x或者y方向速度，如果达到一定数值（源码默认是每秒50px），就是抛操作（也就是快速滑动的时候松手会有这个回调，因此基本上有onFling必然有onScroll）。\n下边就演示一个小例子，利用OnFling函数来识别当前用户是在向左滑还是向右滑，功能原理：\n当用户向左滑动距离超过100px，且滑动速度超过100 px/s时，即判断为向左滑动；向右同理。\n代码如下：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class MainActivity extends Activity implements OnTouchListener &#123;\tprivate GestureDetector mGestureDetector;   \t\t@Override\tprotected void onCreate(Bundle savedInstanceState) &#123;\t\tsuper.onCreate(savedInstanceState);\t\tsetContentView(R.layout.activity_main);\t\t\t\tmGestureDetector = new GestureDetector(new simpleGestureListener());\t\t\t\tTextView tv = (TextView)findViewById(R.id.tv);\t    tv.setOnTouchListener(this);\t    tv.setFocusable(true);   \t    tv.setClickable(true);   \t    tv.setLongClickable(true); \t&#125;\t\tpublic boolean onTouch(View v, MotionEvent event) &#123;\t\t// TODO Auto-generated method stub\t\treturn mGestureDetector.onTouchEvent(event);   \t&#125;\tprivate class simpleGestureListener extends\t\t\tGestureDetector.SimpleOnGestureListener &#123;\t\t\t\t/*****OnGestureListener的函数*****/\t\tfinal int FLING_MIN_DISTANCE = 100, FLING_MIN_VELOCITY = 200;  \t\t\t\t// 触发条件 ：           // X轴的坐标位移大于FLING_MIN_DISTANCE，且移动速度大于FLING_MIN_VELOCITY个像素/秒          \t\t// 参数解释：           // e1：第1个ACTION_DOWN MotionEvent           // e2：最后一个ACTION_MOVE MotionEvent           // velocityX：X轴上的移动速度，像素/秒           // velocityY：Y轴上的移动速度，像素/秒   \t\tpublic boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX,\t\t\t\tfloat velocityY) &#123;\t\t\t\t        \t        if (e1.getX() - e2.getX() &gt; FLING_MIN_DISTANCE  \t                &amp;&amp; Math.abs(velocityX) &gt; FLING_MIN_VELOCITY) &#123;  \t            // Fling left   \t            Log.i(&quot;MyGesture&quot;, &quot;Fling left&quot;);  \t            Toast.makeText(MainActivity.this, &quot;Fling Left&quot;, Toast.LENGTH_SHORT).show();  \t        &#125; else if (e2.getX() - e1.getX() &gt; FLING_MIN_DISTANCE  \t                &amp;&amp; Math.abs(velocityX) &gt; FLING_MIN_VELOCITY) &#123;  \t            // Fling right   \t            Log.i(&quot;MyGesture&quot;, &quot;Fling right&quot;);  \t            Toast.makeText(MainActivity.this, &quot;Fling Right&quot;, Toast.LENGTH_SHORT).show();  \t        &#125;  \t\t\treturn true;\t\t&#125;\t&#125;&#125;\n手势相关事件的触发时机\n下边是大神给出的一个手势相关事件的触发时机总结说明，再此记录一下有待以后验证：\n\n从上面的分析可以看出，虽然GestureDetector能识别很多手势，但是也是不能满足所有的需求的，如滑动和长按之后松开没有回调（这个可以重写onTouch()捕捉UP事件实现）、多点触控缩放手势的实现（这个可以用ScaleGestureDetector）等。\n参考\n\nhttps://blog.csdn.net/harvic880925/article/details/39520901\nhttps://blog.csdn.net/totond/article/details/77881180#commentBox\n\n","plink":"https://blog.ixin.run/posts/1584803165/"},{"title":"健康小记","date":"2020-03-21T10:45:34.000Z","date_formatted":{"ll":"2020年3月21日","L":"2020/03/21","MM-DD":"03-21"},"updated":"2021-01-29T12:51:44.669Z","content":"父亲爱饮酒，爱熬夜，前段时间进了ICU，一时间颇为伤心。人在江湖，面向生活和工作，迫不得已，但也要时刻注意自己的身体。身体是你最大的资本和银行卡，时刻要把握一个度，不可本末倒置。\n\n小诗一首\n内阳外阴需微祛，内阴外阳需微补。\n冬寒易动微出汗，夏伏顺走汗微出。\n衣食住行皆干净，早睡早起杯口嘟。\n混沌世界百病有，莫念莫想遵医嘱。\n来时无有去亦无，勿思扰烦向心舒。\n","thumbnail":"https://tse2-mm.cn.bing.net/th/id/OIP.HEHLhOkAp4E1FiGupZBajQHaDh?pid=Api&rs=1","plink":"https://blog.ixin.run/posts/1584787534/"},{"title":"Edittext的自动填充引起的Bug","date":"2020-03-07T15:11:30.000Z","date_formatted":{"ll":"2020年3月7日","L":"2020/03/07","MM-DD":"03-07"},"updated":"2021-02-03T01:46:16.542Z","content":"最近发现线上有一个bug：\n1234567at com.android.internal.util.SyncResultReceiver.waitResult(SyncResultReceiver.java:60)at com.android.internal.util.SyncResultReceiver.getIntResult(SyncResultReceiver.java:68)at android.view.autofill.AutofillManager.ensureServiceClientAddedIfNeededLocked(AutofillManager.java:1847)at android.view.autofill.AutofillManager.notifyViewEnteredLocked(AutofillManager.java:966)at android.view.autofill.AutofillManager.notifyViewEntered(AutofillManager.java:950)at android.view.autofill.AutofillManager.notifyViewEntered(AutofillManager.java:901)...\n并且只出现在Android10上，经查询原来是Edittext默认开启自动填充功能引起的，本片就简单了解一下自动Edittext自动填充功能，以及相应bug的解决方式。\n\n背景\n在Android 8.0中加入了Autofill framework，也就是自动填充框架，目的在于简化了登录和信用卡表单之类表单的填写工作。如果一个应用支持自动填充，系统从用户的Google账户保存的自动填充信息中选取相应的内容来填充当前输入框，比如，一个登录页面的手机号码输入栏，自动填充的推荐内容则是当前用户的手机号码。\n使用\n作为一个开发者，如何来控制自动填充功能呢？在Android O Developer Preview 3中google提供了一些解决办法，即从sdk26开始，所有的视图中新增了一个android:importantForAutofill的属性，以及相应的一个方法setImportantForAutofill()来控制自动填充功能。\n当然我们也可以在代码中(Activity的onCreat中)强制请求自动填充：\n12345public void forceAutofill() &#123; AutofillManager afm &#x3D; context.getSystemService(AutofillManager.class); if (afm!&#x3D; null) &#123;    afm.requestAutofill(); &#125;\n解决Bug\n自动填充功能很好，但是在某些安全性要求较高或者某些特殊的页面，自动填充不再是一个优势，反而带来影响的时候，另外开篇出现的bug是在Android10默认开启自动填充功能引起的，所以针对这些我们一般会屏蔽自动填充功能。屏蔽方法也很简单：\n1.在XML中实现\n1android:importantForAutofill&#x3D;&quot;no&quot;\n2.在代码中实现\n1234567891011public void onCreate(Bundle savedInstanceState) &#123;    super.onCreate(savedInstanceState);    disableAutoFill();&#125;@TargetApi(Build.VERSION_CODES.O)private void disableAutoFill() &#123;     getWindow().getDecorView().setImportantForAutofill(View.IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS);&#125;\n这里我建议第二种直接写在BaseActivity中，切记判断版本Android O以上才可以。\n","plink":"https://blog.ixin.run/posts/1583593890/"},{"title":"记一次BuildConfig.DEBUG不准确导致的Bug","date":"2019-12-11T15:21:16.000Z","date_formatted":{"ll":"2019年12月11日","L":"2019/12/11","MM-DD":"12-11"},"updated":"2021-01-29T12:51:44.651Z","content":"Android开发过程中通常我们区分debug和release的相关配置都会采用BuildConfig.DEBUG来进行判断，殊不知这个东西弄不好却是一个坑，刚好在最近的开发过程中遇到。\n\n问题\n最近在负责一个内部系统，需要根据BuildConfig.DEBUG来判断相关入参，debug模式主要供QA进行demo环境测试，release模式主要用于模拟线上真实环境和回归。但是发现，无论怎么调，BuildConfig.DEBUG始终都是true，也就是release模式下还是true，这就属于bug了，这个问题必须要解决的，因为项目中使用BuildConfig.DEBUG还是很频繁。\n分析\n再找不到任何头绪的时候开始google和baidu，发现均是BuildConfig.DEBUG始终为false的问题，刚好和我遇到的这个相反，并且一篇文章满天飞，很是费解。\n我开始研究他们的原因，有两种说法：\n\n当项目中有很多module时并且有很多相互依赖，编译的时候因为每个module都会生成一个BuildConfig文件，因为相互依赖，这些BuildConfig都可以看到，也就是说，有可能你导包导错了，导入不是自己当前模块下的BuildConfig。但是这种几乎也不会出错，因为编译的时候所有的module都是跟随编译环境更换debug模式或者release模式，除非你在哪里做了骚操作，把被依赖的那个module下的BuildConfig.DEBUG值改掉了。\n在调试代码时因为Build Variants在debug模式和release模式间进行切换，编译器没有及时同步Gradle，导致BuildConfig.DEBUG的值没能更改。当然这种情况也不太容易发生，如果Gradle一直不同步那我们的编译环境也会出现问题。\n\n最终原因\n经过上边的两种情况都进行了验证，并且都淘汰掉了。接下来我在build.gradle下buildTypes下查找时忽然发现一个字段debuggable true，debug和release模式的配置都是这个。\n\n开始怀疑，通过google查清，debuggable主要用于应用在当前编译模式下是否可以进行调试。以下是引用官方的说明：\n\nWhether or not the application can be debugged, even when running on a device in user mode — “true” if it can be, and “false” if not. The default value is “false”.\n\n这个字段就是引发此次Bug的罪魁祸首，他可以直接影响BuildConfig.DEBUG和ApplicationInfo.FLAG_DEBUGGABLE的值，并且是等同的。\ndebuggable除了可以配置在gradle中，也可以配置在manifest的application的闭包中，gradle中配置不会提醒报错或警告，但是在manifest中配置直接“报红”了：\n\ngoogle并不建议我们进行这样设置：\n\nAvoid hardcoding the debug mode; leaving it out allows debug and release builds to automatically assign one less…\nIt’s best to leave out the android:debuggable attribute from the manifest. If you do, then the tools will automatically insert android:debuggable=true when building an APK to debug on an emulator or device. And when you perform a release build, such as Exporting APK, it will automatically set it to false.\nIf on the other hand you specify a specific value in the manifest file, then the tools will always use it. This can lead to accidentally publishing your app with debug information.\n\n随便翻译了一下，大概以下两种原因：\n\n硬编码导致所有的编译环境不能覆盖，debug和release模式都是相同的值。\n会影响项目中的BuildConfig.DEBUG导致在release会把一些私密信息打印出来，如果用这种方式去判断和设置值，说不定会出现一些严重的bug，像我开篇遇到的那样。\n\n总结\n到此针对BuildConfig.DEBUG值不准确的原因终于弄清楚了。\n总之我们在开发中一定要注意以下几点：\n\n在多模块相互依赖的情况下，api调用导包一定要导正确。\n不要随便在gradle或者manifese中设置debuggable的值。\n如果在gradle中真的需要配置debuggable，可以自己额外再创造一个字段，区分debug和release环境，例如：\n在release模式下： 1buildConfigField(&quot;boolean&quot;, &quot;IS_DEBUG&quot;, &quot;false&quot;)\n在debug模式下： 1buildConfigField(&quot;boolean&quot;, &quot;IS_DEBUG&quot;, &quot;true&quot;)\n然后在项目中直接引用BuildConfig.IS_DEBUG即可，这样始终是准确的。\n\n参考\n\nhttps://developer.android.com/guide/topics/manifest/application-element\nhttps://stackoverflow.com/questions/45637524/buildconfig-debug-vs-applicationinfo-flag-debuggable\nhttps://www.trinea.cn/android/android-whether-debug-mode-why-buildconfig-debug-always-false/\n\n","plink":"https://blog.ixin.run/posts/1576077775/"},{"title":"Android开发混淆的那些事","date":"2019-12-11T14:57:42.000Z","date_formatted":{"ll":"2019年12月11日","L":"2019/12/11","MM-DD":"12-11"},"updated":"2021-01-29T12:51:44.638Z","content":"混淆想必大家都不陌生，android上用的这一套混淆规则和java混淆几乎是一样的。为何需要混淆呢？简单的说，就是将原本正常的项目文件，对其类，方法，字段，重新命名,a,b,c,d,e,f…之类的字母，达到混淆代码的目的，这样反编译出来，结构乱糟糟的，给反编译者制造一些代码阅读的麻烦。\n\nProGuard简介\nProGuard是2002年由比利时程序员Eric Lafortune发布的一款优秀的开源代码优化、混淆工具，适用于Java和Android应用，目标是让程序更小，运行更快，在Java界处于垄断地位。主要分为四个模块：Shrinker（压缩器）、Optimizer（优化器）、Obfuscator（混淆器）、Retrace（堆栈反混淆）。\n\n\n压缩（shrink）通过引用标记算法，移除未使用的类、方法、字段等\n优化（optimize）优化字节码，简化代码等操作\n混淆（obfuscate）使用简短的，无意义的名称重命名类名，方法名，参数字段等\n预校验（perverify）为class添加预校验消息\n\nAndroid启用压缩、混淆、优化\n在 Android 中，我们平常所说的&quot;混淆&quot;其实有两层意思：\n\n是 Java 代码的混淆\n是资源的压缩\n\n其实这两者之间并没有什么关联，只不过习惯性地放在一起来使用。那么，说了这么多，Android平台上到底该如何开启混淆呢？\n123456789android &#123;    buildTypes &#123;        release &#123;            minifyEnabled true            shrinkResources true            proguardFiles getDefaultProguardFile(&#x27;proguard-android.txt&#x27;), &#x27;proguard-rules.pro&#x27;        &#125;    &#125;&#125;\n以上就是开启混淆的基本操作了，通过 minifyEnabled 设置为 true 来开启混淆。同时，可以设置 shrinkResources 为 true 来开启资源的压缩。\n不难看出，我们一般在打 release 包时才启用混淆，因为混淆会增加额外的编译时间，所以不建议在 debug 模式下启用。此外，需要注意的是：只有在启用混淆的前提下开启资源压缩才会有效！\n以上代码中的 proguard-android.txt 表示 Android 系统为我们提供的默认混淆规则文件，而 proguard-rules.pro 则是我们想要自定义的混淆规则。\n如果你不对proguard-rules.pro文件做定制化，默认是整个工程全开启混淆的，但是由于一些三方代码、反射、自定义view等，一旦这些都混淆了编译器在运行时找不到具体的成员，从而会导致错误，所以我们也要忽略一些类或者成员的混淆。\nAndroid混淆配置关键字\n系统混淆配置\n1234567891011121314#混淆时不使用大小写混合类名-dontusemixedcaseclassnames #不跳过library中的非public的类-dontskipnonpubliclibraryclasses #打印混淆的详细信息-verbose #不进行优化，建议使用此选项-dontoptimize #不进行预校验,Android不需要,可加快混淆速度-dontpreverify#忽略警告-ignorewarnings #指定代码的压缩级别-optimizationpasses 5  \nProguard关键字\n\n如果你不确定你需要使用哪一个选项，那么你应该尽量使用 -keep 。它会确保指定的类和成员在 压缩阶段（shrinking step）不会被删除，并且在 混淆阶段（obfuscation step）不会被混淆。\nProguard通配符\n\n上边的通配符没有返回类型。仅仅通配符有一个参数列表。\n字段和方法的名称可以包含如下通配符：\n12? 匹配名称中的任意单个字符* 匹配名称中的任意一部分\n类型描述可以包含如下通配符：\n123456% 匹配任意基本类型（‘boolean’,&#39;int&#39;以及其他，但是不包括‘void’）.? 匹配类名中的任意单个字符* 匹配类名中的任意部分，但是不包含包分隔符 。** 匹配类名中的任意部分，可以包含任意个数的包分隔符。*** 匹配任意类型（基本类型或者非基本类型，数组或者非数组）... 匹配任意个数任意类型的参数。\n注意：? , * 以及 ** 通配符永远都不会匹配基本类型。此外，仅仅 *** 通配符会匹配任意长度任意类型的数组。\n哪些不应该进行混淆\n我们在了解了混淆的基本命令之后，很多人应该还是一头雾水：到底哪些内容该混淆？其实，我们在使用代码混淆时，ProGuard 对我们项目中大部分代码进行了混淆操作，为了防止编译时出错，我们应该通过 keep 命令保留一些元素不被混淆。所以，我们只需要知道哪些元素不应该被混淆：\n枚举\n项目中难免可能会用到枚举类型，然而它不能参与到混淆当中去。原因是：枚举类内部存在 values 方法，混淆后该方法会被重新命名，并抛出 NoSuchMethodException。庆幸的是，Android 系统默认的混淆规则中已经添加了对于枚举类的处理，我们无需再去做额外工作。\n被反射的元素\n被反射使用的类、变量、方法、包名等不应该被混淆处理。原因在于：代码混淆过程中，被反射使用的元素会被重命名，然而反射依旧是按照先前的名称去寻找元素，所以会经常发生 NoSuchMethodException 和 NoSuchFiledException 问题。\n实体类\n实体类即我们常说的&quot;数据类&quot;，当然经常伴随着序列化与反序列化操作。很多人也应该都想到了，混淆是将原本有特定含义的&quot;元素&quot;转变为无意义的名称，所以，经过混淆的&quot;洗礼&quot;之后，序列化之后的 value 对应的 key 已然变为没有意义的字段，这肯定是我们不希望的。同时，反序列化的过程创建对象从根本上来说还是借助于反射，混淆之后 key 会被改变，所以也会违背我们预期的效果。\n四大组件\nAndroid 中的四大组件同样不应该被混淆。原因在于：\n四大组件使用前都需要在 AndroidManifest.xml 文件中进行注册声明，然而混淆处理之后，四大组件的类名就会被篡改，实际使用的类与 manifest 中注册的类并不匹配，故而出错。其他应用程序访问组件时可能会用到类的包名加类名，如果经过混淆，可能会无法找到对应组件或者产生异常。\nJNI 调用的Java 方法\n当 JNI 调用的 Java 方法被混淆后，方法名会变成无意义的名称，这就与 C++ 中原本的 Java 方法名不匹配，因而会无法找到所调用的方法。\n其他不应该被混淆的\n自定义控件不需要被混淆\nJavaScript 调用 Java 的方法不应混淆\nJava 的 native 方法不应该被混淆\n项目中引用的第三方库也不建议混淆\n混淆举例\n以下是一些混淆的举例和说明\n12345678910111213141516171819202122232425262728293031&#x2F;&#x2F;不混淆某个类-keep public class name.huihui.example.Test &#123; *; &#125;&#x2F;&#x2F;不混淆某个类的子类-keep public class * extends name.huihui.example.Test &#123; *; &#125;&#x2F;&#x2F;不混淆所有类名中包含了“model”的类及其成员-keep public class **.*model*.** &#123;*;&#125;&#x2F;&#x2F;不混淆某个接口的实现-keep class * implements name.huihui.example.TestInterface &#123; *; &#125;&#x2F;&#x2F;不混淆某个类的构造方法-keepclassmembers class name.huihui.example.Test &#123;     public &lt;init&gt;(); &#125;&#x2F;&#x2F;不混淆某个类的特定的方法-keepclassmembers class name.huihui.example.Test &#123;     public void test(java.lang.String); &#125;&#x2F;&#x2F;不混淆某个类的内部类-keep class name.huihui.example.Test$* &#123;*;&#125;&#x2F;&#x2F;两个常用的混淆命令，注意：&#x2F;&#x2F;一颗星表示只是保持该包下的类名，而子包下的类名还是会被混淆；&#x2F;&#x2F;两颗星表示把本包和所含子包下的类名都保持；-keep class com.suchengkeji.android.ui.*-keep class com.suchengkeji.android.ui.**&#x2F;&#x2F;用以上方法保持类后，你会发现类名虽然未混淆，但里面的具体方法和变量命名还是变了，&#x2F;&#x2F;如果既想保持类名，又想保持里面的内容不被混淆，我们就需要以下方法了&#x2F;&#x2F;不混淆某个包所有的类-keep class com.suchengkeji.android.bean.** &#123; *; &#125;&#x2F;&#x2F;不混淆某个具体类-keep public class com.android.vending.licensing.ILicensingService\n一个通用的混淆模板\n这里给大家提供一个通用的混淆模板\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124###########################################基本指令(基本不动)########################################代码混淆压缩比，在0~7之间，默认为5，一般不做修改-optimizationpasses 5#混合时不使用大小写混合，混合后的类名为小写-dontusemixedcaseclassnames#指定不去忽略非公共库的类-dontskipnonpubliclibraryclasses#指定不去忽略非公共库的类的成员-dontskipnonpubliclibraryclassmembers#这句话能够使我们的项目混淆后产生映射文件#包含有类名-&gt;混淆后类名的映射关系-verbose#不做预校验，preverify是proguard的四个步骤之一，Android不需要preverify，去掉这一步能够加快混淆速度。-dontpreverify#保留Annotation不混淆-keepattributes *Annotation*,InnerClasses#保留泛型不混淆-keepattributes Signature#抛出异常时保留代码行号-keepattributes SourceFile,LineNumberTable#指定混淆是采用的算法，后面的参数是一个过滤器 #这个过滤器是谷歌推荐的算法，一般不做更改-optimizations !code&#x2F;simplification&#x2F;cast,!field&#x2F;*,!class&#x2F;merging&#x2F;*#########################################java部分############################################native方法不被混淆-keepclasseswithmembernames class * &#123;    native &lt;methods&gt;;&#125;#枚举enum类不被混淆-keepclassmembers enum * &#123;    public static **[] values();    public static ** valueOf(java.lang.String);&#125;#Serializable类不被混淆-keep public class * implements java.io.Serializable &#123;*;&#125;#########################################android部分#####################################保留support下的所有类及其内部类-keep class android.support.** &#123;*;&#125;#基类不被混淆-keep class * extends android.app.Activity-keep class * extends android.app.Application-keep class * extends android.app.Service-keep class * extends android.content.BroadcastReceiver-keep class * extends android.content.ContentProvider-keep class * extends android.app.backup.BackupAgentHelper-keep class * extends android.preference.Preference#自定义控件类不被混淆-keepclasseswithmembers class * &#123;    public &lt;init&gt;(android.content.Context, android.util.AttributeSet);&#125;-keepclasseswithmembers class * &#123;    public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);&#125;#表示不混淆任何一个View中的setXxx()和getXxx()方法，#因为属性动画需要有相应的setter和getter的方法实现，混淆了就无法工作了。-keep class * extends android.view.View&#123;    *** get*();    void set*(***);    &lt;init&gt;(...);&#125;# 保留R下面的资源#不混淆资源类下static的-keepclassmembers class **.R$* &#123;    public static &lt;fields&gt;;&#125;#Parcelable类不被混淆-keep class * implements android.os.Parcelable &#123;  public static final android.os.Parcelable$Creator *;&#125;#WebView相关不被混淆-keepclassmembers class * extends android.webkit.WebView &#123;*;&#125;-keepclassmembers class * extends android.webkit.WebViewClient &#123;*;&#125;-keepclassmembers class * extends android.webkit.WebChromeClient &#123;*;&#125;-keepclassmembers class * &#123;    @android.webkit.JavascriptInterface &lt;methods&gt;;&#125;########################################本项目混淆规则###########################################非本项目不进行混淆-keep class !com.ehai.store.** &#123;*;&#125;-dontwarn **#########################################其他########################################################避免混淆Bugly#-dontwarn com.tencent.bugly.**#-keep public class com.tencent.bugly.**&#123;*;&#125;###极光推送#-dontoptimize#-dontpreverify##-dontwarn cn.jpush.**#-keep class cn.jpush.** &#123; *; &#125;#-keep class * extends cn.jpush.android.helpers.JPushMessageReceiver &#123; *; &#125;##-dontwarn cn.jiguang.**#-keep class cn.jiguang.** &#123; *; &#125;###微众银行OCR SDK 混淆##webank-cloud-normal-proguard-rules.pro的规则已经被webank-cloud-ocr-proguard-rules.pro “include”了，不需要再添加#-include webank-cloud-ocr-proguard-rules.pro\n混淆后的堆栈跟踪\n代码经过 ProGuard 混淆处理后，想要读取 StackTrace（堆栈追踪）信息就会变得很困难。由于方法名称和类的名称都经过混淆处理，即使程序发生崩溃问题，也很难定位问题所在。幸运的是，ProGuard 为我们提供了补救的措施，在着手进行之前，我们先来看一下 ProGuard 每次构建后生成了哪些内容。\n混淆输出结果\n混淆构建完成之后，会在&lt;module-name&gt;/build/outputs/mapping/./ 目录下生成以下文件：\n\ndump.txt\n说明 APK 内所有类文件的内部结构。\nmapping.txt\n提供混淆前后的内容对照表，内容主要包含类、方法和类的成员变量。\nseeds.txt\n罗列出未进行混淆处理的类和成员。\nusage.txt\n罗列出从 APK 中移除的代码。\n\n如何从堆栈中还原ProGuard混淆后的代码\n混淆后的代码一旦发生崩溃，那么所产生的日志也是混淆的，调试起来很麻烦，所以此时有必要将其还原到原生态进行分析。\n还原前\n12345Caused by: java.lang.NullPointerExceptionat net.simplyadvanced.ltediscovery.be.u(Unknown Source)at net.simplyadvanced.ltediscovery.at.v(Unknown Source)at net.simplyadvanced.ltediscovery.at.d(Unknown Source)at net.simplyadvanced.ltediscovery.av.onReceive(Unknown Source)\n还原后\n12345Caused by: java.lang.NullPointerExceptionat net.simplyadvanced.ltediscovery.UtilTelephony.boolean is800MhzNetwork()(Unknown Source)at net.simplyadvanced.ltediscovery.ServiceDetectLte.void checkAndAlertUserIf800MhzConnected()(Unknown Source)at net.simplyadvanced.ltediscovery.ServiceDetectLte.void startLocalBroadcastReceiver()(Unknown Source)at net.simplyadvanced.ltediscovery.ServiceDetectLte$2.void onReceive(android.content.Context,android.content.Intent)(Unknown Source)\n那么如何还原呢？这里提供两种方式：GUI工具和命令行\nGUI工具还原\n\n打开/tools/proguard/bin/proguardgui.bat\n选择左边栏的ReTrace选项\n添加你的mapping文件和混淆过的堆栈信息\n点击ReTrace!\n\n如图：\n\n命令行还原\n\n需要你的ProGuard的mapping文件和你想要还原的堆栈信息（如stacktrace.txt）\n最简单的方法就是将这些文件拷贝到/tools/proguard/bin/目录\n运行以下命令\n\n12345&#x2F;&#x2F;Windowsretrace.bat -verbose mapping.txt stacktrace.txt &gt; out.txt&#x2F;&#x2F;Mac\\Linuxretrace.sh -verbose mapping.txt stacktrace.txt &gt; out.txt\n参考\n\nhttps://tech.meituan.com/2018/04/27/mt-proguard.html\nhttps://stuff.mit.edu/afs/sipb/project/android/sdk/android-sdk-linux/tools/proguard/docs/index.html#manual/introduction.html\nhttps://developer.android.com/studio/build/shrink-code.html\n\n","plink":"https://blog.ixin.run/posts/1576076353/"},{"title":"Git分支管理最佳实践","date":"2019-11-19T15:31:00.000Z","date_formatted":{"ll":"2019年11月19日","L":"2019/11/19","MM-DD":"11-19"},"updated":"2021-01-29T12:51:44.654Z","content":"Git是什么，这里就不再多说了，本篇就目前主流公司普遍流行的git分支管理方式做一个简单的总结，另外在开发过程中代码规范提交也是很重要的，本文也会做一个说明。\n\nGit 分支管理方式\n单主干\n单主干的分支实践（Trunk-based development，TBD）在 SVN 中比较流行。trunk 是 SVN 中主干分支的名称，对应到 Git 中则是 master 分支。TBD的特点是所有团队成员都在单个主干分支上进行开发。当需要发布时，先考虑使用标签（tag），tag 即某个 commit 来作为发布的版本。如果仅靠 tag 不能满足要求，则从主干分支创建发布分支。bug 修复在主干分支中进行，再 cherry-pick 到发布分支。下图是 TBD 中分支流程的示意图。\n\n由于所有开发人员都在同一个分支上工作，团队需要合理的分工和充分的沟通来保证不同开发人员的代码尽可能少的发生冲突。持续集成和自动化测试是必要的，用来及时发现主干分支中的 bug。因为主干分支是所有开发人员公用的，一个开发人员引入的 bug 可能对其他很多人造成影响。不过好处是由于分支所带来的额外开销非常小。开发人员不需要频繁在不同的分支之间切换。\nGitHub flow\nGitHub flow 是 GitHub 所使用的一种简单的流程。该流程只使用两类分支，并依托于 GitHub 的 pull request 功能。在 GitHub flow 中，master 分支中包含稳定的代码。该分支已经或即将被部署到生产环境。master 分支的作用是提供一个稳定可靠的代码基础。任何开发人员都不允许把未测试或未审查的代码直接提交到 master 分支。\n对代码的任何修改，包括 bug 修复、hotfix、新功能开发等都在单独的分支中进行。不管是一行代码的小改动，还是需要几个星期开发的新功能，都采用同样的方式来管理。当需要进行修改时，从 master 分支创建一个新的分支。新分支的名称应该简单清晰地描述该分支的作用。所有相关的代码修改都在新分支中进行。开发人员可以自由地提交代码和 push 到远程仓库。\n当新分支中的代码全部完成之后，通过 GitHub 提交一个新的 pull request。团队中的其他人员会对代码进行审查，提出相关的修改意见。由持续集成服务器（如 Jenkins）对新分支进行自动化测试。当代码通过自动化测试和代码审查之后，该分支的代码被合并到 master 分支。再从 master 分支部署到生产环境。下图是 GitHub flow 分支流程的示意图。\n\nGitHub flow 的好处在于非常简单实用。开发人员需要注意的事项非常少，很容易形成习惯。当需要进行任何修改时，总是从 master 分支创建新分支。完成之后通过 pull request 和相关的代码审查来合并回 master 分支。GitHub flow 要求项目有完善的自动化测试、持续集成和部署等相关的基础设施。每个新分支都需要测试和部署，如果这些不能自动化进行，会增加开发人员的工作量，导致无法有效地实施该流程。这种分支实践也要求团队有代码审查的相应流程。\ngit-flow\ngit-flow 应该是目前流传最广的 Git 分支管理实践。git-flow 围绕的核心概念是版本发布（release）。目前推崇的做法是持续集成和随时发布，也有可能很长时间发布某个功能，或者版本发布时候由于市场的考量，只发布其中某些功能等，git-flow及其适合这种灵活以及稳定性的场景。\ngit-flow 流程中包含 5 类分支，分别是 master、develop、新功能分支（feature）、发布分支（release）和 hotfix。这些分支的作用和生命周期各不相同。master 分支中包含的是可以部署到生产环境中的代码，这一点和 GitHub flow 是相同的。develop 分支中包含的是下个版本需要发布的内容。从某种意义上来说，develop 是一个进行代码集成的分支。当 develop 分支集成了足够的新功能和 bug 修复代码之后，通过一个发布流程来完成新版本的发布。发布完成之后，develop 分支的代码会被合并到 master 分支中。\n其余三类分支的描述如下表所示。这三类分支只在需要时从 develop 或 master 分支创建。在完成之后合并到 develop 或 master 分支。合并完成之后该分支被删除。这几类分支的名称应该遵循一定的命名规范，以方便开发人员识别。\n\n对于开发过程中的不同任务，需要在对应的分支上进行工作并正确地进行合并。每个任务开始前需要按照指定的步骤完成分支的创建。例如当需要开发一个新的功能时，基本的流程如下：\n\n从 develop 分支创建一个新的 feature 分支，如 feature/my-awesome-feature。\n在该 feature 分支上进行开发，提交代码，push 到远端仓库。\n当代码完成之后，合并到 develop 分支并删除当前 feature 分支。\n\n在进行版本发布和 hotfix 时也有类似的流程。当需要发布新版本时，采用的是如下的流程：\n\n从 develop 分支创建一个新的 release 分支，如 release/1.4。\n把 release 分支部署到持续集成服务器上进行测试。测试包括自动化集成测试和手动的用户接受测试。\n对于测试中发现的问题，直接在 release 分支上提交修改。完成修改之后再次部署和测试。\n当 release 分支中的代码通过测试之后，把 release 分支合并到 develop 和 master 分支，并在 master 分支上添加相应的 tag。\n\nGit commit msssage 规范\nGit 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。\n1$ git commit -m &quot;hello world&quot;\n一般情况简简单单一句话就能够说明本次提交的信息，但是我们在大项目开发时，正如上边所说，持续集成，随时发布，提交的次数是很多的，这样回顾的时候很容易弄混，并且不清晰，所以我们在提交时候最好还是针对提交message有一个规范，这样看起来有条有理，甚好。这里引用阮一峰所提到的Angular 规范规范，并简单解释说明。\nCommit message 的格式\n每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。\n12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&#x2F;&#x2F; 空一行&lt;body&gt;&#x2F;&#x2F; 空一行&lt;footer&gt;\n其中，Header 是必需的，Body 和 Footer 可以省略。\n不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。\nHeader\nHeader部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）。\ntype\ntype用于说明 commit 的类别，只允许使用下面7个标识。\n\nfeat：新功能（feature）\nfix：修补bug\ndocs：文档（documentation）\nstyle： 格式（不影响代码运行的变动）\nrefactor：重构（即不是新增功能，也不是修改bug的代码变动）\ntest：增加测试\nchore：构建过程或辅助工具的变动\n\n如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。\nscope\nscope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。\nsubject\nsubject是 commit 目的的简短描述，不超过50个字符。\n\n以动词开头，使用第一人称现在时，比如change，而不是changed或changes\n第一个字母小写\n结尾不加句号（.）\n\nBody\nBody 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。\n1234567More detailed explanatory text, if necessary.  Wrap it to about 72 characters or so. Further paragraphs come after blank lines.- Bullet points are okay, too- Use a hanging indent\n有两个注意点:\n\n使用第一人称现在时，比如使用change而不是changed或changes。\n应该说明代码变动的动机，以及与以前行为的对比。\n\nFooter\nFooter 部分只用于两种情况。\n1.不兼容变动\n如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。\n1234567891011121314151617BREAKING CHANGE: isolate scope bindings definition has changed.    To migrate the code follow the example below:    Before:    scope: &#123;      myAttr: &#39;attribute&#39;,    &#125;    After:    scope: &#123;      myAttr: &#39;@&#39;,    &#125;    The removed &#96;inject&#96; wasn&#39;t generaly useful for directives so there should be no code using it.\n2.关闭 Issue\n如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。\n1Closes #234\n也可以一次关闭多个 issue。\n1Closes #123, #245, #992\nRevert\n还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。\n123revert: feat(pencil): add &#39;graphiteWidth&#39; optionThis reverts commit 667ecc1654a317a13331b17617d973392f415f02.\nBody部分的格式是固定的，必须写成This reverts commit &lt;hash&gt;.，其中的hash是被撤销 commit 的 SHA 标识符。\n如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。\n生成 Change log\n如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成，这种在Github上最为常见。\n\n生成的文档包括以下三个部分:\n\nNew features\nBug fixes\nBreaking changes.\n\n每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。\n至于生成Change log工具，大家可以自行根据自家的代码管理平台进行搜索，安装，这里就不说了。\n参考\n\nhttps://www.ibm.com/developerworks/cn/java/j-lo-git-mange/index.html\nhttp://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html\n\n","plink":"https://blog.ixin.run/posts/1574177460/"},{"title":"手撸LRU算法基本思路","date":"2019-10-21T12:54:17.000Z","date_formatted":{"ll":"2019年10月21日","L":"2019/10/21","MM-DD":"10-21"},"updated":"2021-02-24T13:42:12.520Z","content":"LRU（Least Recently Used），即最近最少使用淘汰法，它是按照一个非常注明的计算机操作系统基础理论得来的：最近使用的页面数据会在未来一段时期内仍然被使用,已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用。本文就带着大家徒手撸一个最基本的LRU算法。\n\nLRU算法系列：\n\n《认识LRU经典算法》\n《手撸LRU算法基本思路》\n\n实现过程\n网上大部分对LRU算法的两个指标认为是时间和次数，最朴素的思想就是用数组+时间戳的方式来进行实现，不过这样做效率较低。其实在开发过程中普遍的做法是按照双向链表来实现的，其重要的两个指标是容量大小和位置，进而来决定淘汰规则。\n平时使用LRU算法常见的几个操作有：定义容量大小、添加操作、获取操作、删除操作。其中的添加、获取、删除这三个操作都涉及到链表节点的上下关系重新定向。\n下边我们就根据这个思想来进行实现。\n节点定义\nLRU采用的是双链表形式，针对每一个节点都要有前一个结点和后一个节点的引用。\n123456789101112131415public class Node &#123;    //键    Object key;    //值    Object value;    //上一个节点    Node pre;    //下一个节点    Node next;     public Node(Object key, Object value) &#123;        this.key = key;        this.value = value;    &#125;&#125;\n链表定义\n前面也说了通常LRU的两个指标是容量和位置，因此LRU定义中还要定义最大容量、当前容量、和当前存放node节点的数据池。\n123456789101112public class LRU&lt;K, V&gt; &#123;    private int currentSize;//当前的大小    private int capcity;//总容量    private HashMap&lt;K, Node&gt; caches;//所有的node节点    private Node first;//头节点    private Node last;//尾节点     public LRU(int size) &#123;        currentSize = 0;        this.capcity = size;        caches = new HashMap&lt;K, Node&gt;(size);    &#125;\n添加操作\n添加元素的时候首先判断是不是新的元素，如果是新元素，判断当前的大小是不是大于总容量了，防止超过总链表大小，如果大于的话直接抛弃最后一个节点，然后再以传入的key\\value值创建新的节点。对于已经存在的元素，直接覆盖旧值，再将该元素移动到头部，然后保存在map中。\n123456789101112131415161718192021222324/**   * 添加元素   * @param key   * @param value   */  public void put(K key, V value) &#123;      Node node = caches.get(key);      //如果新元素      if (node == null) &#123;          //如果超过元素容纳量          if (caches.size() &gt;= capcity) &#123;              //移除最后一个节点              caches.remove(last.key);              removeLast();          &#125;          //创建新节点          node = new Node(key,value);      &#125;      //已经存在的元素覆盖旧值      node.value = value;      //把元素移动到首部      moveToHead(node);      caches.put(key, node);  &#125;\n获取操作\n通过key值来访问元素，主要的做法就是先判断是否存在，如果是不存在的，直接返回null。如果存在，把数据移动到首部头节点，然后再返回旧值。\n1234567891011121314/** * 通过key获取元素 * @param key * @return */public Object get(K key) &#123;    Node node = caches.get(key);    if (node == null) &#123;        return null;    &#125;    //把访问的节点移动到首部    moveToHead(node);    return node.value;&#125;\n删除操作\n一个关键点是把删除的节点的前后节点关系相互绑定。额外要考虑到如果删除的是头部，关系怎么处理，如果删除的尾部关系又要怎么处理。\n\n1234567891011121314151617181920212223/** * 根据key移除节点 * @param key * @return */public Object remove(K key) &#123;    Node node = caches.get(key);    if (node != null) &#123;        if (node.pre != null) &#123;            node.pre.next = node.next;        &#125;        if (node.next != null) &#123;            node.next.pre = node.pre;        &#125;        if (node == first) &#123;            first = node.next;        &#125;        if (node == last) &#123;            last = node.pre;        &#125;    &#125;    return caches.remove(key);&#125;\n移动到头节点\n上边的“添加”、“获取”、“删除”三种操作是最基本的，其中一旦拿到可用节点都要移动到头节点，这是一个重要环节，此时也是要处理这种前后节点的关系。\n1234567891011121314151617181920212223242526/** * 把当前节点移动到首部 * @param node */private void moveToHead(Node node) &#123;    if (first == node) &#123;        return;    &#125;    if (node.next != null) &#123;        node.next.pre = node.pre;    &#125;    if (node.pre != null) &#123;        node.pre.next = node.next;    &#125;    if (node == last) &#123;        last = last.pre;    &#125;    if (first == null || last == null) &#123;        first = last = node;        return;    &#125;    node.next = first;    first.pre = node;    first = node;    first.pre = null;&#125;\n删除尾节点\n添加过程中遇到队满的情况，就要有移除尾节点了。\n12345678910111213/** * 移除最后一个节点 */private void removeLast() &#123;    if (last != null) &#123;        last = last.pre;        if (last == null) &#123;            first = null;        &#125; else &#123;            last.next = null;        &#125;    &#125;&#125;\n完整代码\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160import java.util.HashMap; public class LRU&lt;K, V&gt; &#123;    private int currentSize;//当前的大小    private int capcity;//总容量    private HashMap&lt;K, Node&gt; caches;//所有的node节点    private Node first;//头节点    private Node last;//尾节点     public LRU(int size) &#123;        currentSize = 0;        this.capcity = size;        caches = new HashMap&lt;K, Node&gt;(size);    &#125;     /**     * 放入元素     * @param key     * @param value     */    public void put(K key, V value) &#123;        Node node = caches.get(key);        //如果新元素        if (node == null) &#123;            //如果超过元素容纳量            if (caches.size() &gt;= capcity) &#123;                //移除最后一个节点                caches.remove(last.key);                removeLast();            &#125;            //创建新节点            node = new Node(key,value);        &#125;        //已经存在的元素覆盖旧值        node.value = value;        //把元素移动到首部        moveToHead(node);        caches.put(key, node);    &#125;     /**     * 通过key获取元素     * @param key     * @return     */    public Object get(K key) &#123;        Node node = caches.get(key);        if (node == null) &#123;            return null;        &#125;        //把访问的节点移动到首部        moveToHead(node);        return node.value;    &#125;     /**     * 根据key移除节点     * @param key     * @return     */    public Object remove(K key) &#123;        Node node = caches.get(key);        if (node != null) &#123;            if (node.pre != null) &#123;                node.pre.next = node.next;            &#125;            if (node.next != null) &#123;                node.next.pre = node.pre;            &#125;            if (node == first) &#123;                first = node.next;            &#125;            if (node == last) &#123;                last = node.pre;            &#125;        &#125;        return caches.remove(key);    &#125;     /**     * 清除所有节点     */    public void clear() &#123;        first = null;        last = null;        caches.clear();    &#125;     /**     * 把当前节点移动到首部     * @param node     */    private void moveToHead(Node node) &#123;        if (first == node) &#123;            return;        &#125;        if (node.next != null) &#123;            node.next.pre = node.pre;        &#125;        if (node.pre != null) &#123;            node.pre.next = node.next;        &#125;        if (node == last) &#123;            last = last.pre;        &#125;        if (first == null || last == null) &#123;            first = last = node;            return;        &#125;        node.next = first;        first.pre = node;        first = node;        first.pre = null;    &#125;     /**     * 移除最后一个节点     */    private void removeLast() &#123;        if (last != null) &#123;            last = last.pre;            if (last == null) &#123;                first = null;            &#125; else &#123;                last.next = null;            &#125;        &#125;    &#125;     @Override    public String toString() &#123;        StringBuilder sb = new StringBuilder();        Node node = first;        while (node != null) &#123;            sb.append(String.format(&quot;%s:%s &quot;, node.key, node.value));            node = node.next;        &#125;        return sb.toString();    &#125;          public static void main(String[] args) &#123;        LRU&lt;Integer, String&gt; lru = new LRU&lt;Integer, String&gt;(5);        lru.put(1, &quot;a&quot;);        lru.put(2, &quot;b&quot;);        lru.put(3, &quot;c&quot;);        lru.put(4,&quot;d&quot;);        lru.put(5,&quot;e&quot;);        System.out.println(&quot;原始链表为:&quot;+lru.toString());         lru.get(4);        System.out.println(&quot;获取key为4的元素之后的链表:&quot;+lru.toString());         lru.put(6,&quot;f&quot;);        System.out.println(&quot;新添加一个key为6之后的链表:&quot;+lru.toString());         lru.remove(3);        System.out.println(&quot;移除key=3的之后的链表:&quot;+lru.toString());    &#125;&#125;\n总结\nLRU算法，最近最少使用末位淘汰法，也是通用做法采用双向链表的形式来进行实现这一算法，链表内每个节点保留有该节点的前后关系，关键点就是获取后的节点重新置为首位，末尾节点有可能被“挤”掉，置换过程中处理好该节点与前后节点的关系即可。\n彩蛋\n上边我们是徒手实现了一个双向链表，那么在Java中有没有一个现成的api来实现类似这种访问顺序的链表呢，其实Java中有一个LinkedHashMap，他有两种排序规则：普通插入排序和访问顺序排序。平时用的最多的是普通插入排序，如果LRU采用LinkedHashMap的访问顺序排序，那么实现起来就非常简单了，Android SDK中默认有LruCache的API，其内部思想就是采用这种方式。\n","plink":"https://blog.ixin.run/posts/1571663304/"},{"title":"Android媒体库你了解多少","date":"2019-10-19T14:15:26.000Z","date_formatted":{"ll":"2019年10月19日","L":"2019/10/19","MM-DD":"10-19"},"updated":"2021-01-29T12:51:44.623Z","content":"Android系统中有一个媒体库，这个大家应该有所了解，平时在开发过程中如果不涉及媒体文件（图片、音频、视频）这块则很少接触到。有些时候我们在本地添加一张图片，但是在相册中却无法搜索到，这里主要原因就是没有通知系统媒体库刷新导致的。本篇我们就探讨下Android上媒体库的这些事。\n为什么通知媒体库后，媒体库里就能找到了呢？兴许你还会遇到一种情况，就是明明相册里可以发现这张图片，可是到图片的具体路径下却找不到这张图片。到此应该会猜测到是不是媒体库和本地相册都持有一份媒体文件信息呢？基本上猜到了八九不离十了，其实媒体库就是一个数据库，专门管理媒体文件的相关信息，例如图片信息，缩略图等。\n\n多媒体文件管理\nAndroid多媒体文件扫描管理简单来说，有以下四部分内容：\n\n通知：MediaScannerReceiver\n扫描：MediaScannerService\n存储：MediaProvider\n查询：MediaStore\n\nMediaScannerReceiver\nMediaScannerReceiver主要用于接受扫描通知，然后启动MediaScannerService进行扫描操作。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@Overridepublic void onReceive(Context context, Intent intent) &#123;    final String action = intent.getAction();    final Uri uri = intent.getData();    if (Intent.ACTION_BOOT_COMPLETED.equals(action)) &#123;        // Scan internal only.        scan(context, MediaProvider.INTERNAL_VOLUME);    &#125; else if (Intent.ACTION_LOCALE_CHANGED.equals(action)) &#123;        scanTranslatable(context);    &#125; else &#123;        if (uri.getScheme().equals(&quot;file&quot;)) &#123;            // handle intents related to external storage            String path = uri.getPath();            String externalStoragePath = Environment.getExternalStorageDirectory().getPath();            String legacyPath = Environment.getLegacyExternalStorageDirectory().getPath();            try &#123;                path = new File(path).getCanonicalPath();            &#125; catch (IOException e) &#123;                Log.e(TAG, &quot;couldn&#x27;t canonicalize &quot; + path);                return;            &#125;            if (path.startsWith(legacyPath)) &#123;                path = externalStoragePath + path.substring(legacyPath.length());            &#125;            Log.d(TAG, &quot;action: &quot; + action + &quot; path: &quot; + path);            if (Intent.ACTION_MEDIA_MOUNTED.equals(action)) &#123;                // scan whenever any volume is mounted                scan(context, MediaProvider.EXTERNAL_VOLUME);            &#125; else if (Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action) &amp;&amp;                    path != null &amp;&amp; path.startsWith(externalStoragePath + &quot;/&quot;)) &#123;                scanFile(context, path);            &#125;        &#125;    &#125;        。。。    private void scan(Context context, String volume) &#123;    Bundle args = new Bundle();    args.putString(&quot;volume&quot;, volume);    context.startService(            new Intent(context, MediaScannerService.class).putExtras(args));&#125;private void scanFile(Context context, String path) &#123;    Bundle args = new Bundle();    args.putString(&quot;filepath&quot;, path);    context.startService(            new Intent(context, MediaScannerService.class).putExtras(args));&#125;private void scanTranslatable(Context context) &#123;    final Bundle args = new Bundle();    args.putBoolean(MediaStore.RETRANSLATE_CALL, true);    context.startService(new Intent(context, MediaScannerService.class).putExtras(args));&#125;\n从onReceive方法中可以看出，MediaScannerReceiver执行scan的时机有四种：\n\n启动完毕，扫描内部存储和外部存储\n本地语言切换\nsdcard挂载完毕，扫描外部存储\n扫描单个文件\n\nMediaScannerService\nMediaScannerService主要负责媒体文件的扫描过程，因此是耗时的，其内部的scan()方法是扫描核心。\n123456789101112131415161718192021222324private void scan(String[] directories, String volumeName) &#123;    ...    try &#123;        ...        sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_STARTED, uri));                try &#123;            if (volumeName.equals(MediaProvider.EXTERNAL_VOLUME)) &#123;                openDatabase(volumeName);            &#125;            try (MediaScanner scanner = new MediaScanner(this, volumeName)) &#123;                scanner.scanDirectories(directories);            &#125;        &#125; catch (Exception e) &#123;            Log.e(TAG, &quot;exception in MediaScanner.scan()&quot;, e);        &#125;                ...            &#125; finally &#123;        sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_FINISHED, uri));    &#125;&#125;\n核心内容也很简单，最终调用MediaScanner的scanDirectories()执行文件扫描。其中MediaScanner是一个专门用于媒体文件扫描的类，其scanDirectories()内部核心就是采用ContentProviderClient来对MediaProvider进行数据的更新或删除操作。\nMediaProvider\n我们都知道Android有四大组件，Activity、Service、BroadcastReceiver、ContentProvider。MediaProvider就是Android系统中的一个数据库，类似的还有TelephonyProvider、CalendarProvider、ContactsProvider，这些数据库的源码都在/packages/providers/目录下。\n其中MediaProvider又称多媒体数据库，保存了手机上存储的所有媒体文件的信息。这个数据库存放在/data/data/com.android.providers.media/databases当中，里面有两个数据库：internal.db和external.db，internal.db存放的是系统分区的文件信息，开发者是没法通过接口获得其中的信息的，而external.db存放的则是我们用户能看到的存储区的文件信息，即包含了手机内置存储，还包含了SD卡。\nMediaStore\nMediaStore主要用于提供内部或外部存储中所有可用的媒体文件的各种信息，我们后边都需要借助此类来进行媒体库的操作（添加，删除等）。\n媒体库信息查询\n上边我们知道MediaStore是专门用于存放多媒体信息的，通过ContentResolver即可对数据库进行操作。\nMediaStore中的资源有四类：\n\nMediaStore.Files\nMediaStore.Audio\nMediaStore.Images\nMediaStore.Video\n\n这些内部类中都又包含了Media,Thumbnails和相应的MediaColumns，分别提供了媒体信息，缩略信息和操作字段。\n查询\n媒体库是通过ContentResolver来进行查询的，其核心扫描方法如下：\n1234567public final @Nullable Cursor query(@RequiresPermission.Read         @NonNull Uri uri,         @Nullable String[] projection,         @Nullable String selection,         @Nullable String[] selectionArgs,         @Nullable String sortOrder        @Nullable CancellationSignal cancellationSignal)\n开发过程中可能根据不同情况调用此方法的重载方法，下边我们就解析一下这个方法的相关入参。\nUri uri\n12Uri uri = MediaStore.Video.Media.INTERNAL_CONTENT_URI;Uri uri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI;\nuri表示数据资源路径，总共有两种，分别对应内部存储和外部存储。\n需要注意的是，MediaStore.Files没有EXTERNAL_CONTENT_URI，所以只能用getContentUri()自行获取MediaStore.Images.Files.getContentUri(&quot;external&quot;)\n以MediaStore.Images.Media为例，其URI有三种写法：\n123Uri uri1 = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;Uri uri2 = MediaStore.Images.Media.getContentUri(&quot;external&quot;);Uri uri3 = Uri.parse(&quot;content://media/external/images/media&quot;);\nString[] projection\n123456String[] mediaColumns = &#123;            MediaStore.Video.Media._ID,            MediaStore.Video.Media.DATA,            MediaStore.Video.Media.SIZE,            MediaStore.Video.Media.DATE_MODIFIED,            MediaStore.Video.Media.DURATION&#125;;\n用于指定查询后返回给用户的媒体信息，当然你可以理解为对应媒体数据库中相关字段。\nString selection 和 String[] selectionArgs\n1234567String selection = MediaStore.Video.Media.MIME_TYPE + &quot;=? or &quot;            + MediaStore.Video.Media.MIME_TYPE + &quot;=? or &quot;            + MediaStore.Video.Media.MIME_TYPE + &quot;=? or &quot;            + MediaStore.Video.Media.MIME_TYPE + &quot;=? or &quot;            + MediaStore.Video.Media.MIME_TYPE + &quot;=?&quot;String[] selectionArgs = new String[]&#123;&quot;video/mp4&quot;, &quot;video/avi&quot;, &quot;video/quicktime&quot;, &quot;video/webm&quot;, &quot;video/x-ms-wmv&quot;&#125;\n定制化查询条件，这两个必须结合使用，前者表示条件语句，后者表示对应的条件参数。\nString sortOrder\n查询的排序方式\nCancellationSignal cancellationSignal\n取消正在进行的操作的信号，如果没有则为空。如果操作被取消，那么在执行查询时将抛出OperationCanceledException异常\n举栗\n1.利用MediaStore.Files，查询所有类型的文件：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 获取所有文件 **/public static List&lt;FileEntity&gt; getFilesByType(Context context) &#123;    List&lt;FileEntity&gt; files = new ArrayList&lt;&gt;();    // 扫描files文件库    Cursor c = null;    try &#123;        mContentResolver = context.getContentResolver();        c = mContentResolver.query(MediaStore.Files.getContentUri(&quot;external&quot;), null, null, null, null);        int columnIndexOrThrow_ID = c.getColumnIndexOrThrow(MediaStore.Files.FileColumns._ID);        int columnIndexOrThrow_MIME_TYPE = c.getColumnIndexOrThrow(MediaStore.Files.FileColumns.MIME_TYPE);        int columnIndexOrThrow_DATA = c.getColumnIndexOrThrow(MediaStore.Files.FileColumns.DATA);        int columnIndexOrThrow_SIZE = c.getColumnIndexOrThrow(MediaStore.Files.FileColumns.SIZE);        // 更改时间        int columnIndexOrThrow_DATE_MODIFIED = c.getColumnIndexOrThrow(MediaStore.Files.FileColumns.DATE_MODIFIED);          int tempId = 0;        while (c.moveToNext()) &#123;            String path = c.getString(columnIndexOrThrow_DATA);            String minType = c.getString(columnIndexOrThrow_MIME_TYPE);            LogUtil.d(&quot;FileManager&quot;, &quot;path:&quot; + path);            int position_do = path.lastIndexOf(&quot;.&quot;);            if (position_do == -1) &#123;                continue;            &#125;            int position_x = path.lastIndexOf(File.separator);            if (position_x == -1) &#123;                continue;            &#125;            String displayName = path.substring(position_x + 1, path.length());            long size = c.getLong(columnIndexOrThrow_SIZE);            long modified_date = c.getLong(columnIndexOrThrow_DATE_MODIFIED);            File file = new File(path);            String time = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date(file.lastModified()));            FileEntity info = new FileEntity();            info.setName(displayName);            info.setPath(path);            info.setSize(ShowLongFileSzie(size));            info.setId((tempId++) + &quot;&quot;);            info.setTime(time);            files.add(info);        &#125;    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125; finally &#123;        if (c != null) &#123;            c.close();        &#125;    &#125;    return files;&#125;\n2.指定获取文件字段\n123String[] columns = new String[]&#123;MediaStore.Files.FileColumns._ID, MediaStore.Files.FileColumns.MIME_TYPE, MediaStore.Files.FileColumns                .SIZE, MediaStore.Files.FileColumns.DATE_MODIFIED, MediaStore.Files.FileColumns.DATA&#125;;c = mContentResolver.query(MediaStore.Files.getContentUri(&quot;external&quot;), columns, null, null, null);\n3.根据文件夹的名称查询\n12//查找文件夹ScreenRecord下的文件c = mContentResolver.query(MediaStore.Files.getContentUri(&quot;external&quot;), null, MediaStore.Video.Media.BUCKET_DISPLAY_NAME+&quot;=?&quot;, &quot;ScreenRecord&quot;, null);\n4.查询指定类型的文件\n12String select = &quot;(&quot; + MediaStore.Files.FileColumns.DATA + &quot; LIKE &#x27;%.doc&#x27;&quot; + &quot; or &quot; + MediaStore.Files.FileColumns.DATA + &quot; LIKE &#x27;%.docx&#x27;&quot; + &quot;)&quot;;c = mContentResolver.query(MediaStore.Files.getContentUri(&quot;external&quot;), null, select , null, null);\n5.指定排序类型，如根据id倒序查询\n1c = mContentResolver.query(MediaStore.Files.getContentUri(&quot;external&quot;), null, null, null, MediaStore.Files.FileColumns._ID+&quot;DESC&quot;);\n刷新媒体库\n媒体库刷新方法\n刷新媒体库常用的有如下几种方式：\n\n通过ContentProvider操作媒体数据库。\n发送广播更新MediaStore。\n通过操作MediaScannerConnection类。\n\n通过ContentProvider操作媒体数据库\n123456ContentValues values = new ContentValues(4);values.put(MediaStore.Video.Media.TITLE, &quot;&quot;);values.put(MediaStore.Video.Media.MIME_TYPE, minetype);values.put(MediaStore.Video.Media.DATA, path);values.put(MediaStore.Video.Media.DURATION, duration_int);context.getContentResolver().insert(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, values);\n和上边所讲的媒体库信息查询一样，直接对数据库操作。需要注意的是这种方式不能和其他刷新媒体库方式公用，有可能同时存入两张一模一样的文件。\n发送广播更新MediaStore进行刷新\n123Intent intent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);intent.setData(Uri.fromFile(new File(filePath)));context.sendBroadcast(intent);\n在Android4.4之前，是可以通过ACTION_MEDIA_MOUNTED广播，来通知系统刷新MediaStore的,4.4后系统封闭这种方式，取而代之的是ACTION_MEDIA_SCANNER_SCAN_FILE，建议单个文件扫描插入。\n通过操作MediaScannerConnection类进行刷新\nAndroid4.0系统API中多了一个更新媒体库的方法——MediaScannerConnection，这也是我们比较推荐的。MediaScannerConnection有一个静态方法scanFile()，可直接操作此方法完成媒体库刷新操作。并且可对其刷新完成后回调更新。\n123456789101112public static void insert(Context context, String[] paths, String[] types) &#123;    MediaScannerConnection.scanFile(            context,            paths,            types,            new MediaScannerConnection.OnScanCompletedListener() &#123;                @Override                public void onScanCompleted(String path, Uri uri) &#123;                    LogUtils.i(TAG, &quot;insert onScanCompleted path &quot; + path + &quot; uri &quot; + uri);                &#125;            &#125;);&#125;\n当然你也可以实现MediaScannerConnection.MediaScannerConnectionClient来进行扫描，在构造方法中执行connect()，在onScanCompleted()方法中执行disconnect()关闭链接，在onMediaScannerConnected()中执行scanFile()进行扫描。\n媒体文件添加后刷新\n通常我们在图片或者音视频添加后，在需要更新的地方执行刷新媒体库操作才能在媒体库中看到。\n1234567if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123;    new MediaScanner(context, file);&#125; else &#123;    Intent intent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);    intent.setData(Uri.fromFile(file));    context.sendBroadcast(intent);&#125;\n媒体文件删除后刷新\n有时候我们需要删除本地图片同时又希望刷新一下媒体库，让媒体库中去除此图片，以上边刷新媒体库的方式大多都是insert模式，那我们只能直接操作数据库了。需要注意file.delete()后不可立即将file置为null;\n12345678910111213if (!file.exists()) &#123;    String filePath = file.getAbsolutePath();    if (filePath.endsWith(&quot;.mp4&quot;)) &#123;        context.getContentResolver().delete(MediaStore.Video.Media.EXTERNAL_CONTENT_URI,                MediaStore.Audio.Media.DATA + &quot;= \\&quot;&quot; + filePath + &quot;\\&quot;&quot;,                null);    &#125; else if (filePath.endsWith(&quot;.jpg&quot;) || filePath.endsWith(&quot;.png&quot;) || filePath.endsWith(&quot;.bmp&quot;)) &#123;        context.getContentResolver().delete(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,                MediaStore.Audio.Media.DATA + &quot;= \\&quot;&quot; + filePath + &quot;\\&quot;&quot;,                null);    &#125;    return;&#125;\n一个项目中使用的例子：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class MediaScanner implements MediaScannerConnection.MediaScannerConnectionClient &#123;    private static final String TAG = MediaScanner.class.getSimpleName();    /**     * 刷新媒体库     *     * @param context     * @param file     */    public static void refresh(Context context, File file) &#123;        if (context == null || file == null) &#123;            return;        &#125;        //如果图片不存在，删除媒体库中记录        if (!file.exists()) &#123;            String filePath = file.getAbsolutePath();            if (filePath.endsWith(&quot;.mp4&quot;)) &#123;                context.getContentResolver().delete(MediaStore.Video.Media.EXTERNAL_CONTENT_URI,                        MediaStore.Audio.Media.DATA + &quot;= \\&quot;&quot; + filePath + &quot;\\&quot;&quot;,                        null);            &#125; else if (filePath.endsWith(&quot;.jpg&quot;) || filePath.endsWith(&quot;.png&quot;) || filePath.endsWith(&quot;.bmp&quot;)) &#123;                context.getContentResolver().delete(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,                        MediaStore.Audio.Media.DATA + &quot;= \\&quot;&quot; + filePath + &quot;\\&quot;&quot;,                        null);            &#125;            return;        &#125;        //4.0以上的系统使用MediaScanner更新        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123;            new MediaScanner(context, file);        &#125; else &#123;            Intent intent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);            intent.setData(Uri.fromFile(file));            context.sendBroadcast(intent);        &#125;    &#125;    private File mFile;    private MediaScannerConnection mMsc;    private MediaScanner(Context context, File file) &#123;        this.mFile = file;        this.mMsc = new MediaScannerConnection(context, this);        mMsc.connect();    &#125;    @Override    public void onMediaScannerConnected() &#123;        mMsc.scanFile(mFile.getAbsolutePath(), null);    &#125;    @Override    public void onScanCompleted(String path, Uri uri) &#123;        mMsc.disconnect();    &#125;&#125;\n刷新过滤\n有时候，我们有一些目录下的媒体文件，并不想让MediaStore扫描到，例如在SDCard上缓存的图片、图标等，这些我们都不想出现在系统相册内。怎么办呢？\n很简单，文件夹中新建一个.nomedia的空文件，会屏蔽掉系统默认的媒体库扫描。带有该文件的文件夹只能通过文件遍历的方式进行扫描。\n总结\n以上是有关媒体库开发过程中的知识点，系统媒体库是维护了一个有关媒体文件的数据库，在开发过程中只有在需要相册内的图片或者音视频更新时才需要刷新媒体库，这点个人建议适量使用不可滥用，否则有可能会造成媒体库文件泛滥，或者媒体库中有相应文件的预览，本地却不存在此文件的bug。\n参考\n\nhttps://developer.android.com/guide/topics/data/data-storage.html\nhttps://blog.csdn.net/yann02/article/details/92844364\nhttps://juejin.im/post/5ae0541df265da0b9d77e45a\nhttps://zhuanlan.zhihu.com/p/46533159\nhttps://www.bbsmax.com/A/amd0omej5g/\n\n","plink":"https://blog.ixin.run/posts/1571496871/"},{"title":"Java垃圾回收（三）GC算法","date":"2019-09-22T09:07:50.000Z","date_formatted":{"ll":"2019年9月22日","L":"2019/09/22","MM-DD":"09-22"},"updated":"2021-01-29T12:51:44.665Z","content":"在前面的一篇已经讲过GC的过程了，本篇我们就讲一讲在GC过程中所伴随的一些回收算法，Java中标记垃圾的算法主要有两种，引用计数法和可达性分析算法，其中引用计数法由于某些缺陷而不被java所采用的，现阶段所用的各种回收算法都是在可达性分析算法基础上延伸出来的。\n\n引用计数法\n原理：引用计数法就是给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的，可以当做垃圾收集。\n\n引用计数算法的实现简单，判定效率也高，大部分情况下是一个不错的算法。很多地方应用到它。例如：\n\n微软公司的COM技术：Computer Object Model\n使用Action3的FlashPlayer\nPython\n\n但是，主流的java虚拟机并没有选用引用计数算法来管理内存，其中最主要的原因是：它很难解决对象之间相互循环引用的问题。\n\n上面的3个图中，对于最右边的那张图而言：循环引用的计数器都不为0，但是他们对于根对象都已经不可达了，但是无法释放。\n引用计数算法的问题：\n\n引用和去引用伴随加法和减法，影响性能\n致命的缺陷：对于循环引用的对象无法进行回收\n\n可达性分析法\n为了解决引用计数法这个循环引用不可回收问题，后来那些巨人们又想到一个牛掰的算法——可达性分析法。\n\n这个算法的基本思想就是通过一系列的称为 “GC Roots”的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots没有任何引用链相连的话，则证明此对象是不可用的。目前JVM所采用的各种回收算法都是在此基础上引申出来的。\n什么对象可以作为GC Root？\n\n虚拟机栈中的引用对象\n方法区中的常量引用对象\n方法区中的类静态属性引用对象\n本地方法栈中的引用对象\n活跃线程中的引用对象\n\n不可达的对象一定会回收吗？\n答案是否定的。在可达性分析法中不可达的对象，它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选保留，筛选保留的条件是此对象是否有必要执行finalize()方法。\n当对象没有覆盖finalize()方法，或finalize()方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行筛选保留。被判定为需要执行筛选的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。\nfinalize的作用\n\nfinalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。\nfinalize()与C++ 中的析构函数不是对应的。C++ 中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但Java中的finalize的调用具有不确定性。\n不建议用finalize方法完成“非内存资源”的清理工作，操作不慎可能导致错误，如果真的用，请准确使用：\n\n清理本地对象(通过JNI创建的对象)；\n作为确保某些非内存资源(如Socket、文件等)释放的一个补充：在finalize方法中显式调用其他资源释放方法。\n\n\n\n经验：\n\n避免使用finalize()，操作不慎可能导致错误。\nfinalize 优先级低，何时被调用，不确定。\n何时发生gc不确定。\n如果需要释放资源，可以使用try-catch-finally来替代它。\n\n可触及性\n\n可触及：从根节点出发，可以触及到这个对象，即可达。\n可复活：一旦所有引用被释放，就是不可达状态，不可达并不是一定不可触及，因为在finalize()中可能复活该对象，但是同个对象finalize()方法只会进行一次。\n不可触及：在finalize()后，可能进入不可触及状态。不可触及对象不可能复活，所以只有一条路——回收。\n\n代码说事\n1234567891011121314151617181920212223242526272829303132333435363738public class TestRelive&#123;\tpublic static TestRelive tr;\t\t@Override\tprotected void finalize() throws Throwable&#123;\t\tsuper.finalize();\t\tSystem.out.println(&quot;TestRelive finalize called&quot;);\t\tobj = this;\t&#125;\t\t@Override\tpublic String toString()&#123;\t\treturn &quot;i am TestRelive object&quot;;\t&#125;\t\tpublic static void main(String[] args) throws Exception&#123;\t\ttr = new TestRelive();\t\ttr = null;//不可达，但不一定不可触及\t\tSystem.gc();\t\tThread.sleep(1000);\t\tif(tr == null)&#123;\t\t\tSystem.out.println(&quot;tr is null&quot;);\t\t&#125;\t\telse&#123;\t\t\tSystem.out.println(&quot;tr is useable&quot;);\t\t&#125;\t\tSystem.out.println(&quot;the second gc&quot;);\t\ttr = null;\t\tSystem.gc();\t\tThread.sleep(1000);\t\tif(tr == null)&#123;\t\t\tSystem.out.println(&quot;tr is null&quot;);\t\t&#125;\t\telse&#123;\t\t\tSystem.out.println(&quot;tr is useable&quot;);\t\t&#125;\t&#125;&#125;\n结果：\n\n当第一次tr设置成null的时候，tr处于不可达状态，并且系统调用gc，由于重写了finalize方法，在gc之前需要调用finalize，使得tr又重新处于可达状态，第二次gc的时候，由于finalize只会执行一次，所以tr就真正处于不可触及的状态了，故被清理了。\nJVM常见的GC算法\n在Java中存在着四种垃圾回收算法，他们都是在可达性分析法中延伸出来的。这四种算法分别是：标记清除算法、复制算法、标记压缩（整理）算法、分代回收算法。下边我将分别介绍一下他们。\n标记-清除算法\n将垃圾回收分为两个阶段：标记阶段和清除阶段。\n原理：在标记阶段，首先通过根节点，标记从根节点出发的可达对象，因此，未被标记的对象就是未被引用的垃圾对象，然后，在清除阶段，清除所有未被标记的对象。\n\n上图中，箭头表示引用，从根节点出发，有箭头的地方经过的节点都是可达对象，即浅灰色的部分，而深灰色的对象都是不可达对象。算法对可达对象进行标记，然后将未被标记的对象进行清理。\n该算法是回收算法中最基础的算法，其他的算法都是基于该算法进行改进的。面临的主要缺点有两个：\n\n效率问题：标记和清除两个过程的效率都不高。\n空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。\n\n复制算法\n原理：它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉，然后交换两个内存的角色，往复进行，完成垃圾回收。\n\n优点：该算法每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。\n缺点：\n\n效率问题，面对对象存活率较高的场合，例如老年代，需要不断的频繁复制操作，效率低下。\n空间问题，内存的可用大小缩小为了原来的一半，因为每次只能用其中的一半，造成空间浪费。\n\n整合标记清理进行改进\n复制空间越大，浪费的空间越大，复制算法空间一般不会很大，另外大的空间，如果在极端情况下，会涉及大量存活对象的移动，这种大量的移动对于系统本身，无疑问是灾难性的。所以一般整合标记清理思想，对复制算法会做一些改进。\n\n第一块最大的作为主要存储空间（对象产生的地方，新生代中的eden），中间两块（from和to）作为复制算法的核心，老年代空间作为复制算法的担保空间；\n垃圾回收开始之后，首先大对象直接进入担保空间，大对象进入复制空间不合理的原因：复制空间可能不会很大，因为越大资源浪费越严重，因此大对象尽可能不要在复制空间分配，否则会引起两个问题：\n\n如果大对象放入复制空间，很多小对象可能没地方去，就会排挤到老年代中。\n大对象根本复制空间放不进去，就只能去老年代。\n\n因此大对象一般直接去担保空间，剩余对象（小对象、年轻对象）进入复制空间，年轻对象每被清理一次，对象年龄就会加1，如果经过几次清理都没有被清理掉，是一个长期有效的对象，就会变成老年代，接着执行老年代的一个清理工作。\n我们上一篇文章中讲到JVM将内存分为年轻代和老年代，其中年轻代又包括eden区和两个survivor区，和这里的整合思想分区可以做一下对比，几乎是完全吻合的。\n标记-压缩算法\n为了解决复制算法中在某些场合效率低下和空间浪费的问题，后来又演变出一个标记-压缩算法。\n原理：在标记-清除的基础上做了一些优化，和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记，但是之后，它并不简单的清理未标记对象，而是将所有的存活对象压缩到内存的一端，之后，清除边界外所有的内存空间。\n\n优点：最适用于存活对象比较多的场合，如老年代。\n分代收集算法\n原理：根据对象存活周期的不同将内存划分为几块，一般是把java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。\n依据对象的存活周期进行分类：\n\n第一类：有些对象创建后，很快就会回收，我们把短命对象归为新生代，\n第二类：有些对象创建后会长期存在，有可能和JVM生命周期相同，我们把长命对象归为老年代。\n\n根据不同代的特点，选取合适的收集算法：\n\n新生代仅有少量对象存活，适合复制算法；\n老年代中的对象有两种：\n\n多次GC没有回收掉，年龄校大的对。\n生命周期较长复制算法空间担保 ，直接进入 老年代的大对象。\n\n\n\n所以老年代会有大量大年龄对象和大对象存活，适合标记清理或者标记压缩。\nStop the world\n虚拟机在一些特定指令位置设置一些“安全点”，当程序运行到这些“安全点”的时候就会暂停所有当前运行的线程（Stop The World 所以叫STW），暂停后再找到“GC Roots”进行关系的组建，进而执行标记和清除。\n这些特定的指令（安全点）位置主要在：\n\n循环的末尾\n方法临返回前 | 调用方法的call指令后\n可能抛异常的位置\n\n为什么会有这个过程呢\n我们知道垃圾回收首先是要经过标记的。对象被标记后就会根据不同的区域采用不同的收集方法。看上去很完美的一件事情，其实并不然。\n大家有没有想过一件事情，当虚拟机完成两次标记后，便确认了可以回收的对象。但是，垃圾回收并不会阻塞我们程序的线程，他是与当前程序并发执行的。所以问题就出在这里，当GC线程标记好了一个对象的时候，此时我们程序的线程又将该对象重新加入了“关系网”中，当执行二次标记的时候，该对象也没有重写finalize()方法，因此回收的时候就会回收这个不该回收的对象。\nSTW危害\n\n长时间服务停止，造成系统响应时间增长或者没有响应。\n2、长时间服务停止，没有响应，遇到HA系统，可能引起主备切换，最终导致主备同时启动。在一些业务场景下，可能会导致数据不致，甚至无法正常工作。\n\n主备机切换：\n\n平常由主机工作，备机不工作，一般情况下，不允许主备机同时工作，会出现系统问题。如果此时主机发生gc，系统长时间没有反应，备机以为主机出现问题，此时备机开始工作；等到主机gc结束，则主备机同时开始工作，严重危害生产环境。\n总结\n本篇我们讲解了GC过程中常用的GC算法，按照大的方向从标记来说GC算法分为引用计数法和可达性分析法；引用计数法无法避免因循环造成对象无法回收的现象不被java使用，目前的GC过程所涉及的算法都是根据可达性分析法基础上延伸出来的，主要有四个：标记清除算法、复制算法、标记压缩算法、分代回收算法，最后一个也算是前三个面对不同场景的综合运用。\n下篇我们再深入一层，讲解一下垃圾回收器都有哪些，顺便最后简单讲一下虚拟机GC调优，做一个了断。\n","plink":"https://blog.ixin.run/posts/1569143270/"},{"title":"Java垃圾回收（二）GC过程","date":"2019-09-22T08:07:50.000Z","date_formatted":{"ll":"2019年9月22日","L":"2019/09/22","MM-DD":"09-22"},"updated":"2021-01-29T12:51:44.660Z","content":"什么样的对象才是垃圾？对于Java对象来讲，如果说这个对象没有被其他对象所引用该对象就是无用的，此对象就被称为垃圾，其占用的内存也就要被销毁。本篇我们就讲一讲GC（Garbage Collection）的具体过程。\n\nGC\nGC：Garbage Collection垃圾收集。这里所谓的垃圾指的是在系统运行过程当中所产生的一些无用的对象，这些对象占据着一定的内存空间，如果长期不被释放，可能导致OOM。\n在C/C++里是由程序猿自己去申请、管理和释放内存空间，因此没有GC的概念。而在Java中，后台专门有一个专门用于垃圾回收的线程来进行监控、扫描，自动将一些无用的内存进行释放，这就是垃圾收集的一个基本思想，目的在于防止由程序猿引入的人为的内存泄露。\nGC分代\n正如易经中的九重天一样，JVM对内存也进行了分代，分别分为：年轻代（Young）、年老代（Tenured）、持久代（Perm）。对不同生命周期的对象使用不同的垃圾回收算法。\n\n年轻代(Young)\n年轻代分为三个区，一个eden区，两个Survivor区。程序中生成的大部分新的对象都在Eden区中，当Eden区满时，还存活的对象将被复制到其中一个Survivor区，当此Survivor区的对象占用空间满了时，此区存活的对象又被复制到另外一个Survivor区，当这个Survivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制到年老代。\n需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来对象和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。\n年老代（Tenured）\n年老代存放的是上面年轻代复制过来的对象，也就是在年轻代中还存活的对象，并且区满了复制过来的。一般来说，年老代中的对象生命周期都比较长。\n持久代（Perm）\n用于存放静态的类和方法，持久代对垃圾回收没有显著的影响。\n三种GC类型\nJava GC类型通常分为三种：Minor GC、Major GC、Full GC。\nMinor GC\n指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。\n一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Minor GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。\n\nMajor GC\n指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在ParallelScavenge收集器的收集策略里\n就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。\nFull GC\n对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比Minor GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。有如下原因可能导致Full GC：\n\n年老代（Tenured）被写满\n持久代（Perm）被写满\nSystem.gc()被显示调用（系统建议执行Full GC，但是不必然执行）\n通过Minor GC后进入老年代的平均大小大于老年代的可用内存\n上一次GC之后Heap的各域分配策略动态变化\n\nMajor GC vs Full GC\n很多同学对这两种GC类型分不清，通常也会认为Major GC和Full GC是等同的。以下是来自一个知乎的大神的解释：\n针对HotSpot VM的实现，它里面的GC其实准确分类只有两大种：\n\nPartial GC：并不收集整个GC堆的模式\n\nYoung GC：只收集young gen的GC\nOld GC：只收集old gen的GC。只有CMS的concurrent collection是这个模式\nMixed GC：收集整个young gen以及部分old gen的GC。只有G1有这个模式。\n\n\nFull GC：收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式。\n\nMajor GC通常是跟full GC是等价的，收集整个GC堆。但因为HotSpot VM发展了这么多年，外界对各种名词的解读已经完全混乱了，当有人说“major GC”的时候一定要问清楚他想要指的是上面的full GC还是old GC。\n最简单的分代式GC策略，按HotSpot VM的serial GC的实现来看，触发条件是：\n\nyoung GC：当young gen中的eden区分配满的时候触发。注意young GC中有部分存活对象会晋升到old gen，所以young GC后old gen的占用量通常会有所升高。\nfull GC：当准备要触发一次young GC时，如果发现统计数据说之前young GC的平均晋升大小比目前old gen剩余的空间大，则不会触发young GC而是转为触发full GC（因为HotSpot VM的GC里，除了CMS的concurrent collection之外，其它能收集old gen的GC都会同时收集整个GC堆，包括young gen，所以不需要事先触发一次单独的young GC）；或者，如果有perm gen的话，要在perm gen分配空间但已经没有足够空间时，也要触发一次full GC；或者System.gc()、heap dump带GC，默认也是触发full GC。\n\nPS：这里涉及到的“CMS的concurrent collection”属于JVM GC性能调优部分的，后边文章会讲到。\n为什么要分代回收\n在一开始的时候，JVM的GC就是采用标记-清除-压缩方式进行的，这么做并不是很高效，因为当对象分配的越来越多时，对象列表也越来也大，扫描和移动越来越耗时，造成了内存回收越来越慢。然而，经过根据对java应用的分析，发现大部分对象的存活时间都非常短，只有少部分数据存活周期是比较长的，请看下面对java对象内存存活时间的统计：\n\n从图表中可以看出，大部分对象存活时间是非常短的，随着时间的推移，被分配的对象越来越少。\nGC过程\n理解Java的垃圾回收机制，就要从：“什么时候”，“对什么东西”，“做了什么”三个方面来具体分析。\n第一：“什么时候”即就是GC触发的条件。GC触发的条件有两种。\n\n程序调用System.gc时可以触发；\n系统自身来决定GC触发的时机。系统判断GC触发的依据：根据Eden区和From Space区的内存大小来决定。当内存大小不足时，则会启动GC线程并停止应用线程。\n\n第二：“对什么东西”笼统的认为是Java对象。但是准确来讲，GC操作的对象分为：通过可达性分析法无法搜索到的对象和可以搜索到的对象。对于搜索不到的方法进行标记。\n第三：“做了什么”最浅显的理解为释放对象。但是从GC的底层机制可以看出，对于可以搜索到的对象进行复制操作，对于搜索不到的对象，调用finalize()方法进行释放。\n以下是具体的GC过程：\n1.在初始阶段，新创建的对象被分配到Eden区，survivor的两块空间都为空。\n\n2.当Eden区满了的时候，minor garbage被触发\n\n3.经过扫描与标记，存活的对象被复制到S0，不存活的对象被回收\n\n4.在下一次的Minor GC中，Eden区的情况和上面一致，没有引用的对象被回收，存活的对象被复制到survivor区。然而在survivor区，S0的所有的数据都被复制到S1，需要注意的是，在上次minor GC过程中移动到S0中的两个对象在复制到S1后其年龄要加1。此时Eden区S0区被清空，所有存活的数据都复制到了S1区，并且S1区存在着年龄不一样的对象，过程如下图所示：\n\n5.再下一次Minor GC则重复这个过程，这一次survivor的两个区对换，存活的对象被复制到S0，存活的对象年龄加1，Eden区和另一个survivor区被清空。\n\n6.再经过几次Minor GC之后，当存活对象的年龄达到一个阈值之后（可通过参数配置，默认是8），就会被从年轻代Promotion到老年代。\n\n7.随着MinorGC一次又一次的进行，不断会有新的对象被promote到老年代。\n\n8.上面基本上覆盖了整个年轻代所有的回收过程。最终，MajorGC将会在老年代发生，老年代的空间将会被清除和压缩。\n\n从上面的过程可以看出，Eden区是连续的空间，且Survivor总有一个为空。经过一次GC和复制，一个Survivor中保存着当前还活着的对象，而Eden区和另一个Survivor区的内容都不再需要了，可以直接清空，到下一次GC时，两个Survivor的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将Eden区和一个Survivor中仍然存活的对象拷贝到另一个Survivor中），这不代表着停止复制清理法很高效，其实，它也只在这种情况下（基于大部分对象存活周期很短的事实）高效，如果在老年代采用停止复制，则是非常不合适的。\n老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-压缩算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。在发生Minor GC时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次Full GC，否则，就查看是否设置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行MinorGC，此时可以容忍内存分配失败；如果不允许，则仍然进行Full GC（这代表着如果设置-XX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。\n关于方法区即永久代的回收，永久代的回收有两种：\n\n常量池中的常量\n无用的类信息\n\n常量的回收很简单，没有引用了就可以被回收。对于无用的类进行回收，必须保证3点：\n1231. 类的所有实例都已经被回收2. 加载类的ClassLoader已经被回收3. 类对象的Class对象没有被引用（即没有通过反射引用该类的地方）\n永久代的回收并不是必须的，可以通过参数来设置是否对类进行回收。\n总结\n以上就是GC回收的整个过程，到这里应该有所明了了吧，Java虽然有很好的回收机制，降低了开发者时刻关心内存的顾虑，但是如果不对此了解，也会有一定隐患，就好比温水里煮青蛙，时间长了自己都不知道该怎么“跳”了。\n下一篇我将对GC回收过程中所使用的算法做一个归总，好多同学在总结这块东西的时候总是看到哪里想到哪里，总出来的东西就感觉东拼西凑一样，说不定他自己就不懂，总也是白总，循序渐进才是越深入越知会。\n参考\n\nhttps://www.zhihu.com/question/41922036/answer/93079526\nhttps://yq.aliyun.com/articles/5910\n\n","plink":"https://blog.ixin.run/posts/1569139670/"},{"title":"Java垃圾回收（一）四种对象引用类型","date":"2019-09-22T07:07:50.000Z","date_formatted":{"ll":"2019年9月22日","L":"2019/09/22","MM-DD":"09-22"},"updated":"2021-01-29T12:51:44.659Z","content":"垃圾收集GC（Garbage Collection）是Java语言的核心技术之一， 在Java中，程序员不需要去关心内存动态分配和垃圾回收的问题，这一切都交给了JVM来处理。本篇我们先弄清楚在开发过程中如何使用对象引用来实现合适时机的垃圾回收，下篇再由浅入深谈谈jvm底层是如何垃圾回收的。\n在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用(Strong Reference)，软引用(Soft Reference)，弱引用(Weak Reference)，虚引用(Phantom Reference)四种，这四种引用强度依赖逐渐减弱。理解这四种对象引用方式也是对java垃圾回收机制的基本认识。\n\n强引用(StrongReference)\n强引用就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类引用，只要强引用存在，垃圾收集器永远不会回收掉被引用的对象。\n软引用(SoftReference)\n软引用用来描述一些还有用，但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出之前，将会把这些对象列进回收范围之中，并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出错误。在JDK1.2之后，提供了SoftReference来实现软引用。\n123456789101112131415161718public static void main(String[] args)&#123;  //创建软引用数组  SoftReference&lt;Person&gt; [] p = new SoftReference[100];   //赋值    for(int i = 0; i&lt; p.length ;i++)&#123;   p[i] = new SoftReference&lt;Person&gt;(new Person(&quot;name&quot;+i ,i));  &#125;  //测试  System.out.println(p[1].get());  System.out.println(p[4].get());  //通知系统进行回收  System.gc();  System.runFinalization();    System.out.println(&quot;---------------&quot;);  System.out.println(p[1].get());  System.out.println(p[4].get()); &#125;\n软引用的对象当系统内存充足时和强引用没有太多区别，但内存不足时会回收软引用的对象。\n弱引用(WeakReference)\n弱引用也是用来描述非必须对象的，但是它的强度比软引用更弱一点，被弱引用关联的对象只能生存到下一次垃圾回收之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉被弱引用关联的对象。在JDK1.2之后，提供了WeakReference来实现弱引用。\n123456789101112public static void main(String[] args) &#123;   String str = new String(&quot;JAVA讲义&quot;);   //创建一个弱引用对象 指向 str对象   WeakReference&lt;String&gt; wr = new WeakReference&lt;String&gt; (str);   //切断强引用   str =null;   //输出   System.out.println(wr.get());//JAVA讲义   //强制垃圾回收   System.gc();   System.out.println(wr.get()); //null &#125;\n弱引用具有很强的不确定性。因为垃圾回收每次都会回收弱引用的对象。\n软引用只有在内存不足时进行回收，而弱引用只要发生gc就进行回收，这是二者区别\n虚引用(PhantomReference)\n虚引用它是最弱的一种引用关系。一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象的实例。为一个对象设置虚引用关联的唯一目的是希望能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference来实现虚引用。\n软引用和弱引用可以单独使用，虚引用不能单独使用，虚引用的作用是就跟踪对象被垃圾回收的状态，程序可以通过检测与虚引用关联的虚引用队列是否已经包含了指定的虚引用，从而了解虚引用的对象是否即将被回收。如果一个对象只有一个虚引用存在，那么他就类似没有引用存在。\n123456789101112131415161718public static void main(String[] args)&#123;  //创建一个对象  String str = new String(&quot;JAVA讲义&quot;);  //创建一个引用队列  ReferenceQueue&lt;String&gt; rq = new ReferenceQueue&lt;String&gt;();  //创建一个虚引用，指定引用对象.不能单独使用必须关联引用队列  PhantomReference pr = new PhantomReference(str,rq);  //切断强引用  str =null;  //试图取得虚引用对象  System.out.println(pr.get()); //null    //垃圾回收  System.gc();  System.runFinalization();  //取出引队列中的最先进入队列的引用与pr进行比较  System.out.println(rq.poll()==pr); //true&#125;\n引用队列(Reference Queue)\n引用队列可以很容易地实现跟踪不需要的引用。当你在构造WeakReference时传入一个ReferenceQueue对象（PhantomReference必须和引用队列结合使用），当该引用指向的对象被标记为垃圾的时候，这个引用对象会自动地加入到引用队列里面。接下来，你就可以在固定的周期处理传入的引用队列，比如做一些清理工作来处理这些没有用的引用对象。\n12345678User user = new User();WeakReference&lt;User&gt; weakReference = new WeakReference&lt;User&gt;(user);weakReference.get();ReferenceQueue&lt;User&gt; referenceQueue = new ReferenceQueue&lt;User&gt;();WeakReference&lt;User&gt; weakReference2 = new WeakReference&lt;User&gt;(user, referenceQueue);//当引用对象被标识为可回收时返回trueweakReference.isEnqueued();\n总结\n以上讲解了java四种对象引用方式，这也是面对java垃圾回收机制在开发过程中很重要的一环。有两点总结：\n\n如果希望尽可能减小程序在起声明周期中所占用的内存大小，可以灵活使用这些引用。\n如果使用了这些引用就不能保留这些对象的强引用（强引用应该置null），否则就浪费了这些类提供的任何好处。\n\n","plink":"https://blog.ixin.run/posts/1569136070/"},{"title":"JVM（一）内存分配","date":"2019-09-20T11:42:46.000Z","date_formatted":{"ll":"2019年9月20日","L":"2019/09/20","MM-DD":"09-20"},"updated":"2021-01-29T12:51:44.657Z","content":"Java内存分配无论是处于正常开发计算过程还是绞尽脑汁思考内存回收都需要深入理解的，本文所属范畴是JVM，不应该先来个类加载和运行机制吗，为什么先研究内存分配呢？老实说因为这块很接近我们的开发，越接近后边的深入越容易理解。在了解JVM内存分配之前我们先简单熟悉一下Java HotSpot VM，因为我们经常挂在嘴边的JVM目前就是这家伙。\n\nJava HotSpot VM\n提起HotSpot VM，相信所有Java程序员都知道，它是Sun JDK和OpenJDK中所带的虚拟机，也是目前使用范围最广的Java虚拟机。 但不一定所有人都知道的是，这个目前看起来“血统纯正”的虚拟机在最初并非由Sun公司开发，而是由一家名为“Longview Technologies”的小公司设计的；甚至这个虚拟机最初并非是为Java语言而开发的，它来源于Strongtalk VM，而这款虚拟机中相当多的技术又是来源于一款支持Self语言实现“达到C语言50%以上的执行效率”的目标而设计的虚拟机，Sun公司注意到了这款虚拟机在JIT编译上有许多优秀的理念和实际效果，在1997年收购了Longview Technologies公司，从而获得了HotSpot VM。\nHotSpot VM既继承了Sun之前两款商用虚拟机的优点（如前面提到的准确式内存管理），也有许多自己新的技术优势，如它名称中的HotSpot指的就是它的热点代码探测技术（其实两个VM基本上是同时期的独立产品，HotSpot还稍早一些，HotSpot一开始就是准确式GC，而Exact VM之中也有与HotSpot几乎一样的热点探测。 为了Exact VM和HotSpot VM哪个成为Sun主要支持的VM产品，在Sun公司内部还有过争论，HotSpot打败Exact并不能算技术上的胜利）， HotSpot VM的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知JIT编译器以方法为单位进行编译。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发标准编译和OSR（栈上替换）编译动作。通过编译器与解释器恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无须等待本地代码输出才能执行程序，即时编译的时间压力也相对减小，这样有助于引入更多的代码优化技术，输出质量更高的本地代码。\n在2006年的JavaOne大会上，Sun公司宣布最终会把Java开源，并在随后的一年，陆续将JDK的各个部分（其中当然也包括了HotSpot VM）在GPL协议下公开了源码，并在此基础上建立了OpenJDK。这样，HotSpot VM便成为了SunJDK和OpenJDK两个实现极度接近的JDK项目的共同虚拟机。\n在2008年和2009年，Oracle公司分别收购了BEA公司和Sun公司，这样Oracle就同时拥有了两款优秀的Java虚拟机：JRockit VM和HotSpot VM。 Oracle公司宣布在不久的将来（大约应在发布JDK8的时候）会完成这两款虚拟机的整合工作，使之优势互补。整合的方式大致上是在HotSpot的基础上，移植JRockit的优秀特性，譬如使用JRockit的垃圾回收器与MissionControl服务，使用HotSpot的JIT编译器与混合的运行时系统。\n更多JVM可参看这篇文章：https://blog.csdn.net/qq_36582604/article/details/81564905\nJVM内存分配\nJava虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域存储不同类型的数据，这些区域的内存分配和销毁的时间也不同，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（第2版）》的规定，Java虚拟机管理的内存包括五个运行时数据区域，如下图所示：\n\n方法区（Method Area）\n方法区（Method Area）是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息（包括类的名称、方法信息、成员变量信息）、常量、静态变量、以及编译器编译后的代码等数据。当方法区无法满足内存分配需求时，将抛出OutOfMemeryError异常。\n堆（Heap）\nJava堆是Java虚拟机所管理的内存中最大的一块，在虚拟机启动时创建，此内存区域的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区(TLAB)。Java堆可以处于物理上不连续的内存空间，只要逻辑上连续即可，在实现上，既可以实现固定大小的，也可以是扩展的。如果堆中没有足够的内存分配给实例，并且堆也无法再拓展时，将会抛出OutOfMemeryError异常。\n堆是运行时动态分配内存，对象在没有引用变量指向它的时候，才变成垃圾，但是仍然占着内存，在程序空闲的时候（没有工作线程运行，GC线程优先级最低）或者堆内存不足的时候（GC线程被触发），被垃圾回收器释放掉，由于要在运行时动态分配内存，存取速度较慢。\n虚拟机栈（VM Stack）\n虚拟机栈就是Java中的方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧，这个栈帧用于存储局部变量表、操作数栈、指向当前方法所属的类的运行时常量池的引用、方法返回地址等信息，每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。\n局部变量表用来存储方法中的局部变量，包括方法中声明的变量以及函数形参。对于基本数据类型的变量，则直接存储它的值，对于引用类型的变量，则存的是指向对象的引用。局部变量表的大小在编译器就可以确定其大小，并且在程序执行期间局部变量表的大小是不会改变的。\n程序中的所有计算过程都是在借助于操作数栈来完成的。\n指向运行时常量池的引用，因为在方法执行的过程中有可能需要用到类中的常量，所以必须要有一个引用指向当前方法所属的类的运行时常量池。\n方法返回地址，当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。\n在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。\n本地方法栈（Native Method Stack）\n本地方法栈与虚拟机栈的作用相似，它们之间的区别在于java虚拟机栈为虚拟机执行java方法（字节码）服务，而本地方法栈为虚拟机栈使用到的Native方法服务（在SUN HotSpot虚拟机中将虚拟机栈和本地方法栈合二为一）。\n程序计数器（Program Counter Register）\n程序计数器是一块较小的内存空间，它可以看做当前线程所执行的字节码的行号指示器，在jvm中，虚拟机通过改变程序计数器的值来选取下一条需要执行的字节码的指令，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖它。\n在java多线程中是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程的指令，每一条线程都需要一个独立的程序计数器，各个计数器之间不相互影响，独立存储，因为这类内存区域称为“线程私有”的内存。此内存区域是唯一一个在jvm中没有规定任何OutOfMemoryError情况的区域。\n常量池\n常量池是jvm的一块特殊的内存空间。在java用于保存在编译器一确定的已变异的class文件中的一份数据，它包括了关于类、方法、接口等中的常量，也包括字符串常量。\n\n常量池的版本变化：\n\nJava6和6之前，常量池是存放在方法区中的。\nJava7，将常量池是存放到了堆中，常量池就相当于是在永久代中，所以永久代存放在堆中。\nJava8之后，取消了整个永久代区域，取而代之的是元空间。没有再对常量池进行调整。\n\nJava中的常量池分为三种类型：\n\n类文件中常量池（The Constant Pool）\n运行时常量池（The Run-Time Constant Pool）\nString常量池\n\n类文件中常量池\n所处区域：堆\n诞生时间：编译时\n内容概要：符号引用和字面量\nclass常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量的符号引用。\n下面对字面量和符号引用进行说明\n字面量\n字面量类似与我们平常说的常量，主要包括：\n\n文本字符串：就是我们在代码中能够看到的字符串，例如String a = “aa”。其中”aa”就是字面量。\n被final修饰的变量。\n\n符号引用\n主要包括以下常量：\n\n类和接口和全限定名：例如对于String这个类，它的全限定名就是java/lang/String。\n字段的名称和描述符：所谓字段就是类或者接口中声明的变量，包括类级别变量（static)和实例级的变量。\n方法的名称和描述符。所谓描述符就相当于方法的参数类型+返回值类型。\n\n运行时常量池\n所处区域：内存的元空间\n诞生时间：JVM运行时\n内容概要：class文件元信息描述，编译后的代码数据，引用类型数据，类文件常量池。\n所谓的运行时常量池其实就是将编译后的类信息放入运行时的一个区域中，用来动态获取类信息。\n运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。\n字符串常量池\n所处区域：堆\n诞生时间：类加载完成\n字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的）。\n四段解析\n解析1：\n12345678910111213141516171819202122232425String str1 &#x3D; new String(&quot;1&quot;);解析：首先此行代码创建了两个对象，在执行前会在常量池中创建一个&quot;1&quot;的对象，然后执行该行代码时new一个&quot;1&quot;的对象存放在堆区中；然后str1指向堆区中的对象；str1.intern();解析：该行代码首先查看&quot;1&quot;字符串有没有存在在常量池中，此时存在则直接返回该常量，这里返回后没有引用接受他，【假如不存在的话在 jdk1.6中会在常量池中建立该常量，在jdk1.7以后会把堆中该对象的引用放在常量池中】String str2 &#x3D; &quot;1&quot;;解析：此时&quot;1&quot;已经存在在常量池中，str2指向常量池中的对象；System.out.println(str1 &#x3D;&#x3D; str2);  &#x2F;&#x2F;结果是 false or true？解析：str1指向堆区的对象，str2指向常量池中的对象，两个引用指向的地址不同，输入false；String str3 &#x3D; new String(&quot;2&quot;) + new String(&quot;2&quot;);解析：此行代码执行的底层执行过程是 首先使用StringBuffer的append方法将&quot;2&quot;和&quot;2&quot;拼接在一块，然后调用toString方法new出“22”；所以此时的“22”字符串是创建在堆区的；t3.intern();解析：此行代码执行时字符串常量池中没有&quot;22&quot;,所以此时在jdk1.6中会在字符串常量池中创建&quot;22&quot;,而在jdk1.7以后会把堆中该对象的引用放在常量池中；String str4 &#x3D; &quot;22&quot;;解析：此时的str4在jdk1.6中会指向方法区，而在jdk1,7中会指向堆区；　　System.out.println(str3 &#x3D;&#x3D; str4); &#x2F;&#x2F;结果是 false or true？解析：很明显了 jdk1.6中为false 在jdk1.7中为true；　　\n解析2：\n123456789101112131415161718192021222324String str1 &#x3D; &quot;aaa&quot;;解析：str1指向方法区；String str2 &#x3D; &quot;bbb&quot;;解析： str2 指向方法区String str3 &#x3D; &quot;aaabbb&quot;;解析：str3指向方法区String str4 &#x3D; str1 + str2;解析：此行代码上边已经说过原理。str4指向堆区String str5 &#x3D; &quot;aaa&quot; + &quot;bbb&quot;;解析：该行代码重点说明一下，jvm对其有优化处理，也就是在编译阶段就会将这两个字符串常量进行拼接，也就是&quot;aaabbb&quot;;所以他是在方法区中的；’System.out.println(str3 &#x3D;&#x3D; str4); &#x2F;&#x2F; false or true解析：很明显 为false， 一个指向堆, 一个指向方法区System.out.println(str3 &#x3D;&#x3D; str4.intern()); &#x2F;&#x2F; true or false解析：jdk1.6中str4.intern会把“aaabbb”放在方法区，1.7后在堆区，所以在1.6中会是true 但是在1.7中是falseSystem.out.println(str3 &#x3D;&#x3D; str5);&#x2F;&#x2F; true or false解析：都指向字符串常量区，字符串长常量区在方法区，相同的字符串只存在一份，其实这个地方在扩展一下，因为方法区的字符串常量是共享的，在两个线程同时共享这个字符串时，如果一个线程改变他会是怎么样的呢，其实这种场景下是线程安全的，jvm会将改变后的字符串常量在字符串常量池中重新创建一个处理，可以保证线程安全\n解析3：\n1234567891011121314151617181920212223String t1 &#x3D; new String(&quot;2&quot;);解析：创建了两个对象，t1指向堆区String t2 &#x3D; &quot;2&quot;;解析：t2指向字符串常量池t1.intern();解析:字符串常量池已经存在该字符串，直接返回；System.out.println(t1 &#x3D;&#x3D; t2); &#x2F;&#x2F;false or true解析：很明显 falseString t3 &#x3D; new String(&quot;2&quot;) + new String(&quot;2&quot;);解析：过程同问题1 t3指向堆区String t4 &#x3D; &quot;22&quot;;解析：t4 在1.6 和 1.7中指向不同t3.intern();解析： 字符串常量池中已经存在该字符串 直接返回System.out.println(t3 &#x3D;&#x3D; t4); &#x2F;&#x2F;false or true解析： 很明显为 false 指向不同的内存区\n解析4：\n12345678910111213141516171819202122232425Integer a &#x3D; 1;Integer b &#x3D; 2;Integer c &#x3D; 3;Integer d &#x3D; 3;Integer e &#x3D; 321;Integer f &#x3D; 321;Long g &#x3D; 3L;System.out.println(c &#x3D;&#x3D; d);解析：由于常量池的作用，c与d指向的是同一个对象(注意此时的&#x3D;&#x3D;比较的是对象，也就是地址，而不是数值)。因此为trueSystem.out.Println(e &#x3D;&#x3D; f);解析：由于321超过了127，因此常量池失去了作用，所以e和f数值虽然相同，但不是同一个对象，以此为false。System.out.println(c &#x3D;&#x3D; (a + b));解析：此时&#x3D;&#x3D;两边有算术运算，会进行拆箱，因此此时比较的是数值，而并非对象。因此为true。System.out.println(c.equals(a+b));解析：c与a+b的数值相等，为true。System.out.println(g &#x3D;&#x3D; (a + b));解析：由于&#x3D;&#x3D;两边有算术运算，所以比较的是数值，因此为true。System.out.println(g.equals(a + b));解析：Long类型的equal在比较是时候，会先判断a+b是否为Long类型，显然a+b不是，因此false\n这个地方存在一些知识点：\n\n内存中有一个java基本类型封装类的常量池。这些类包括Byte, Short, Integer, Long, Character, Boolean。需要注意的是，Float和Double这两个类并没有对应的常量池。\n上面5种整型的包装类的对象是存在范围限定的；范围在-128~127存在在常量池，范围以外则在堆区进行分配。\n在周志明的那本虚拟机中有这样一句话：包装类的==运行符在不遇到算术运算的情况下不会自动拆箱，以及他们的equals()方法不处理数据类型的关系，通俗的讲也就是==两边如果有算术运算，那么自动拆箱和进行数据类型转换处理，比较的是数值等不等。\nLong的equals方法会先判断是否是Long类型。\n无论是Integer还是Long，他们的equals方法比较的是数值。\n\n总结\n理解JVM内存分配对开发者来说是有很重要的意义，有同学说了无非就是一些概念，其实我们了解这块内容其真正目的是为了知道数据真正是存在哪里的，这对后边的程序计算以及内存管理回收有很大帮助，否则看着很对实际是错的，也就是说我们必须根据计算机规则来走。\n","plink":"https://blog.ixin.run/posts/1568979766/"},{"title":"位运算的那些事（三）位掩码","date":"2019-08-28T14:34:40.000Z","date_formatted":{"ll":"2019年8月28日","L":"2019/08/28","MM-DD":"08-28"},"updated":"2021-01-29T12:51:44.674Z","content":"前两篇我重点针对位运算基础以及运算过程详细的进行了讲解说明，相信看过的小伙伴也都很明了了。那么基础有了，也知道运算过程了，那我们常见的战场在哪里呢？这就像排兵布阵一样，只阅读兵法，而没有实践和模拟，只能算纸上谈兵了。本篇就拉开帷幕直面开发中这个最常见的战场——位掩码（BitMask）。\n\n什么是掩码\n说起掩码大家都听过子网掩码吧，子网掩码的主要作用是判断当前IP是属于什么样的网络，是A类还是B类还是C类；当前IP处于什么样的网段，网段内可以拥有多少个机子。比如我们公司电脑的子网掩码是255.255.255.0，很明显就是一个局域网。如果你对子网掩码还是不清晰，可以看一下《如何理解子网掩码》。\n掩码就是一串二进制代码对目标字段进行位与运算，屏蔽当前的输入位，最终得到一个合理的需求。说白了，掩码就是一把辅助钥匙，你给我一个盒子我帮助你打开看看里面是什么。\n说到这不知道大家有没有对掩码有一个概念性的认识呢？不清楚没关系，这只是位运算中一个插曲，下边的讲解中也会相应用到，到时候你就明白了，本篇的目的是为了讲位运算在项目开发中的一些典型用法。\n抛砖引玉\n有一个很经典的算法题，说是有1000个一模一样的瓶子，其中有999瓶是普通的水，有一瓶是毒药。任何喝下毒药的生物都会在一星期之后死亡。现在，你只有10只小白鼠和一星期的时间，如何检验出哪个瓶子里有毒药？如果按照常规的解法是不是很繁琐，我们不妨思考一下用二进制来处理。\n具体实现跟3个老鼠确定8个瓶子原理一样：\n12345678000&#x3D;0001&#x3D;1010&#x3D;2011&#x3D;3100&#x3D;4101&#x3D;5110&#x3D;6111&#x3D;7\n一位表示一个老鼠，0-7表示8个瓶子。也就是分别将1、3、5、7号瓶子的药混起来给老鼠1吃，2、3、6、7号瓶子的药混起来给老鼠2吃，4、5、6、7号瓶子的药混起来给老鼠3吃，哪个老鼠死了，相应的位标为1。如老鼠1死了、老鼠2没死、老鼠3死了，那么就是101=5号瓶子有毒。同样道理10个老鼠可以确定1000个瓶子。\n经典场景\n在开发过程中，有些时候我们要定义很多种状态标，举一个经典的权限操作的例子（来源于网上）,假设这里有四种权限状态如下：\n12345678910111213public class Permission &#123;\t// 是否允许查询\tprivate boolean allowSelect;\t\t// 是否允许新增\tprivate boolean allowInsert;\t\t// 是否允许删除\tprivate boolean allowDelete;\t\t// 是否允许更新\tprivate boolean allowUpdate;&#125;\n我们的目的是判断当前用户是否拥有某种权限，如果单个判断好说，也就四种。但如果混合这来呢，就是2的4次方，共有16种，这就繁琐了。那如果有更多权限呢？组合起来复杂度也就成倍往上升了。\n应用分析\n还是拿上边的权限例子来说事，我们改造一下，运用二进制移位来表示：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class NewPermission &#123;\t// 是否允许查询，二进制第1位，0表示否，1表示是\tpublic static final int ALLOW_SELECT = 1 &lt;&lt; 0; // 0001\t// 是否允许新增，二进制第2位，0表示否，1表示是\tpublic static final int ALLOW_INSERT = 1 &lt;&lt; 1; // 0010\t// 是否允许修改，二进制第3位，0表示否，1表示是\tpublic static final int ALLOW_UPDATE = 1 &lt;&lt; 2; // 0100\t// 是否允许删除，二进制第4位，0表示否，1表示是\tpublic static final int ALLOW_DELETE = 1 &lt;&lt; 3; // 1000\t// 存储目前的权限状态\tprivate int flag;\t/**\t *  重新设置权限\t */\tpublic void setPermission(int permission) &#123;\t\tflag = permission;\t&#125;\t/**\t *  添加一项或多项权限\t */\tpublic void enable(int permission) &#123;\t\tflag |= permission;\t&#125;\t/**\t *  删除一项或多项权限\t */\tpublic void disable(int permission) &#123;\t\tflag &amp;= ~permission;\t&#125;\t/**\t *  是否拥某些权限\t */\tpublic boolean isAllow(int permission) &#123;\t\treturn (flag &amp; permission) == permission;\t&#125;\t/**\t *  是否禁用了某些权限\t */\tpublic boolean isNotAllow(int permission) &#123;\t\treturn (flag &amp; permission) == 0;\t&#125;\t/**\t *  是否仅仅拥有某些权限\t */\tpublic boolean isOnlyAllow(int permission) &#123;\t\treturn flag == permission;\t&#125;&#125;\n上边代码就是抛开常规的状态表示法（移位表示），例如：\nALLOW_SELECT = 1 &lt;&lt; 0，转成二进制就是0001，二进制第一位表示Select权限。\nALLOW_INSERT = 1 &lt;&lt; 1，转成二进制就是0010，二进制第二位表示Insert权限。\nALLOW_UPDATE = 1 &lt;&lt; 2，转成二进制就是0100，二进制第三位表示Update权限。\nALLOW_DELETE = 1 &lt;&lt; 3，转成二进制就是1000，二进制第四位表示Delete权限。\n你会发现上边四种权限表示都有一个特点，那就是转化成二进制中的“1”只占用其中的某一位，其余的全部都是0，这就为接下来的位运算提供了极大的便利。我们用一个全局的整形变量flag来存储各种权限的启用和停用状态，那么得到的二进制结果中每一位的0或1都代表当前所在位的权限关闭和开启，四种权限有16种组合方式，下边就列举一部分，大家可以看一下：\n\n\nflag\n查询\n新增\n修改\n删除\n说明\n\n\n\n\n1（0001）\n0\n0\n0\n1\n只允许查询（即等于ALLOW_SELECT）\n\n\n2（0010）\n0\n0\n1\n0\n只允许新增（即等于ALLOW_INSERT）\n\n\n4（0100）\n0\n1\n0\n0\n只允许修改（即等于ALLOW_UPDATE）\n\n\n8（1000）\n1\n0\n0\n0\n只允许删除（即等于ALLOW_DELETE）\n\n\n3（0011）\n0\n0\n1\n1\n只允许查询和新增\n\n\n12（1100）\n1\n1\n0\n0\n只允许修改和删除\n\n\n0（0000）\n0\n0\n0\n0\n都不允许\n\n\n15（1111）\n1\n1\n1\n1\n全都允许\n\n\n四种权限有16种组合方式，这16种组合方式就都是通过位运算得来的，其中参与位运算的每个因子你都可以叫做掩码（MASK），例如我要查询是否有修改和删除的权限我可以这样：\n123if (permission.isAllow(NewPermission.ALLOW_UPDATE | ALLOW_DELETE))&#123;    ...&#125;\n当然我也可以定义一个isAllowUpdateDelete()这样的方法，这样处理：\n12345678910111213// 定义拥有修改和删除权限的maskprivate static final int ALLOW_UPDATE_DELETE_MASK = 12; // 是否拥有修改和删除的权限public boolean isAllowUpdateDelete()&#123;    return flag &amp; ALLOW_UPDATE_DELETE_MASK;&#125;...// 用的时候这样既可if (permission.isAllowUpdateDelete())&#123;    ...&#125;\n代码中的常量ALLOW_UPDATE_DELETE_MASK就是我们定义的拥有某些操作的掩码，这在Android源码也是很常见的，这样处理我们就不用建立List或者专门遍历判断一些相关权限了。\n至此应该对掩码有一个清楚的了解了吧，那位掩码（BitMask）是什么呢？\nBitMask并不是一个类，也不是某种特殊的单位，它更像是一种思想。在BitMask中，使用一个数值来记录各种状态的集合，使用这个数值的每一位来表达每一种状态。在Android中，一个普通的int类型，是32位，则可以表达32中不同的状态而互不影响。\n其实在开发过程中除了移位表示标识，大部分采用的是十六进制表示，还有十六进制和移位混合形式，这些在一些系统源码中普遍体现。\n源码实例\n在Android源码中主要针对FLAG的运算有三种：\n1.增加属性 “|” 。\n如果需要向flag变量中增加某个FLAG，使用&quot;|&quot;运算符 flag |= XXX_FLAG;\n原因: 如果flag变量没有XXX_FLAG，则“|”完后flag对应的位的值为1，如果已经有XXX_FLAG，则“|”完后值不会变，对应位还是1。\n2.包含属性 “&amp;” 。\n如果需要判断flag变量中是否包含XXX_FLAG，使用&quot;&amp;&quot;运算符，flag &amp; XXX_FLAG != 0 或者 flag &amp; XXX_FLAG = XXX_FLAG。\n原因: 如果flag变量里包含XXX_FLAG，则“&amp;”完后flag对应的位的值为1，因为XXX_FLAG的定义保证了只有一位非0，其他位都为0，所以如果是包含的话进行“&amp;”运算后值不为0，该位上的值为此XXX_FLAG的所在位上的值，不包含的话值为0。\n3.去除属性 “&amp;~” 。\n如果需要去除flag变量的XXX_FLAG, 使用 “&amp;~”， flag &amp;= ~XXX_FLAG;\n原因: 先对XXX_FLAG进行取反则XXX_FLAG原来非0的那一位变为0，然后使用“&amp;”运算后如果flag变量非0的那一位变为0，则意味着flag变量不包含XXX_FLAG。\nConfiguration 类\n比如Android源码中的Configuration类。Configuration类专门描述手机设备上的配置信息，包括屏幕旋转、屏幕方向、字体设置、缩放因子、软键盘、移动信号等等，因此有很多种状态配置，以下是部分配置：\n1234567891011121314151617181920212223242526272829303132333435363738394041/** Constant for &#123;@link #colorMode&#125;: bits that encode whether the screen is wide gamut. */public static final int COLOR_MODE_WIDE_COLOR_GAMUT_MASK = 0x3;/** * Constant for &#123;@link #colorMode&#125;: a &#123;@link #COLOR_MODE_WIDE_COLOR_GAMUT_MASK&#125; value * indicating that it is unknown whether or not the screen is wide gamut. */public static final int COLOR_MODE_WIDE_COLOR_GAMUT_UNDEFINED = 0x0;/** * Constant for &#123;@link #colorMode&#125;: a &#123;@link #COLOR_MODE_WIDE_COLOR_GAMUT_MASK&#125; value * indicating that the screen is not wide gamut. * &lt;p&gt;Corresponds to the &lt;code&gt;-nowidecg&lt;/code&gt; resource qualifier.&lt;/p&gt; */public static final int COLOR_MODE_WIDE_COLOR_GAMUT_NO = 0x1;/** * Constant for &#123;@link #colorMode&#125;: a &#123;@link #COLOR_MODE_WIDE_COLOR_GAMUT_MASK&#125; value * indicating that the screen is wide gamut. * &lt;p&gt;Corresponds to the &lt;code&gt;-widecg&lt;/code&gt; resource qualifier.&lt;/p&gt; */public static final int COLOR_MODE_WIDE_COLOR_GAMUT_YES = 0x2;/** Constant for &#123;@link #colorMode&#125;: bits that encode the dynamic range of the screen. */public static final int COLOR_MODE_HDR_MASK = 0xc;/** Constant for &#123;@link #colorMode&#125;: bits shift to get the screen dynamic range. */public static final int COLOR_MODE_HDR_SHIFT = 2;/** * Constant for &#123;@link #colorMode&#125;: a &#123;@link #COLOR_MODE_HDR_MASK&#125; value * indicating that it is unknown whether or not the screen is HDR. */public static final int COLOR_MODE_HDR_UNDEFINED = 0x0;/** * Constant for &#123;@link #colorMode&#125;: a &#123;@link #COLOR_MODE_HDR_MASK&#125; value * indicating that the screen is not HDR (low/standard dynamic range). * &lt;p&gt;Corresponds to the &lt;code&gt;-lowdr&lt;/code&gt; resource qualifier.&lt;/p&gt; */public static final int COLOR_MODE_HDR_NO = 0x1 &lt;&lt; COLOR_MODE_HDR_SHIFT;/** * Constant for &#123;@link #colorMode&#125;: a &#123;@link #COLOR_MODE_HDR_MASK&#125; value * indicating that the screen is HDR (dynamic range). * &lt;p&gt;Corresponds to the &lt;code&gt;-highdr&lt;/code&gt; resource qualifier.&lt;/p&gt; */public static final int COLOR_MODE_HDR_YES = 0x2 &lt;&lt; COLOR_MODE_HDR_SHIFT;\nConfiguration类标识这设备的详细信息，但是源码编写者也不可能把每一个很微小的细节都标识进来，这样就太庞大了，他们会把基本使用标识进来，然后在定义一些场景掩码（_MASK），通过这些场景掩码在代码逻辑中进行位掩码实现所需要的功能：\n1234567891011121314151617181920212223242526272829/** * Return whether the screen has a round shape. Apps may choose to change styling based * on this property, such as the alignment or layout of text or informational icons. * * @return true if the screen is rounded, false otherwise */public boolean isScreenRound() &#123;    return (screenLayout &amp; SCREENLAYOUT_ROUND_MASK) == SCREENLAYOUT_ROUND_YES;&#125;/** * Return whether the screen has a wide color gamut and wide color gamut rendering * is supported by this device. * * @return true if the screen has a wide color gamut and wide color gamut rendering * is supported, false otherwise */public boolean isScreenWideColorGamut() &#123;    return (colorMode &amp; COLOR_MODE_WIDE_COLOR_GAMUT_MASK) == COLOR_MODE_WIDE_COLOR_GAMUT_YES;&#125;/** * Return whether the screen has a high dynamic range. * * @return true if the screen has a high dynamic range, false otherwise */public boolean isScreenHdr() &#123;    return (colorMode &amp; COLOR_MODE_HDR_MASK) == COLOR_MODE_HDR_YES;&#125;\nView绘制过程中onMeasure的参数\n在自定义view中我们常常实现三种方法，其中有一个onMeasure方法，主要用于view绘制过程中的一个测量，Android开发的同学这点很清楚:\n1234@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;    super.onMeasure(widthMeasureSpec, heightMeasureSpec);&#125;\n其入参中有两个参数“widthMeasureSpec”、“heightMeasureSpec”。这两个参数都是32位int值，其中高2位是SpecMode（测量模式），低30位是SpecSize（在某种测量模式下，所测得的精确值）。\n针对测量模式，系统预制了三种：\n123456789101112131415161718/** * Measure specification mode: The parent has not imposed any constraint * on the child. It can be whatever size it wants. */public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT;/** * Measure specification mode: The parent has determined an exact size * for the child. The child is going to be given those bounds regardless * of how big it wants to be. */public static final int EXACTLY     = 1 &lt;&lt; MODE_SHIFT;/** * Measure specification mode: The child can be as large as it wants up * to the specified size. */public static final int AT_MOST     = 2 &lt;&lt; MODE_SHIFT;\n那我们在平时开发中如何取view的精确值（宽、高）呢，按理说只需要取后30位的值即可，左移两位。如果用api去处理：MeasureSpec.getSize(widthMeasureSpec)，然后我们深入系统源码看一下系统是如何运作的：\n123456789/** * Extracts the size from the supplied measure specification. * * @param measureSpec the measure specification to extract the size from * @return the size in pixels defined in the supplied measure specification */public static int getSize(int measureSpec) &#123;    return (measureSpec &amp; ~MODE_MASK);&#125;\n这里就清楚了，原来系统也是用位掩码处理的，我们再看一下掩码MODE_MASK是怎么表示的：\n12private static final int MODE_SHIFT = 30;private static final int MODE_MASK  = 0x3 &lt;&lt; MODE_SHIFT;\n看到有同学可能会问为什么是0x3呢？当你想到上边的三种模式，不由的惊喜，原来MODE_MASK = UNSPECIFIED | EXACTLY | AT_MOST。MODE_MASK左移30位刚好是view的SpecMode，然后measureSpec再将SpecMode去除，刚好就是我们想要的SpecSize。\n一个小问题\n上边也提到开发过程中针对位掩码这些FLAG，会用到移位表示法、十六进制表示法、混合表示法，但十六进制表示法更为常见，那么这里抛出一个小问题：为什么开发普遍用十六进制来定义FLAG？\n其实开发过程中不固定使用哪种进制，8进制的也有用到，但是最终回归到的都是二进制，开发者普遍用十六进制主要是编码习惯和更为方便，具体原因个人总结有两条：\n\n缩短编写空间，总不能用二进制32个1或者0来定义一个整形常量吧。\n十六进制更容易转化成二进制，因此在代码阅读和逻辑分析尤其是运用在位运算上更有优势。\n\n其他用法\n1.判断int型变量a是奇数还是偶数\n12a&amp;1 &#x3D; 0 偶数a&amp;1 &#x3D; 1 奇数 \n2.整数的平均值\n对于两个整数x,y，如果用 (x+y)/2 求平均值，会产生溢出，因为 x+y 可能会大于INT_MAX，但是我们知道它们的平均值是肯定不会溢出的，我们用如下算法：\n123public int average(int x, int y)&#123;     return (x&amp;y)+((x^y)&gt;&gt;1); &#125;\n3.判断一个正整数是不是2的幂\n123public boolean power2(int x) &#123;     return ((x&amp;(x-1))==0)&amp;&amp;(x!=0)； &#125;\n总结\n到此针对位运算的相关知识点终于完了，从起初的机器码，到位运算规则，再到本篇的实用战场，相信读过这三篇的小伙伴一定有很大收获。\n在开发过程中运用位运算，有些时候可以极好的缩短编写空间和良好的程序扩展性，但是并不是说位运算就是最好的，毕竟代码是写给人看的，我们的代码要有可读性可持续维护性，所以在开发过程中针对场景的不用，运用的策略也不同，避免滥用，良好运用。\n","plink":"https://blog.ixin.run/posts/1567003105/"},{"title":"位运算的那些事（二）如何位运算","date":"2019-08-25T14:18:59.000Z","date_formatted":{"ll":"2019年8月25日","L":"2019/08/25","MM-DD":"08-25"},"updated":"2021-01-29T12:51:44.675Z","content":"上一篇为了讲位运算不得已将二进制机器码与真值之间的关系系统的解释了一通，本篇我们就根据这些基础将二进制位运算几个常用的运算符运算规则理一理，相信本文之后你就明白了这一个过程。\n上篇我也提到位运算符主要针对二进制，它主要包括：“与（&amp;）”、“或（|）”、“非（~）”、“异或（^）”，当然还有移位运算（左移、右移，无符号左移），这在开发过程中也是很常见的，下边我就以这两部分来说。\n\n位运算过程\n常见的位运算都是针对两个值之间的运算，只有“非”是针对一个值计算。\n再次强调一下，上篇文章我提到的计算机最终参与运算和存储的是真值的二进制补码，所以本篇位运算转化为二进制都要以补码的形式进行运算，然后再还原成真值才能得到正确的结果，这也是上篇文末提到的两个过程。\n为了描述简单起见，下边四种位运算都用a = 12, b= -21来进行运算，所以我们先对这两个数字进行补码，用一个字节来表示，方便下边运算使用，如果这里还看不懂，建议返回上一篇。\n伪代码：\n123a &#x3D; 12 &#x3D; [0000 1100]原 &#x3D; [0000 1100]反 &#x3D; [0000 1100]补b &#x3D; -21 &#x3D; [1001 0101]原 &#x3D; [1110 1010]反 &#x3D; [1110 1011]补\n与（AND）\n与运算符用符号“&amp;”表示，其使用规则如下：\n两个操作数所对应的二进制补码相同坐标位值都为1，结果才为1，否则结果为0。例如下面的程序段：\n1System.out.println(&quot;a和b，与的结果是：&quot;+(a&amp;b));\n运行结果：\na和b，与的结果是：8\n分析:\n“a”的补码：0000 1100\n“b”的补码：1110 1011\n“与”的补码：0000 1000\n转换为真值：[0000 1000]补 = [0000 1000]反 = [0000 1000]原 = 8\n或（OR）\n或运算符用符号“|”表示，其运算规则如下：\n两个操作数所对应的二进制补码相同坐标位值有一个为1，结果就为1，否则结果为0。例如下面的程序段：\n1System.out.println(&quot;a和b，或的结果是：&quot;+(a|b));\n运行结果：\na和b，或的结果是：-17\n分析：\n“a”的补码：0000 1100\n“b”的补码：1110 1011\n“或”的补码：1110 1111\n转换为真值：[1110 1111]补 = [1110 1110]反 = [1001 0001]原 = -17\n非（NOT）\n非运算符用符号“~”表示，其使用规则如下：\n操作数所对应的二进制补码位值都为0，结果为1，位值为1结果为0。例如下面的程序段：\n1System.out.println(&quot;a，非的结果是：&quot;+(~a));\n运行结果：\na，非的结果是：-13\n分析:\n“a”的补码：0000 1100\n“非”的补码：1111 0011\n转换为真值：[1111 0011]补 = [1111 0010]反 = [1000 1101]原 = -13\n这里有一个有趣的规律：\n\n所有正整数的非，是其本身加1的负数\n所有负整数的非，是其本身加1的正数\n0的非，是-1\n\n异或（XOR）\n异或运算符用符号“^”表示，其使用规则如下：\n两个操作数所对应的二进制补码相同坐标位值相同（无论同为1还是同为0）则为为0，不同则为1。例如下面的程序段：\n1System.out.println(&quot;a和b，异或的结果是：&quot;+(a^b));\n运行结果：\na和b，异或的结果是：-25\n分析：\n“a”的补码：0000 1100\n“b”的补码：1110 1011\n“异或”的补码：1110 0111\n转换为真值：[1110 0111]补 = [1110 0110]反 = [1001 1001]原 = -25\n到这里四种位运算符的运算过程已经分析完了，是否和你之前想象的一样呢？如果一样，恭喜你，你已经理解了位运算相关运算符的运算过程了。下边我们就进一步探讨移位运算的运算过程。\n移位运算过程\n移位运算中主要涉及到三种运算符：左移（&lt;&lt;）、右移（&gt;&gt;）、无符号右移（&gt;&gt;&gt;）。假设有一个管道是固定长度的（这个长度是根据数据类型来确定的），移位运算就是一组二进制码在此管道中移动，不够的地方做补充，多余的部分省去。下边就分别讲一下这三个区别以及运算过程。\n为了方便下边的运算，我们这里还是先定义一个数字a = -8，则：\n“a”的原码：1000 1000\n“a”的反码：1111 0111\n“a”的补码：1111 1000\n假设管道长度按照一个字节8位来定（按照移动位数2位，管道长度我猜可能是够用的）。\n左移\n左移运算符用符号“&lt;&lt;”表示，其使用规则如下：\n操作数所对应的二进制补码整体向左移动，原来左边的数据会被溢出，右边会空缺相应的位数，需要进行补0。例如下面的程序段：\n1System.out.println(&quot;a和b，异或的结果是：&quot;+(a&lt;&lt;2));\n运行结果：\na,左移2位的结果是：-32\n分析：\n“a”的补码：1111 1000\n“左移2位”的补码：1110 0000\n转换为真值：[1110 0000]补 = [1101 1111]反 = [1010 0000]原 = -32\n右移\n右移运算符用符号“&gt;&gt;”表示，其使用规则如下：\n操作数所对应的二进制补码整体向右移动，原来右边的数据会被溢出，左边会空缺相应的位数，需要进行补0或补1（根据原值的正负，正数补0，负数补1）。例如下面的程序段：\n1System.out.println(&quot;a和b，异或的结果是：&quot;+(a&gt;&gt;2));\n运行结果：\na,右移2位的结果是：-2\n分析：\n“a”的补码：1111 1000\n“右移2位”的补码：1111 1110\n转换为真值：[1111 1110]补 = [1111 1101]反 = [1000 0010]原 = -2\n无符号右移\n无符号右移运算符用符号“&gt;&gt;&gt;”表示，其使用规则如下：\n操作数所对应的二进制补码整体向右移动，原来右边的数据会被溢出，左边会空缺相应的位数，忽略正负情况，统一补0。例如下面的程序段：\n1System.out.println(&quot;a和b，异或的结果是：&quot;+(a&gt;&gt;&gt;2));\n运行结果：\na,无符号右移2位的结果是：1073741822\n分析：\n“a”的补码：1111 1000\n“无符号右移2位”的补码：0011 1110\n转换为真值：[0011 1110]补 = [0011 1110]反 = [0011 1110]原 = 62\n显然这个结果出入很大，其错误原因就是我定义的这个管道长度不够导致的，按照我上边说的管道长度是按照数据类型来确定的，我程序里面都是java来写的，java中一个int占四个字节即32位。所以应该这样算：\na的原码：1000 0000 0000 0000 0000 0000 0000 1000\na的反码：1111 1111 1111 1111 1111 1111 1111 0111\na的补码：1111 1111 1111 1111 1111 1111 1111 1000\n无符号右移2位的补码：0011 1111 1111 1111 1111 1111 1111 1110\n转换成真值：[0011 … 1110]补 = [0011 … 1110]反 = [0011 … 1110]原 = 1073741822\n这样就对了，你可能会问为什么上边的左移右移没问题呢？其实当你看到最终的原码就发现了其实中间都是0，可以省略的。还有疑问吗？好，最多再给你一个问题：为什么没有无符号左移呢？，其实我也想问一句：无符号左移和左移有区别吗？\n至此移位运算分析完毕，你有没有发现一个规律：\n\n左移运算，相当于原值乘以2的n次方\n右移运算，相当于原值除以2的n次方\n\n总结\n本篇文章将位运算和移位运算的运算过程整体分析了一遍，二者其实都可以统一叫做位运算，总之就是以上七中规则，细心看来其实这些也都有规律可循。\n当你看完之后是不是又惊喜又懵X，哈哈，虽然我们也知道有这样一个计算过程，但是开发过程中，无论是写代码还是看代码，总不能让我在私下先画一些小杠杠吧。其实位运算在计算机中的用途很广，拿异或来说，可用于数据的加密，并且是高度对称的，也可用于各类纠错码和校验码的编码…，虽然这些有代我们去深入开辟，但是在现阶段针对C++、java等上层语言主要用在哪些地方呢？下篇文章我会根据前两篇的思路叙说一下位运算在常规开发阶段的一个重要用途。\n","plink":"https://blog.ixin.run/posts/1566743147/"},{"title":"位运算的那些事（一）搞懂机器码","date":"2019-08-25T14:16:59.000Z","date_formatted":{"ll":"2019年8月25日","L":"2019/08/25","MM-DD":"08-25"},"updated":"2021-01-29T12:51:44.674Z","content":"最近在开发过程中查看Android源码，多处看到一些类似result = specSize | MEASURED_STATE_TOO_SMALL;的写法，乍一看很熟悉，实际阅读起来很痛苦，这是我们大学里学过的位运算，单看代码似乎我们不可能一瞬间知道结果是多少，所以千万要和我们常见的result = a || b区分开来。以此为引子我们就了解一下有关位运算的那些事。\n位运算主要针对二进制，它包括了：“与（&amp;）”、“或(|)”、“非（~）”、“异或(^)”。从表面上看似乎有点像逻辑运算符，但逻辑运算符是针对两个关系运算符来进行逻辑运算，而位运算符主要针对两个二进制数的位进行逻辑运算。\n理解位运算，必须先了解二进制在计算机中转换过程，这也是本篇所讲的重点内容。这些明白了，针对一些复杂的简单的运算法则也就很清晰了。\n\n机器码和真值\n在谈二进制之前我们先了解两个简单的概念：“机器码”和“真值”。\n机器码\n一个数在计算机中的二进制表示形式，叫做这个数的机器码。机器码是带符号的，在计算机用一个数的最高位存放符号，正数为0，负数为1。比如，十进制中的数+1，计算机字长为8位，转换成二进制就是00000001，如果是-1 ，就是10000001。那么，这里的00000001和10000001就是机器码。\n真值\n在机器码中第一位是符号位，但是我们抛去这个规则，就得到不知正确的数值了，还是上边的例子-1，用机器码来表示为10000001，但如果表示成十进制的真值则等于129，这差别就大了。或者你可以总结真值转换成二进制和机器码的区别就是有没有符号之说，符号你自己定义。\n原码, 反码, 补码\n上边有了机器码和真值的概念，从这里开始我们就揭开计算机是如何将“-1”这类真值转换成机器码参与计算或存储起来的。首先我们要明白二进制数在内存中是以补码的形式存放的，这里又引申出原码、反码、补码的概念，也是二进制位运算的基础，后边会说。\n原码\n前边我们已经说到机器码是带符号的，所以我们的真值转换成机器码的时候要根据其符号正或者负分别将其转成首位的0和1。\n例：\n[+1] = [0000 0001]原\n[-1] = [1000 0001]原\n注：这里按照单个字节来表示，java上int类型是四个字节，就不用过于纠结了。\n因为第一位是符号位, 所以8位二进制数的取值范围就是:[11111111, 01111111]，即[127, -127]。\n反码\n同样，反码也是区分符号的，正数的反码是他本身， 负数的反码是符号位不变其余按位取反。\n例：\n[+1] = [0000 0001]原 = [0000 0001]反\n[-1] = [1000 0001]原 = [1111 1110]反\n补码\n和上边一样，补码也是区分符号的，正数的补码是他本身，负数的补码是在反码的基础上加1。\n例：\n[+1] = [0000 0001]原 = [0000 0001]反 = [0000 0001]补\n[-1] = [1000 0001]原 = [1111 1110]反 = [1111 1111]补\n由上边三个概念我们得到两个结论:\n\n正数的原码、反码、补码都一样，负数根据原、反、补规则做变换；\n计算机将一个真值最终存储或参与计算是需要经过这几步：真值-&gt;原码-&gt;反码-&gt;补码；\n\n计算机中为什么要以补码形式参与运算或存储\n我们都知道，CPU是由运算器、寄存器、总线构成。单说运算器说的简单点就是有一个个小开关构成的集成器，每一个开关的状态代表0和1，每一次运算都是有由时钟脉冲将这些状态带出来或存储在寄存器中…（不好意思，扯远了）。对于一个有符号的真值转换成机器码做运算，人的大脑很轻松的就能判断处理，但是如果让计算机集成器中一个个小开关去保存这些状态，那么每个集成器上还要预留一个开关做为正负，并且其余开关进行转换的过程中还要兼顾符号开关的状态，这样是不是很繁琐。\n聪明的人们在想能不能将真值中的符号位直接参与到运算呢？这样就可以不用在硬件中专门预留一个这样的符号开关标识了。我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了。\n例如计算十进制的表达式: 1-1=0，以下循序渐进给出计算机为什么最终采用补码形式计算的原因。\n原码计算\n上边表达式用原码计算：\n11 - 1 &#x3D; 1 + (-1) &#x3D; [00000001]原 + [10000001]原 &#x3D; [10000010]原 &#x3D; -2\n如果用原码表示, 让符号位也参与计算,显然对于减法来说,结果是不正确的.这也就是为何计算机内部不使用原码表示一个数的原因。\n反码计算\n为了解决原码做减法的问题, 聪明的人们又想到了反码计算:\n11 - 1 &#x3D; 1 + (-1) &#x3D; [0000 0001]原 + [1000 0001]原&#x3D; [0000 0001]反 + [1111 1110]反 &#x3D; [1111 1111]反 &#x3D; [1000 0000]原 &#x3D; -0\n发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在&quot;0&quot;这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.\n补码计算\n补码的出现, 彻底解决了0的符号以及两个编码的问题:\n11-1 &#x3D; 1 + (-1) &#x3D; [0000 0001]原 + [1000 0001]原 &#x3D; [0000 0001]补 + [1111 1111]补 &#x3D; [0000 0000]补&#x3D;[0000 0000]原\n这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了，而且可以用[1000 0000]表示-128:\n1(-1) + (-127) &#x3D; [1000 0001]原 + [1111 1111]原 &#x3D; [1111 1111]补 + [1000 0001]补 &#x3D; [1000 0000]补\n-1-127的结果应该是-128，在用补码运算的结果中，[1000 0000]补就是-128。但是注意因为实际上是使用以前的-0的补码来表示-128， 所以-128并没有原码和反码表示。(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原，这是不正确的)。\n使用补码, 不仅仅修复了0的符号以及存在两个编码的问题，而且还能够多表示一个最低数（多开辟一个存储空间）。这就是为什么8位二进制使用原码或反码表示的范围为[-127, +127]，而使用补码表示的范围为[-128, 127]。\n总结\n本篇系统了阐述了一个真值转化到计算机所最终使用的机器码的一个过程。一个真值最终被计算机所使用会经过真值-&gt;原码-&gt;反码-&gt;补码这些步骤，但如果计算机计算完之后呢，当然要逆过来走一遍，由补码-&gt;反码-&gt;原码-&gt;真值这个过程最终得到一个被人脑所认知的正确结果。\n开篇提到了二进制的位运算，但是不摸清原码、反码、补码这些基础很难去得到位运算的正确结果的。下一篇我会以本篇的基础来讲一下二进制位运算相关运算符的运算规则。\n参考\n\ncnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html\nhttps://www.zhihu.com/question/20159860\n\n","plink":"https://blog.ixin.run/posts/1566742995/"},{"title":"Android数据库GreenDao的使用完全解析","date":"2019-07-23T12:20:19.000Z","date_formatted":{"ll":"2019年7月23日","L":"2019/07/23","MM-DD":"07-23"},"updated":"2021-01-29T12:51:44.642Z","content":"最近一直在处理公司项目本地数据库，原来的订单数据都是采用SP加密保存的，但SP仅仅适合数据量小的数据存储，随着功能的扩展发现数据越来越多越来越杂，所以这部分数据全部迁移到本地数据库还是有必要的，之前项目已经采用了Greendao，这块本来也想做个总结，但是greendao知识点比较丰富，后来上网发现别人总结的一篇很全面——《一篇技术好文之Android数据库 GreenDao的使用完全解析》，这里就做一个转载记录，方便工作过程中查阅调优。另外特别说明一下Greendao官方已经不再维护了，替代方案也有很多，例如ObjectBox（与Greendao同一公司）、Realm、Room（Google官方）等。本篇也有额外说明，如果想更好的使用Greendao，请结合另外一篇《DataBase 数据库整理（greenDao示例）》查看，会起到事半功倍的效果。\n\n本文主要从如下几个方面进行讲解：\n\n存储的数据库结构\nGreenDao的优缺点\nGreenDao的使用配置\n使用GreenDao实现数据的增删改查\nGreenDao的注解使用\nGreenDao的关系处理\nGreenDao的升级\nGreenDao数据库加密\n项目地址\n总结\n参考博客\n\n\n\n存储的数据库结构\n学习数据库之前，我们先得设计自己的数据库，不多废话，下面是我此次学习的数据库结构，后面所有的数据请参考这个图进行学习：\n\nGreenDao的介绍\n简单的GreenDao的介绍，嫌麻烦的可以直接跳到GreenDao使用开始看。\n什么是GreenDao？\nGreenDAO是一个开源的Android ORM(“对象/关系映射”)，通过ORM（称为“对象/关系映射”），在我们数据库开发过程中节省了开发时间！\n\nGreenDao的官方文档\n\nGreenDao：适用于您的SQLite数据库的Android ORM\nGreenDao的github地址\nGreenDao的Google讨论区\nGreenDao 加密SQLCipher for Android官方说明地址\nGreenDao使用文档\n\nGreenDao的作用\n通过GreenDao，我们可以更快速的操作数据库，我们可以使用简单的面相对象的API来存储，更新，删除和查询Java对象。\nGreenDao的优缺点\n\n高性能，下面是官方给出的关于GreenDao，OrmLite和ActiveAndroid三种ORM解决方案的数据统计图：\n\n易于使用的强大API，涵盖关系和连接；\n最小的内存消耗;\n小库大小（&lt;100KB）以保持较低的构建时间并避免65k方法限制;\n数据库加密：greenDAO支持SQLCipher，以确保用户的数据安全;\n\nGreenDao的使用\nGreenDao的核心类有三个：分别是DaoMaster,DaoSession,XXXDao，这三个类都会自动创建，无需自己编写创建！\n\nDaoMaster:：DaoMaster保存数据库对象（SQLiteDatabase）并管理特定模式的DAO类（而不是对象）。它有静态方法来创建表或删除它们。它的内部类OpenHelper和DevOpenHelper是SQLiteOpenHelper实现，它们在SQLite数据库中创建模式。\nDaoSession：管理特定模式的所有可用DAO对象，您可以使用其中一个getter方法获取该对象。DaoSession还提供了一些通用的持久性方法，如实体的插入，加载，更新，刷新和删除。\nXXXDao：数据访问对象（DAO）持久存在并查询实体。对于每个实体，greenDAO生成DAO。它具有比DaoSession更多的持久性方法，例如：count，loadAll和insertInTx。\nEntities ：可持久化对象。通常, 实体对象代表一个数据库行使用标准 Java 属性(如一个POJO 或 JavaBean )。\n\n\n导入Gradle插件和Dao代码生成\n要在Android项目中使用GreenDao，您需要添加GreenDao Gradle插件并添加GreenDao库：\n导入插件\n1234567891011// 在 Project的build.gradle 文件中添加:buildscript &#123;    repositories &#123;        jcenter()        mavenCentral() // add repository    &#125;    dependencies &#123;        classpath &#x27;com.android.tools.build:gradle:3.1.2&#x27;        classpath &#x27;org.greenrobot:greendao-gradle-plugin:3.2.2&#x27; // add plugin    &#125;&#125;\n配置相关依赖\n1234567// 在 Moudle:app的  build.gradle 文件中添加:apply plugin: &#x27;com.android.application&#x27;apply plugin: &#x27;org.greenrobot.greendao&#x27; // apply plugin dependencies &#123;    implementation &#x27;org.greenrobot:greendao:3.2.2&#x27; // add library&#125;\n配置数据库相关信息\n12345678greendao &#123;    schemaVersion 1 //数据库版本号    daoPackage &#x27;com.aserbao.aserbaosandroid.functions.database.greenDao.db&#x27;// 设置DaoMaster、DaoSession、Dao 包名    targetGenDir &#x27;src.main.java&#x27;//设置DaoMaster、DaoSession、Dao目录,请注意，这里路径用.不要用/    generateTests false //设置为true以自动生成单元测试。    targetGenDirTests &#x27;src/main/java&#x27; //应存储生成的单元测试的基本目录。默认为 src / androidTest / java。&#125;\n配置完成，在Android Studio中使用Build&gt; Make Project，重新build项目，GreenDao集成完成！\n创建存储对象实体类\n使用GreenDao存储数据只需要在存储数据类前面声明@Entity注解就让GreenDao为其生成必要的代码：\n12345678910111213141516171819202122232425262728293031323334@Entitypublic class Student &#123;    @Id(autoincrement = true)    Long id;    @Unique    int studentNo;//学号    int age; //年龄    String telPhone;//手机号    String sex; //性别    String name;//姓名    String address;//家庭住址    String schoolName;//学校名字    String grade;//几年级    ……getter and setter and constructor method……    &#125;```    ### GreenDao初始化我们可以在Application中维持一个全局的会话。我们在Applicaiton进行数据库的初始化操作：```java /**     * 初始化GreenDao,直接在Application中进行初始化操作     */    private void initGreenDao() &#123;        DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(this, &quot;aserbao.db&quot;);        SQLiteDatabase db = helper.getWritableDatabase();        DaoMaster daoMaster = new DaoMaster(db);        daoSession = daoMaster.newSession();    &#125;        private DaoSession daoSession;    public DaoSession getDaoSession() &#123;        return daoSession;    &#125;\n初始化完成之后重新rebuild一下项目会发现在设置的targetGenDir的目录生成三个类文件，这个是GreenDao自动生成的！说明数据库已经连接好了，咱们接下来只需要进行数据库的增删改查操作就行了。Let’s Go!\n使用GreenDao实现增删改查\n增\ninsert() 插入数据\n12345678910111213141516171819202122@Override   public void insertData(Thing s) &#123;    DaoSession daoSession = ((AserbaoApplication) getApplication()).getDaoSession();           for (int i = 0; i &lt; 1000; i++) &#123;              Student student = new Student();                       student.setStudentNo(i);                       int age = mRandom.nextInt(10) + 10;                       student.setAge(age);                       student.setTelPhone(RandomValue.getTel());                       String chineseName = RandomValue.getChineseName();                       student.setName(chineseName);                       if (i % 2 == 0) &#123;                           student.setSex(&quot;男&quot;);                       &#125; else &#123;                           student.setSex(&quot;女&quot;);                       &#125;                       student.setAddress(RandomValue.getRoad());                       student.setGrade(String.valueOf(age % 10) + &quot;年纪&quot;);                       student.setSchoolName(RandomValue.getSchoolName());                       daoSession.insert(student);           &#125;   &#125;\ninsertOrReplace()数据存在则替换，数据不存在则插入\n12345678910111213141516171819202122@Override    public void insertData(Thing s) &#123;    DaoSession daoSession = ((AserbaoApplication) getApplication()).getDaoSession();            for (int i = 0; i &lt; 1000; i++) &#123;                 Student student = new Student();                        student.setStudentNo(i);                        int age = mRandom.nextInt(10) + 10;                        student.setAge(age);                        student.setTelPhone(RandomValue.getTel());                        String chineseName = RandomValue.getChineseName();                        student.setName(chineseName);                        if (i % 2 == 0) &#123;                            student.setSex(&quot;男&quot;);                        &#125; else &#123;                            student.setSex(&quot;女&quot;);                        &#125;                        student.setAddress(RandomValue.getRoad());                        student.setGrade(String.valueOf(age % 10) + &quot;年纪&quot;);                        student.setSchoolName(RandomValue.getSchoolName());                        daoSession.insertOrReplace(student);//插入或替换            &#125;    &#125;\n删\n删除有两种方式：delete()和deleteAll()；分别表示删除单个和删除所有。\n123456789101112@Override   public void deleteData(Student s) &#123;       DaoSession daoSession = ((AserbaoApplication) getApplication()).getDaoSession();       daoSession.delete(s);   &#125;@Override   public void deleteAll() &#123;       DaoSession daoSession = ((AserbaoApplication) getApplication()).getDaoSession();       daoSession.deleteAll(Student.class);   &#125;\n改\n通过update来进行修改：\n12345@Override    public void updataData(Student s) &#123;        DaoSession daoSession = ((AserbaoApplication) getApplication()).getDaoSession();        daoSession.update(s);    &#125;\n查\n查询的方法有：\n\nloadAll()：查询所有数据。\nqueryRaw()：根据条件查询。\nqueryBuilder() : 方便查询的创建，后面详细讲解。\n\n12345678910public List queryAll()&#123;       List&lt;Student&gt; students = daoSession.loadAll(Student.class);       return students;   &#125; @Override   public void queryData(String s) &#123;      List&lt;Student&gt; students = daoSession.queryRaw(Student.class, &quot; where id = ?&quot;, s);       mDataBaseAdapter.addNewStudentData(students);   &#125;\nQueryBuilder的使用\n编写SQL可能很困难并且容易出现错误，这些错误仅在运行时才会被注意到。该QueryBuilder的类可以让你建立你的实体，而不用SQL自定义查询，并有助于在编译时已检测错误。\n我们先讲下QueryBuilder的常见方法：\n\nwhere(WhereCondition cond, WhereCondition… condMore): 查询条件，参数为查询的条件！\nor(WhereCondition cond1, WhereCondition cond2, WhereCondition… condMore): 嵌套条件或者，用法同or。\nand(WhereCondition cond1, WhereCondition cond2, WhereCondition… condMore): 嵌套条件且，用法同and。\njoin(Property sourceProperty, Class destinationEntityClass):多表查询，后面会讲。\n输出结果有四种方式，选择其中一种最适合的即可，list()返回值是List,而其他三种返回值均实现Closeable,需要注意的不使用数据时游标的关闭操作：\nlist （）所有实体都加载到内存中。结果通常是一个没有魔法的 ArrayList。最容易使用。\nlistLazy （）实体按需加载到内存中。首次访问列表中的元素后，将加载并缓存该元素以供将来使用。必须关闭。\nlistLazyUncached （）实体的“虚拟”列表：对列表元素的任何访问都会导致从数据库加载其数据。必须关闭。\nlistIterator （）让我们通过按需加载数据（懒惰）来迭代结果。数据未缓存。必须关闭。\norderAsc() 按某个属性升序排；\norderDesc() 按某个属性降序排；\n\nGreenDao中SQL语句的缩写，我们也了解下，源码在Property中,使用的时候可以自己点进去查询即可：\n\neq()：“equal (‘=?’)” 等于；\nnotEq() ：“not equal (‘&lt;&gt;?’)” 不等于；\nlike()：&quot; LIKE ?&quot; 值等于；\nbetween()：&quot; BETWEEN ? AND ?&quot; 取中间范围；\nin()：&quot; IN (&quot;  in命令;\nnotIn()：&quot; NOT IN (&quot; not in 命令;\ngt()：“&gt;?”  大于;\nlt()：&quot;&lt;? &quot;  小于;\nge()：“&gt;=?”  大于等于;\nle()：&quot;&lt;=? &quot;  小于等于;\nisNull()：&quot; IS NULL&quot; 为空;\nisNotNull()：&quot; IS NOT NULL&quot; 不为空;\n\n使用QueryBuilder进行查询操作\n简单条件查询\n查询当前Student表的所有的数据：\n1234567891011121314151617  public List queryAllList()&#123;        DaoSession daoSession = ((AserbaoApplication) getApplication()).getDaoSession();        QueryBuilder&lt;Student&gt; qb = daoSession.queryBuilder(Student.class);        List&lt;Student&gt; list = qb.list(); // 查出所有的数据    return list;    &#125;```    查询Name为“一”的所有Student:```java public List queryListByMessage(String name)&#123;         DaoSession daoSession = ((AserbaoApplication) getApplication()).getDaoSession();        QueryBuilder&lt;Student&gt; qb = daoSession.queryBuilder(Student.class);        QueryBuilder&lt;Student&gt; studentQueryBuilder = qb.where(StudentDao.Properties.Name.eq(&quot;一&quot;)).orderAsc(StudentDao.Properties.Name);        List&lt;Student&gt; studentList = studentQueryBuilder.list(); //查出当前对应的数据        return list;    &#125;\n原始查询\n通过原始的SQL查询语句进行查询！其实上面有提到QueryBuilder的目的就是方便快捷的编写SQL查询语句，避免我们自己在编写过程中出错！简单介绍下通过QueryBuilder编写数据库，方式方法如下 ：\n12345678910public List queryListBySqL()&#123;// 查询ID大于5的所有学生        DaoSession daoSession = ((AserbaoApplication) getApplication()).getDaoSession();        Query&lt;Student&gt; query = daoSession.queryBuilder(Student.class).where(                new WhereCondition.StringCondition(&quot;_ID IN &quot; +                        &quot;(SELECT _ID FROM STUDENT WHERE _ID &gt; 5)&quot;)        ).build();        List&lt;Student&gt; list = query.list();        return list;    &#125;\n嵌套条件查询\n查询Id大于5小于10，且Name值为&quot;一&quot;的数据：\n123456789public List queryList()&#123;        DaoSession daoSession = ((AserbaoApplication) getApplication()).getDaoSession();        QueryBuilder&lt;Student&gt; qb = daoSession.queryBuilder(Student.class);        qb = daoSession.queryBuilder(Student.class);        List&lt;Student&gt; list2 = qb.where(StudentDao.Properties.Name.eq(&quot;一&quot;),                qb.and(StudentDao.Properties.Id.gt(5),                        StudentDao.Properties.Id.le(50))).list();        return  list2;    &#125;\n取10条Id大于1的数据，且偏移2条\n123456789public List queryListByOther()&#123;       DaoSession daoSession = ((AserbaoApplication) getApplication()).getDaoSession();       QueryBuilder&lt;Student&gt; qb = daoSession.queryBuilder(Student.class);       //搜索条件为Id值大于1，即结果为[2,3,4,5,6,7,8,9,10,11];       // offset(2)表示往后偏移2个，结果为[4,5,6,7,8,9,10,11,12,13];       List&lt;Student&gt; list = qb.where(StudentDao.Properties.Id.gt(1)).limit(10).offset(2).list();       return list;   &#125;\n多次执行查找\n使用QueryBuilder构建查询后，可以重用 Query对象以便稍后执行查询。这比始终创建新的Query对象更有效。如果查询参数没有更改，您可以再次调用list / unique方法。可以通过setParameter方法来修改条件参数值：\n123456789101112131415161718192021222324252627282930313233 public List queryListByMoreTime()&#123;        DaoSession daoSession = ((AserbaoApplication) getApplication()).getDaoSession();        QueryBuilder&lt;Student&gt; qb = daoSession.queryBuilder(Student.class);        //搜索条件为Id值大于1，即结果为[2,3,4,5,6,7,8,9,10,11];        // offset(2)表示往后偏移2个，结果为[4,5,6,7,8,9,10,11,12,13];        Query&lt;Student&gt; query = qb.where(StudentDao.Properties.Id.gt(1)).limit(10).offset(2).build();        List&lt;Student&gt; list = query.list();                //通过SetParameter来修改上面的查询条件，比如我们将上面条件修改取10条Id值大于5，往后偏移两位的数据，方法如下！        query.setParameter(0,5);        List&lt;Student&gt; list1 = query.list();        return list1;    &#125;```    #### 在多个线程中使用QueryBuilder如果在多个线程中使用查询，则必须调用 forCurrentThread （）以获取当前线程的Query实例。Query的对象实例绑定到构建查询的拥有线程。这使您可以安全地在Query对象上设置参数，而其他线程不会干扰。如果其他线程尝试在查询上设置参数或执行绑定到另一个线程的查询，则会抛出异常。像这样，您不需要同步语句。实际上，您应该避免锁定，因为如果并发事务使用相同的Query对象，这可能会导致死锁。每次调用forCurrentThread （）时， 参数都会在使用其构建器构建查询时设置为初始参数。### 使用QueryBuilder进行批量删除操作使用QueryBuilder进行批量删除操作，不会删除单个实体，但会删除符合某些条件的所有实体。要执行批量删除，请创建QueryBuilder，调用其 buildDelete （）方法，然后执行返回的 DeleteQuery。例子：删除数据库中id大于5的所有其他数据```javapublic boolean deleteItem()&#123;        DaoSession daoSession = ((AserbaoApplication) getApplication()).getDaoSession();        QueryBuilder&lt;Student&gt; where = daoSession.queryBuilder(Student.class).where(StudentDao.Properties.Id.gt(5));        DeleteQuery&lt;Student&gt; deleteQuery = where.buildDelete();        deleteQuery.executeDeleteWithoutDetachingEntities();        return false;    &#125;\n注解讲解\n从GreenDao 3 使用注解来定义模型和实体，前面也讲过，通过注解的使用可以快速构建数据库表，包括设置主键，自增，值是否唯一等等等……\n下面我们来看下注解的简单使用：\n123456789101112131415@Entitypublic class Student &#123;    @Id(autoincrement = true)    Long id;    @Unique    int studentNo;//学号    int age; //年龄    String telPhone;//手机号    String sex; //性别    String name;//姓名    String address;//家庭住址    String schoolName;//学校名字    String grade;//几年级    ……getter and setter and constructor method……    &#125;\n@Entity注解\n@Entity是GreenDao必不可少的注解，只有在实体类中使用了@Entity注解GreenDao才会创建对应的表。当然我们也可以使用@Entity配置一些细节：\n\nschema：如果你有多个架构，你可以告诉GreenDao当前属于哪个架构。\nactive：标记一个实体处于活跃状态，活动实体有更新、删除和刷新方法。\nnameInDb：在数据中使用的别名，默认使用的是实体的类名。\nindexes：标记如果DAO应该创建数据库表(默认为true)，如果您有多个实体映射到一个表，或者表的创建是在greenDAO之外进行的，那么将其设置为false。\ncreateInDb：标记创建数据库表。\ngenerateGettersSetters：如果缺少，是否应生成属性的getter和setter方法。\n\n12345678910111213141516@Entity(        schema = &quot;myschema&quot;,        active = true,        nameInDb = &quot;AWESOME_USERS&quot;,        indexes = &#123;                @Index(value = &quot;message DESC&quot;, unique = true)        &#125;,        createInDb = false,        generateConstructors = true,        generateGettersSetters = true)public class Student&#123;       ……&#125;\n基础属性注解（@Id，@Property，@NotNull，@Transient）\n@Id\n@Id注解选择 long / Long属性作为实体ID。在数据库方面，它是主键。参数autoincrement = true 表示自增，id不给赋值或者为赋值为null即可（这里需要注意，如果要实现自增，id必须是Long,为long不行！)。\n@Entity\npublic class Student {\n@Id(autoincrement = true)\nLong id;\n……\n}\n@Property\n允许您定义属性映射到的非默认列名。如果不存在，GreenDAO将以SQL-ish方式使用字段名称（大写，下划线而不是camel情况，例如 name将成为 NAME）。注意：您当前只能使用内联常量来指定列名。\n12345678@Entitypublic class Student &#123;    @Id(autoincrement = true)    Long id;    @Property (nameInDb=&quot;name&quot;) //设置了，数据库中的表格属性名为&quot;name&quot;,如果不设置，数据库中表格属性名为&quot;NAME&quot;    String name;    ……&#125;\n@NotNull ：设置数据库表当前列不能为空 。\n@Transient ：添加次标记之后不会生成数据库表的列。标记要从持久性中排除的属性。将它们用于临时状态等。或者，您也可以使用Java中的transient关键字。\n索引注解\n@Index：使用@Index作为一个属性来创建一个索引，通过name设置索引别名，也可以通过unique给索引添加约束。\n@Unique：向索引添加UNIQUE约束，强制所有值都是唯一的。\n123456789@Entitypublic class Student &#123;    @Id(autoincrement = true)    Long id;    @Property(nameInDb=&quot;name&quot;)    @Index(unique = true)     String name;    ……&#125;\n注意： 上面这种情况，约定name为唯一值，向数据库中通过insert方法继续添加已存在的name数据，会抛异常：\n123410-08 20:59:46.274 31939-31939/com.example.aserbao.aserbaosandroid E/AndroidRuntime: FATAL EXCEPTION: main    Process: com.example.aserbao.aserbaosandroid, PID: 31939    android.database.sqlite.SQLiteConstraintException: UNIQUE constraint failed: STUDENT.name (Sqlite code 2067), (OS error - 2:No such file or directory)    ……\n若使用insertOrReplace()方法添加数据，当前数据库中不会有重复的数据，但是重复的这条数据的id会被修改！若项目中有用到id字段进行排序的话，这一点需要特别注意。\n关系注解\n关系型注解GreenDao中主要就两个：\n\n@ToOne：定义与另一个实体（一个实体对象）的关系\n@ToMany：定义与多个实体对象的关系\n至于如何使用，我们马上就讲。\n\n一对一，一对多，多对多关系表的创建\n平常项目中，我们经常会使用到多表关联，如文章开头所说的数据库表结构设置的那样！接下来我们来讲如何通过GreenDao实现多表关联。\n一对一\n一个学生对应一个身份证号:\n做法：\n\n我们在Student中设置一个注解@ToOne(joinProperty = “name”)\n在创建Student的时候，将对应的数据传递给IdCard;\n\n代码部分：\n学生Student代码：\n1234567891011121314151617@Entitypublic class Student &#123;    @Id(autoincrement = true)    Long id;    @Unique    int studentNo;//学号    int age; //年龄    String telPhone;//手机号    String sex; //性别    String name;//姓名    String address;//家庭住址    String schoolName;//学校名字    String grade;//几年级    @ToOne(joinProperty = &quot;name&quot;)    IdCard student;    ……getter and setter ……&#125;\n身份证IdCard代码：\n12345678@Entitypublic class IdCard &#123;    @Id     String userName;//用户名    @Unique    String idNo;//身份证号       ……getter and setter ……&#125;\ninsert一组数据：\n12345678910111213141516171819202122232425public void addStudent()&#123;    DaoSession daoSession = ((AserbaoApplication) getApplication()).getDaoSession();    Student student = new Student();    student.setStudentNo(i);    int age = mRandom.nextInt(10) + 10;    student.setAge(age);    student.setTelPhone(RandomValue.getTel());    String chineseName = RandomValue.getChineseName();    student.setName(chineseName);    if (i % 2 == 0) &#123;        student.setSex(&quot;男&quot;);    &#125; else &#123;        student.setSex(&quot;女&quot;);    &#125;    student.setAddress(RandomValue.getRoad());    student.setGrade(String.valueOf(age % 10) + &quot;年纪&quot;);    student.setSchoolName(RandomValue.getSchoolName());    daoSession.insert(student);        //插入对应的IdCard数据    IdCard idCard = new IdCard();    idCard.setUserName(userName);    idCard.setIdNo(RandomValue.getRandomID());    daoSession.insert(idCard);      &#125;\nok,数据可以了！现在数据库表插入完成了。\n一对多\n一个人拥有多个信用卡\n做法：\n\n在我们在Student中设置@ToMany(referencedJoinProperty = “studentId”);\n我们在CreditCard中设置编写对应的id主键；\n\nStudent的代码：\n1234567891011121314151617181920@Entitypublic class Student &#123;    @Id(autoincrement = true)    Long id;    @Unique    int studentNo;//学号    int age; //年龄    String telPhone;//手机号    String sex; //性别    String name;//姓名    String address;//家庭住址    String schoolName;//学校名字    String grade;//几年级        @ToMany(referencedJoinProperty = &quot;studentId) // 这个studentId是对应在CreditCard中的studentId    List&lt;CreditCard&gt; creditCardsList;      ……getter and setter ……    &#125;\nCreditCard的代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Entitypublic class CreditCard &#123;    @Id    Long id;    Long studentId;    Long teacherId;    String userName;//持有者名字    String cardNum;//卡号    String whichBank;//哪个银行的    int cardType;//卡等级，分类 0 ~ 5     ……getter and setter ……    &#125;```    添加数据代码：```javapublic void addStudent()&#123;    DaoSession daoSession = ((AserbaoApplication) getApplication()).getDaoSession();    Student student = new Student();    student.setStudentNo(i);    int age = mRandom.nextInt(10) + 10;    student.setAge(age);    student.setTelPhone(RandomValue.getTel());    String chineseName = RandomValue.getChineseName();    student.setName(chineseName);    if (i % 2 == 0) &#123;        student.setSex(&quot;男&quot;);    &#125; else &#123;        student.setSex(&quot;女&quot;);    &#125;    student.setAddress(RandomValue.getRoad());    student.setGrade(String.valueOf(age % 10) + &quot;年纪&quot;);    student.setSchoolName(RandomValue.getSchoolName());    daoSession.insert(student);        //插入对应的CreditCard数据    for (int j = 0; j &lt; random.nextInt(5) + 1 ; j++) &#123;    CreditCard creditCard = new CreditCard();    creditCard.setUserId(id);    creditCard.setUserName(userName);    creditCard.setCardNum(String.valueOf(random.nextInt(899999999) + 100000000) + String.valueOf(random.nextInt(899999999) + 100000000));    creditCard.setWhichBank(RandomValue.getBankName());    creditCard.setCardType(random.nextInt(10));    daoSession.insert(creditCard);    &#125;&#125;```      ### 多对多一个学生有多个老师，老师有多个学生。做法：我们需要创建一个学生老师管理器(StudentAndTeacherBean)，用来对应学生和老师的ID;我们需要在学生对象中，添加注解：```java@ToMany@JoinEntity(entity = StudentAndTeacherBean.class,sourceProperty = &quot;studentId&quot;,targetProperty = &quot;teacherId&quot;)List&lt;Teacher&gt; teacherList;\n我们需要在老师对象中，添加注解：@ToMany\n12@JoinEntity(entity = StudentAndTeacherBean.class,sourceProperty = &quot;teacherId&quot;,targetProperty = &quot;studentId&quot;)  List&lt;Student&gt; studentList;\nStudentAndTeacherBean代码：\n12345678@Entitypublic class StudentAndTeacherBean &#123;    @Id(autoincrement = true)    Long id;    Long studentId;//学生ID    Long teacherId;//老师ID    ……getter and setter ……&#125;\nStudent 代码：\n123456789101112131415161718@Entitypublic class Student &#123;    @Id(autoincrement = true)    Long id;    @Unique    int studentNo;//学号    int age; //年龄    String telPhone;//手机号    String sex; //性别    String name;//姓名    String address;//家庭住址    String schoolName;//学校名字    String grade;//几年级    @ToMany    @JoinEntity(entity = StudentAndTeacherBean.class,sourceProperty = &quot;studentId&quot;,targetProperty = &quot;teacherId&quot;)    List&lt;Teacher&gt; teacherList;        ……getter and setter ……    &#125;\nTeacher代码：\n123456789101112131415161718@Entitypublic class Teacher &#123;    @Id(autoincrement = true)    Long id;    @Unique    int teacherNo;//职工号    int age; //年龄    String sex; //性别    String telPhone;    String name;//姓名    String schoolName;//学校名字    String subject;//科目    @ToMany    @JoinEntity(entity = StudentAndTeacherBean.class,sourceProperty = &quot;teacherId&quot;,targetProperty = &quot;studentId&quot;)    List&lt;Student&gt; studentList;  ……getter and setter ……&#125;\n数据添加：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public void addData()&#123;    Student student = new Student();    student.setStudentNo(i);    int age = mRandom.nextInt(10) + 10;    student.setAge(age);    student.setTelPhone(RandomValue.getTel());    String chineseName = RandomValue.getChineseName();    student.setName(chineseName);    if (i % 2 == 0) &#123;        student.setSex(&quot;男&quot;);    &#125; else &#123;        student.setSex(&quot;女&quot;);    &#125;    student.setAddress(RandomValue.getRoad());    student.setGrade(String.valueOf(age % 10) + &quot;年纪&quot;);    student.setSchoolName(RandomValue.getSchoolName());    daoSession.insert(student);    Collections.shuffle(teacherList);    for (int j = 0; j &lt; mRandom.nextInt(8) + 1; j++) &#123;        if(j &lt; teacherList.size())&#123;            Teacher teacher = teacherList.get(j);            StudentAndTeacherBean teacherBean = new StudentAndTeacherBean(student.getId(), teacher.getId());            daoSession.insert(teacherBean);        &#125;    &#125;&#125;```                        好了，成功;## 数据库的升级GreenDao的OpenHelper下有个 onUpgrade(Database db, int oldVersion, int newVersion)方法，当设置的数据库版本改变时，在数据库初始化的时候就会回调到这个方法，我们可以通过继承OpenHelper重写onUpgrade方法来实现数据库更新操作：GreenDao的升级思路：- 创建临时表TMP_,复制原来的数据库到临时表中；- 删除之前的原表；- 创建新表；- 将临时表中的数据复制到新表中，最后将TMP_表删除掉；ok,思路就是这样， 总共两个类： 一个MyDaoMaster(OpenHelper继承类)，一个MigrationHelper(数据库操作类) 下面是代码编写：修改Application中的DaoMaster的创建：```java        MyDaoMaster helper = new MyDaoMaster(this, &quot;aserbaos.db&quot;);//      DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(this, &quot;aserbao.db&quot;);        SQLiteDatabase db = helper.getWritableDatabase();        DaoMaster daoMaster = new DaoMaster(db);        daoSession = daoMaster.newSession();\nMyDaoMaster代码:\n1234567891011121314151617181920212223242526public class MyDaoMaster extends OpenHelper &#123;    private static final String TAG = &quot;MyDaoMaster&quot;;    public MyDaoMaster(Context context, String name) &#123;        super(context, name);    &#125;    public MyDaoMaster(Context context, String name, SQLiteDatabase.CursorFactory factory) &#123;        super(context, name, factory);    &#125;    @Override    public void onUpgrade(Database db, int oldVersion, int newVersion) &#123;        super.onUpgrade(db, oldVersion, newVersion);        MigrationHelper.migrate(db, new MigrationHelper.ReCreateAllTableListener() &#123;            @Override            public void onCreateAllTables(Database db, boolean ifNotExists) &#123;                DaoMaster.createAllTables(db, ifNotExists);            &#125;            @Override            public void onDropAllTables(Database db, boolean ifExists) &#123;                DaoMaster.dropAllTables(db, ifExists);            &#125;        &#125;,ThingDao.class);        Log.e(TAG, &quot;onUpgrade: &quot; + oldVersion + &quot; newVersion = &quot; + newVersion);    &#125;&#125;\nMigrationHelper 代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289public final class MigrationHelper &#123;    public static boolean DEBUG = false;    private static String TAG = &quot;MigrationHelper&quot;;    private static final String SQLITE_MASTER = &quot;sqlite_master&quot;;    private static final String SQLITE_TEMP_MASTER = &quot;sqlite_temp_master&quot;;    private static WeakReference&lt;ReCreateAllTableListener&gt; weakListener;    public interface ReCreateAllTableListener&#123;        void onCreateAllTables(Database db, boolean ifNotExists);        void onDropAllTables(Database db, boolean ifExists);    &#125;    public static void migrate(SQLiteDatabase db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;        printLog(&quot;【The Old Database Version】&quot; + db.getVersion());        Database database = new StandardDatabase(db);        migrate(database, daoClasses);    &#125;    public static void migrate(SQLiteDatabase db, ReCreateAllTableListener listener, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;        weakListener = new WeakReference&lt;&gt;(listener);        migrate(db, daoClasses);    &#125;    public static void migrate(Database database, ReCreateAllTableListener listener, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;        weakListener = new WeakReference&lt;&gt;(listener);        migrate(database, daoClasses);    &#125;    public static void migrate(Database database, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;        printLog(&quot;【Generate temp table】start&quot;);        generateTempTables(database, daoClasses);        printLog(&quot;【Generate temp table】complete&quot;);        ReCreateAllTableListener listener = null;        if (weakListener != null) &#123;            listener = weakListener.get();        &#125;        if (listener != null) &#123;            listener.onDropAllTables(database, true);            printLog(&quot;【Drop all table by listener】&quot;);            listener.onCreateAllTables(database, false);            printLog(&quot;【Create all table by listener】&quot;);        &#125; else &#123;            dropAllTables(database, true, daoClasses);            createAllTables(database, false, daoClasses);        &#125;        printLog(&quot;【Restore data】start&quot;);        restoreData(database, daoClasses);        printLog(&quot;【Restore data】complete&quot;);    &#125;    private static void generateTempTables(Database db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;        for (int i = 0; i &lt; daoClasses.length; i++) &#123;            String tempTableName = null;            DaoConfig daoConfig = new DaoConfig(db, daoClasses[i]);            String tableName = daoConfig.tablename;            if (!isTableExists(db, false, tableName)) &#123;                printLog(&quot;【New Table】&quot; + tableName);                continue;            &#125;            try &#123;                tempTableName = daoConfig.tablename.concat(&quot;_TEMP&quot;);                StringBuilder dropTableStringBuilder = new StringBuilder();                dropTableStringBuilder.append(&quot;DROP TABLE IF EXISTS &quot;).append(tempTableName).append(&quot;;&quot;);                db.execSQL(dropTableStringBuilder.toString());                StringBuilder insertTableStringBuilder = new StringBuilder();                insertTableStringBuilder.append(&quot;CREATE TEMPORARY TABLE &quot;).append(tempTableName);                insertTableStringBuilder.append(&quot; AS SELECT * FROM &quot;).append(tableName).append(&quot;;&quot;);                db.execSQL(insertTableStringBuilder.toString());                printLog(&quot;【Table】&quot; + tableName +&quot;\\n ---Columns--&gt;&quot;+getColumnsStr(daoConfig));                printLog(&quot;【Generate temp table】&quot; + tempTableName);            &#125; catch (SQLException e) &#123;                Log.e(TAG, &quot;【Failed to generate temp table】&quot; + tempTableName, e);            &#125;        &#125;    &#125;    private static boolean isTableExists(Database db, boolean isTemp, String tableName) &#123;        if (db == null || TextUtils.isEmpty(tableName)) &#123;            return false;        &#125;        String dbName = isTemp ? SQLITE_TEMP_MASTER : SQLITE_MASTER;        String sql = &quot;SELECT COUNT(*) FROM &quot; + dbName + &quot; WHERE type = ? AND name = ?&quot;;        Cursor cursor=null;        int count = 0;        try &#123;            cursor = db.rawQuery(sql, new String[]&#123;&quot;table&quot;, tableName&#125;);            if (cursor == null || !cursor.moveToFirst()) &#123;                return false;            &#125;            count = cursor.getInt(0);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (cursor != null)                cursor.close();        &#125;        return count &gt; 0;    &#125;    private static String getColumnsStr(DaoConfig daoConfig) &#123;        if (daoConfig == null) &#123;            return &quot;no columns&quot;;        &#125;        StringBuilder builder = new StringBuilder();        for (int i = 0; i &lt; daoConfig.allColumns.length; i++) &#123;            builder.append(daoConfig.allColumns[i]);            builder.append(&quot;,&quot;);        &#125;        if (builder.length() &gt; 0) &#123;            builder.deleteCharAt(builder.length() - 1);        &#125;        return builder.toString();    &#125;    private static void dropAllTables(Database db, boolean ifExists, @NonNull Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;        reflectMethod(db, &quot;dropTable&quot;, ifExists, daoClasses);        printLog(&quot;【Drop all table by reflect】&quot;);    &#125;    private static void createAllTables(Database db, boolean ifNotExists, @NonNull Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;        reflectMethod(db, &quot;createTable&quot;, ifNotExists, daoClasses);        printLog(&quot;【Create all table by reflect】&quot;);    &#125;    /**     * dao class already define the sql exec method, so just invoke it     */    private static void reflectMethod(Database db, String methodName, boolean isExists, @NonNull Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;        if (daoClasses.length &lt; 1) &#123;            return;        &#125;        try &#123;            for (Class cls : daoClasses) &#123;                Method method = cls.getDeclaredMethod(methodName, Database.class, boolean.class);                method.invoke(null, db, isExists);            &#125;        &#125; catch (NoSuchMethodException e) &#123;            e.printStackTrace();        &#125; catch (InvocationTargetException e) &#123;            e.printStackTrace();        &#125; catch (IllegalAccessException e) &#123;            e.printStackTrace();        &#125;    &#125;    private static void restoreData(Database db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123;        for (int i = 0; i &lt; daoClasses.length; i++) &#123;            DaoConfig daoConfig = new DaoConfig(db, daoClasses[i]);            String tableName = daoConfig.tablename;            String tempTableName = daoConfig.tablename.concat(&quot;_TEMP&quot;);            if (!isTableExists(db, true, tempTableName)) &#123;                continue;            &#125;            try &#123;                // get all columns from tempTable, take careful to use the columns list                List&lt;TableInfo&gt; newTableInfos = TableInfo.getTableInfo(db, tableName);                List&lt;TableInfo&gt; tempTableInfos = TableInfo.getTableInfo(db, tempTableName);                ArrayList&lt;String&gt; selectColumns = new ArrayList&lt;&gt;(newTableInfos.size());                ArrayList&lt;String&gt; intoColumns = new ArrayList&lt;&gt;(newTableInfos.size());                for (TableInfo tableInfo : tempTableInfos) &#123;                    if (newTableInfos.contains(tableInfo)) &#123;                        String column = &#x27;`&#x27; + tableInfo.name + &#x27;`&#x27;;                        intoColumns.add(column);                        selectColumns.add(column);                    &#125;                &#125;                // NOT NULL columns list                for (TableInfo tableInfo : newTableInfos) &#123;                    if (tableInfo.notnull &amp;&amp; !tempTableInfos.contains(tableInfo)) &#123;                        String column = &#x27;`&#x27; + tableInfo.name + &#x27;`&#x27;;                        intoColumns.add(column);                        String value;                        if (tableInfo.dfltValue != null) &#123;                            value = &quot;&#x27;&quot; + tableInfo.dfltValue + &quot;&#x27; AS &quot;;                        &#125; else &#123;                            value = &quot;&#x27;&#x27; AS &quot;;                        &#125;                        selectColumns.add(value + column);                    &#125;                &#125;                if (intoColumns.size() != 0) &#123;                    StringBuilder insertTableStringBuilder = new StringBuilder();                    insertTableStringBuilder.append(&quot;REPLACE INTO &quot;).append(tableName).append(&quot; (&quot;);                    insertTableStringBuilder.append(TextUtils.join(&quot;,&quot;, intoColumns));                    insertTableStringBuilder.append(&quot;) SELECT &quot;);                    insertTableStringBuilder.append(TextUtils.join(&quot;,&quot;, selectColumns));                    insertTableStringBuilder.append(&quot; FROM &quot;).append(tempTableName).append(&quot;;&quot;);                    db.execSQL(insertTableStringBuilder.toString());                    printLog(&quot;【Restore data】 to &quot; + tableName);                &#125;                StringBuilder dropTableStringBuilder = new StringBuilder();                dropTableStringBuilder.append(&quot;DROP TABLE &quot;).append(tempTableName);                db.execSQL(dropTableStringBuilder.toString());                printLog(&quot;【Drop temp table】&quot; + tempTableName);            &#125; catch (SQLException e) &#123;                Log.e(TAG, &quot;【Failed to restore data from temp table 】&quot; + tempTableName, e);            &#125;        &#125;    &#125;    private static List&lt;String&gt; getColumns(Database db, String tableName) &#123;        List&lt;String&gt; columns = null;        Cursor cursor = null;        try &#123;            cursor = db.rawQuery(&quot;SELECT * FROM &quot; + tableName + &quot; limit 0&quot;, null);            if (null != cursor &amp;&amp; cursor.getColumnCount() &gt; 0) &#123;                columns = Arrays.asList(cursor.getColumnNames());            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (cursor != null)                cursor.close();            if (null == columns)                columns = new ArrayList&lt;&gt;();        &#125;        return columns;    &#125;    private static void printLog(String info)&#123;        if(DEBUG)&#123;            Log.d(TAG, info);        &#125;    &#125;    private static class TableInfo &#123;        int cid;        String name;        String type;        boolean notnull;        String dfltValue;        boolean pk;        @Override        public boolean equals(Object o) &#123;            return this == o                    || o != null                    &amp;&amp; getClass() == o.getClass()                    &amp;&amp; name.equals(((TableInfo) o).name);        &#125;        @Override        public String toString() &#123;            return &quot;TableInfo&#123;&quot; +                    &quot;cid=&quot; + cid +                    &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                    &quot;, type=&#x27;&quot; + type + &#x27;\\&#x27;&#x27; +                    &quot;, notnull=&quot; + notnull +                    &quot;, dfltValue=&#x27;&quot; + dfltValue + &#x27;\\&#x27;&#x27; +                    &quot;, pk=&quot; + pk +                    &#x27;&#125;&#x27;;        &#125;        private static List&lt;TableInfo&gt; getTableInfo(Database db, String tableName) &#123;            String sql = &quot;PRAGMA table_info(&quot; + tableName + &quot;)&quot;;            printLog(sql);            Cursor cursor = db.rawQuery(sql, null);            if (cursor == null)                return new ArrayList&lt;&gt;();            TableInfo tableInfo;            List&lt;TableInfo&gt; tableInfos = new ArrayList&lt;&gt;();            while (cursor.moveToNext()) &#123;                tableInfo = new TableInfo();                tableInfo.cid = cursor.getInt(0);                tableInfo.name = cursor.getString(1);                tableInfo.type = cursor.getString(2);                tableInfo.notnull = cursor.getInt(3) == 1;                tableInfo.dfltValue = cursor.getString(4);                tableInfo.pk = cursor.getInt(5) == 1;                tableInfos.add(tableInfo);                // printLog(tableName + &quot;：&quot; + tableInfo);            &#125;            cursor.close();            return tableInfos;        &#125;    &#125;&#125;\nGreenDao数据库加密\n开发中对于存储于数据库中的敏感数据，我们可以通过对数据库加密来进行保护。GreenDao可以通过SQLCipher来进行加密处理。下面我们简单讲解下加密过程：\n步骤：\n\n导入加密库文件： 1implementation &#x27;net.zetetic:android-database-sqlcipher:3.5.6&#x27;\n\n修改DaoSession的生成方式： 123456//       MyDaoMaster helper = new MyDaoMaster(this, &quot;aserbaos.db&quot;);  //数据库升级写法        DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(this, &quot;aserbao.db&quot;);        //SQLiteDatabase db = helper.getWritableDatabase(); //不加密的写法        Database db = helper.getEncryptedWritableDb(&quot;aserbao&quot;); //数据库加密密码为“aserbao&quot;的写法        DaoMaster daoMaster = new DaoMaster(db);        daoSession = daoMaster.newSession();\n\n\n项目地址\nAserbaosAndroid\n当前文章所有代码在AserbaosAndroid/app/src/main/java/com/aserbao/aserbaosandroid/functions/database/greenDao/relation目录下；\n参考博客\n\nAndroid ORM 框架：GreenDao 使用详解\nAndroid数据存储之GreenDao 3.0 详解\n拆轮子系列之GreenDao框架原理分析\n\n修改记录\n\n\nCreditCard中不能只使用一个useId来做关联，因为我这里Teacher和Student都和CreditCard是一对多关系，所以我们需要建两个对应关系字段。为了分辨添加了studentId和teacherId。\n 1234567891011@Entitypublic class CreditCard &#123;    @Id    Long id;    Long studentId;    Long teacherId;    String userName;//持有者名字    String cardNum;//卡号    String whichBank;//哪个银行的    int cardType;//卡等级，分类 0 ~ 5&#125;\n\n\nStudent中的@ToMany（referencedJoinProperty =“id”）这个id对应的是CreditCard中的studentId，不是自增Id。（问题由@山豆几_提出，感谢）\n修改后的代码应该是：\n 12@ToMany(referencedJoinProperty = &quot;studentId&quot;)    List&lt;CreditCard&gt; creditCardsList;\n\n\n扩展\ngreendao官方已经做的很不错了，但是针对项目开发我们还要写很多东西，项目开发注重的是模块化和组件化，因此这里有另外一篇专门针对greendao处理业务做了一个封装《DataBase 数据库整理（greenDao示例）》，可以作为参考，我自己的项目则是额外在此基础上又封了一层，业务和API之间做到完全隔离，前边说到greendao已经不再维护了，官方将重心移到了ObjectBox上，我这样做也是方便后期更容易的更替。\n","plink":"https://blog.ixin.run/posts/1563884419/"},{"title":"对象拷贝性能对比分析","date":"2019-07-20T04:30:09.000Z","date_formatted":{"ll":"2019年7月20日","L":"2019/07/20","MM-DD":"07-20"},"updated":"2021-01-29T12:51:44.651Z","content":"对象拷贝可分为浅拷贝和深拷贝，在开发过程中深拷贝不是随处可见，大部分是引用的赋值，也即是内存地址的引用。如果简单的类似Student studen1 = student0这样便认为复制了一份，这就大错特错了，有些时候你会莫名的发现studen1没有任何操作里面的属性却发生变化了，不用说一定是student0在某个时候被修改了，因为这两个对象引用的是一个地址的内容。开发过程中，因为嵌套过深，对象中转过多，着实需要小心。\n真正的拷贝是完全复制一份，从而与原对象隔离开，保证了原对象的定格，从而在操作过程中不用担心原对象被修改，必要时可“一键还原”。\n\n什么是浅拷贝？什么是深拷贝？\n先了解一个基础知识：堆内存和栈内存。\n针对变量，栈内存上分配一些基本类型的变量与对象的引用，而堆内存分配给真正的对象本身以及数组等，堆内存上的数据由栈内存上的相应变量引用，相当于栈中存储着堆内存中实际对象或数组的标记或别名（实际上是堆内存变量首地址）。这里包含两部分：一个是基本数据类型，一个是引用数据类型，浅拷贝和深拷贝就是在这个基础之上做的区分。\n假如在拷贝这个对象的时候，只对基本数据类型进行了拷贝，而对引用数据类型只是进行了引用的传递，而没有真实的创建一个新的对象，则认为是浅拷贝。反之，在对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量，则认为是深拷贝。\n简单的说：不能拷贝完全的就是浅拷贝，能够完完全全复制一份的叫深拷贝。\n浅拷贝：\n\n对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。\n深拷贝：\n\n对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。\nAndroid常见的拷贝方式\nAndroid开发常见的拷贝方式总结大概有以下六种：\n\n对象属性相互赋值\nSerializable\nParcelable\nGson\nCloneable\nMapstruct\n\n对象的相互赋值\n对象属性相互赋值这个是最普通也是操作最笨重的，就是两个对象所有属性相互赋值，从而实现对象的拷贝；注意前边说的是操作最笨重的，但是如果从性能和执行效率上考虑应该是最快的，因为免去了其他额外的开销直接从最基本入手。\n123456789101112Student student = new Student();student.setAge(11);student.setName(&quot;小明&quot;);Classmate classmate = new Classmate();classmate.setAge(12);classmate.setName(&quot;张三&quot;);student.setClassmates(classmate);Student studen1 = new Student();studen1.setAge(student.getAge());studen1.setName(student.getName());studen1.setClassmates(student.getClassmate());\n细心的同学看到上边有一个引用类型classmate，前边已经说过如果对引用数据类型只是进行了引用的传递，而没有真实的创建一个新的对象，则认为是浅拷贝。那么深拷贝应该如何操作呢？\n1234567student1 = new Student();student1.setName(student.getName());student1.setAge(student.getAge());Classmate classmate1 = new Classmate();classmate1.setName(student.getClassmates().getName());classmate1.setAge(student.getClassmates().getAge());student1.setClassmates(classmate1);\n如上把studen的Classmate各个属性值重新拼装成一个对象然后存入stuent1中，充分将student中的各个属性做一个拷贝过程，算是一个深拷贝。\nSerializable\nSerializable实现拷贝过程原理是将对象序列化成二进制流到本地硬盘，然后在反序列化成对象，因此整个过程不存在某个引用类型共同指向问题，因此整个拷贝过程都属于深拷贝。需要注意的是拷贝的对象包括其内部引用类型的属性对象都要实现Serializable接口。\n123456789101112131415161718192021/** * 对象拷贝，传入和返回的T必须是serializable类型。 * 将对象序列化成流,因为写在流里的是对象的一个拷贝，而原对象仍然存在于JVM里面。所以利用这个特性可以实现对象的深拷贝。 */public static &lt;T extends Serializable&gt; T sCopy(T object) &#123;    try &#123;        //将对象写到流里        ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(object);        //从流里读出对象        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());        ObjectInputStream ois = new ObjectInputStream(bais);        return (T) ois.readObject();    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125; catch (ClassNotFoundException e) &#123;        e.printStackTrace();    &#125;    return null;&#125;\nParcelable\nParcelable实现拷贝过程的原理和Serializable如出一辙，Parcelable和Serializable的区别是一个序列化时的状态的保存，前者仅仅是保存在内存中，后者保存在硬盘中，因此前者性能更快，这也是android序列化所推荐的。因此Parcelable的拷贝过程也是深拷贝，所拷贝的对象以及引用类型的属性对象都要实现Parcelable接口。\n12345678910111213141516171819/** * 对象拷贝，传入的对象是Parcelable类型。 */public static &lt;T extends Parcelable&gt; T pCopy(T object) &#123;    Parcel parcel = null;    try &#123;        parcel = Parcel.obtain();        parcel.writeParcelable(object, 0);        parcel.setDataPosition(0);        return parcel.readParcelable(object.getClass().getClassLoader());    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125; finally &#123;        if (parcel != null) &#123;            parcel.recycle();        &#125;    &#125;    return null;&#125;\nGson\nGson拷贝的原理同样是序列化和反序列的过程，和Serializable是类似的，只不过Gson仅仅是序列化成json格式，并且不保存对象的相关方法和状态（反序列化时需要指定相应的对象类型），因此相比Serializable性能更优。使用时需要Gson相关依赖。\n123456/** * Gson copy */public static &lt;T, S&gt; T gCopy(S source, Class&lt;T&gt; targetType) &#123;    return sGson.fromJson(sGson.toJson(source), targetType);&#125;\nCloneable\nCloneable拷贝是java对象固有的功能，每个实体类中父类Object中都有一个clone方法，专门用于本类的拷贝工作的。采用Cloneable拷贝需要实体类中实现Cloneable接口，并且要重写Object中的clone方法。\n12345678910111213141516171819202122232425262728293031323334353637public class Student implements Cloneable &#123;    private String name;    private int age;    private Classmate classmates;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public Classmate getClassmates() &#123;        return classmates;    &#125;    public void setClassmates(Classmate classmates) &#123;        this.classmates = classmates;    &#125;    @Override    protected Object clone() throws CloneNotSupportedException &#123;        Student student = (Student) super.clone();        student.classmates = (Classmate) this.classmates.clone();        return student;    &#125;&#125;\n注意观察Student中引用型属性对象classmates，重写的clone方法中如果仅仅是对Studen对象进行clone，而不对classmates进行clone的话则属于浅拷贝。这里我们需要深拷贝，所以需要针对Student中的所有引用型属性对象做一个clone（这里指classmates）。依次类推Classmate同样实现Cloneable，同样需要重写clone方法。\n12345678910111213141516171819202122232425public class Classmate implements Cloneable &#123;    private String name;    private int age;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    @Override    protected Object clone() throws CloneNotSupportedException &#123;        return super.clone();    &#125;&#125;\nClassmate实体类中没有引用型属性对象了，所以重写的clone方法里面仅仅返回父类的clone()方法即可。\nMapstruct\nMapStruct是一种类型安全的bean映射类生成java注释处理器。\n我们要做的就是定义一个映射器接口，声明必需的映射方法。在编译的过程中，MapStruct会生成此接口的实现。该实现使用纯java方法调用的源和目标对象之间的映射，MapStruct节省了时间，通过生成代码完成繁琐和容易出错的代码逻辑。这里巧妙借助一下其映射功能实现类的拷贝，其拷贝原理和对象属性相互赋值相同。\nandroid中使用Mapstruct需要在build.gradle中引入Mapstruct的相关依赖：\n123//模型映射implementation &#x27;org.mapstruct:mapstruct:1.2.0.Final&#x27;annotationProcessor &#x27;org.mapstruct:mapstruct-processor:1.2.0.Final&#x27;\n使用也很简单，只需要自定义一个Mapstruct接口，在编译时会根绝注解自动生成相关代码方法。\n12345678@Mapperpublic interface MapStructCopy &#123;    MapStructCopy INSTANCE = Mappers.getMapper(MapStructCopy.class);        Student copy(Student t);    Classmate copy(Classmate c);    &#125;\n这里需要注意的是，如果仅仅定义Student的映射方法，则同样属于浅拷贝，因为Classmate属于Student中的一个引用型对象属性，所以需要在自定义接口中定义一个属于Classmate的映射方法；来覆盖Student中属性映射。接下来就可以对Student对象拷贝了。\n1Student student = MapStructCopy.INSTANCE.copy(student);\n性能对比\n下边通过一个例子来对比以上各个拷贝的性能做一个分析对比。\n假设这里有一个Student类，包含名字、年龄、同学Classmate（名字，年龄），这里做两个功能：\n\n分别对上边的各个方法拷贝一万次，观察各个耗时。\n修改拷贝对象属性值，查看原对象属性值是否变化，来验证是深拷贝还是浅拷贝。\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class Student implements Serializable, Parcelable, Cloneable &#123;    private String name;    private int age;    private Classmate classmates;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public Classmate getClassmates() &#123;        return classmates;    &#125;    public void setClassmates(Classmate classmates) &#123;        this.classmates = classmates;    &#125;    @Override    public int describeContents() &#123;        return 0;    &#125;    @Override    public void writeToParcel(Parcel dest, int flags) &#123;        dest.writeString(this.name);        dest.writeInt(this.age);        dest.writeParcelable(this.classmates, flags);    &#125;    public Student() &#123;    &#125;    protected Student(Parcel in) &#123;        this.name = in.readString();        this.age = in.readInt();        this.classmates = in.readParcelable(Classmate.class.getClassLoader());    &#125;    public static final Parcelable.Creator&lt;Student&gt; CREATOR = new Parcelable.Creator&lt;Student&gt;() &#123;        @Override        public Student createFromParcel(Parcel source) &#123;            return new Student(source);        &#125;        @Override        public Student[] newArray(int size) &#123;            return new Student[size];        &#125;    &#125;;    @Override    protected Object clone() throws CloneNotSupportedException &#123;        Student student = (Student) super.clone();        student.classmates = (Classmate) this.classmates.clone();        return student;    &#125;&#125;\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Classmate implements Serializable, Parcelable, Cloneable &#123;    private String name;    private int age;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    @Override    public int describeContents() &#123;        return 0;    &#125;    @Override    public void writeToParcel(Parcel dest, int flags) &#123;        dest.writeString(this.name);        dest.writeInt(this.age);    &#125;    public Classmate() &#123;    &#125;    protected Classmate(Parcel in) &#123;        this.name = in.readString();        this.age = in.readInt();    &#125;    public static final Parcelable.Creator&lt;Classmate&gt; CREATOR = new Parcelable.Creator&lt;Classmate&gt;() &#123;        @Override        public Classmate createFromParcel(Parcel source) &#123;            return new Classmate(source);        &#125;        @Override        public Classmate[] newArray(int size) &#123;            return new Classmate[size];        &#125;    &#125;;    @Override    protected Object clone() throws CloneNotSupportedException &#123;        return super.clone();    &#125;&#125;\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public class MainActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        test();    &#125;    private void test() &#123;        ExecutorService executorService = Executors.newSingleThreadExecutor();        executorService.execute(new Runnable() &#123;            @Override            public void run() &#123;                Student student = new Student();                student.setAge(11);                student.setName(&quot;小明&quot;);                Classmate classmate = new Classmate();                classmate.setAge(12);                classmate.setName(&quot;张三&quot;);                student.setClassmates(classmate);                Student student1 = null;                long last;                int count = 10000;                Log.e(&quot;TAG&quot;,&quot;+++++++++++++++++开始&quot;);                try &#123;                    last = System.currentTimeMillis();                    for (int i = 0; i &lt; count; i++) &#123;                        student1 = new Student();                        student1.setName(student.getName());                        student1.setAge(student.getAge());                        Classmate classmate1 = new Classmate();                        classmate1.setName(student.getClassmates().getName());                        classmate1.setAge(student.getClassmates().getAge());                        student1.setClassmates(classmate1);                    &#125;                    log(&quot;Normal&quot;, last, student1, student);                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;                try &#123;                    last = System.currentTimeMillis();                    for (int i = 0; i &lt; count; i++) &#123;                        student1 = CopyUtil.sCopy(student);                    &#125;                    log(&quot;Serializable&quot;, last, student1, student);                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;                try &#123;                    last = System.currentTimeMillis();                    for (int i = 0; i &lt; count; i++) &#123;                        student1 = CopyUtil.pCopy(student);                    &#125;                    log(&quot;Parcelable&quot;, last, student1, student);                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;                try &#123;                    last = System.currentTimeMillis();                    for (int i = 0; i &lt; count; i++) &#123;                        student1 = CopyUtil.gCopy(student, Student.class);                    &#125;                    log(&quot;Gson&quot;, last, student1, student);                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;                try &#123;                    last = System.currentTimeMillis();                    for (int i = 0; i &lt; count; i++) &#123;                        student1 = (Student) student.clone();                    &#125;                    log(&quot;Cloneable&quot;, last, student1, student);                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;                try &#123;                    last = System.currentTimeMillis();                    for (int i = 0; i &lt; count; i++) &#123;                        student1 = MapStructCopy.INSTANCE.copy(student);                    &#125;                    log(&quot;MapStruct&quot;, last, student1, student);                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;);    &#125;    private void log(String tag, long lastTime, Student targetBean, Student resouceBean) &#123;        Log.e(&quot;TAG&quot;, &quot;+++++&quot; + tag+&quot;+++++&quot;);        Log.e(&quot;TAG&quot;, &quot;耗时：&quot; + (System.currentTimeMillis() - lastTime)                + &quot;  student hash:&quot; + (targetBean.hashCode() == resouceBean.hashCode())                + &quot;  classmate hash:&quot; + (targetBean.getClassmates().hashCode() == resouceBean.getClassmates().hashCode()));        Log.e(&quot;TAG&quot;, &quot;student1 name:&quot; + targetBean.getName()+&quot;  classmate1 name:&quot; + targetBean.getClassmates().getName());        targetBean.setName(&quot;王五&quot;);        targetBean.getClassmates().setName(&quot;赵六&quot;);        Log.e(&quot;TAG&quot;, &quot;student name:&quot; + resouceBean.getName()+&quot;  classmate name:&quot; + resouceBean.getClassmates().getName());    &#125;&#125;\n打印结果如下：\n\n根据打印结果可以得出一个性能对比队列：\nCloneable &gt; Normal = MapStruct &gt; parcelable &gt; Serializable = Gson\n这个结果也是合乎常理的，前面已经着重针对每种拷贝原理做了分析，不用说凡是内存上操作的肯定优于硬盘上操作的。\n如果根据操作麻烦程度可以得到一个对比队列：\nGson &gt; Serializable &gt; MapStruct &gt; Cloneable &gt; Parcelable &gt; Normal\n根据以上对比，项目开发过程中我个人认为，如果仅仅是简单的拷贝不必在意于性能多消耗那么一点点可以采用Gson，如果项目中的Model都实现了Serializable，也可以采用Serializable序列化形式；如果要兼顾性能和易用性，推荐Cloneable。\n知识扩展\n文中提到MapStruct是一种类型安全的bean映射类生成java注释处理器，而文中仅仅是利用很简单的映射来实现拷贝功能，其实MapStruct功能很强大，下边就举几个简单实用场景：\n两个对象的映射\n1234567891011@Mapper(unmappedTargetPolicy = ReportingPolicy.IGNORE)public interface OrderInfoMapper &#123;    OrderInfoMapper INSTANCE = Mappers.getMapper(OrderInfoMapper.class);    @Mappings(&#123;        @Mapping(source = &quot;feeDesc&quot;, target = &quot;feeTypeDesc&quot;),        @Mapping(source = &quot;origAmount&quot;, target = &quot;originAmount&quot;),        @Mapping(source = &quot;confirmationNo&quot;, target = &quot;orderNo&quot;)    &#125;)    PriceInfo dbToOrderPriceInfo(OrderPriceOffineDb orderOffineDb);&#125;\n这里将OrderPriceOffineDb中的字段’feeDesc’、‘origAmount’、‘confirmationNo’字段赋值给PriceInfo的’feeTypeDesc’、‘originAmount’、'orderNo’这三个字段，其他这两个对象中字段相同的相互赋值，不同的根据MapStruct处理器策略做相应处理。\n多个对象的映射\n123456789@Mapperpublic interface AddressMapper &#123;     @Mappings(&#123;        @Mapping(source = &quot;person.description&quot;, target = &quot;description&quot;),        @Mapping(source = &quot;address.houseNo&quot;, target = &quot;houseNumber&quot;)    &#125;)    DeliveryAddressDto personAndAddressToDeliveryAddressDto(Person person, Address address);&#125;\n这里映射来源有两个分别是Person、Address，分别将Person对象中description字段和Address对象中houseNo字段的值分别赋值给DeliveryAddressDto中description、houseNumber。\n如果多个源对象定义具有相同名称的属性，则必须使用@Mapping注解指定从中检索属性的source参数，如示例中的description属性所示。如果不解决这种歧义，将会引发错误。对于在给定源对象中仅存在一次的属性，可以选择指定源参数的名称，因为它可以自动确定。\nMapStruct映射策略\n正如上边两个对象的映射一样，所采用的映射策略是unmappedTargetPolicy = ReportingPolicy.IGNORE，假如目标映射对象有字段未被映射将被忽略，如果没有这个策略指定则会给出响应的提示警告。\n下边给出MapStruct常用的映射策略：\n\n其他\n\nMapStruct GitHub 访问地址 : https://github.com/mapstruct/mapstruct/\n使用例子 : https://github.com/mapstruct/mapstruct-examples\nMapStrcut与其它工具对比以及使用说明! http://www.tuicool.com/articles/uiIRjai\nMapStruct 1.1.0.Final中文参考指南 https://blog.csdn.net/YoshinoNanjo/article/details/81363285\n\n","plink":"https://blog.ixin.run/posts/1563597009/"},{"title":"Android开发之Context认识和运用","date":"2019-05-15T15:26:33.000Z","date_formatted":{"ll":"2019年5月15日","L":"2019/05/15","MM-DD":"05-15"},"updated":"2021-01-29T12:51:44.630Z","content":"谈到Context，做Android的可以说是无人不知无人不晓，例如“XXXXActivity.this”、“getApplicationContext()”、“getContext()”等多种形式。虽然大家都知道，可是真正的去用好它也是一门艺术，深入不全免不了也要入坑。\n之前我们项目上新增了一个悬浮球功能，获取的是全局Application的WINDOW_SERVICE，然而那个悬浮球的实例却采用的Activity的context，存在的问题就是内存回收时将此context回收掉，导致windowManager不能控制这个view了。\n1java.lang.IllegalArgumentException: View not attached to window manager\n本篇就针对的Context深入学习做一个总结吧。\n\nContext是什么\nContext，中文直译为“上下文”，它描述的是一个应用程序环境的信息，SDK中对其说明如下：\n\nInterface to global information about an application environment. This is an abstract class whose implementation is provided by the Android system. It allows access to application-specific resources and classes, as well as up-calls  for application-level operations such as launching activities, broadcasting and receiving intents, etc\n\n从Android系统的角度来理解：Context是一个场景，代表与操作系统的交互的一种过程。Context在加载资源、启动Activity、获取系统服务、创建View等操作都要参与。\n从程序的角度上来理解：Context是个抽象类，而Activity、Service、Application等都是该类的一个实现。\nContext的行为\nContext体现到代码上来说，是个抽象类，其主要表达的行为列表如下：\n\n\nContext行为分类\n常用函数\n\n\n\n\n使用系统提供的服务\ngetPackageManager()、getSystemService()…\n\n\n基本功能\nstartActivity()、sendBroadcast()、registerReceiver()、startService()、bindService()、getContentResolver()…【内部基本上是和AMS打交道】\n\n\n访问资源\ngetAssets()、getResources()、getString()、getColor()、getClassLoader()…\n\n\n和当前所寄身的进程之间的联系\ngetMainLooper()、getApplicationContext()…\n\n\n和信息存储相关\ngetSharedPreferences()、openFileInput()、openFileOutput()、deleteFile()、openOrCreateDatabase()、deleteDatabase()…\n\n\nContext的关系谱\nContext的系谱中主要包含Context、ContextImpl、ContextWrapper、ContextThemeWrapper以及最终的成员Application、Activity、Service。\n这些成员的关系如下图所示：\n\n1234567Context├── ContextImpl└── ContextWrapper    ├── Application    ├── ContextThemeWrapper    │   └── Activity    └── Service\n从继承关系图中可以看出，Application类、Service类和Activity类都继承了Context类。应用程序被启动后，会为应用程序创建一个全局的Application对应的Context对象。ContextImpl类是Context的真正实现。ContextWrapper类是Context的包装类，可以在不改变ContextImpl的情况下，为其增加一些自定义操作。ContextWrapper中的mBase实际上是一个ContextImpl对象。而ContextImpl类中的mOuterContext是一个Context对象，指向相对应的Activity或Service或Application。\n是不是有点绕？没关系，下边就简要分析一下这几个成员的具体细节。\n相关类介绍\nContext\n路径： /frameworks/base/core/java/android/content/Context.java\n说明：抽象类，提供了一组通用的API。\n123456789public abstract class Context &#123;\t ... \t public abstract Object getSystemService(String name);  //获得系统级服务\t public abstract void startActivity(Intent intent);     //通过一个Intent启动Activity\t public abstract ComponentName startService(Intent service);  //启动Service\t //根据文件名得到SharedPreferences对象\t public abstract SharedPreferences getSharedPreferences(String name,int mode);\t ...&#125;\nContextIml\n路径：/frameworks/base/core/java/android/app/ContextImpl.java\n说明：该Context类的实现类为ContextIml，该类实现了Context类的功能。请注意，该函数的大部分功能都是直接调用，其属性mPackageInfo去完成，这点我们后面会讲到。\n1234567891011121314151617181920212223242526/** * Common implementation of Context API, which provides the base * context object for Activity and other application components. */class ContextImpl extends Context&#123;\t//所有Application程序公用一个mPackageInfo对象    ActivityThread.PackageInfo mPackageInfo;        @Override    public Object getSystemService(String name)&#123;    \t...    \telse if (ACTIVITY_SERVICE.equals(name)) &#123;            return getActivityManager();        &#125;     \telse if (INPUT_METHOD_SERVICE.equals(name)) &#123;            return InputMethodManager.getInstance(this);        &#125;    &#125;     @Override    public void startActivity(Intent intent) &#123;    \t...    \t//开始启动一个Activity        mMainThread.getInstrumentation().execStartActivity(            getOuterContext(), mMainThread.getApplicationThread(), null, null, intent, -1);    &#125;&#125;\nContextWrapper\n路径：\\frameworks\\base\\core\\java\\android\\content\\ContextWrapper.java\n说明：正如其名称一样，该类只是对Context类的一种包装，该类的构造函数包含了一个真正的Context引用，即ContextImpl对象。\n123456789101112131415161718public class ContextWrapper extends Context &#123;    //该属性指向一个ContextIml实例，一般在创建Application、Service、Activity时赋值    Context mBase;      //创建Application、Service、Activity，会调用该方法给mBase属性赋值    protected void attachBaseContext(Context base) &#123;        if (mBase != null) &#123;            throw new IllegalStateException(&quot;Base context already set&quot;);        &#125;        mBase = base;    &#125;    @Override    public void startActivity(Intent intent) &#123;        //调用mBase实例方法        mBase.startActivity(intent);      &#125;&#125;\nContextThemeWrapper\n路径：/frameworks/base/core/java/android/view/ContextThemeWrapper.java\n说明：该类内部包含了主题(Theme)相关的接口，即android:theme属性指定的。只有Activity需要主题，Service不需要主题，所以Service直接继承于ContextWrapper类。\n1234567891011121314151617public class ContextThemeWrapper extends ContextWrapper &#123;\t //该属性指向一个ContextIml实例，一般在创建Application、Service、Activity时赋值\t private Context mBase;\t //mBase赋值方式同样有一下两种\t public ContextThemeWrapper(Context base, int themeres) &#123;\t        super(base);\t        mBase = base;\t        mThemeResource = themeres;\t &#125; \t @Override\t protected void attachBaseContext(Context newBase) &#123;\t        super.attachBaseContext(newBase);\t        mBase = newBase;\t &#125;&#125;\nContext的创建时机\n熟悉了Context的继承关系后，我们接下来分析应用程序在什么情况需要创建Context对象的。\nContext的数量\n应用程序创建Context实例的情况有如下几种情况：\n\n创建Application 对象时， 而且整个App共一个Application对象\n创建Activity对象时\n创建Service对象时\n\n因此应用程序App共有的Context数目公式为：\n总Context实例个数 =1（Application对应的Context实例）+ Activity个数 + Service个数\n具体的创建时机\n创建Application对象的时机\n每个应用程序在第一次启动时，都会首先创建Application对象。如果对应用程序启动一个Activity(startActivity)流程比较清楚的话，创建Application的时机在创建handleBindApplication()方法中，该函数位于ActivityThread.java类中 ，如下：\n123456789101112131415161718192021//创建Application时同时创建的ContextIml实例private final void handleBindApplication(AppBindData data)&#123;    ...\t///创建Application对象    Application app = data.info.makeApplication(data.restrictedBackupMode, null);    ...&#125; public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123;\t...\ttry &#123;        java.lang.ClassLoader cl = getClassLoader();        ContextImpl appContext = new ContextImpl();    //创建一个ContextImpl对象实例        appContext.init(this, null, mActivityThread);  //初始化该ContextIml实例的相关属性        ///新建一个Application对象         app = mActivityThread.mInstrumentation.newApplication(                cl, appClass, appContext);       appContext.setOuterContext(app);  //将该Application实例传递给该ContextImpl实例             &#125; \t...&#125;\n创建Activity对象的时机\n通过startActivity()或startActivityForResult()请求启动一个Activity时，如果系统检测需要新建一个Activity对象时，就会回调handleLaunchActivity()方法，该方法继而调用performLaunchActivity()方法，去创建一个Activity实例，并且回调onCreate()、onStart()方法等，函数都位于ActivityThread.java类，如下：\n 123456789101112131415161718192021//创建一个Activity实例时同时创建ContextIml实例private final void handleLaunchActivity(ActivityRecord r, Intent customIntent) &#123;\t...\tActivity a = performLaunchActivity(r, customIntent);  //启动一个Activity&#125;private final Activity performLaunchActivity(ActivityRecord r, Intent customIntent) &#123;\t...\tActivity activity = null;    try &#123;    \t//创建一个Activity对象实例        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);    &#125;    if (activity != null) &#123;        ContextImpl appContext = new ContextImpl();      //创建一个ContextImpl对象实例        appContext.init(r.packageInfo, r.token, this);   //初始化该ContextIml实例的相关属性        appContext.setOuterContext(activity);            //将该Activity信息传递给该ContextImpl实例        ...    &#125;    ...    &#125;\n创建Service对象的时机\n通过startService或者bindService时，如果系统检测到需要新创建一个Service实例，就会回调handleCreateService()方法，\n完成相关数据操作。handleCreateService()函数位于ActivityThread.java类，如下：\n12345678910111213141516171819//创建一个Service实例时同时创建ContextIml实例private final void handleCreateService(CreateServiceData data)&#123;\t...\tService service = null;    try &#123;        //创建一个Service实例        java.lang.ClassLoader cl = packageInfo.getClassLoader();        service = (Service) cl.loadClass(data.info.name).newInstance();    &#125; catch (Exception e) &#123;    &#125;\t...\tContextImpl context = new ContextImpl(); //创建一个ContextImpl对象实例    context.init(packageInfo, null, this);   //初始化该ContextIml实例的相关属性    //获得我们之前创建的Application对象信息    Application app = packageInfo.makeApplication(false, mInstrumentation);    //将该Service信息传递给该ContextImpl实例    context.setOuterContext(service);    ...&#125;\n重量级PackageInfo\n需要强调一点的是，通过对ContextImp的分析可知，其方法的大多数操作都是直接调用其属性mPackageInfo(该属性类\n型为PackageInfo)的相关方法而来。这说明ContextImp是一种轻量级类，而PackageInfo才是真正重量级的类。而一个App里的所有ContextIml实例，都对应同一个packageInfo对象。\nContext的getSharedPreferences()方法\n这里给大家分析利用Context获取SharedPreferences类的使用方法，SharedPreferences类想必大家都使用过，其一般获取方\n法就是通过调用getSharedPreferences()方法去根据相关信息获取SharedPreferences对象。具体流程如下：\n1.调用getSharedPreferences()获取对应的的文件，该函数实现功能如下：\n123456789101112131415161718192021222324252627282930313233343536373839404142//Context类静态数据集合，以键值对保存了所有读取该xml文件后所形成的数据集合private static final HashMap&lt;File, SharedPreferencesImpl&gt; sSharedPrefs = \t   new HashMap&lt;File, SharedPreferencesImpl&gt;();  @Overridepublic SharedPreferences getSharedPreferences(String name, int mode)&#123;\t //其所对应的SharedPreferencesImpl对象 ，该对象已一个HashMap集合保存了我们对该文件序列化结果\t SharedPreferencesImpl sp;       File f = getSharedPrefsFile(name);  //该包下是否存在对应的文件，不存在就新建一个     synchronized (sSharedPrefs) &#123;       //是否已经读取过该文件，是就直接返回该SharedPreferences对象         sp = sSharedPrefs.get(f);         if (sp != null &amp;&amp; !sp.hasFileChanged()) &#123;             //Log.i(TAG, &quot;Returning existing prefs &quot; + name + &quot;: &quot; + sp);             return sp;         &#125;     &#125;     //以下为序列化该xml文件，同时将数据写到map集合中          Map map = null;     if (f.exists() &amp;&amp; f.canRead()) &#123;         try &#123;             str = new FileInputStream(f);             map = XmlUtils.readMapXml(str);             str.close();         &#125;          ...     &#125;          synchronized (sSharedPrefs) &#123;         if (sp != null) &#123;             //Log.i(TAG, &quot;Updating existing prefs &quot; + name + &quot; &quot; + sp + &quot;: &quot; + map);             sp.replace(map);   //更新数据集合         &#125; else &#123;             sp = sSharedPrefs.get(f);             if (sp == null) &#123;              \t //新建一个SharedPreferencesImpl对象，并且设置其相关属性                 sp = new SharedPreferencesImpl(f, mode, map);                   sSharedPrefs.put(f, sp);             &#125;         &#125;         return sp;     &#125;&#125;\n2.SharedPreferences不过是个接口，它定义了一些操作xml文件的方法，其真正实现类为SharedPreferencesImpl，该类是ContextIml的内部类，该类如下：\n12345678910111213141516171819//SharedPreferences只是一种接口，其真正实现类是SharedPreferencesImpl类private static final class SharedPreferencesImpl implements SharedPreferences&#123;    //保存了该文件序列化结果后的操作，键值对形式\t private Map mMap;  \t \t //通过key值获取对应的value值\t public String getString(String key, String defValue) &#123;         synchronized (this) &#123;             String v = (String)mMap.get(key);             return v != null ? v : defValue;         &#125;     &#125;\t ...\t //获得该SharedPreferencesImpl对象对应的Edito类，对数据进行操作\t public final class EditorImpl implements Editor &#123;         //保存了对键值变化的集合\t\t private final Map&lt;String, Object&gt; mModified = Maps.newHashMap(); \t &#125;&#125;\nContext的使用\n如何获取Context\n\nView.getContext()，返回当前Activity所在的应用进程的Context对象，通常是当前正在展示的Activity对象。\nActivity.getApplicationContext()，获取当前Activity所在的（应用）进程的Context对象，通常我们使用Context对象时，要优先考虑这个全局的进程Context。\nActivity.this，返回当前的Activity实例，如果是UI控件需要使用Activity作为Context对象，但是默认的Toast因为是系统层级的Windows，直接使用ApplicationContext则可。\ngetApplication()，和getApplicationContext获取的对象一致的，但是getApplication方法只有在Activity和Service中才能调到。例如BroadcasrReceiver中需要获取Application，则需要借助getApplicationContext（）方法。\n\nContext的使用场景\n先来看一张Context使用场景图：\n\n大家注意看到有一些NO上添加了一些数字，其实这些从能力上来说是YES，但是为什么说是NO呢？下面一个一个解释：\n\n数字1：启动Activity在这些类中是可以的，但是需要创建一个新的task。一般情况不推荐。\n数字2：在这些类中去layout inflate是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用。\n数字3：在receiver为null时允许，在4.2或以上的版本中，用于获取黏性广播的当前值。（可以无视）\n\n注：ContentProvider、BroadcastReceiver之所以在上述表格中，是因为在其内部方法中都有一个context用于使用。\n这里我们看下表格，重点看Activity和Application，可以看到，和UI相关的方法基本都不建议或者不可使用Application。并且，前三个操作基本不可能在Application中出现。实际上，只要把握住一点，凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以，当然了，注意Context引用的持有，防止内存泄漏。\n假如我是面试官，问你Service能否启动Activity呢，想必你也应该知道怎么回答了吧\nContext引起的内存泄漏\nContext引起的内存泄漏也是很恐怖的，下边就举例两个场景：\n1.错误的单例模式\n123456789101112131415public class Singleton &#123;    private static Singleton instance;    private Context mContext;     private Singleton(Context context) &#123;        this.mContext = context;    &#125;     public static Singleton getInstance(Context context) &#123;        if (instance == null) &#123;            instance = new Singleton(context);        &#125;        return instance;    &#125;&#125;\n这种情况下即使Activity被销毁掉，但因为它的引用还存在于一个Singleton中，就不可能被GC掉。\n2.View持有Activity引用\n123456789101112public class MainActivity extends Activity &#123;    private static Drawable mDrawable;     @Override    protected void onCreate(Bundle saveInstanceState) &#123;        super.onCreate(saveInstanceState);        setContentView(R.layout.activity_main);        ImageView iv = new ImageView(this);        mDrawable = getResources().getDrawable(R.drawable.ic_launcher);        iv.setImageDrawable(mDrawable);    &#125;&#125;\n有一个静态的Drawable对象当ImageView设置这个Drawable时，ImageView保存了mDrawable的引用，而ImageView传入的this是MainActivity的mContext，因为被static修饰的mDrawable是常驻内存的，MainActivity是它的间接引用，MainActivity被销毁时，也不能被GC掉，所以造成内存泄漏。\n所以我们平时使用的时候尽量保证以下几点：\n\n如果不涉及Activity的主题样式，尽量使用Application的Context。\n不要让生命周期长于Activity的对象持有其的引用。\n尽量不要在Activity中使用非静态内部类，因为非静态内部类会隐式持有外部类示例的引用，如果使用静态内部类，将外部实例引用作为弱引用持有。\n\n参考\n\nhttps://blog.csdn.net/lmj623565791/article/details/40481055\nhttps://blog.csdn.net/qinjuning/article/details/7310620\nhttps://developer.android.com/reference/android/content/Context\n\n","plink":"https://blog.ixin.run/posts/1557933993/"},{"title":"Android开发之UI线程和非UI线程","date":"2019-05-12T06:15:23.000Z","date_formatted":{"ll":"2019年5月12日","L":"2019/05/12","MM-DD":"05-12"},"updated":"2021-01-29T12:51:44.634Z","content":"这里又是老生畅谈的话了，前边已经有多篇文章针对线程进行探究解释，Android开发过程中线程的体现更是淋漓尽致。Android开发过程中涉及到的线程从大类上分可以归为两类：UI线程和非UI线程。本篇就根据这两类做一个总结。\n\n谈到线程，首先顺带讲一下Android上进程的相关知识，进程和线程是相辅相成的，前边我也写过一篇针对进程和线程概括性的解释——《什么是进程，什么是线程》，这里就针对Android上面向开发的做一个记录总结。\n当某个应用组件启动且该应用没有运行其他任何组件时，Android 系统会使用单个执行线程为应用启动新的 Linux 进程。默认情况下，同一应用的所有组件在相同的进程和线程（称为“主”线程）中运行。 如果某个应用组件启动且该应用已存在进程（因为存在该应用的其他组件），则该组件会在此进程内启动并使用相同的执行线程。 但是，您可以安排应用中的其他组件在单独的进程中运行，并为任何进程创建额外的线程。\n进程\n默认情况下，同一应用的所有组件均在相同的进程中运行，且大多数应用都不会改变这一点。 但是，如果您发现需要控制某个组件所属的进程，则可在清单文件中执行此操作。\n各类组件元素的清单文件条目、、和均支持 android:process 属性，此属性可以指定该组件应在哪个进程运行。此外， 元素还支持 android:process 属性，以设置适用于所有组件的默认值。\n如果内存不足，而其他为用户提供更紧急服务的进程又需要内存时，Android 可能会决定在某一时刻关闭某一进程。在被终止进程中运行的应用组件也会随之销毁。 当这些组件需要再次运行时，系统将为它们重启进程。\n进程生命周期\nAndroid 系统将尽量长时间地保持应用进程，但为了新建进程或运行更重要的进程，最终需要移除旧进程来回收内存。 为了确定保留或终止哪些进程，系统会根据进程中正在运行的组件以及这些组件的状态，将每个进程放入“重要性层次结构”中。 必要时，系统会首先消除重要性最低的进程，然后是重要性略逊的进程，依此类推，以回收系统资源。\n重要性层次结构一共有 5 级。以下列表按照重要程度列出了各类进程（第一个进程最重要，将是最后一个被终止的进程）：\n\n\n前台进程\n用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：\n\n托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法）\n托管某个 Service，后者绑定到用户正在交互的 Activity\n托管正在“前台”运行的 Service（服务已调用 startForeground()）\n托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）\n托管正执行其 onReceive() 方法的 BroadcastReceiver\n\n\n\n通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。\n\n\n可见进程\n没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程：\n\n托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况。\n托管绑定到可见（或前台）Activity 的 Service。\n\n\n\n可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。\n\n\n服务进程\n正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。\n\n\n后台进程\n包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。 有关保存和恢复状态的信息，请参阅 Activity文档。\n\n\n空进程\n不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。\n\n\n主线程（UI线程）\n应用启动时，系统会为应用创建一个名为“主线程”的执行线程。 此线程非常重要，因为它负责将事件分派给相应的用户界面小部件，其中包括绘图事件。 此外，它也是应用与 Android UI 工具包组件（来自 android.widget 和 android.view 软件包的组件）进行交互的线程。因此，主线程有时也称为 UI 线程。\n系统不会为每个组件实例创建单独的线程。运行于同一进程的所有组件均在 UI 线程中实例化，并且对每个组件的系统调用均由该线程进行分派。 因此，响应系统回调的方法（例如，报告用户操作的 onKeyDown() 或生命周期回调方法）始终在进程的 UI 线程中运行。\n主线程是不安全的\nandroid主线程是不安全的，这句话是不是经常听到？上边也说了所有相关的UI更新操作均在主线程（UI线程），为什么都要在主线程中完成呢？这里就是主线程不全性导致的，其实主线程的不安全性就是指的UI刷新界面展示的不安全性。前边一篇文章《Android开发Handler消息机制探究》开篇提到，从主线程中可以创建多个子线程来分配任务，一个activity的所有view都是唯一的，都有唯一的标识，如果在每个子线程中更新view，我们不能预知线程执行结果的先后顺序，也就无法预知什么时候才能更新view，所以造成结果就是view更新时的冲突问题。官方也是为了规避这种多线程执行无序导致冲突的问题，所以从安卓2.0之后规定只能在主线程中更新界面了。\n单线程模式下必须遵守两条规则\n现在又有一个新问题了，既然都要在主线程中去执行有关界面的更新操作，主线程势必给人感觉比较“重”，在应用执行繁重的任务以响应用户交互时，除非正确实现应用，否则这种单线程模式可能会导致性能低下。 具体地讲，如果 UI 线程需要处理所有任务，则执行耗时很长的操作（例如，网络访问或数据库查询）将会阻塞整个 UI。 一旦线程被阻塞，将无法分派任何事件，包括绘图事件。 从用户的角度来看，应用显示为挂起。 更糟糕的是，如果 UI 线程被阻塞超过几秒钟时间（目前大约是 5 秒钟），用户就会看到一个让人厌烦的“应用无响应”(ANR) 对话框。如果引起用户不满，他们可能就会决定退出并卸载此应用。\n因此，您不得通过工作线程操纵 UI，而只能通过 UI 线程操纵用户界面。 因此，Android 的单线程模式必须遵守两条规则：\n\n不要阻塞UI线程\n不要在UI线程之外访问Android UI 组件（工具包）\n\n工作线程（非UI线程）\n根据上述单线程模式，要保证应用UI的响应能力，关键是不能阻塞 UI 线程。 如果执行的操作不能很快完成，则应确保它们在单独的线程（“后台”或“工作”线程）中运行。\n如何从非UI线程访问UI线程\n以下代码演示了一个点击侦听器从单独的线程下载图像并将其显示在ImageView中：\n12345678public void onClick(View v) &#123;    new Thread(new Runnable() &#123;        public void run() &#123;            Bitmap b = loadImageFromNetwork(&quot;http://example.com/image.png&quot;);            mImageView.setImageBitmap(b);        &#125;    &#125;).start();&#125;\n乍看起来，这段代码似乎运行良好，因为它创建了一个新线程来处理网络操作。 但是，它违反了单线程模式的第二条规则：不要在UI线程之外访问Android UI组件（工具包） ，此示例从工作线程（而不是UI线程）修改了ImageView。 这可能导致出现不明确、不可预见的行为，但要跟踪此行为困难而又费时。\n为解决此问题，Android 提供了几种途径来从其他线程访问 UI 线程：\n\n使用Handler实现线程之间的通信\nActivity.runOnUiThread(Runnable)\nView.post(Runnable)\nView.postDelayed(Runnable, long)\n\n例如，您可以通过使用 View.post(Runnable) 方法修复上述代码：\n12345678910111213public void onClick(View v) &#123;    new Thread(new Runnable() &#123;        public void run() &#123;            final Bitmap bitmap =                    loadImageFromNetwork(&quot;http://example.com/image.png&quot;);            mImageView.post(new Runnable() &#123;                public void run() &#123;                    mImageView.setImageBitmap(bitmap);                &#125;            &#125;);        &#125;    &#125;).start();&#125;\nAsyncTask\n少量情况下非UI线程访问UI线程可以采用上边的Activity.runOnUiThread(Runnable)、View.post(Runnable)，多的情况下可以采用Handler+Thread方式，但是这种也不好，代码量太大。好在Android官方给我们封了一个可以异步处理并在UI线程中回调的类——AsyncTask，AsyncTask可以正确，方便地使用UI线程。此类允许您执行后台操作并在UI线程上发布结果，而无需操作线程和/或处理程序。\nAsyncTask的设计其实也是围绕一个辅助类Thread和Handler，AsyncTask主要用于短时间内的异步回调操作，如果长时间执行线程，还是强烈建议采用各种API java.util.concurrent包，如Executor， ThreadPoolExecutor和FutureTask。\nAsyncTask的泛型参数\nAsyncTask&lt;Params,Progress,Result&gt;是一个抽象类,通常用于被继承.继承AsyncTask需要指定如下三个泛型参数:\n\nParams:启动任务执行时输入的参数类型.\nProgress:后台任务执行中返回进度值的类型.\nResult:后台任务执行完成后返回结果的类型.\n\nAsyncTask主要方法\nAsyncTask主要有如下几个方法:\n\ndoInBackground:必须重写,异步执行后台线程要完成的任务,耗时操作将在此方法中完成.\nonPreExecute:执行后台耗时操作前被调用,通常用于进行初始化操作.\nonPostExecute:当doInBackground方法完成后,系统将自动调用此方法,并将doInBackground方法返回的值传入此方法.通过此方法进行UI的更新.\nonProgressUpdate:当在doInBackground方法中调用publishProgress方法更新任务执行进度后,将调用此方法.通过此方法我们可以知晓任务的完成进度.\n\nAsyncTask使用遵循规则及缺点\n使用AsyncTask时必须遵循如下规则：\n\n必须在UI线程中创建AsyncTask的实例\n必须在UI线程中调用AsyncTask的execute()方法\n重写的四个方法是系统自动调用的，不应手动调用\n每个AsyncTask只能被执行一次，多次调用将会引发异常\n\nAsyncTask使用时虽然很简单，并且块化好管理，但是AsyncTask也有一定的缺点，使用的过程中也要格外在意：\n\n线程池中已经有128个线程，缓冲队列已满，如果此时向线程提交任务，将会抛出RejectedExecutionException。过多的线程会引起大量消耗系统资源和导致应用FC的风险。\nAsyncTask不会随着Activity的销毁而销毁，直到doInBackground()方法执行完毕。如果我们的Activity销毁之前，没有取消 AsyncTask，这有可能让我们的AsyncTask崩溃(crash)。因为它想要处理的view已经不存在了。所以，我们总是必须确保在销毁活动之前取消任务。如果在doInBackgroud里有一个不可中断的操作，比如BitmapFactory.decodeStream()，调用了cancle() 也未必能真正地取消任务。关于这个问题，在4.4后的AsyncTask中，都有判断是取消的方法isCancelled()。\n如果AsyncTask被声明为Activity的非静态的内部类，那么AsyncTask会保留一个对创建了AsyncTask的Activity的引用。如果Activity已经被销毁，AsyncTask的后台线程还在执行，它将继续在内存里保留这个引用，导致Activity无法被回收，引起内存泄露。\n屏幕旋转或Activity在后台被系统杀掉等情况会导致Activity的重新创建，之前运行的AsyncTask会持有一个之前Activity的引用，这个引用已经无效，这时调用onPostExecute()再去更新界面将不再生效。\n\nAsyncTask简单使用\n以下是一个AsyncTask创建声明的例子：\n123456789101112131415161718192021private class DownloadFilesTask extends AsyncTask&lt;URL, Integer, Long&gt; &#123;    protected Long doInBackground(URL... urls) &#123;        int count = urls.length;        long totalSize = 0;        for (int i = 0; i &lt; count; i++) &#123;            totalSize += Downloader.downloadFile(urls[i]);            publishProgress((int) ((i / (float) count) * 100));            // Escape early if cancel() is called            if (isCancelled()) break;        &#125;        return totalSize;    &#125;    protected void onProgressUpdate(Integer... progress) &#123;        setProgressPercent(progress[0]);    &#125;    protected void onPostExecute(Long result) &#123;        showDialog(&quot;Downloaded &quot; + result + &quot; bytes&quot;);    &#125;&#125;\n声明好后，只需要在主线程中简单执行execute即可：\n1new DownloadFilesTask().execute(url1, url2, url3);\n参考\n\nhttps://developer.android.com/guide/components/processes-and-threads.html\nhttps://developer.android.com/reference/android/os/AsyncTask.html\n《疯狂Android讲义》——李刚\n\n","plink":"https://blog.ixin.run/posts/1557641723/"},{"title":"Java线程之ThreadLocal探讨","date":"2019-05-12T06:07:50.000Z","date_formatted":{"ll":"2019年5月12日","L":"2019/05/12","MM-DD":"05-12"},"updated":"2021-01-29T12:51:44.664Z","content":"未wan待续。。。\n","plink":"https://blog.ixin.run/posts/1557641270/"},{"title":"Java线程总结","date":"2019-05-12T06:06:29.000Z","date_formatted":{"ll":"2019年5月12日","L":"2019/05/12","MM-DD":"05-12"},"updated":"2021-01-29T12:51:44.664Z","content":"未wan待续。。。\n","plink":"https://blog.ixin.run/posts/1557641189/"},{"title":"Android开发之OKHttp知识归总","date":"2019-04-22T16:11:26.000Z","date_formatted":{"ll":"2019年4月23日","L":"2019/04/23","MM-DD":"04-23"},"updated":"2021-01-29T12:51:44.632Z","content":"未wan待续。。。\n\nOKHttp\nOKHttp常用方式\nOKHttp拦截器\nOKHttp针对Https证书处理\n","plink":"https://blog.ixin.run/posts/1555949544/"},{"title":"Android开发之Fragment知识总结","date":"2019-04-18T15:55:14.000Z","date_formatted":{"ll":"2019年4月18日","L":"2019/04/18","MM-DD":"04-18"},"updated":"2021-01-29T12:51:44.631Z","content":"最近华为的新出的折叠手机（mate X）甚是火爆，甚至欧美国外发烧网友都为之疯狂，折起来是一步双面屏手机，展开有瞬间编程一个平板，最重要的特色就是分屏，可以左边看电视右边聊天。手机从塞班时代百花争艳到乔布斯的方块范畴，再到现在的不到不小的16:9，然后就是华为、三星的折叠系列，不出意料未来的手机又会到一个个性化高峰。这些对于我们开发者又是一个里程碑的挑战，以前我们只需要维护好一个页面，现在为了实行多样化需求，我们要尽可能在单个页面上做更多的碎片处理。\n\nFragment的生命周期（对比Activity）\nFragment的实例过程是跟随在Activity生命周期后边的。\n\nFragment有两种创建方式：静态和动态。静态创建方式是直接在Activity的xml中布局Fragment，动态方式一般是在Activity的onCreat()方法下动态引入Fragment，因此两种情况生命周期在初始化过程略有不同，以下是Fragment的周期：\n静态方式初始化过程：\n\n动态方式初始化过程：\n\n退到后台过程：\n\n恢复到前台过程：\n\n静态方式屏幕旋转过程：\n\n动态方式屏幕旋转过程：\n\n销毁过程：\n\nonSaveInstanceState\nFragment的onSaveInstanceState和Activity的onSaveInstanceState执行时间一样，也是处于onPause和onStop之间。\n我的声明周期为什么和你的不一致？\n有些同学问为什么我Demo里Fragment声明周期却比Activity的早，比如Fragment的onStart方法比Activity的onStart()执行早呢？其实Activity的onStart方法执行的时候会执行父类的onStart方法（super.onStart()），此时由Activity的super.onStart()影响Fragment的onStart方法的启动，然而你的日志却在Activity的super.onStart方法之后，然后就有这种疑问了，Activity生命周期的super方法均会影响Fragment的生命周期，所以我们真正去生命周期时候要顺藤摸瓜，否则结果恰恰相反。\n123456789101112131415//Activity@Overrideprotected void onStart() &#123;    Log.e(TAG, &quot;++++++++++++++-onStart()&quot;);    super.onStart();&#125;...//Fragment@Overridepublic void onStart() &#123;    Log.e(TAG,&quot;-----------+onStart()&quot;);    super.onStart();&#125;\n为什么动态方式创建我执行屏幕旋转时初始化过程Fragment的初始化执行了两编，并且伴随着还有一编销毁过程？\n大家知道屏幕旋转会使Activity的生命周期重建，并且onSaveInstanceState也会执行相应状态保存，然后在重建的时候进行释放。动态创建是在super.onCreate(savedInstanceState);这句之后，因此父类的onCreate()方法会根据savedInstanceState状态做判断，这里会将之前存储的Fragment作相应的销毁，然后在进行实例加载。所以我们动态加载的时候一般会从savedInstanceState中根据Fragment的Tag取出相应的Fragment，然后用事务在进行加载。\n1234567891011121314151617181920212223242526272829303132333435//Activity源码protected void onCreate(@Nullable Bundle savedInstanceState) &#123;    this.mFragments.attachHost((Fragment)null);    super.onCreate(savedInstanceState);    FragmentActivity.NonConfigurationInstances nc = (FragmentActivity.NonConfigurationInstances)this.getLastNonConfigurationInstance();    if (nc != null &amp;&amp; nc.viewModelStore != null &amp;&amp; this.mViewModelStore == null) &#123;        this.mViewModelStore = nc.viewModelStore;    &#125;    if (savedInstanceState != null) &#123;        Parcelable p = savedInstanceState.getParcelable(&quot;android:support:fragments&quot;);        this.mFragments.restoreAllState(p, nc != null ? nc.fragments : null);        if (savedInstanceState.containsKey(&quot;android:support:next_request_index&quot;)) &#123;            this.mNextCandidateRequestIndex = savedInstanceState.getInt(&quot;android:support:next_request_index&quot;);            int[] requestCodes = savedInstanceState.getIntArray(&quot;android:support:request_indicies&quot;);            String[] fragmentWhos = savedInstanceState.getStringArray(&quot;android:support:request_fragment_who&quot;);            if (requestCodes != null &amp;&amp; fragmentWhos != null &amp;&amp; requestCodes.length == fragmentWhos.length) &#123;                this.mPendingFragmentActivityResults = new SparseArrayCompat(requestCodes.length);                for(int i = 0; i &lt; requestCodes.length; ++i) &#123;                    this.mPendingFragmentActivityResults.put(requestCodes[i], fragmentWhos[i]);                &#125;            &#125; else &#123;                Log.w(&quot;FragmentActivity&quot;, &quot;Invalid requestCode mapping in savedInstanceState.&quot;);            &#125;        &#125;    &#125;    if (this.mPendingFragmentActivityResults == null) &#123;        this.mPendingFragmentActivityResults = new SparseArrayCompat();        this.mNextCandidateRequestIndex = 0;    &#125;    this.mFragments.dispatchCreate();&#125;\nFragmentActivity和Activity的区别\nfragment是3.0以后的东西，为了在低版本中使用fragment就要用到android-support-v4.jar兼容包,而fragmentActivity就是这个兼容包里面的，它提供了操作fragment的一些方法，其功能跟3.0及以后的版本的Activity的功能一样。下面是API中的原话：\n\nFragmentActivity is a special activity provided in the Support Library to handle fragments on system versions older than API level 11. If the lowest system version you support is API level 11 or higher, then you can use a regular Activity.\n\n\nfragmentactivity 继承自activity，用来解决android3.0 之前没有fragment的api，所以在使用的时候需要导入support包，同时继承fragmentActivity，这样在activity中就能嵌入fragment来实现你想要的布局效果。\n当然3.0之后你就可以直接继承自Activity，并且在其中嵌入使用fragment了。\n获得Manager的方式也不同\n3.0以下：getSupportFragmentManager()\n3.0以上：getFragmentManager()\n\nFragment常用形式\n终于讲到Fragment的加载形式了，上边提到Fragment的加载形式有两种：静态加载和动态加载。\n静态创建\n静态创建方式是直接在Activity的xml中布局Fragment，这个很简单，但是一定要注意两点：\n\nxml中的fragment一定要有一个id或者tag。\n所对应的fragment一定要返回一个视图。\n\nxml布局：\n12345&lt;fragment    android:id=&quot;@+id/myfragment_1&quot;    android:name=&quot;com.example.admin.TestFragment&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot; /&gt;\nfragment类：\n12345678public class TestFragment extends Fragment &#123;    @Nullable    @Override    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123;        return inflater.inflate(R.layout.fragment, container, false);    &#125;&#125;\n动态创建\n动态创建方式是需要在Activity的onCreat()方法下动态引入Fragment，由于上边提到在屏幕旋转或者Activity被无意回收销毁前系统会执行onSaveInstanceState()方法保存相应的状态，然后在Activity的onCreat方法执行时savedInstanceState会释放相应资源，此时如果直接在onCreat方法中创建有可能会走两遍生命周期，因此我们要利用这个特点直接从相应状态中去取，去不到时再创建也不迟。\n1234567891011121314151617//在Activity中onCreat中实现@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);        FragmentManager fm = getSupportFragmentManager();    FragmentTransaction transaction = fm.beginTransaction();    if(savedInstanceState != null)&#123;        tf = (TestFragment) fm.findFragmentByTag(&quot;TestFragment&quot;);    &#125;    if (tf == null)&#123;        tf = new TestFragment();    &#125;    transaction.replace(R.id.id_content, tf, &quot;TestFragment&quot;);    transaction.commit();&#125;\n动态创建涉及到两个类：FragmentManager和FragmentTransaction。\nFragmentManager\nFragmentManager是一个抽象类，定义了一些和 Fragment 相关的操作和内部类/接口。\n12345678910111213141516171819202122232425262728293031323334353637//开启一系列对 Fragments 的操作 public abstract FragmentTransaction beginTransaction(); //FragmentTransaction.commit() 是异步执行的，如果你想立即执行，可以调用这个方法 public abstract boolean executePendingTransactions(); //根据 ID 找到从 XML 解析出来的或者事务中添加的 Fragment //首先会找添加到 FragmentManager 中的，找不到就去回退栈里找 public abstract Fragment findFragmentById(@IdRes int id); //跟上面的类似，不同的是使用 tag 进行查找 public abstract Fragment findFragmentByTag(String tag); //弹出回退栈中栈顶的 Fragment，异步执行的 public abstract void popBackStack(); //立即弹出回退栈中栈顶的，直接执行哦 public abstract boolean popBackStackImmediate(); //返回栈顶符合名称的，如果传入的 name 不为空，在栈中间找到了 Fragment，那将弹出这个 Fragment 上面的所有 Fragment //有点类似启动模式的 singleTask 的感觉 //如果传入的 name 为 null，那就和 popBackStack() 一样了 //异步执行 public abstract void popBackStack(String name, int flags); //同步版的上面 public abstract boolean popBackStackImmediate(String name, int flags); //和使用 name 查找、弹出一样 //不同的是这里的 id 是 FragmentTransaction.commit() 返回的 id public abstract void popBackStack(int id, int flags); //你懂得 public abstract boolean popBackStackImmediate(int id, int flags); //获取回退栈中的元素个数 public abstract int getBackStackEntryCount(); //根据索引获取回退栈中的某个元素 public abstract BackStackEntry getBackStackEntryAt(int index); //添加或者移除一个监听器 public abstract void addOnBackStackChangedListener(OnBackStackChangedListener listener); public abstract void removeOnBackStackChangedListener(OnBackStackChangedListener listener); //还定义了将一个 Fragment 实例作为参数传递 public abstract void putFragment(Bundle bundle, String key, Fragment fragment); public abstract Fragment getFragment(Bundle bundle, String key); //获取 manager 中所有添加进来的 Fragment public abstract List&lt;Fragment&gt; getFragments();\n我们获取FragmentManager有两种包引入：\n12345//针对4.0之前的方式，能兼容更低的版本，引入的包是v4包，所对应的fragment也要时v4包下的。（推荐）FragmentManager fm = getSupportFragmentManager();//针对4.0之后的方式，引入的包是v7包，所对应的fragment也要是v7包下的。FragmentManager fm = getFragmentManager();\nFragmentTransaction\n做过数据库的童鞋都有事务的印象，主要针对数据的增删改查。FragmentTransaction就是对Fragment的“增删改查”。FragmentTransaction的相关操作大概有以下相关方法。\n\nadd(id, fragment) —— 增加framgent到队列中，并显示该fragment到指定布局中。\n生命周期调用：\n当fragment与activity连接并被建立时（onAttach()、onCreate()被调用过）\nonCreateView()、onActivityCreated()、onStart()、onResume()。\n当fragment与activity未连接并未被建立时（onAttach()、onCreate()未被调用过）\nonAttach()、onCreate()、onCreateView()、onActivityCreated()、onStart()、onResume()。\n注意：同一个Fragmen不能增加到队列两次或多次。\nshow(fragment) —— 显示队列中的指定framgent。\n生命周期的调用：\n当队列中不存在该fragment时，回调onAttach()、onCreate()。\n当队列中存在该fragment时并被调用过hide(fragment)时，回调onHiddenChange(boolean)。\n其他情况没有回调函数。\nreplace(id, fragment) —— 先检查队列中是否已经存在，存在就会崩溃，不存在就会进入队列并把其他fragment清出队列，最后显示该fragment到指定布局中。\n生命周期的调用：同add(id, fragment)。\nremove(fragment) —— 销毁队列中指定的fragment。\n生命周期调用：\n当队列中不存在该fragment时，不会有任何反应。\n当队列中存在该fragment时，fragment的生命周期执行情况主要依赖是否当前fragment进入到返回栈。\nhide(fragment) —— 隐藏队列中指定的fragment，相当于调用视图的.setVisibility(View.GONE)\n生命周期的调用：\n当队列中存在该fragment时，回调onHiddenChange(boolen)\n当队列中不存在该fragment时，回调onAttach()、onCreate()、onHiddenChange(boolen)。\ndetach(fragment) —— 销毁指定frament的视图，并且该fragment的onCreateView(……)不能再被调用（除非调用attach(fragment)重新连接）\n生命周期的调用：\n当队列中存在该fragment时，回调onDestroyView()\n当队列中不存在该fragment时，回调onAttach()、onCreate()。\nattach(fragment) —— 创建指定fragment的视图。标识该fragment的onCreateView(……)能被调用。\n生命周期的调用：\n当队列中存在该fragment时且被调用detach(fragment)时，回调createView()、onActivityCreated()、onResume()。\n当队列中不存在该fragment时，回调onAttach()、onCreate()。\n其他情况没有用。\naddToBackStack(string) —— 使本次事务增加的fragment进入当前activity的返回栈中。当前参数是对返回栈的描述，没什么实际用途。传入null即可。\ncommit() —— 提交本次事务，可在非主线程中被调用。主要用于多线程处理情况。\ncommitNow() —— 提交本次事务，只在主线程中被调用。 这时候addToBackStack(string)不可用。\n\n针对事务，我们最常用的有两种：\n\nreplace() --父容器中只能存在一个fragment，好处就是生命周期好管理。\nadd(), show(), hide() --父容器中根据还需要add一次，后边根据情况show或者hide，好处就是省内存空间。\n\nFragment进出栈管理\n我们知道在多个activity的情况下按下返回键会返回到上一页，但是一个activity中有多个fragment时按下返回键却直接退出了当前Activity。我们知道Activity有任务栈，用户通过startActivity将Activity加入栈，点击返回按钮将Activity出栈。Fragment也有类似的栈，称为回退栈（Back Stack），回退栈是由FragmentManager管理的（上边谈到FragmentManager使用的相关方法都已经提到）。\n加入回退栈\n默认情况下，Fragment事务是不会加入回退栈的，如果想将Fragment加入回退栈并实现事物回滚，首先需要在commit()方法之前调用事务的以下方法将其添加到回退栈中：addToBackStack(String tag) //标记本次的回滚操作\n弹出回退栈\nFragment的回退非常简单，默认每次只能回退到上一步操作，并不能一次性回退到我们想要的位置，这在开发的时候是不灵活的。所以需要我们来多了解事物回滚的相关原理来解决这样的问题，其实在Fragment回退时，默认调用FragmentManager的popBackStack()方法将最上层的操作弹出回退栈。当栈中有多层时，我们可以根据id或TAG标识来指定弹出到的操作所在层：\n\npopBackStack(int id, int flags)：其中id表示提交变更时commit()的返回值。\npopBackStack(String name, int flags)：其中name是addToBackStack(String tag)中的tag值。\n\n在上面2个方法里面，都用到了flags，其实flags有两个取值：0或FragmentManager.POP_BACK_STACK_INCLUSIVE。当取值0时，表示除了参数指定这一层之上的所有层都退出栈，指定的这一层为栈顶层；当取值POP_BACK_STACK_INCLUSIVE时，表示连着参数指定的这一层一起退出栈。\n如果想要了解回退栈中Fragment的情况，可以通过以下2个方法来实现：\n\ngetBackStackEntryCount()：获取回退栈中Fragment的个数。\ngetBackStackEntryAt(int index)：获取回退栈中该索引值下的Fragment。\n\n使用popBackStack()来弹出栈内容的话，调用该方法后会将事物操作插入到FragmentManager的操作队列，只有当轮询到该事物时才能执行。如果想立即执行事物的话，可以使用下面这几个方法：\n\npopBackStackImmediate()\npopBackStackImmediate(String tag)\npopBackStackImmediate(String tag, int flag)\npopBackStackImmediate(int id, int flag)\n\nFragment懒加载\n什么是懒加载，单例模式有一个懒汉模式，和这种有异曲同工，即所见即所得，例如页面可见时才加载数据，既节省内存，又能提示用户当前数据正在处理，不必感到迷茫。Fragment的懒加载主要用到setUserVisibleHint()这个方法。\nsetUserVisibleHint()使用范围必须在一组有序的Fragment时（FragmentPageAdapter）才会起作用，单个Fragment是不起作用的，并且该方法调用不一定在Fragment正常的生命周期之内。见源码注释：\n\n在FragmentPageAdapter中，假如有四张fragment：\n初始时：\n先执行setUserVisibleHint，将一次性加载在内存中的每个fragement（默认一次性加载两个Fragment）的该方法执行一遍，先默认都初始为false，最后将可见的那个fragment（第一个）初始为true。然后执行Fragment的生命周期：\nsetUserVisibleHint -------&gt; onAttach、 onCreat…\n\n滑动到第二页时：\n此时该fragment的部分生命周期已经走过（例如：onCreatView），但是该fragment的可见情况发生了变化，所以在第二页的时候只执行了setUserVisibleHint，不再执行onCreatView等生命周期方法。不过滑到第二页的时候顺便把第三页的相关方法初始一下：\n\n滑到最后一页时：\n假如这里一组只有四个Fragment，因为接下来没有第5个Fragment，所以不用进行预加载了，只需要做两步操作：\n\n把前一页的可见性置为false,把本页的可见性置为true。\n把上上一页的生命周期关闭（内存中只允许放两页，所以要把老的fragment出栈）。\n\n懒加载滑到最后一页时时生命周期\n\n间接跳转：\n假如从第四页直接跳到第一页（这里不是滑动，是导航跳转），可见性上先根据第一页的预加载方式进行逐个初始关闭，把第四页关闭，在把第一页打开。生命周期上先预处理第一页第二页的生命开启，接着将第三页第四页的生命关闭。举一反三其他间接跳转也类似。\n\n综上：其实这里只需要考虑两件事：\n\n设置可见性（初始可见性为false，关闭老页面可见性为false, 开启当前页可见性为true）。\n设置生命周期（预加载新的生命周期，关闭老的生命周期）。\n\n因为这两件事是交替变换，可见性为true但生命周期不一定初始化，此时是不能做一些有关界面的数据填充；生命周期准备好了但是可见性为false，加载的数据用户看不到，资源显的浪费。所以在数据加载时要同时考虑这两种情况，这里设置两个全局变量（mIsPrepare：标识生命周期； mIsVisible ：标识可见状态）来标识这两个情况：\n1234567891011121314151617181920212223@Overrideprotected void loadData(Bundle savedInstanceState) &#123;  mIsPrepare = true;  onLazyLoad();&#125;@Overridepublic void setUserVisibleHint(boolean isVisibleToUser) &#123;  super.setUserVisibleHint(isVisibleToUser);  mIsVisible = isVisibleToUser;  onLazyLoad();&#125;private void onLazyLoad() &#123;  if (mIsPrepare) &#123;    // 初始相关数据，以便于在滑动过程中能看到下一页有预处理数据    initData();    if (mIsVisible) &#123;      // 加载最终数据      queryData(true);    &#125;  &#125;&#125;\nFragment常见问题及解决方式\n以下两个坑是对我印象最深，早在还未毕业在实习的时候与fragment第一次亲密接触就遇到了。\nFragment的getActivity为null\n这种情况主要是主Activity被回收，然后在恢复的时候重新实例了一个新的Activity，导致原来的Fragment找不到原来的Activity，既然知道原因了，我们可以从以下三种情况入手：\n\n\nActivity销毁不缓存任何状态，这样在Activity重置时Fragment也会跟着重置。\n 1234@Overrideprotected void onSaveInstanceState(Bundle outState) &#123;//super.onSaveInstanceState(outState);&#125;\n这里说明一下：Activity的onSaveInstanceState是保存Activity被回收时的状态，同理Fragment的也是，因此这里只需把Activity的super.onSaveInstanceState(outState)注释即可，Fragment自行根据情况选择是否注释。\n\n\nFragment内部onAttach时把当前Activity的上下文保存起来。(推荐)\n当出现这个问题时，只要在Fragment 中声明一个上下文类型的成员变量，并在onAttach()方法中将getActivity()的值赋给变量，在Fragment中使用到getActivity()时，都是用context即可。也就是说在将Fragment挂载到Activity时，就获得到了这个activity，并将这个activity保存起来了，这样就可以直接使用而不需要每次使用时都调用一遍getActivity()了。\n 123456protected Context context;@Override      public void onAttach(Activity activity)&#123;          super.onAttach(activity);          context = activity;      &#125;\n\n\n使用全局Application的上下文。\n\n\n同一容器中多个Fragment重叠\n这种情况也是当所属Activity被回收重置时，由于一个容器中多个fragment找不到归属，本来有些是需要隐藏的，结果却都显示出来了。\n解决方法也有两种方法：\n\n不保存Activity的状态，让Fragment重新创建实例化。和上边getActivity()为null的第一种处理方式一样。\n在Activity的onCreate(Bundle savedInstanceState)方法里判断savedInstanceState是否为空，不为空则根据fragment的tag，将fragment的实例找出来，然后根据情况显示还是隐藏。 12345678910if(savedInstanceState != null)&#123;    tf = (TestFragment) fm.findFragmentByTag(&quot;TestFragment&quot;);&#125;if (tf == null)&#123;    tf = new TestFragment();    transaction.add(R.id.id_content, tf, &quot;TestFragment&quot;);    transaction.commit();&#125;else&#123;    transaction.show(tf);&#125; \n\n\nFragment与Fragment、Activity通信\n首先说明一下官方不建议Fragment与Fragment直接进行通信的，这会造成碎片耦合，不易后期维护和扩展，一般都是有Activity作为中间桥梁进行转接。以下是Fragment与Fragment、Fragment与Activity之间通信的方法归总。\nHandler消息推送方式\n例如Activity向Fragment中传递消息，思想是在Fragment中注册handler，然后将此Handler实例通过Activity的公有方法传递给Activity，最后Activity再合适的情况下触发handler的sendMessage()。具体过程如下：\n1.Fragment注册Handler，用于将来的消息接收。\n123456789private Handler mHandler = new Handler()&#123;     @Override     public void handleMessage(Message msg) &#123;         super.handleMessage(msg);         Bundle bundle = msg.getData();         strHandler = bundle.getString(&quot;hehe&quot;);         textView.setText(strHandler+TwoFragment.class.getName());     &#125;&#125;;\n2.Activity中暴露公有setHandler方法，用于Fragment将注册的handler传给Activity.\n123public void setHandler(Handler handler)&#123;    this.handler = handler;&#125;\n3.Fragment将Handler实例传递给Activity\n12345public void onAttach(Context context) &#123;    super.onAttach(context);     MainActivity activity = (MainActivity) getActivity();     activity.setHandler(mHandler); &#125;\n4.Activity事件响应，发送Handler消息\n1234567891011121314tvMain.setOnClickListener(new View.OnClickListener() &#123;     @Override     public void onClick(View v) &#123;         //如果是activity相应事件，发送msg         if(handler == null)&#123;             return;         &#125;         Message message = new Message();         Bundle bundle = new Bundle();         bundle.putString(&quot;hehe&quot;,&quot;我是activity发送的msg&quot;);         message.setData(bundle);         handler.sendMessage(message);     &#125; &#125;);\n其实不建议用handler处理，因为你会发现他耦合性挺重的，既要在Fragment中注册又要在Activity中handler发射，并且用不好还会出现内存泄露的情况。\n广播发送方式\n这个应该都明白，假如现在Fragment向Activity通信，我们只需在Activity中注册广播，然后由Fragment发送广播，Activity即可接收到。\n如果项目中fragment不是很多话，可以用广播传递，当然要注意广播的注销，方法也比较简单。\n事件总线发送方式\n我们常用的事件总线如EventBus，EventBus是一款针对Android优化的发布/订阅事件总线。简化了应用程序内各组件间、组件与后台线程间的通信。可以利用EventBus代替广播进行发送，其过程和上边广播发送方式类似，这里就不多说了。\nEventBus虽然更加简单，但是采用反射机制，造成性能上问题，并且EventBus不设好标示，将来甚至都不知道消息是从哪里传来的。\n使用自定义接口方式\nFragment中创建接口，Activity中实现接口，然后Fragment在需要的地方通过接口实例调用接口方法，从而Activity中即可接收到。\n1.Fragment中创建接口\n123public interface IListener&#123;    void changerSomething(String msg);&#125;\n2.Fragment中创建接收接口实例方法\n123public void setListener(IListener listener)&#123;    this.mListener = listener;&#125;\n3.Activity中Fragment实例实现自身接口实例\n12345mFragment.setListener(new Ilistener&#123;    public void changerSomething(String msg)&#123;        tvMain.setText(msg);    &#125;&#125;);\n4.Fragment中调用接口实例\n12345678button.setOnClickListener(new View.OnClickListener() &#123;     @Override     public void onClick(View v) &#123;         if(mListener != null)&#123;            mListener.changerSomething(&quot;我是通过接口传递到MainActivity中&quot;);        &#125;    &#125; &#125;);\n以上几种方式都有缺点，看起来这一种还不错，简单，解耦，并且完全可定制化，但是你会发现每个Fragment都要写这么多代码是很耐受的。所以接下来我们需要对这种方式进行一个完美封装，让其想EventBus一样，一行代码即可搞定。\n万能接口方式\n这里就不贴代码了，封装嘛，考验一下大家的奇思妙想。\n最后\n整个Fragment的相关知识点这里做了一个完全总结，文章有点长，需耐心看了，当然Fragment也不仅仅这一点，例如FragmentDialog代替Dialog，更多的需要我们在开发的过程中去挖掘学习。\n参考\n\nhttps://blog.csdn.net/cqkxzsxy/article/details/78593823\nhttps://blog.csdn.net/HUandroid/article/details/79481363\n\n","thumbnail":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1555613909401&di=6752f902ac9ad9912b724457339747e7&imgtype=0&src=http%3A%2F%2Fnowre.com%2Fwp-content%2Fuploads%2F2019%2F02%2F000.jpg","plink":"https://blog.ixin.run/posts/1555602958/"},{"title":"网络优化之HttpDNS实践","date":"2019-04-07T15:07:18.000Z","date_formatted":{"ll":"2019年4月7日","L":"2019/04/07","MM-DD":"04-07"},"updated":"2021-03-15T04:16:08.123Z","content":"**DNS是什么？**作为计算机专业的学生应该都不陌生，DNS全称“Domain Name System”，我们常常又叫做域名解析系统。每一个接入互联网的机器都有一个唯一的IP（形式是xxxx.xxxx.xxxx.xxxx），网上的人通过这个IP就可以访问到这台机器。但是看到那16个x是不是懵了，为了让别人更容易发现和记住怎么连接这台设备，需要对这个IP包装一下，额外起一个好记的名字，例如百度的网址是 baidu.com，再例如我的博客（i猩人）https://ixin.run 。从ixin.run到我的博客服务器这个阶段就需要DNS域名解析了，但是这个过程也容易被别人劫持攻击，有可能本来是正常访问一篇博客却弹出一个广告页。App大多是面向接口开发，即使不是网页，遇到这样的事也是很危险的，一些金融类或者电商类的App更不能忽视。\n\n顶级域名、一级域名、二级域名、三级域名、父域名、子域名\n在谈DNS，先了解一下域名知识。我们知道域名至少由两个词组成，中间用“.”分割，例如baidu.com。\n\n顶级域名\n顶级域名常常被用来指域名后缀，例如表示工商企业的 .com，表示网络提供商的 .net，表示非盈利组织的 .org等。\n一级域名\n一级域名又叫顶级域名，是由一个“.”分割出来的域名，例如baidu.com。\n二级域名\n二级域名是由两个“.”分割出来的，例如www.baidu.com。\n三级域名\n三级域名同理是由三个“.”分割出来的。\n父域名、子域名\n这个地方是相对来说的，www.sina.com.cn和news.sina.com.cn都是sina.com.cn的子域名，其中sina.com.cn就是父域名。同样，sina.com.cn其实又可以看作是com.cn的子域名；而com.cn又是.cn的一个子域名。\n\nDNS分类\nDNS按照功能角色分类，个人总结分为如下四类。\n1.权威DNS：\n权威DNS是经过上一级授权对域名进行解析的服务器，同时它可以把解析授权转授给其他人，如COM顶级服务器可以授权ABC.COM这个域名的权威服务器为NS.ABC.COM，同时NS.ABC.COM还可以把授权转授给NS.DDD.COM，这样NS.DDD.COM就成了ABC.COM实际上的权威服务器了。平时我们解析域名的结果都源自权威DNS。\n权威DNS即最终决定域名解析结果的服务器，开发者可以在权威DNS上配置、变更、删除具体域名的对应解析结果信息。阿里云云解析（ https://wanwang.aliyun.com/domain/dns ）即权威DNS服务提供商。\n2.递归DNS:\n递归DNS又称为Local DNS，它没有域名解析结果的决定权，但代理了用户向权威DNS获取域名解析结果的过程。递归DNS上有缓存模块，当目标域名存在缓存解析结果并且TTL未过期时（每个域名都有TTL时间，即有效生存时间，若域名解析结果缓存的时间超过TTL，需要重新向权威DNS获取解析结果），递归DNS会返回缓存结果，否则，递归DNS会一级一级地查询各个层级域名的权威DNS直至获取最终完整域名的解析结果。\n3.转发DNS:\n负责接受用户查询，并返回结果给用户。但这个结果不是按标准的域名解析过程得到的，而是直接把递归DNS的结果转发给用户。它也具备缓存功能。他主要使用在没有直接的互联网连接，但可以连接到一个递归DNS那里，这时使用转发DNS就比较合适。其缺陷是：直接受递归DNS的影响，服务品质较差。比如我们用的路由器里面的DNS就是这一类，用路由器的朋友可以看下本地电脑的DNS一般都是192.168.1.1。\n4.公共DNS:\n公共DNS是递归DNS的一种特例，它是一种全网开放的递归DNS服务，而传统的递归DNS信息一般由运营商分发给用户。一个比较典型的公共DNS即Google的8.8.8.8，我们可以通过在操作系统配置文件中配置公共DNS来代替Local DNS完成域名解析流程。\n域名解析过程\n在实际的使用过程中，我们通常不需要手工指定自己的Local DNS地址。运营商会通过DHCP协议在系统网络初始化阶段将Local DNS地址分配给我们的计算机。当我们需要使用公共DNS服务时，我们就必须手工指定这些服务的地址。以Linux为例，我们可以通过在’/etc/resolv.conf’中添加Local DNS地址项来改变本机Local DNS的地址。\n以下是www.baidu.com域名解析过程：\n\n\n我有一台计算机，通过ISP（Internet Service Provider，互联网服务提供商，即向广大用户综合提供互联网接入业务、信息业务和增值业务的电信运营商）接入了互联网，那么ISP就会给我分配一个DNS服务器，这个DNS服务器不是权威服务器，而是相当于一个代理的dns解析服务器（递归DNS），他会帮你迭代权威服务器返回的应答，然后把最终查到IP返回给你。\n\n\n现在我的计算机要向这台ISPDNS发起请求查询www.baidu.com这个域名了，(这里的ISP也可能是公共DNS，例如我们自己电脑手动配置的8.8.8.8)\n\n\nISPDNS拿到请求后，先检查一下自己的缓存(Local DNS)中有没有这个地址，有的话就直接返回。这个时候拿到的ip地址，会被标记为非权威服务器的应答。\n\n\n如果缓存中没有的话，ISPDNS会从配置文件里面读取13个根域名服务器的地址（这些地址是不变的，直接在BIND的配置文件中），\n\n\n然后向其中一台发起请求。\n\n\n根服务器拿到这个请求后，知道他是.com这个顶级域名下的，所以就会返回com域中的NS记录，一般来说是13台主机名和IP。\n\n\n然后ISPDNS向其中一台再次发起请求，com域的服务器发现你这请求是baidu.com这个域的，我一查发现了这个域的NS，那我就返回给你，你再去查。\n\n\nISPDNS不厌其烦的再次向baidu.com这个域的权威服务器发起请求，baidu.com收到之后，查了下有www的这台主机，就把这个IP返回给你了，\n\n\n然后ISPDNS拿到了之后，将其返回给了客户端，并且把这个保存在高速缓存中。\n\n\n图解DNS解析过程：\n\n传统域名解析所面临的窘境\n域名劫持\n本来域名A应该返回的DNS解析结果的IP1被恶意替换为了IP2，导致对A的访问失败或访问了一个不安全的站点。以下是两种可能发生的劫持方式：\n1）攻击Local DNS周边：一方面，黑客侵入了宽带路由器并将终端用户指定的Local DNS篡改为黑客自己伪造的Local DNS；另一方面，由于传统DNS解析主要是基于UDP协议，攻击者可以监听终端用户的域名解析请求，并在Local DNS返回正确结果之前将伪造的DNS解析响应传递给终端用户，进而控制终端用户的域名访问行为。\n2）攻击Local DNS缓存：最常碰到的域名劫持现象是缓存污染。由于Local DNS在接收到域名解析请求时首先会查找缓存，如果命中就会直接返回缓存结果，不再进行递归DNS查询。如果黑客将缓存结果指向第三方的广告页，就会导致用户的访问请求被引导到这些广告页地址上。\n第二种针对Local DNS缓存的污染往往能带来更明显的群体伤害，比如某个省份某个运营商的用户群可能因为该地区Local DNS的缓存污染而导致群体性访问服务异常。而且这类缓存污染行为往往是间歇性、局部性发生的，没有明显的规律，导致开发者很难对其进行量化、评估、预防。\n调度不精准\n基于传统Local DNS的域名解析还会带来域名调度精准性的问题。有这样一种场景，为了应用后续的访问性能，用户希望的初始的DNS解析结果带有地域或运营商性质，比如CDN。\n1）部分Local DNS供应商为了降低运营成本，会将发给自己的域名解析请求转发给其他供应商的Local DNS节点，如下图所示，用户请求解析的是cdn.aliyun.com，分配给用户的是Local DNS A，该DNS节点为了节省成本，把该次请求转发给了另一运营商的Local DNS B。而最终的权威DNS在进行域名解析时可能会根据Local DNS的IP信息进行智能调度（比如采用地理位置就近接入的调度策略），分配与Local DNS B 78.29.29.1相同运营商并且地理位置最近的CDN节点78.29.29.2，然而这个CDN节点对于终端135.35.35.1并不是最优的CDN节点，他们分属不同的运营商，并且地理位置上可能相隔很远。这类解析转发行为会严重影响域名解析的精准性并对用户业务访问延迟带来影响。\n\n2）除了解析转发对调度精准性带来的影响外，Local DNS的布署情况同样影响着域名智能解析的精准性。受成本因素制约，部分运营商Local DNS部署分布并不均匀，比如在东部地区部署比较密集，在西部地区部署比较稀疏。当一位西藏用户准备访问CDN节点时，我们预期他应该会被调度到西藏的CDN节点A上以实现就近接入和访问加速。但由于Local DNS的资源有限，西部地区的终端用户被统一调度到青海的Local DNS B上，这时候权威DNS根据Local DNS B的IP进行CDN域名的智能解析，并将青海的CDN节点B返回给西藏用户，导致西藏地区用户的网络访问延迟上升。另一种情况是Local DNS的分配甚至并非遵循就近原则，比如有实际案例显示西藏用户甚至被分配了北京的Local DNS节点C，导致西藏的用户在进行CDN资源访问时被调度到了北京的CDN节点C上，类似的由于调度精度的缺失带来的访问体验的影响是非常严重的。\n\n解析生效滞后\nLocal DNS是由各个地区不同运营商独立部署的，服务质量参差不齐。在对域名解析缓存的处理上，各个独立节点的实现策略也有区别，比如部分节点为了节省开支忽略了域名解析结果的TTL时间限制，导致用户在权威DNS进行解析变更，但解析结果在全网生效的周期非常漫长（最长生效时间甚至高达48小时）。部分业务场景下开发者对域名解析结果变更的生效时间非常敏感，比如当业务服务器受到攻击时，我们需要最快速地将业务IP切换到另一组集群上，如果全网解析生效不够迅速，可能直接导致用户业务访问的异常，造成严重事故。\n\n延迟大\nDNS首次查询或缓存过期后的查询，需要递归遍历多个DNS服务器以获取最终的解析结果，这增加了网络请求的前置延时时间。特别是在移动互联网场景下，移动网络质量参差不齐，弱网环境的RTT时间可能高达数百毫秒，对于一次普通的业务请求而言，上述延时是非常沉重的负担。另一方面，弱网环境下的解析超时、解析失败等现象屡见不鲜，如何合理优化DNS解析对于整体网络访问质量的提升至关重要。\nHTTPDNS\n上边由于传统的DNS解析种种弊端，HTTPDNS应运而生。HTTPDNS能够有效避免Local DNS造成的域名劫持问题和调度不精准问题。\n工作原理\nHTTP DNS使用HTTP协议进行域名解析，代替现有Local DNS基于UDP的DNS协议。域名解析请求直接发送到HTTP DNS服务端，绕过运营商的Local DNS。\n相关优点\n除了解决传统DNS的容易劫持和调度不精准等问题，基于HTTP协议的设计可以适用于几乎所有的网络环境，同时保留了鉴权、HTTPS等更高安全性的扩展能力，避免恶意攻击劫持行为。而商业化的HTTP DNS服务（比如阿里和腾讯的HTTP DNS）对缓存管理有严格的安全保障，避免了类似Local DNS的缓存污染的问题。\n如何接入\n目前国内比较给力的DNS解析供应商有：\n\n阿里云 HTTPDNS\n腾讯云 HTTPDNS\nDNSPOD | D+\n\n其中DNSPOD有免费版本可供使用，我们进入其网站的接入页面，能够看到其收费信息和接入指南。一般来说一个服务提供商应该会想所有客户端提供响应的SDK以方便使用，不过这个 DNSPOD 没有，他只提供了一个C语言版本，如果是企业用户，他会给提供一个定制的SDK以供使用，对于免费用户，如果不用这个C语言版本，还有一个选择，那就是开源的第三方SDK：\n\n新浪-安卓版(支持D+企业版加密功能)\n七牛-安卓版(支持D+企业版加密功能)\n七牛-OC版(支持D+企业版加密功能)\n\n个人建议如果是企业开发建议还是选择阿里或者腾讯云的，官方文档比较详细，另外技术支持也比较好，比较稳定。当然如果是个人开发者可以看看第三种。\n移动端域名解析最佳方案\nandroid端针对DNS需要优化最多的大概在两个地方：\n\nWebView请求URL\nOKHttp数据接口请求\n\n这里的对接过程我就不详细阐述了，拿阿里云HTTPDNS来说，官方文档很详细，可查看以下链接进行自行对接学习：\n\nWebview + HttpDns最佳实践\nHttpDns+OkHttp最佳实践\n\nCDN加速\n上边也提到了CDN的知识，CDN是什么？CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。\nCDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。\nCDN的关键技术主要有内容存储、分发技术和负载均衡等。具体详细说明可参阅百度百科\n目前市面上阿里云、腾讯云、七牛云等均提供有CDN加速服务，可根据个体情况进行接入。\n参考\n\nhttps://help.aliyun.com/product/30100.html?spm=a2c4g.11186623.6.540.5cda623dn0n0TK\nhttps://www.aliyun.com/product/httpdns\nhttps://yq.aliyun.com/articles/58967?spm=a2c4g.11186623.2.11.139a702dOgB32o#2\n\n","plink":"https://blog.ixin.run/posts/1554649638/"},{"title":"谈谈session、cookie、token的区别","date":"2019-04-04T16:24:39.000Z","date_formatted":{"ll":"2019年4月5日","L":"2019/04/05","MM-DD":"04-05"},"updated":"2021-03-15T04:16:08.123Z","content":"作为移动端开发有好多同学对session、cookie、token这三个概念起初是陌生的，如果不涉及到架构很少接触的这一块。在android开发中用到的session和token比较多些，自己也是从小白一路走过来的，根据以往的学习和经验在这里就谈谈这三者的区别，以便于在日后的开发过程中温故而知新顺手能够拿来。\n\nHttp协议无状态\n这里的无状态是指在标准的Http协议中并没有Session、cookie之类的记忆功能的，对于同一个url的链接请求没有上下文关系，并且每次请求都是独立的，客户端请求服务器也只能自己单独携带一些参数请求。这样就造成一个普遍的囧像，例如逛淘宝买东西，每个页面服务器都要知道是谁在买，又是谁买的什么，又是谁买了什么买了多少…\n事实上并不是这样的，我们逛淘宝只需登录一次，然后全程买东西并不需要再次登陆了，并且你也会发现甚至好几天都不用登录，直接进官网就已经默认登录了。这也是目前好多网站通用的做法。如何做到的呢？下边也就引出了session、cookie、token的概念。\nsession\nsession顾名思义就是“会话”，大白话就是“你访问我，需要让我知道你是谁，我才能和你交流”。这也是针对上边的http无状态呈现的问题最早最直接的解决方案。session是服务端生成，把客户端的个人登录信息以kv形式存储在服务器中。客户端第一次登录服务端会返回给客户端一个唯一的sessionId（key），然后后边的每次请求都会携带此sessionId到服务端，服务端根据此sessionId查询相应的session信息，查到了即表示验证通过能够正常访问。session还有一个过期时间概念，每次请求都会更新当前的请求时间，如果长时间不请求则会session失效，要进行重新登录。\nsession有一个很大的弊端就是session信息都要在服务器上保存，一个人两个人登录没问题，如果成千上万都保存在服务器上，这样服务器的压力就会很大了。另外一些大的公司一般都不只一个服务器，那么又会面临一个新问题：“这个服务器上有，那个服务器上没有”，也有人给出的一个方案是负载均衡，就是两个服务器上相互复制，但是挪来挪去也是一个问题。还有人给出了统一源存储的思想，就是用一个中央服务器存放这些session，其他服务器统一从这个中央处理器上取，但是有没有想过一旦中央服务器宕机了所有人都要重新登录一遍，有没有想骂娘的节奏。\nsession负载均衡：\n\nsession统一源存储：\n\ncookie\ncookie是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。上边提到session验证时每次请求都要将sessionId发送给服务端验证，那么这个sessionId存在浏览器哪个地方呢？这里就提到cookie的作用了。cookie是由服务端生成保存浏览器某个特有的文件夹下，浏览器也加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。\ntoken\n因为上边遇到了session的种种弊端，再后来又延伸出了一个token思想，token顾名思义就是“令牌”，意思是服务端会向客户端发放一个令牌，客户端保存到本地，每次请求的时候客户端只需要带上这个令牌通过验证即可，服务器也不需要存储这个令牌，因此也就不需要到库里进行查询验证，这样就大大减少了服务器的压力了。\n在我个人理解session和token最重要的区别就是session是一个固件，需要双方保存，必要的时候都拿出来做一下对比，而token是一个算法思想，只需要双方都保持一致的算法验证，无论是请求还是响应只需要把各自携带的参数因子根据这种算法得出一个结果再与一并携带的签名作比对验证通过即可，这里注意因子和签名都是客户端发来的，服务器只是帮着验证一下。目前大多数token的算法获取是采用HMAC-SHA256加密形式得出的，秘钥保存在服务器上，这样做也是防止token篡改。一个简单的token验证元素至少包含用户唯一标示（userID或设备号等）、请求的时间戳(token过期问题)、上次服务器返回的签名(token)。token应该在HTTP的头部发送从而保证了Http请求无状态。\n\n基于Token的身份验证的过程如下:\n\n用户通过用户名和密码发送请求。\n程序验证。\n程序返回一个签名的token 给客户端。\n客户端储存token,并且每次用于每次发送请求。\n服务端验证token并返回数据。\n\n每一次请求都需要token。实现思路如下：\n\n综上token相比session有众多优点：\n\n无状态\n服务器无需保存token信息，大大减轻服务器的压力。\n安全性\n请求中发送token而不再是发送cookie能够防止CSRF(跨站请求伪造)。加密过程是由服务端规定，以及密钥存储也是服务端管理保证了一定的安全性。另外token同样保持着时效性，一段时间之后用户需要重新验证。\n可扩展性\n可以给一些第三方账号放权，例如可以使用微信或支付宝账号登录，只需要根据这些第三方账号设置特定的api，得出特殊权限的token即可。\n多平台跨域\n以前的session大多是配合cookie用在B/S端，token不但可以用在B/S端，目前的主流形式用在C/S端更多，例如移动端。\n\n","plink":"https://blog.ixin.run/posts/1554395079/"},{"title":"记一次Git抽风现场","date":"2019-03-30T14:22:44.000Z","date_formatted":{"ll":"2019年3月30日","L":"2019/03/30","MM-DD":"03-30"},"updated":"2021-01-29T12:51:44.655Z","content":"这两天世界最大的猴类交友社区GitHub也被国人给攻陷了，只因国人在github建了一个仓库996.ICU，目的召集众猿人共同声讨996加班制度，有一种现实版猩球大战的节奏。何为996？就是朝9晚9连上6天。何为ICU？就是重症监护室。整个连起来就是上班996生病ICU，听起来真顺耳。就在前几天我自己面临了一次git偶发性事故，差点体验一把。\n\n前言\n前几天电脑抽风，下午正在敲着代码，几分钟前提交一个图标，后来经产品审查图标不好看需要换一个，发现本地代码使用git可以正常pull和push代码，就是不能提交这个图片。起初怀疑是一并提交jar和so包引起的，后来我切一个分支还原到只有这个图标，还是不行：\n\n看到401首先想到的是权限不足，于是找管理员查看tfs上自己的权限，发现都正常的，也应该是正常的，因为自己可以正常的pull和push代码，无奈要尽快找原因，下周一要打包提测。\n调大git推送限制\n后来想到既然是图片、jar、so包，说不定和提交的文件质量有关。其实还是怀疑，因为就一个小图片和一个jar两个so包都很小，并且单个传也不行。于是百度、google，还真有这个说法的，并且满篇都是：\n\n激动啊，试呗，试了好多遍，还是不行，于是仔细看是他们的报错原因：\nRPC failed; HTTP 411 curl 22 The requested URL returned error: 411 Length Req\n401和411差一个数，我的是401，是没有登录权限，他们的是411，是长度权限限制。耽误青春，没办法只能接着找原因。\n端口号思考\n想着是不是remote断开了，查看config一切正常。着急啊，全网找过来也找不到什么原因，后来想到前段时间公司把常用的3389端口号和22端口号给禁了，这里也刚好有一个22，好巧，说不定就是这原因。于是我把电脑上之前改过的3389端口号以及防火墙策略恢复了，还是不行，重新更改，还是不行，那就是剩下22端口了。后来上网搜发现22端口和ssh链接有关，但我一直用的https形式remote代码库的，跟我关系不大，不过这个22端口一直挂在我心里。。。继续度娘，狗爹，就这样半天过去，今天周五难不成要加班吗，其实已经8点了，还是下班吧。\n验证环境\n一晚上就想着这件事，第二天我把自己的笔记本带来了，连上公司的局域网，然后用自己的代码库账户拉代码提交代码，拉文件提交文件，卧槽，一切如丝般顺滑。顺便试了试昨天的22端口，采用ssh形式连一下果真不行，sourcetree提示这不是一个git仓库。至少我的笔记本是正确的，能战斗的，我开始怀疑我的台式机了。越想越想不开，装机？等等再看看，装机吧，等等再看看，装吧，哎，装。为了下周一的快准狠，这里也必须痛下决断，装好后先装git，然后进行尝试，结果呢还是老样子，雨一直下。\n怀疑windows凭证\n后来我看到有人提到说是“windows凭证”的问题，说是windows凭证保存有之前的账号密码，可能账号密码错了。于是希望又来了，进到系统管理凭证界面，发现并没有多余的凭证，又一次冷水凉身。想到周一的快准狠，不能死心，重启电脑吧说不定就好了，结果呢再次洗澡。\n剃度皈依之我是谁\n再后来我又把git卸载了，卸的干干净净，把常用的几个config统统删掉，注册表清理干净，项目隐藏的“.git”————删！凡是和git有关的统统剃干净。来一次美丽的重生，直接装到C盘。希望又来了，结果再次push的时候，却不提示填账号密码，并且显示remote仓库地址失败，多次尝试就是不提示账号密码，就只显示remote仓库地址失败，于是咬牙切齿，把本地的、全局、系统的config再次解剖了一遍，只差再次剃他们了。忽然我看到一个解决不显示账号密码的指令git config --system --unset credential.helper，迅雷不及眼耳执行啊，kao，又说找不到c盘git目录的config文件。但是我来到c盘里git目下确实有config文件啊，于是又问度娘狗爹，说是属性git文件夹设置管理员再执行，结果没用，哎主问题没找到又来个此问题，屋漏偏逢连夜雨。\n惊喜过后仍不自知\n后来想C盘属于系统级别的，自己作为开发者以开发为主，平时也很少去动系统，但是知道系统盘有很多系统权限限制，尤其是ProgramFiles或(x86)，后来果断把git最外层的系统级别的文件夹授予访问权限（其实额外新建一个文件夹装进去也是可以的）。接着执行上边的指令，哇，竟然可以提示输入账号了，哇，竟然也提示输入密码了。草，又来了个fatal: Authentication failed，又报身份验证问题，这明显和原来如出一辙，我是不是被团队踢了，哎，雨一直下。\n剖腹or破釜沉舟\n冥思苦想，回忆这两天自己的经历，把之前自己学的统统用了一遍，敲git命令敲到恶心（我已经不再相信任何git操作工具了，只相信最原始的命令），没少洗澡，只剩下等着周一上班剖腹吧，但是后来想到期初的401和22还是不能瞑目。周一终于到了，灰头丧气的找到运维给自己新装的系统加域，一边嘀咕着加完域我就找个介错人（领导）帮忙执行剖腹。域加完了，内心很平静，然而肌肉反应促使我闭着眼把命令又敲了一下————奇迹，他竟然好了！百思不得其姐啊，本着程序员刨不倒墙根儿不死心的决心，私下询问和观察发现从周一早上来身边有好多打伞的，哈哈。坑爹运维，为了提高安全性把好多软件、网址都禁了，包括上传文件的大小和下载文件的速度都限制了，我的电脑之前为了不想受他们的控制偷偷脱缰了，所以无法回到家园的怀抱。\n总结\n以上是自己亲身经历的一次git偶发性事故，浪费了很多精力，当然也思考了很多（都差点切腹了），记一次里程吧。所以啊，国有国法家有家规，想要在某个环境中生存就要去适应这个环境，不然耽搁的都是自己的生命。\n","plink":"https://blog.ixin.run/posts/1553955764/"},{"title":"Android开发通知栏的那些事","date":"2019-03-18T15:11:30.000Z","date_formatted":{"ll":"2019年3月18日","L":"2019/03/18","MM-DD":"03-18"},"updated":"2021-01-29T12:51:44.640Z","content":"对于通知栏的使用，Android各个版本其实都有比较大的调整。例如老版本的不兼容，大小图标问题以及自定义通知栏适配问题，这些都是比较头大的事，当然弄懂了就清楚了，本篇就处理下这些疑惑。\n\n通知栏的使用\n显示一个普通的通知栏\n12345678910111213141516171819202122232425262728public static void showNotification(Context context) &#123;    Notification notification = new NotificationCompat.Builder(context)            /**设置通知左边的大图标**/            .setLargeIcon(BitmapFactory.decodeResource(context.getResources(), R.mipmap.ic_launcher))            /**设置通知右边的小图标**/            .setSmallIcon(R.mipmap.ic_launcher)            /**通知首次出现在通知栏，带上升动画效果的**/            .setTicker(&quot;通知来了&quot;)            /**设置通知的标题**/            .setContentTitle(&quot;这是一个通知的标题&quot;)            /**设置通知的内容**/            .setContentText(&quot;这是一个通知的内容这是一个通知的内容&quot;)            /**通知产生的时间，会在通知信息里显示**/            .setWhen(System.currentTimeMillis())            /**设置该通知优先级**/            .setPriority(Notification.PRIORITY_DEFAULT)            /**设置这个标志当用户单击面板就可以让通知将自动取消**/            .setAutoCancel(true)            /**设置他为一个正在进行的通知。他们通常是用来表示一个后台任务,用户积极参与(如播放音乐)或以某种方式正在等待,因此占用设备(如一个文件下载,同步操作,主动网络连接)**/            .setOngoing(false)            /**向通知添加声音、闪灯和振动效果的最简单、最一致的方式是使用当前的用户默认设置，使用defaults属性，可以组合：**/            .setDefaults(Notification.DEFAULT_VIBRATE | Notification.DEFAULT_SOUND)            .setContentIntent(PendingIntent.getActivity(context, 1, new Intent(context, MainActivity.class), PendingIntent.FLAG_CANCEL_CURRENT))            .build();    NotificationManager notificationManager = (NotificationManager) context.getSystemService(context.NOTIFICATION_SERVICE);    /**发起通知**/    notificationManager.notify(0, notification);&#125;\n显示一个下载带进度条的通知\n12345678910111213141516171819202122232425262728293031323334353637383940public static void showNotificationProgress(Context context) &#123;    //进度条通知    final NotificationCompat.Builder builderProgress = new NotificationCompat.Builder(context);    builderProgress.setContentTitle(&quot;下载中&quot;);    builderProgress.setSmallIcon(R.mipmap.ic_launcher);    builderProgress.setTicker(&quot;进度条通知&quot;);    builderProgress.setProgress(100, 0, false);    final Notification notification = builderProgress.build();    final NotificationManager notificationManager = (NotificationManager) context.getSystemService(context.NOTIFICATION_SERVICE);    //发送一个通知    notificationManager.notify(2, notification);    /**创建一个计时器,模拟下载进度**/    Timer timer = new Timer();    timer.schedule(new TimerTask() &#123;        int progress = 0;        @Override        public void run() &#123;            Log.i(&quot;progress&quot;, progress + &quot;&quot;);            while (progress &lt;= 100) &#123;                progress++;                try &#123;                    Thread.sleep(100);                &#125; catch (InterruptedException e) &#123;                    // TODO Auto-generated catch block                    e.printStackTrace();                &#125;                //更新进度条                builderProgress.setProgress(100, progress, false);                //再次通知                notificationManager.notify(2, builderProgress.build());            &#125;            //计时器退出            this.cancel();            //进度条退出            notificationManager.cancel(2);            return;//结束方法        &#125;    &#125;, 0);&#125;\n显示一个悬挂式的通知\n悬挂式,部分系统厂商可能不支持。\n12345678910111213141516171819public static void showFullScreen(Context context) &#123;    NotificationCompat.Builder builder = new NotificationCompat.Builder(context);    Intent mIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(&quot;http://blog.csdn.net/linglongxin24&quot;));    PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, mIntent, 0);    builder.setContentIntent(pendingIntent);    builder.setSmallIcon(R.mipmap.ic_launcher);    builder.setLargeIcon(BitmapFactory.decodeResource(context.getResources(), R.mipmap.ic_launcher));    builder.setAutoCancel(true);    builder.setContentTitle(&quot;悬挂式通知&quot;);    //设置点击跳转    Intent hangIntent = new Intent();    hangIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);    hangIntent.setClass(context, MainActivity.class);    //如果描述的PendingIntent已经存在，则在产生新的Intent之前会先取消掉当前的    PendingIntent hangPendingIntent = PendingIntent.getActivity(context, 0, hangIntent, PendingIntent.FLAG_CANCEL_CURRENT);    builder.setFullScreenIntent(hangPendingIntent, true);    NotificationManager notificationManager = (NotificationManager) context.getSystemService(context.NOTIFICATION_SERVICE);    notificationManager.notify(3, builder.build());&#125;\n显示一个折叠式的通知\n123456789101112131415161718192021public static void shwoNotify(Context context) &#123;    //先设定RemoteViews    RemoteViews view_custom = new RemoteViews(context.getPackageName(), R.layout.view_custom);    //设置对应IMAGEVIEW的ID的资源图片    view_custom.setImageViewResource(R.id.custom_icon, R.mipmap.icon);    view_custom.setTextViewText(R.id.tv_custom_title, &quot;今日头条&quot;);    view_custom.setTextColor(R.id.tv_custom_title, Color.BLACK);    view_custom.setTextViewText(R.id.tv_custom_content, &quot;金州勇士官方宣布球队已经解雇了主帅马克-杰克逊，随后宣布了最后的结果。&quot;);    view_custom.setTextColor(R.id.tv_custom_content, Color.BLACK);    NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(context);    mBuilder.setContent(view_custom)            .setContentIntent(PendingIntent.getActivity(context, 4, new Intent(context, MainActivity.class), PendingIntent.FLAG_CANCEL_CURRENT))            .setWhen(System.currentTimeMillis())// 通知产生的时间，会在通知信息里显示            .setTicker(&quot;有新资讯&quot;)            .setPriority(Notification.PRIORITY_HIGH)// 设置该通知优先级            .setOngoing(false)//不是正在进行的   true为正在进行  效果和.flag一样            .setSmallIcon(R.mipmap.icon);    Notification notify = mBuilder.build();    NotificationManager notificationManager = (NotificationManager) context.getSystemService(context.NOTIFICATION_SERVICE);    notificationManager.notify(4, notify);&#125;\n低版本不兼容处理\nAndroid在appcompat-v7库中提供了一个NotificationCompat类来处理新老版本的兼容问题，我们在编写通知功能时都使用NotificationCompat这个类来实现，appcompat-v7库就会自动帮我们做好所有系统版本的兼容性处理了。一段基本的触发通知代码如下所示：\n12345678910NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);NotificationCompat.Builder builder = new NotificationCompat.Builder(context);Notification notification = builder.setContentTitle(&quot;这是通知标题&quot;).setContentText(&quot;这是通知内容&quot;).setWhen(System.currentTimeMillis()).setSmallIcon(R.mipmap.ic_launcher).setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)).build();manager.notify(1, notification);\n现在我们的app直接面对的设备一般都在android 5.0以上，所以也不需要做这种处理了。\n大小图标问题\n注意看一下我们给通知设置的图标，一个小图标、一个大图标，都是使用的R.mipmap.ic_launcher这张图，这在较低的编译版本上是没问题的，如果将targetSdkVersion指定成21或者更高的话，那么小图标则不可见（通知栏和大图的右下角有一个白白的圆），导致界面很不友好。\n这到底是为什么呢？实际上，Android从5.0系统开始，对于通知栏图标的设计进行了修改。现在Google要求，所有应用程序的通知栏图标，应该只使用alpha图层来进行绘制，而不应该包括RGB图层（通俗点来讲，就是让我们的通知栏图标不要带颜色就可以了）。下边是支付宝和网易新闻的展示：\n\n\n\n上图你会发现网易的图标更好看一些，因为系统给右下角的这个小圆圈默认是设置成灰色的，和我们的整体色调并不搭配，而网易则将这个小圆圈改成了红色，因此总体视觉效果更好。这种也很好处理，只需要在NotificationCompat.Builder中再多连缀一个setColor()方法就可以了：\n1234Notification notification = builder    ......    .setColor(Color.parseColor(&quot;#EAA935&quot;))    .build();\n自定义通知栏\n自定义通知需要定义一个layout文件，使用RemoteViews加载它并设置一些点击事件，再设置到builder，如下：\n123456789101112131415161718public void showNotification()&#123;    NotificationCompat.Builder builder = new NotificationCompat.Builder(this);    builder.setSmallIcon(R.mipmap.small_launch_ic);        //自定义布局    RemoteViews rv = new RemoteViews(getPackageName(),R.layout.message);    rv.setTextViewText(R.id.tv,&quot;有新通知了&quot;);    builder.setContent(rv);    //点击跳转    Intent intent = new Intent(this, MainAct.class);    PendingIntent pendingIntent = PendingIntent.getActivity(this, 1, intent, PendingIntent.FLAG_UPDATE_CURRENT);    remoteViews.setOnClickPendingIntent(R.id.root, pendingIntent);    Notification notification = builder.build();    NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);    notificationManager.notify(NOTIFICATION_ID,notification);&#125;\n认识RemoteViews\nRemoteViews主要用在通知栏和桌面小部件上，简单来说RemoteViews是一个可以跨进程显示view的类，显示的view是从布局文件inflate出来，且该类提供了一些基本的方法来修改这个view的内容。\nRemoteViews并不是一个view， 但可以表示一个layout的布局；又因为是继承parcelable,所以可以跨进程使用，但因为是跨进程，所以没办法像我们之前通过findviewById方法来访问布局里的每个view，所以RemoteViews提供了一些set方法来更新view 的显示，RemoteViews可以支持大部分系统控件，但是不支持自定义控件。\n原理\n自定义通知栏和桌面小部件，是由NotificationManager和AppWidgetmanager管理，而NotificationManager和AppWidgetManager是通过Binder分别和SystemServer进程中的NotificationManagerServer以及AppWidgetService进行通信，他们是运行在系统进程中，即SystemServer进程, 而我们是要在自身的应用进程中来更新远程系统进程的UI。这样就构成来跨进程通信的场景。 最开始的一节我们知道RemoteViews 是实现了Parcelable接口的，这样就可以跨进程使用了。从构造方法开始，系统首先根据包名去得到该应用的资源，然后inflate出布局文件，在SystemServer进程中是一个普通的view,而在我们的进程看来这是一个RemoteViews，然后会通过一系列set方法来更新该RemoteViews。\n认识PendingIntent\n所谓的 PendingIntent 是区别于 Intent 而存在的。Intent（即意图）是立即发生的，而 PendingIntent 是在将来的某个时刻发生的。PendIntent其实是Intent的封装。\nPendingIntent的使用场景主要用于闹钟、通知、桌面部件。\n与Intent的区别\n\nIntent 是意图的意思。Android 中的　Intent 正是取自这个意思，它是一个消息对象，通过它，Android 系统的四大组件能够方便的通信，并且保证解耦。Intent 可以说明某种意图，携带一种行为和相应的数据，发送到目标组件。\nPendingIntent是对Intent的封装，但它不是立刻执行某个行为，而是满足某些条件或触发某些事件后才执行指定的行为。\n\n我们的 Activity 如果设置了 exported = false，其他应用如果使用 Intent 就访问不到这个 Activity，但是使用 PendingIntent 是可以的。\n即：PendingIntent将某个动作的触发时机交给其他应用；让那个应用代表自己去执行那个动作（权限都给他）\n获取PendingIntent\n关于PendingIntent的实例获取一般有以下五种方法，分别对应Activity、Broadcast、Service：\n\ngetActivity()\ngetActivities()\ngetBroadcast()\ngetService()\ngetForegroundService()\n\n它们的参数都相同，都是四个：Context， requestCode, Intent, flags，分别对应上下文对象、请求码、请求意图用以指明启动类及数据传递、关键标志位。前面三个参数共同标志一个行为的唯一性。\nPendingIntent的FLAG\n\nFLAG_CANCEL_CURRENT：如果当前系统中已经存在一个相同的PendingIntent对象，那么就将先将已有的PendingIntent取消，然后重新生成一个PendingIntent对象。\nFLAG_NO_CREATE：如果当前系统中不存在相同的PendingIntent对象，系统将不会创建该PendingIntent对象而是直接返回null，如果之前设置过，这次就能获取到。\nFLAG_ONE_SHOT：该PendingIntent只作用一次。在该PendingIntent对象通过send()方法触发过后，PendingIntent将自动调用cancel()进行销毁，那么如果你再调用send()方法的话，系统将会返回一个SendIntentException。\nFLAG_UPDATE_CURRENT：如果系统中有一个和你描述的PendingIntent对等的PendingInent，那么系统将使用该PendingIntent对象，但是会使用新的Intent来更新之前PendingIntent中的Intent对象数据，例如更新Intent中的Extras\n\n8.0通知栏新增通知渠道\nAndroid 8.0 系统，Google引入通知渠道，提高用户体验，方便用户管理通知信息，同时也提高了通知到达率\n什么是通知渠道呢？顾名思义，就是每条通知都要属于一个对应的渠道。每个App都可以自由地创建当前App拥有哪些通知渠道，但是这些通知渠道的控制权都是掌握在用户手上的。用户可以自由地选择这些通知渠道的重要程度，是否响铃、是否振动、或者是否要关闭这个渠道的通知。\nbuild.gradle中targetSdkVersion设置大于等于26。这时如果不对通知渠道适配，通知就无法显示。\n所以我们要额外处理：\n1.创建NotificationChannel对象，指定Channel的id、name和通知的重要程度\n2.使用NotificationMannager的createNotificationChannel方法来添加Channel。\n1234567891011121314151617181920212223242526272829303132333435private NotificationCompat.Builder getNotificationBuilder() &#123;    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;        NotificationChannel channel = new NotificationChannel(&quot;channel_id&quot;, &quot;channel_name&quot;,                NotificationManager.IMPORTANCE_DEFAULT);        //是否绕过请勿打扰模式        channel.canBypassDnd();        //闪光灯        channel.enableLights(true);        //锁屏显示通知        channel.setLockscreenVisibility(VISIBILITY_SECRET);        //闪关灯的灯光颜色        channel.setLightColor(Color.RED);        //桌面launcher的消息角标        channel.canShowBadge();        //是否允许震动        channel.enableVibration(true);        //获取系统通知响铃声音的配置        channel.getAudioAttributes();        //获取通知取到组        channel.getGroup();        //设置可绕过  请勿打扰模式        channel.setBypassDnd(true);        //设置震动模式        channel.setVibrationPattern(new long[]&#123;100, 100, 200&#125;);        //是否会有灯光        channel.shouldShowLights();        getNotificationManager().createNotificationChannel(channel);    &#125;    NotificationCompat.Builder notification = new NotificationCompat.Builder(this, &quot;channel_id&quot;);    notification.setContentTitle(&quot;新消息来了&quot;);    notification.setContentText(&quot;周末到了，不用上班了&quot;);    notification.setSmallIcon(R.mipmap.ic_launcher);    notification.setAutoCancel(true);    return notification;&#125;\n3.设置通知重要性级别\nAndroid 8.0 及以上是使用NotificationManager.IMPORTANCE_，Android 7.1 及以下是使用NotificationCompat.PRIORITY_它们都是定义的常量:\n\n总结\n以上是我对通知栏相关使用或自定义方式的总结，这块也很简单，重点关注是RemoteViews和PendingIntent的知识点的认识和理解。\n参考\n\nhttps://www.jianshu.com/p/426d85f34561\nhttps://www.jianshu.com/p/b83fc1697232\n\n","plink":"https://blog.ixin.run/posts/1552921890/"},{"title":"Android开发ContentProvider学习总结","date":"2019-03-09T15:11:30.000Z","date_formatted":{"ll":"2019年3月9日","L":"2019/03/09","MM-DD":"03-09"},"updated":"2021-01-29T12:51:44.625Z","content":"ContentProvider是Android四大组件之一，其地位不言而喻。其使用场景就是应用间的数据共享，举个例子：阿里旗下的哥俩app-淘宝和天猫，登录淘宝的时候想引用天猫本地存储的数据，即从天猫本地数据库去查找。这时候天猫说了，老弟啊，你想用我的数据那么你要听我的，只能用我本地的方法去查，给你个URI指令去操作就行。是不是明白了些呢，其实这和webview的js交互如出一辙。\n\n什么是ContentProvider\nAndroid的四大组件之一，主要用于不同的应用程序之间实现数据共享功能，主要作用作为共享方的共享工具构建。\nAndroid 系统中比如相册、日历、音频、视频、通讯录等模块都提供了 ContentProvider 的访问支持。它的使用非常简单，你可以参考官方文档。\n什么是ContentResolver\n数据调用者，ContentProvider提供共享方的数据四大操作功能，调用方通过ContentResolver对象结合Uri进行调用ContentProvider的增删改查功能。\n什么是URI\nUri（通用资源标识符 Universal Resource Identifer），在这里代表数据操作的地址，每一个ContentProvider发布数据时都会有唯一的地址。\n比如：content：//（固定写法）+com.android.contacts(包名，可变)+/contacts（path路径）\n什么是UriMatcher\n共享方定义URI匹配规则，将来调用方可根据这些规则定义操作地址（URI）进行数据操作。\nUriMatcher的匹配工作的第一步就是先将所需要的匹配的URI使用addURI（）添加到UriMatcher中，\n1public void addURI(String authority, String path, int code)\n\nauthority:就是URI对应的authority\npath:就是我们在URI中 authority后的那一串\ncode:表示匹配成功以后的返回值；\n\nContentProvider使用步骤\n共享方：\n\n使用SQLite技术，创建好数据库和数据表\n新建类继承ContentProvider\n重写6个抽象方法\n创建UriMatcher，定义Uri规则\n在Manifest中注册provider\n\n调用方：\nContentResolver对ContentProvider中共享的数据进行增删改查操作\nContentProvider实例应用\n共享方所做的工作：\n1.新建类继承ContentProvider\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122//新建类继承ContentProviderpublic class DatabaseProvider extends ContentProvider &#123;    private MyDBHelpter myDBHelpter;    private static final String TAG = &quot;DatabaseProvider&quot;;    //添加整形常亮    public static final int USER_DIR = 0;    public static final int USER_ITEM = 1;    //创建authority    public static final String AUTHORITY = &quot;com.example.administrator.databasetest.provider&quot;;    //创建UriMatcher对象    private static UriMatcher uriMatcher;    //创建静态代码块    static &#123;        //实例化UriMatcher对象        uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);        //可以实现匹配URI的功能        //参数1：authority 参数2：路径 参数3：自定义代码        uriMatcher.addURI(AUTHORITY, &quot;userdemo&quot;, USER_DIR);        uriMatcher.addURI(AUTHORITY, &quot;userdemo/#&quot;, USER_ITEM);    &#125;    public DatabaseProvider() &#123;        Log.e(TAG, &quot;DatabaseProvider: &quot;);    &#125;    //onCreate()方法    @Override    public boolean onCreate() &#123;        //实现创建MyDBHelpter对象        myDBHelpter = new MyDBHelpter(getContext(), &quot;userdbdemo&quot;, null, 1);        return true;    &#125;    //删除数据表数据    @Override    public int delete(Uri uri, String selection, String[] selectionArgs) &#123;        //创建SQLiteDatabase对象        SQLiteDatabase db = myDBHelpter.getWritableDatabase();        int deleteInt = 0;        //匹配uri        switch (uriMatcher.match(uri)) &#123;            case USER_DIR:                //参数1：表名   参数2：约束删除列的名字   参数3：具体行的值                deleteInt = db.delete(&quot;userdemo&quot;, selection, selectionArgs);                break;            case USER_ITEM:                String deleteId = uri.getPathSegments().get(1);                deleteInt = db.delete(&quot;userdemo&quot;, &quot;id=?&quot;, new String[]&#123;deleteId&#125;);                break;            default:        &#125;        return deleteInt;    &#125;    //插入数据    @Override    public Uri insert(Uri uri, ContentValues values) &#123;        SQLiteDatabase db = myDBHelpter.getWritableDatabase();        switch (uriMatcher.match(uri)) &#123;            case USER_DIR:            case USER_ITEM:                //参数1：表名  参数2：没有赋值的设为空   参数3：插入值                long newUserId = db.insert(&quot;userdemo&quot;, null, values);                break;            default:                break;        &#125;        return null;    &#125;    //查询数据    @Override    public Cursor query(Uri uri, String[] projection, String selection,                        String[] selectionArgs, String sortOrder) &#123;        SQLiteDatabase db = myDBHelpter.getWritableDatabase();        Cursor cursor = null;        switch (uriMatcher.match(uri)) &#123;            case USER_DIR:                //参数1：表名  其他参数可借鉴上面的介绍                cursor = db.query(&quot;userdemo&quot;, projection, selection, selectionArgs, null, null, sortOrder);                break;            case USER_ITEM:                String queryId = uri.getPathSegments().get(1);                cursor = db.query(&quot;userdemo&quot;, projection, &quot;id=?&quot;, new String[]&#123;queryId&#125;, null, null, sortOrder);                break;            default:        &#125;        return cursor;    &#125;    //更新数据    @Override    public int update(Uri uri, ContentValues values, String selection,                      String[] selectionArgs) &#123;        SQLiteDatabase db = myDBHelpter.getWritableDatabase();        int updateRow = 0;        switch (uriMatcher.match(uri)) &#123;            case USER_DIR:                updateRow = db.update(&quot;userdemo&quot;,values,selection,selectionArgs);                break;            case USER_ITEM:                String updateId = uri.getPathSegments().get(1);                updateRow = db.update(&quot;userdemo&quot;,values,&quot;id=?&quot;,new String[]&#123;updateId&#125;);                break;            default:        &#125;        return updateRow;    &#125;    @Override    public String getType(Uri uri) &#123;        throw new UnsupportedOperationException(&quot;Not yet implemented&quot;);    &#125;&#125;\n2.在Manifest中注册provider\n12345&lt;provider   android:name=&quot;.provider.DatabaseProvider&quot;   android:authorities=&quot;com.example.administrator.databasetest.provider&quot;   android:enabled=&quot;true&quot;   android:exported=&quot;true&quot;/&gt;\n调用方所做的工作：\n在另外一个程序中定义相应的URI操作共享方的数据\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123;    private Button insertBtn;    private EditText editText;    private Button deleteBtn;    private  Button queryBtn;    private Button updateBtn;    private  String newId;    private static final String TAG = &quot;MainActivity&quot;;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        bangID();    &#125;    private void bangID() &#123;        insertBtn = findViewById(R.id.main_insert_btn);        editText = findViewById(R.id.main_et);        deleteBtn = findViewById(R.id.main_delete_btn);        queryBtn = findViewById(R.id.main_query_btn);        updateBtn = findViewById(R.id.main_update_btn);        insertBtn.setOnClickListener(this);        deleteBtn.setOnClickListener(this);        queryBtn.setOnClickListener(this);        updateBtn.setOnClickListener(this);    &#125;    @Override    public void onClick(View v) &#123;        switch(v.getId())&#123;            case R.id.main_insert_btn:                String name = editText.getText().toString();                //创建期待匹配的uri                Uri uri1 = Uri.parse(&quot;content://com.example.administrator.databasetest.provider/userdemo&quot;);                ContentValues values = new ContentValues();                values.put(&quot;name&quot;,name);                //获得ContentResolver对象，调用方法                getContentResolver().insert(uri1,values);                break;            case R.id.main_delete_btn:                String name1 = editText.getText().toString();                Uri uri2 = Uri.parse(&quot;content://com.example.administrator.databasetest.provider/userdemo&quot;);                getContentResolver().delete(uri2,&quot;name=?&quot;,new String[]&#123;name1&#125;);                break;            case R.id.main_query_btn:                Uri uri = Uri.parse(&quot;content://com.example.administrator.databasetest.provider/userdemo&quot;);                Cursor cursor = getContentResolver().query(uri,null,null,null,null);                cursor.moveToFirst();                do&#123;                    String name2 = cursor.getString(cursor.getColumnIndex(&quot;name&quot;));                    Log.e(TAG, &quot;onClick: &quot;+name2 );                &#125;while(cursor.moveToNext());                cursor.close();                break;            case R.id.main_update_btn:                String updateStr = editText.getText().toString();                Uri uri3 =Uri.parse(&quot;content://com.example.administrator.databasetest.provider/userdemo&quot;);                ContentValues values1 = new ContentValues();                values1.put(&quot;name&quot;,updateStr);                getContentResolver().update(uri3,values1,&quot;name=?&quot;,new String[]&#123;&quot;&quot;&#125;);                break;            default:        &#125;    &#125;&#125;\nContentProvider使用过程中注意点\nContentProvider 在使用过程中也存在一些“暗坑”需要我们特别注意。\n启动性能\nContentProvider 的生命周期默认在 Application onCreate() 之前，而且都是在主线程创建的。我们自定义的 ContentProvider 类的构造函数、静态代码块、onCreate 函数都尽量不要做耗时的操作，会拖慢启动速度。\n\n稳定性\nContentProvider 在进行跨进程数据传递时，利用了 Android 的 Binder 和匿名共享内存机制。简单来说，就是通过 Binder 传递 CursorWindow 对象内部的匿名共享内存的文件描述符。这样在跨进程传输中，结果数据并不需要跨进程传输，而是在不同进程中通过传输的匿名共享内存文件描述符来操作同一块匿名内存，这样来实现不同进程访问相同数据的目的。\n\n基于 mmap 的匿名共享内存机制也是有代价的。当传输的数据量非常小的时候，可能不一定划算。所以 ContentProvider 提供了一种 call 函数，它会直接通过 Binder 来传输数据。\nAndroid 的 Binder 传输是有大小限制的，一般来说限制是 1 ~ 2MB。ContentProvider 的接口调用参数和 call 函数调用并没有使用匿名共享机制，比如要批量插入很多数据，那么就会出现一个插入数据的数组，如果这个数组太大了，那么这个操作就可能出现数据超大异常。\n安全性\n虽然 ContentProvider 为应用程序之间的数据共享提供了很好的安全机制，但是如果 ContentProvider 是 exported，当支持执行 SQL 语句时就需要注意 SQL 注入的问题。另外如果我们传入的参数是一个文件路径，然后返回文件内容，这个时候也要校验合法性，不然整个应用的私有数据都有可能被别人拿到，在 Intent 传递参数的时候可能会经常会犯这个错误。\n参考\n\nhttps://blog.csdn.net/harvic880925/article/details/44521461\nhttps://blog.csdn.net/shaochen2015821426/article/details/79748487?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task#commentBox\nhttps://www.jianshu.com/p/41391e96ce48\n\n","plink":"https://blog.ixin.run/posts/1552144290/"},{"title":"URL和URI的区别","date":"2019-03-08T09:47:49.000Z","date_formatted":{"ll":"2019年3月8日","L":"2019/03/08","MM-DD":"03-08"},"updated":"2021-03-15T04:16:08.122Z","content":"什么是URL？什么是URI？这两个在开发中很常见，但是总是让很多同学感觉很绕，有些时候项目中明明标明的是URI传入的却是一个具体的URL，莫非两个是一个东西？本篇就为大家揭开这个谜底。\n\nURI、URL、URN\n怎么又来了一个URN？别慌接着往下看。\n这三个的命名和具体意义分别是：\n\nURI：（Universal Resource Identifier） 统一资源标志符\nURL：（Universal Resource Locator） 统一资源定位符\nURN：（Universal Resource Name） 统一资源名称\n\n这三者的关系如下：\n\n从图中可以看出：URI分别是URL和URN的父类，因此URL和URN都可以称为URI。\n什么是URI\nURI，即（Universal Resource Identifier） 统一资源标志符。它主要包含两层意思：\n\n具体什么东西\n叫什么\n\n这里大家就清楚了吧，例如有一个歌曲文件“爱我中华.mp3”，我们用URI解释一下就是，这是一个名字叫做“爱我中华”的可以用网络音乐播放器播放的一个MP3格式的歌曲文件。\nWeb上可用的每种资源如HTML文档、图像、视频片段、程序等都是用URI来定义的\nURI一般由三部组成\n\n访问资源的命名机制 （类似上边的MP3格式）\n存放资源的主机名\n资源自身的名称，由路径表示，着重强调于资源。\n\n这里路径可以是绝对路径也可以是相对路径。\n什么是URL\nURL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上。\n采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。\n一个URL通常包括三部分：\n\n协议部分（scheme）：http://\n地址部分：127.0.0.1:8080/\n资源部分：1.jpg\n\n一个完整的URL，包括协议（HTTP、HTTPS、FTP）和文件，另外URL可以精确匹配，也可在最后一个位置使用通配符来匹配。\nURL和URI的区别\nURL是在URI的基础上重点强调了文件的具体路径，而二者的区别也在于此。如果说URI所表达的是这是一个什么东西，而URL则直接说明这东西具体在哪儿。URI类在实例化的时候，可以指定为绝对路径，相对路径，但可以不指定到具体的某个资源，甚至只需描述所处的域即可。\n什么是URN\nURN，从时间和空间上为该资源定一个唯一的资源名称。URN只能确定一个唯一资源名称但是不能确定资源的具体位置，如用于唯一标识书目的ISBN系统是一个典型的URN使用范例。\n例如，ISBN 0-486-27557-4(urn:isbn:0-486-27557-4)无二义性地标识出莎士比亚的戏剧《罗密欧与朱丽叶》的某一特定版本。解释如下：\n\nISBN: 国际标准书号 （域，具体是什么东西，哦，原来是一本书啊）\n0-486-27557-4: 图书唯一命名（叫什么，我搜搜，哦，原来是某个版本的《罗密欧与朱丽叶》）\n\n总结\n到这里感觉怎么样，是不是豁然开朗，URI包含URL和URN，只是我们平时用URL更多一些，再有URI和URL本神存在着共性，所以很容混淆，弄清楚根源一切都明白了。\n一般思考问题，我们尽可能的去抛开官方的文字狱，结合生活去解释都很好解释的通，如果生活中不常见或者未知，那么恭喜你，发现了新大陆。\n","plink":"https://blog.ixin.run/posts/1552038469/"},{"title":"Android开发之SQLite使用详解","date":"2019-03-07T15:11:30.000Z","date_formatted":{"ll":"2019年3月7日","L":"2019/03/07","MM-DD":"03-07"},"updated":"2021-01-29T12:51:44.633Z","content":"Android开发中数据库框架是越来越多了，前段时间总结了一篇针对GreenDao的使用，不过这玩意官方不在维护了，但以目前的还是有很多公司在用。而Android上SQLite似乎永远也不会过时，这两年Google官方主推Room数据库框架，Room持久型类库在SQLite的基础上提供了一个抽象层，方便大家流利的访问数据库。并且，利用了SQlite的全部强大功能。\n\nSQLite的文件结构\n使用SQLite主要注意三个类：SQLiteOpenHelper、SQLiteDatabase、XXXDAO。\nSQLiteOpenHelper主要用于数据库的库名、版本、表创建、升级、降级等重要操作。\nSQLiteDatabase主要用于数据库语句的相关执行。\nXXXDAO的目的就是封装我们常用的增删改查操作，配合SQLiteOpenHelper和SQLiteDatabase的使用，在项目中调用操作主要用的是这个DAO类。\nSQLiteOpenHelper\nSQLiteOpenHelper是一个抽象类，平时使用我们需要创建一个类继承SQLiteOpenHelper。\n123456789101112131415161718192021222324252627282930public class DBOpenHelper extends SQLiteOpenHelper &#123;\tprivate static final String DATABASE_NAME = &quot;word.db&quot;;      private static final int DATABASE_VERSION = 1;  \tpublic DBOpenHelper(Context context) &#123;\t\tsuper(context, DATABASE_NAME, null, DATABASE_VERSION);\t&#125;\t/**     * 1、在第一次打开数据库的时候才会走     * 2、在清除数据之后再次运行--&gt;打开数据库，这个方法会走     * 3、没有清除数据，不会走这个方法     * 4、数据库升级的时候这个方法不会走     */\t@Override\tpublic void onCreate(SQLiteDatabase db) &#123;\t\t db.execSQL(&quot;CREATE TABLE IF NOT EXISTS userinfo (id integer primary key autoincrement, userid int, plan int, yet_num_day int, yet_num_all int, select_sort int, username text, userphoto text, oldwordsort text, sort_word text, time text)&quot;);\t&#125;\t/**     * 1、这个方法只有当数据库已经存在，而且版本升高的时候，才会调用     * 2、第一次创建数据库的时候，这个方法不会走     * 3、清除数据后再次运行(相当于第一次创建)这个方法也不会走     */\t@Override\tpublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;\t&#125;&#125;\n创建数据库表\nSQLite也是有生命周期的，其中最重要的一个方法就是onCreate，我们常常在这里初始化一些表的定义。db.execSQL()可直接进行编写SQL语句。\n这里顺便提一下SQLiteDatabase的execSQL()和rawQuery()方法，这两个方法都是用于执行SQL语句，后边的增删改查中都离不开，他们两个使用区别也很简单，一句话说就是凡是需要数据改动的使用execSQL()，查询使用rawQuery()。\n数据库升级\n一般我们的数据库表结构需要在新版本发生变化时，就要对数据库进行升级了，需要调高一个版本号。\nSQLite提供了ALTER TABLE命令，允许用户重命名或添加新的字段到已有表中，但是不能从表中删除字段。并且只能在表的末尾添加字段，\n数据库升级大概有以下几种情况：\n1.在老表基础上新增字段\n1234567891011@Overridepublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;       switch (oldVersion) &#123;           case 1:                //这里的数值是上次的版本，也就是针对上次的版本，本次的版本要做哪些改变                //这种情况需要同时在onCreate中加上执行新增字段的创建表sql(针对新用户)                db.execSQL(&quot;ALTER TABLE TableEvent.CREATE_SQL ADD COLUMN TableEvent.xxx VARCHAR(255)&quot;);           default:                break;        &#125;&#125;\n2.在之前基础上创建新的表\n1234567891011@Overridepublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;       switch (oldVersion) &#123;           case 1:                   //这里的数值是上次的版本，也就是针对上次的版本，本次的版本要做哪些改变                //这种情况需要同时在onCreate中加上执行新表的创建sql(新用户)                db.execSQL(&quot;CREATE TABLE IF NOT EXISTS newword (id integer primary key autoincrement, userid int, sort int, word text, soundmark text, explain text, example text, translate text)&quot;);           default:                break;        &#125;&#125;\n3.数据库升级时保留老的数据并同步到新的表当中\n这种情况是新表保留老表的字段结构情况\n123456789101112131415161718192021@Overridepublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;       switch (oldVersion) &#123;           case 1://这里的数值是上次的版本，也就是针对上次的版本，本次的版本要做哪些改变                //老的表重命名                String CREATE_TEMP_BOOK = &quot;alter table book rename to _temp_book&quot;;                //创建新的表，表名跟原来一样，并保留原来的字段                String CREATE_BOOK = &quot;create table book(bookId integer primarykey, bookName text);&quot;;                //将重命名后的老表中的数据导入新的表中                String INSERT_DATA = &quot;insert into book select *,&#x27;&#x27; from _temp_book&quot;;                //删除老表                String DROP_BOOK = &quot;drop table _temp_book&quot;;                db.execSQL(CREATE_TEMP_BOOK);                //这句要同时放到onCreate中，针对新用户                db.execSQL(CREATE_BOOK);                db.execSQL(INSERT_DATA);                db.execSQL(DROP_BOOK);           default:                break;        &#125;&#125;\n4.跨版本升级\n前面几种情况是单级升级的时候，针对上次的版本本次的版本需要做的处理，如果是跨级升级，比如用户app很久没有更新了，这次升级数据库版本从1升到了3，或者2升到了6，这时需要分开处理每次的版本：\n123456789101112131415161718192021@Overridepublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;    switch (oldVersion) &#123;        case 1:                db.execSQL(CREATE_TBL_CATEGORY)  // 建立新表        case 2:                db.execSQL(&quot;ALTER TABLE Book ADD COLUMN category_id INTEGER&quot;);  // 增加字段        case 3:                //同步老的数据到新的表                String CREATE_TEMP_BOOK = &quot;alter table book rename to _temp_book&quot;;                String CREATE_BOOK = &quot;create table book(bookId integer primarykey, bookName text);&quot;;                String INSERT_DATA = &quot;insert into book select *,&#x27;&#x27; from _temp_book&quot;;                String DROP_BOOK = &quot;drop table _temp_book&quot;;                db.execSQL(CREATE_TEMP_BOOK);                db.execSQL(CREATE_BOOK);                db.execSQL(INSERT_DATA);                db.execSQL(DROP_BOOK);        default:            break;    &#125;&#125;\n注意，这里OnUpgrade() 方法中的 switch 语句是没有 break 的，会一直执行到语句结束。为什么要这么写想想就明白了。比如用户手上的版本是 1，新版 App 的版本是 5，那么就会有 4 个版本的数据库升级，switch() 自然不能中途 break，必须执行这 4 个版本的数据库升级语句。同时每次的case中添加的创建新表的sql代码不要忘了在onCreate中同时添加，因为新用户也是要执行的。\n另外在执行这些sql语句时，个人建议最好加一个事务来进行处理，来保证整个流程的完整性。\n数据库降级\n针对数据库降级，我们需要重写onDowngrade()方法，使用形式和数据库升级数据迁移的步骤一样：\n\n重命名老表为备份表\n创建新表\n数据迁移\n删除备份表\n\n一般情况我们很少用到数据库降级操作，如果真的需要数据还原，还是直接数据库升级处理最好。\nDAO\nDAO类的目的就是封装我们常用的增删改查操作。前边我们说过数据库的语句执行主要用到的是SQLiteDatabase，获取SQLiteDatabase对象的方式有两种：\n\nSQLiteOpenHelper的getWritableDatabase()，此方法主要用于数据的增删改。\nSQLiteOpenHelper的getReadableDatabase()，此方法主要用于数据的查询。\n\n需要说明的是getWritableDatabase()和getReadableDatabase()伴随着资源和内存的消耗，一定要记着关闭；另外这两个方法的开启相对来说也是耗时的，所以也不要频繁的开启，因此我们在操作的过程中要合适的去处理这两件事，例如我会在使用的时候开启一次，而在页面销毁的时候统一关闭。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public class UserInfoDAO &#123;\tprivate DBOpenHelper openHelper;\tprivate SQLiteDatabase db;\t\t//生成数据库对象并开启数据库\tpublic UserInfoDAO(Context context) &#123;\t\topenHelper = new DBOpenHelper(context);\t\tdb = openHelper.getWritableDatabase();\t&#125;\t\t//记录用户数据\tpublic void insert(MyApplication application) &#123;\t\tdb.execSQL(&quot;insert into userinfo values(null,?,?,?,?,?,?,?,?,?,?)&quot;,\t\t\t\tnew Object[] &#123;application.getUserid(), application.getPlan(), application.getYet_num_day(), application.getYet_num_all(), application.getSelect_sort(), application.getUsername(), application.getUserphoto(), application.getOldwordsort(), application.getSort_word(), application.getTime()&#125;);\t&#125;\t\t//删除用户所有数据\tpublic void deleteAll(int userid) &#123;\t\tdb.execSQL(&quot;delete from userinfo where userid = ?&quot;,new String[]&#123;userid+&quot;&quot;&#125;);\t&#125;\t\t//更新计划\tpublic void updatePlan(int plan,int userid) &#123;\t\tdb.execSQL(&quot;update userinfo set plan= ? where userid=?&quot;,new String[]&#123;plan+&quot;&quot;,userid+&quot;&quot;&#125;);\t&#125;\t\t//更新今日已学的单词数\tpublic void updateYet_num_day(int yet_num_day,int userid) &#123;\t\tdb.execSQL(&quot;update userinfo set yet_num_day= ? where userid=?&quot;,new String[]&#123;yet_num_day+&quot;&quot;,userid+&quot;&quot;&#125;);\t&#125;\t\t//更新已学的单词数\tpublic void updateYet_num_all(int yet_num_all,int userid) &#123;\t\tdb.execSQL(&quot;update userinfo set yet_num_all= ? where userid=?&quot;,new String[]&#123;yet_num_all+&quot;&quot;,userid+&quot;&quot;&#125;);\t&#125;\t\t//更新是否选择单元的标记值\tpublic void updateSelect_sort(int select_sort,int userid) &#123;\t\tdb.execSQL(&quot;update userinfo set select_sort= ? where userid=?&quot;,new String[]&#123;select_sort+&quot;&quot;,userid+&quot;&quot;&#125;);\t&#125;\t\t//更新背过的单元\tpublic void updateOldSort(String oldwordsort,int userid) &#123;\t\tdb.execSQL(&quot;update userinfo set oldwordsort= ? where userid=?&quot;,new String[]&#123;oldwordsort,userid+&quot;&quot;&#125;);\t&#125;\t\t//更新记录（第几单元的第几个单词）\tpublic void updateSortWord(String sort_word,int userid) &#123;\t\tdb.execSQL(&quot;update userinfo set sort_word= ? where userid=?&quot;,new String[]&#123;sort_word,userid+&quot;&quot;&#125;);\t&#125;\t\t//更新日期\tpublic void updateTime(String time,int userid) &#123;\t\tdb.execSQL(&quot;update userinfo set time= ? where userid=?&quot;,new String[]&#123;time,userid+&quot;&quot;&#125;);\t&#125;\t\t//查询某个用户是否存在\tpublic boolean userExist(int userid) &#123;\t\t db=openHelper.getReadableDatabase();//如果只对数据进行读取，建议使用此方法\t\t Cursor cursor=db.rawQuery(&quot;select count (*) from userinfo where userid = ?&quot;,new String[]&#123;userid+&quot;&quot;&#125;);\t\t cursor.moveToFirst();//从第一条数据开始读取（计数）\t\t int a = cursor.getInt(0); //获取总数目\t\t cursor.close();\t\t if (a&gt;0) &#123;\t\t \treturn true;\t\t &#125;else &#123;\t\t\treturn false;\t\t &#125;\t&#125;\t\t//查询某个用户数据\tpublic HashMap&lt;String, Object&gt; findUserInfo(int userid) &#123;\t\tdb = openHelper.getReadableDatabase();\t\tCursor cursor = db.rawQuery(&quot;select * from userinfo where userid = ?&quot;,new String[]&#123;userid+&quot;&quot;&#125;);\t\tHashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();\t\twhile (cursor.moveToNext()) &#123;\t\t\tmap.put(&quot;id&quot;, cursor.getInt(cursor.getColumnIndex(&quot;id&quot;)));\t\t\tmap.put(&quot;userid&quot;, cursor.getInt(cursor.getColumnIndex(&quot;userid&quot;)));\t\t\tmap.put(&quot;plan&quot;, cursor.getInt(cursor.getColumnIndex(&quot;plan&quot;)));\t\t\tmap.put(&quot;yet_num_day&quot;, cursor.getInt(cursor.getColumnIndex(&quot;yet_num_day&quot;)));\t\t\tmap.put(&quot;yet_num_all&quot;, cursor.getInt(cursor.getColumnIndex(&quot;yet_num_all&quot;)));\t\t\tmap.put(&quot;select_sort&quot;, cursor.getInt(cursor.getColumnIndex(&quot;select_sort&quot;)));\t\t\tmap.put(&quot;username&quot;, cursor.getString(cursor.getColumnIndex(&quot;username&quot;)));\t\t\tmap.put(&quot;userphoto&quot;, cursor.getString(cursor.getColumnIndex(&quot;userphoto&quot;)));\t\t\tmap.put(&quot;oldwordsort&quot;, cursor.getString(cursor.getColumnIndex(&quot;oldwordsort&quot;)));\t\t\tmap.put(&quot;sort_word&quot;, cursor.getString(cursor.getColumnIndex(&quot;sort_word&quot;)));\t\t\tmap.put(&quot;time&quot;, cursor.getString(cursor.getColumnIndex(&quot;time&quot;)));\t\t&#125;\t\tcursor.close();\t\treturn map;\t&#125;\t\t//关闭数据库\tpublic void closeDB() &#123;          db.close();      &#125;&#125;\n数据库的增删改查除了可以采用SQLiteDatabase的execSQL()和rawQuery()方法来执行相关SQLite语句，SQLiteDatabase也提供有额外的针对每种操作的处理形式。\n增\n使用insert(String table, String nullColumnHack, ContentValues values)方法来插入，ContentValues内部实现就是HashMap，但是两者还是有差别的，ContenValues Key只能是String类型，Value只能存储基本类型的数据，像string，int之类的，不能存储对象。\n123ContentValues values = new ContentValues();values.put(&quot;name&quot;,insert_data);db.insert(&quot;user&quot;,null,values);\n删\n使用delete(String table,String whereClause,String[] whereArgs)，whereClause是删除条件，whereArgs是删除条件值数组。\n1db.delete(&quot;user&quot;,&quot;name=?&quot;,new String[]&#123;delete_data&#125;);\n改\n使用update(String table,ContentValues values,String whereClause, String[] whereArgs)：\n123ContentValues values2 = new ContentValues();values2.put(&quot;name&quot;, update_after_data);db.update(&quot;user&quot;, values2, &quot;name = ?&quot;, new String[]&#123;update_before_data&#125;);\n查\n使用query(String table,String[] columns,String selection,String[] selectionArgs,String groupBy,String having,String orderBy,String limit);\n12345678910111213//创建游标对象Cursor cursor = db.query(&quot;user&quot;, new String[]&#123;&quot;name&quot;&#125;, null, null, null, null, null);//利用游标遍历所有数据对象//为了显示全部，把所有对象连接起来，放到TextView中String textview_data = &quot;&quot;;while(cursor.moveToNext())&#123;    String name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;));    textview_data = textview_data + &quot;\\n&quot; + name;&#125;//关闭游标cursor.close();//显示数据textView.setText(textview_data);\n重要提示：一定要记着关闭游标\n总结\n以上是我对SQLite的一个使用详解，SQLite是基础，目前Google主推Room数据建库存储框架也是基于SQLite，Room的使用很简单，大家可以去网上搜寻一下也可以参看官方文档。\n","plink":"https://blog.ixin.run/posts/1551971490/"},{"title":"Android开发Gradle配置总结","date":"2018-11-29T13:51:21.000Z","date_formatted":{"ll":"2018年11月29日","L":"2018/11/29","MM-DD":"11-29"},"updated":"2021-01-29T12:51:44.626Z","content":"前段时间总结了一篇Gradle之Groovy语言，也是站在巨人的肩膀上的一个记录。早在Gradle之前有ant和maven打包构建工具。ant是一个古老的打包构建工具，功能性单一；maven比较有名的是maven仓库，用于依赖和管理项目中所用的jar库，简单便捷，但Maven编译规则是用XML来编写的，不利于程序的扩展性编程。至于为什么又来了一个gradle，相比已经知道答案了，这家伙就是一个加强版AK47，取众家之所长，简直就是编译打包的一个利器，目前AS默认的编译打包工具就是他。今天就简单谈谈AS上gradle的认识和配置，做一个总结。\n\nAndroid项目中Gradle位置\nAndroid项目中Gradle位置有三个地方，每个地方的功能又不一样，这三个位置分别是：\n\n/settings.gradle\n/build.gradle\n/app/build.gradle\n\n以上的三个属于构建的知识点，还有一个针对gradle版本和gradle插件版本的设置，详情可查看之前写过的一篇AndroidStudio项目导入的那些事。\n项目根目录的settings.gradle\n/settings.gradle 主要功能引入工程模块分支，在这里声明过后，代表属于项目的一部分了，接下来才可以做其他事，例如主模块依赖其他子模块，这里要搞清楚。\n新建工程默认只有一行代码，即：include ':app'，因为新建项目中只有一个主模块“app”，如果后边我们新创建模块，则可以接着在后边追加：include ':app','myLibrary'。\n这里也有一些高级用法，有些时候我们喜欢用“project”模式预览工程，特别想把某些module放在一个文件夹下，这样便于管理，我们可以这样操作：\n12include &#x27;myLibrary0&#x27;project (&#x27;:myLibrary0&#x27;).projectDir = new File(&#x27;librarys/myLibrary1&#x27;)\n第一行的include和上边是一样的用于引入模块，“myLibrary0”是myLibrary1别名，myLibrary1在项目根目录新建文件夹libarays下，这样说应该清楚了，后边同属性的其他模块也可以采用别名的形式放在librarys下（根据自己项目所需），后边如果主模块app需要依赖这些模块可直接依赖别名。\n项目根目录的build.gradle\n项目根目录下的build.gradle相对内容稍微多些，主要功能是声明一些远程library的仓库，仓库声明了，我们才能依赖此仓库里的lib。\n123456789101112131415161718192021222324252627// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123;    repositories &#123;        google()        jcenter()            &#125;    dependencies &#123;        classpath &#x27;com.android.tools.build:gradle:3.3.2&#x27;                // NOTE: Do not place your application dependencies here; they belong        // in the individual module build.gradle files    &#125;&#125;allprojects &#123;    repositories &#123;        google()        jcenter()            &#125;&#125;task clean(type: Delete) &#123;    delete rootProject.buildDir&#125;\n这里有四个节点，下面就针对这个几个子节点各个说明一下：\n\nbuildscript.repositories\n这里主要声明gradle脚本自身需要的资源。什么意思？就是我在写gradle脚本时内部可能需要一些类库，好比如Java上的import，主要帮助gradle方法块能够正常执行，不针对项目。\nbuildscript.dependencies\n这里主要声明一些项目中所用的插件，例如gradle构建插件版本，我们项目中数据库采用的greendao，也需要在这里声明一下greendao插件的版本：classpath 'org.greenrobot:greendao-gradle-plugin:3.2.0'\nallprojects.repositories\n细心的同学可能发现了怎么这里和buildscript.repositories一样，哈哈，好多地方其实针对这两处讲的并不清楚。这里不是和buildscript.repositories一模一样，allprojects.repositories主要声明我们自己整个项目工程的依赖仓库，比如说我们项目工程中会用到google库的相关依赖，例如databanding，我们就要在这里声明google()，再比如我们项目需要依赖我们公司自己的maven库，那么就要在这里声明公司自己的maven仓库地址。最早的时候AS在这两个地方默认只是mavenCentral()，后来换成了jcenter()，因为jcenter()比mavenCentral()更丰富，是当前世界上最大的Java和Android开源软件构件仓库，并且兼容maven，再后来为了丰富依赖库的来源，AS又默认加入了google()。\ntask clean\ntask clean声明了一个任务，任务名叫clean（也可以改为其它），任务类型是Delete，可以用gradle命令执行，就会删除rootProject.buildDir下的文件。想要知道当前项目有多少个task可以在Terminal中执行：  123.&#x2F;gradlew tasks（Mac、Linux）gradlew tasks（Windows）\ntask更高级用法可以编写AS插件，AS菜单栏上Build-&gt;Clean Project就是一条task任务，这个可自行学习。\n\n模块下的build.gradle\n模块下的build.gradle是针对当前模块的相关编译设置，例如release和debug模式下混淆声明、abiFilters兼容，以及模块下需要第三方工具依赖声明等设置。另外工程主模块和子模块的模块声明形式也不一样，工程主模块（app）的声明是apply plugin: 'com.android.application'，工程子模块（library）的声明是apply plugin: 'com.android.library'，根绝这两个声明应该也可以想到二者的区别了。以下是工程主模块默认的相关构建设置：\n1234567891011121314151617181920212223242526272829apply plugin: &#x27;com.android.application&#x27;android &#123;    compileSdkVersion 28    defaultConfig &#123;        applicationId &quot;com.ixinrun.myapplication&quot;        minSdkVersion 15        targetSdkVersion 28        versionCode 1        versionName &quot;1.0&quot;        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;    &#125;    buildTypes &#123;        release &#123;            minifyEnabled false            proguardFiles getDefaultProguardFile(&#x27;proguard-android-optimize.txt&#x27;), &#x27;proguard-rules.pro&#x27;        &#125;    &#125;&#125;dependencies &#123;    implementation fileTree(dir: &#x27;libs&#x27;, include: [&#x27;*.jar&#x27;])    implementation &#x27;com.android.support:appcompat-v7:28.0.0&#x27;    implementation &#x27;com.android.support.constraint:constraint-layout:1.1.3&#x27;    testImplementation &#x27;junit:junit:4.12&#x27;    androidTestImplementation &#x27;com.android.support.test:runner:1.0.2&#x27;    androidTestImplementation &#x27;com.android.support.test.espresso:espresso-core:3.0.2&#x27;&#125;\nandroid节点下主要是声明当前模块下的版本设定（如果是主模块即指当前app的版本了），构建插件版本设定，以及构建类型设置（release，debug，自定义），还有风味多渠道打包设置等。\ndefaultConfig\n针对android节点下的compileSdkVersion、buildToolsVersion，以及子节点defaultConfig下的minSdkVersion、targetSdkVersion等相关设置可参见我之前的文章《AndroidStudio项目导入的那些事》，里面有详细说明，这里就不多说了。\n典型的65536问题。android可执行文件“.dex”中的Java方法数引用超过65536就会报com.android.dex.DexIndexOverflowException:method IDnotin[0,0xffff]:65536的错误，相信不少同学已经踩过这个坑了。我们可以在defaultConfig里添加multiDexEnabled true，然后Application继承自MultiDexApplication，在dependencies依赖implementation 'com.android.support:multidex:1.0.3'即可。\n某种情况下我们的app只能限定在abi为armeabi或armeabi-v7的CPU架构模式下，例如公司的内部应用，因为对接很多三方厂商的东西，为此需要更加低廉的限制来降低风险。我们也可以在defaultConfig里进行限制：ndk &#123; abiFilters 'armeabi' &#125;。当然，这里是全局的设定，我们也可以对我们的release、debug包单独区分限制，这个后边的“buildTypes”里的设置会讲到。\n我们也可以对AndroidManifest部分参数在defaultConfig进行替换，为了更好的方便管理，或者动态改变，毕竟gradle可以写脚本嘛，例如我们想把我们AndroidManifest里的appname在gradle里限制，把极光推送的众多的applicationId和appkey也在gradle里限定，可以在defaultConfig（也可以对release、debug包单独处理，和上边一样）这样处理：\n123456manifestPlaceholders = [                app_name     : &quot;@string/app_name&quot;,                //极光推送部分                JPUSH_PKGNAME: applicationId,                  JPUSH_APPKEY : &quot;xxxxxxxxxxxxxxxxxxxxx&quot;        ]\n然后在AndroidManifest做相应的映射：\n123456789101112android:label=&quot;$&#123;app_name&#125;&quot;... &lt;receiver            android:name=&quot;.modules.common.push.MyJPushMessageReceiver&quot;            android:enabled=&quot;true&quot;            android:exported=&quot;false&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;cn.jpush.android.intent.RECEIVE_MESSAGE&quot; /&gt;                &lt;category android:name=&quot;$&#123;JPUSH_PKGNAME&#125;&quot; /&gt;            &lt;/intent-filter&gt; &lt;/receiver&gt;...\nbuildTypes\n这里主要设置编译类型，我们知道一般打包有两种：release和debug。release主要是指我们的线上正式包，而debug就是我们测试环境下的包了。因此release和debug这里基本设置都是相同，只是参数不一样，例如release模式下我们需要混淆，避免我们的源码泄露，提高安全性；debug模式下为了更好将日志输出和调试，我们需要关闭混淆和开启运行时调试。\n\ndebuggable true  //开启运行时调试\nzipAlignEnabled true  //Zipalign 优化\nminifyEnabled true  //开启删除无用代码，配合proguardFiles开启混淆\nshrinkResources true //在编译过程中用来检测并删除无用资源文件，需要配合minifyEnabled二者都为true才生效。\nproguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’ //定义混淆文件，“proguard-android.txt”是Android默认的，我们不用管，项目中的“proguard-rules.pro”是我们主要自定义设置的。\nsigningConfig signingConfigs.releaseConfig //签名设置，可以为release和debug设置不同的签名，其中的“signingConfigs.releaseConfig”是我们在gradle中设置的签名闭包，形式如下：  123456789101112131415//打包签名配置signingConfigs&#123;    releaseConfig&#123;        storeFile file(KEY_PATH)        storePassword KEY_PASS        keyAlias ALIAS_NAME        keyPassword ALIAS_PASS    &#125;    debugConfig&#123;        storeFile file(KEY_PATH)        storePassword KEY_PASS        keyAlias ALIAS_NAME        keyPassword ALIAS_PASS    &#125;&#125;\n\n\n以上我们常用的设置，也可以在release和debug模式下设置项目的接口host地址，便于请求区分线上数据和测试数据来源，还可以加上我们的编译打包时间：\n1234567891011//设置在release或debug模式下buildConfigField(&quot;String&quot;, &quot;BUILD_TIME&quot;, getDate())buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\\&quot;http://www.baidu.com/\\&quot;&quot;)....//获取当前时间，gradle中的一个闭包方法体，需要设置在android闭包外。String getDate() &#123;    Date date = new Date()    return &quot;\\&quot;&quot; + date.format(&quot;yyyy-MM-dd HH:mm:ss&quot;) + &quot;\\&quot;&quot;&#125;\n上边仅仅说了release和debug模式，假如接口方说了这段时间demo环境暂时被占用，而线上的环境我们也不能拿来直接测，怎么办呢？此时接口方又说你可以用我的调试环境，后边都可以一直用，和demo环境一样，只是地址不一样。这是一个突破口，此时我们可以再建一个类型“dev”，我们直接copy于debug类型即可：\n12345dev &#123;    initWith(debug)    matchingFallbacks = [&#x27;dev&#x27;, &#x27;debug&#x27;, &#x27;release&#x27;]    buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\\&quot;http://www.baidu0.com/\\&quot;&quot;)&#125;\n其中initWith(debug)意思就是和debug设置一样，然后下边buildConfigField再对参数覆盖重写。这里说一下matchingFallbacks，我们的工程不可能只有app主模块，肯定还有其他library等子模块，当我们采用dev构建类型编译打包的时候，我们的library也会融入到我们的打包环境中，都是一对一对应的，假如我们library下的gradle中没有dev类型，那么按照matchingFallbacks匹配规则会利用下一级&quot;debug&quot;形式规则打包。如果没有matchingFallbacks匹配规则，则会直接找不到dev类型，从而报错。\nproductFlavors\nproductFlavors是指风味设置，大白话就是我们的多渠道打包。早在gradle2.0时代是不需要加入flavorDimensions风味维度的，gradle3.0加入是为了更加细致区分打包渠道，更直观的说2.0时代只是注重某个品牌下的包，3.0时代又可以区分哪个品牌哪种机型下的包，例如专供小米品牌下小米9提供的包，甚至我们还可以设置针对某个系统版本打包的维度。\n12345678910111213141516171819flavorDimensions &quot;company&quot;,&quot;channel&quot;productFlavors&#123;    companyA&#123;        dimension &quot;company&quot;        buildConfigField &quot;String&quot;,&quot;FLAVOR_NAME&quot;,&quot;\\&quot;companyA\\&quot;&quot;    &#125;    companyB&#123;        dimension &quot;company&quot;        buildConfigField &quot;String&quot;,&quot;FLAVOR_NAME&quot;,&quot;\\&quot;companyB\\&quot;&quot;    &#125;    channelA&#123;        dimension &quot;channel&quot;        buildConfigField &quot;String&quot;,&quot;FLAVOR_NAME&quot;,&quot;\\&quot;channelA\\&quot;&quot;    &#125;    channelB&#123;        dimension &quot;channel&quot;        buildConfigField &quot;String&quot;,&quot;FLAVOR_NAME&quot;,&quot;\\&quot;channelB\\&quot;&quot;    &#125;&#125;\ndependencies\ndependencies闭包里都是项目相关的依赖库，其实没啥说的。这里主要说一下gradle3.0后官方推荐用implementation和api的设置。早在gradle3.4之前我们依赖库所用的方式是compile，使用起来很简单，但是有一个不安全因素，比如我们依赖library，我们同时也可以看到library所依赖的第三方库的方法，本来我只需要看到这个library的几个方法既可，但是现在却让我看到很多没有用的方法，开发过程中针对新人很容易加重编写耦合。而后来的implementation和api的设置可以很好的处理这个弊端，也给我们的组件化过程锦上添花。\n那么implementation和api有什么区别呢？这两个是一个封闭一个开放，前者封闭，后者开放，后者的作用其实和compile完全一样的。假如现有模块app、library1、library2，其中app依赖library1，library1依赖library2，有以下两种区别:\n\nlibrary1和library2依赖关系是implementation，则app不能看到和使用library2中的方法。\nlibrary1和library2依赖关系是api，则app可以使用library2中的公开方法。\n\nimplementation和api在项目开发需要根据具体情况灵活运用。\n参考\n\nGradle DSL 学习\nAndroid Plugin DSL 学习\nGradle task 学习\n深入理解Android之Gradle\nhttps://juejin.im/post/5af4f117f265da0b9f405221#heading-3\n\n","plink":"https://blog.ixin.run/posts/1543499481/"},{"title":"Android开发之Touch事件的分发和消费机制","date":"2018-11-28T14:18:02.000Z","date_formatted":{"ll":"2018年11月28日","L":"2018/11/28","MM-DD":"11-28"},"updated":"2021-01-29T12:51:44.633Z","content":"凡是和视图打交道的避免不了事件的分发和消费，无论是桌面还是移动设备，Android上的Touch事件分发机制尤为重要。\n\n触摸事件场景分配\nAndroid 中与 Touch事件相关的方法包括：\n\ndispatchTouchEvent(MotionEvent ev)\nonInterceptTouchEvent(MotionEvent ev)\nonTouchEvent(MotionEvent ev)\n\n能够响应这些方法的控件包括：\n\nViewGroup 及其子类\nActivity\n\n其中Activity和最小单位的view（例如TextView,不能向其中添加子view ）是不存在onInterceptTouchEvent方法的。以下所说的上层下层是按照由外到内来说。\n\n触摸事件分发流程\n1.事件分发：public boolean dispatchTouchEvent(MotionEvent ev)\n从开始触摸的时候，事件的执行顺序一定是要从最外层的Activity开始，然后按照Activity-&gt;window-&gt;viewgroup-&gt;view依次往下传递，最终将事件传递到具体的view。这种方式也叫隧道方式。我们可以根据它的返回值来控制其走向和终止：\n\nreturn super.dispatchTouchEvent(ev):判断本层是否可执行onInterceptTouchEvent方法，能就派发给onInterceptTouchEvent方法执行，不能就接着向下层的dispatchTouchEvent方法去派发。\nreturn false:判断时候有上层view，有就接着让上层的onTouchEvent方法消费，没有（说明已经是最外层）本方法消费后消失。\nreturn true:仅本view消费后消失，并不往下分发。\n\n2.事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev)\n每当viewgroup中的dispatchTouchEvent正常分发紧接着要执行viewgroup中的onInterceptTpuchEvent方法对此事件进行拦截。和上边一样我们也可以控制其返回值进而控制其是进行拦截事件然后响应还是接着向下一层分发：\n\nreturn super.onInterceptTouchEvent(ev):判断是否有下层，有就接着向下层的dispatchTouchEvent派发，没有就执行本层view的onTouchEvent.\nreturn false:和super.onInterceptTouchEvent返回值功能一样。\nreturn true:进行拦截，不在向下层进行派发，直接交由本层的onTouchEvent方法进行消费。\n\n3.事件响应：public boolean onTouchEvent(MotionEvent ev)\n一旦事件拦截成功或者执行到最后，事件要进行消费（响应），这里也是有三个返回值，可以控制消费完毕后是就此消失还是接着让其他view也跟着响应一下：\n\nreturn super.onTouchEvent(ev):接着向上层传递，通知上层的onTouchEvent方法消费。若上层的返回值也是super.onTouchEvent或者false,接着向上传递，直至事件终止。\nreturn false:和super.onTouchEvent返回值的功能一样。\nreturn true:消费后终止（消失）。\n\n图解具体分发和消费：\n\n","plink":"https://blog.ixin.run/posts/1543414682/"},{"title":"Gradle之Groovy语言","date":"2018-11-28T13:27:38.000Z","date_formatted":{"ll":"2018年11月28日","L":"2018/11/28","MM-DD":"11-28"},"updated":"2021-01-29T12:51:44.647Z","content":"做Android开发的童鞋都了解gradle，知道怎么配置，但是如果在gradle里写一些脚本方法怎么写呢？Java不是Java，c不是c。所以了解核心很重要，这里的核心就是Gradle的生存之本——Groovy语言，其实Groovy很简单，用法上大部分甚至可以直接用Java代替。\n\nGroovy 语法\n基本语法\n1、Groovy注释标记和Java一样，支持 //或者/**/\n2、Groovy语句可以不用分号结尾。Groovy为了尽量减少代码的输入，确实煞费苦心\n3、单引号\n单引号” 中的内容严格对应Java中的String，不对 $ 符号进行转义\n12def s1 = &#x27;i am 100 $ dolloar&#x27;println( s1 )\n运行结果：\n1i am 100 $ dolloar\n4、双引号\n双引号”“的内容则和脚本语言的处理有点像，如果字符中有号的话，则它会表达式先求值。\n1234def x = 100def s1 = &quot;i am $x dolloar&quot;println( s1 )\n运行结果\n1i am 100 dolloar\n5、三引号\n三个引号”’xxx”’中的字符串支持随意换行，比如:\n1234567def s1 = &#x27;&#x27;&#x27; xyzf&#x27;&#x27;&#x27;println(s1)\n运行结果\n1234 xyzf\n定义变量\nGroovy中支持动态类型，即定义变量的时候可以不指定其类型。Groovy中，变量定义可以使用关键字def。注意，虽然def不是必须的，但是为了代码清晰，建议还是使用def关键字\n\n定义一个变量\n\n123456def a = 1 //定义一个整形def b = &quot;字符串&quot; //定义一个字符串def double c = 1.0  //定义一个 double 类型，也可以指定变量类型\n定义函数\n无返回类型的函数定义，必须使用def关键字 ，最后一行代码的执行结果就是本函数的返回值\n123456789//无参函数def fun1()&#123;&#125;//有参函数 , 无需指定参数类型  def fun2( def1 , def2 )&#123;&#125;\n如果指定了函数返回类型，则可不必加def关键字来定义函数\n1234String fun3()&#123;    return &quot;返回值&quot;&#125;\n其实，所谓的无返回类型的函数，我估计内部都是按返回Object类型来处理的。毕竟，Groovy 是基于Java 的，而且最终会转成 Java Code 运行在 JVM 上 .\nGroovy的函数里，可以不使用return xxx 来设置 xxx 为函数返回值。如果不使用 return 语句的话，则函数里最后一句代码的执行结果被设置成返回值。\n1234def getSomething()&#123;       &quot;getSomething return value&quot; //如果这是最后一行代码，则返回类型为String        1000  //如果这是最后一行代码，则返回类型为Integer  &#125;  \n除了每行代码不用加分号外，Groovy中函数调用的时候还可以不加括号\n例子1：\n1234567def s1 = &quot;123&quot;println(s1)//或者println s1 \n例子2：\n1234567println(fun1())println fun1()def fun1()&#123;    &quot;你好&quot;&#125;\n效果：\n12你好你好\n循环 for\n\n方式一\n\n1234for (i = 0; i &lt; 5 ; i++) &#123;    println(&quot;测试&quot;)&#125;\n运行结果： 输出5个测试\ngroovy 语法中，注意 i 前面不用指定 int 类型。\n\n方式二\n\n123for (i in 0..5)&#123;    println(&quot;hello world&quot;)&#125;\n这种方式也是一种循环，只不过他输出的是 6 个 hello world , 如果想要输出5个，有3中方式。\n第一种方法\n123for (i in 0..&lt;5)&#123;    println(&quot;hello world&quot;)&#125;\n第二种方法\n123for (i in 0..4)&#123;    println(&quot;hello world&quot;)&#125;\n第三种方法\n123for (i in 1..5)&#123;    println(&quot;hello world&quot;)&#125;\n循环 time\ntimes表示从0开始循环到4结束\n1234.times &#123;    println it&#125;\n结果：\n12340123\n三目运算符\nJava 语法\n123def namedef result = name != null ? name : &quot;abc&quot;println(result)\ngroovy 语法\n12def name = &#x27;d&#x27;def result = name?: &quot;abc&quot;\n捕获异常\n捕获所有的 Exception ，有两种写法\n12345678910111213//第一种写法，Java 写法try &#123;    println 5 / 0&#125; catch (Exception e) &#123;&#125;//第二种写法，Groovy 写法try &#123;    println 5 / 0&#125; catch (anything) &#123;&#125;\n这里的any并不包括Throwable，如果你真想捕获everything，你必须明确的标明你想捕获Throwable\nswitch\n123456789101112131415161718age = 36def rateswitch (age) &#123;    case 10..26:        rate = 0.05        break    case 27..36:        rate = 0.06        break    case 37..46:        rate = 0.07        break    default:        throw new IllegalArgumentException()&#125;println( rate)\n判断是否为真\n1234567891011Person person//Java 写法if (person!= null)&#123;    if (person.Data!=null)&#123;        println person.Data.name    &#125;&#125;//Groovyprintln person?.Data?.name\nasType\nasType 就是数据类型转换\n12345//String 转成 int def s2 = s1 as int//String 转成 int def s3 = s1.asType(Integer)\nGroovy 数据类型\nGroovy中的数据类型主要分2种，重点分以下3种情况：\n\n一个是Java中的基本数据类型。\n另外一个是Groovy中的容器类。\n最后一个非常重要的是闭包。\n\nJava 基本类型\n123456789def boolean s1 = truedef int s2 = 100def String s3 = &quot;hello world&quot;if (s1) &#123;    println(&quot;hello world&quot;)&#125;\nGroovy 容器\nList：链表，其底层对应Java中的List接口，一般用ArrayList作为真正的实现类。\nMap：键-值表，其底层对应Java中的LinkedHashMap。\nRange：范围，它其实是List的一种拓展。\n\nList\n\n12345678910111213141516171819202122232425//变量定义：List变量由[]定义，其元素可以是任何对象def aList = [5,&#x27;string&#x27;,false]println(aList)println aList[0]  //获取第1个数据println aList[1]  //获取第2个数据println aList[2]  //获取第3个数据println aList[3]  //获取第4个数据println( &quot;集合长度：&quot; + aList.size())//赋值aList[10] = 100  //给第10个值赋值aList&lt;&lt;10 //在 aList 里面添加数据println aListprintln &quot;集合长度：&quot; + aList.size()\n效果如下：\n12345678[5, string, false]5stringfalsenull集合长度：3[5, string, false, null, null, null, null, null, null, null, 100]集合长度：11\n\nmap\n\n12345678910111213141516171819202122232425262728293031323334353637383940def map &#x3D; [key1: &quot;value1&quot;, key2: &quot;value2&quot;, key3: &quot;value3&quot;]println map&#x2F;&#x2F;[key1:value1, key2:value2, key3:value3]println(&quot;数据长度：&quot; + map.size())&#x2F;&#x2F;数据长度：3println(map.keySet())&#x2F;&#x2F;[key1, key2, key3]println(map.values())&#x2F;&#x2F;[value1, value2, value3]println(&quot;key1的值：&quot; + map.key1)&#x2F;&#x2F;key1的值：value1println(&quot;key1的值：&quot; + map.get(&quot;key1&quot;))&#x2F;&#x2F;key1的值：value1&#x2F;&#x2F;赋值map.put(&quot;key4&quot;, &quot;value4&quot;)Iterator it &#x3D; map.iterator()while (it.hasNext()) &#123;    println &quot;遍历map: &quot; + it.next()&#125;&#x2F;&#x2F;遍历map: key1&#x3D;value1&#x2F;&#x2F;遍历map: key2&#x3D;value2&#x2F;&#x2F;遍历map: key3&#x3D;value3&#x2F;&#x2F;遍历map: key4&#x3D;value4map.containsKey(&quot;key1&quot;) &#x2F;&#x2F;判断map是否包含某个keymap.containsValue(&quot;values1&quot;)  &#x2F;&#x2F;判断map是否包含某个valuesmap.clear()  &#x2F;&#x2F;清除map里面的内容Set set &#x3D; map.keySet(); &#x2F;&#x2F;把 map 的key值转换为 set\n\nrange\n\nRange 是 Groovy 对 List 的一种拓展\n123456789101112131415161718def range = 1..5println(range)//[1, 2, 3, 4, 5]range.size()  //长度range.iterator() //迭代器def s1 = range.get(1) //获取标号为1的元素range.contains( 5) //是否包含元素5range.last() //最后一个元素range.remove(1) //移除标号为1的元素range.clear() //清空列表\n例子2：\n12345678910def range = 1..5println(range)//[1, 2, 3, 4, 5]println(&quot;第一个数据: &quot;+range.from) //第一个数据//第一个数据: 1println(&quot;最后一个数据: &quot;+range.to)   //最后一个数据//最后一个数据: 5\n闭包(重要)\n闭包，英文叫Closure，是Groovy中非常重要的一个数据类型或者说一种概念了。闭包，是一种数据类型，它代表了一段可执行的代码。\n12345def aClosure = &#123;//闭包是一段代码，所以需要用花括号括起来..      String param1, int param2 -&gt;  //这个箭头很关键。箭头前面是参数定义，箭头后面是代码      println&quot;this is code&quot; //这是代码，最后一句是返回值，     //也可以使用return，和Groovy中普通函数一样  &#125;  \n简而言之，Closure的定义格式是：\n1234def xxx = &#123;paramters -&gt; code&#125;  //或者  def xxx = &#123;无参数，纯code&#125;\n说实话，从C/C++语言的角度看，闭包和函数指针很像。闭包定义好后，要调用它的方法就是：\n闭包对象.call(参数)\n或者更像函数指针调用的方法：\n闭包对象(参数)\n比如：\n1234aClosure.call(&quot;this is string&quot;,100)  //或者  aClosure(&quot;this is string&quot;, 100)\n实例演练,源码如下\n12345678910def fun1 = &#123;    p1 -&gt;        def s = &quot;我是一个闭包,&quot; + p1&#125;println(fun1.call())  //闭包 调用方式1println(fun1.call(&quot;我是一个参数&quot;)) //闭包 调用方式2println(fun1(&quot;我是一个参数2&quot;))\n运行结果如下：\n123我是一个闭包,null我是一个闭包,我是一个参数我是一个闭包,我是一个参数2\n无参形式\n闭包没定义参数的话，则隐含有一个参数，这个参数名字叫it，和this的作用类似。it代表闭包的参数。\n12345def fun2 = &#123;    it-&gt; &quot;dsdsd&quot;&#125;println( fun2.call())\n如果在闭包定义时，采用下面这种写法，则表示闭包没有参数！\n12345def fun3 = &#123;    -&gt; &quot;dsdsd&quot;&#125;println( fun3.call())\n如果调用 fun3 的时候传递参数就会报错，比如\n1fun3.call(&quot;d&quot;)  //执行这个方法的时候就会报错\n省略圆括号\n123456789101112131415def list = [1,2,3]  //定义一个List//调用它的each，这段代码的格式看不懂了吧？each是个函数，圆括号去哪了?list.each &#123;    println(it)&#125;//结果/** * 1 * 2 * 3 */\neach函数调用的圆括号不见了！其实这在上边已经有所体现，当只有一个参数时可以直接去掉圆括号，这个特点非常关键，因为以后在Gradle中经常会出现这样的代码：\n12345task hello&#123;    doLast&#123;        println(&quot;hello world&quot;)    &#125;&#125;\n省略圆括号虽然使得代码简洁，看起来更像脚本语言\nJava 属性\nGroovy中可以像Java那样写package，然后写类。比如我们在 Person.groovy 文件中编写Java 代码。\n如果不声明public/private等访问权限的话，Groovy中类及其变量默认都是public的。\n再识 Groovy\nJava中，我们最熟悉的是类。但是我们在Java的一个源码文件中，不能不写class（interface或者其他….），而Groovy可以像写脚本一样，把要做的事情都写在xxx.groovy中，而且可以通过groovy xxx.groovy直接执行这个脚本。这到底是怎么搞的？\n既然是基于Java的，Groovy会先把xxx.groovy中的内容转换成一个Java类。\n在运行完 Test.groovy 后，发现会产生一个 out 目录，在这个目录里面可以看到 Person.groovy 、Test.groovy 被转换成了 .class 文件\n\n编译完成后，.groovy 文件都被转换成了 .class 文件，每个 .class 文件都默认有静态 main 方法。每一个脚本都会生成一个static main函数。这样，当我们groovytest.groovy的时候，其实就是用java去执行这个main 函数。\n脚本中的所有代码都会放到run函数中。比如，println ‘Groovy world’，这句代码实际上是包含在run函数里的。\nTest 继承 Script 类。\n\nScript 类\n在 groovy 的库文件中，可以看到 Script 类是一个抽象类，继承 GroovyObjectSupport 类，如下所示\n脚本变量的作用域\n在 Test.groovy 里面定义变量 s1 , 方法 fun1 , 同时在 fun1 方法中输出 s1 , 代码如下：\n但是一运行就报错\ngroovy中方法内不能随意引用java中的“全局”属性，如果想引用可将def去掉，但这种也不是直接引用，而是在groovy转Java的过程中方法体内会复制一份这个属性，如果想真正的进行引用可在字段前边加一个注解标识@Field\n1@Field s1 = &quot;123&quot; //s1 彻彻底底变成 Test 的成员变量\nJSON 操作\nJsonOutput 类把对象转换成 json字符串。\nJsonSlurper 类把 json 字符串转换成对象\n定义 Person 实体类\n12345public class Person &#123;    String name;    int age;&#125;\n对象转json 、 json 转对象\n123456789101112131415Person person = new Person();person.name = &quot;zhaoyanjun&quot;person.age = 27//把对象转换为 json 字符串def json =JsonOutput.toJson(person)println(json)JsonSlurper jsonSlurper = new JsonSlurper()//把字符串转换为对象Person person1 = jsonSlurper.parseText(json)println( person1.name )\n运行效果如下：\n12&#123;&quot;age&quot;:27,&quot;name&quot;:&quot;zhaoyanjun&quot;&#125;zhaoyanjun\n集合对象转json 、json 转集合对象\n123456789101112131415161718192021Person person = new Person();person.name = &quot;zhaoyanjun&quot;person.age = 27Person person1 = new Person();person1.name = &quot;zhaoyanjun2&quot;person1.age = 28def list = [person,person1]//把集合对象转换为 json 字符串def jsonArray =JsonOutput.toJson(list)println(jsonArray)JsonSlurper jsonSlurper = new JsonSlurper()//把字符串转换为集合对象List&lt;Person&gt; list2 = jsonSlurper.parseText(jsonArray)println( list2.get(1).name )\n运行结果为：\n12[&#123;&quot;age&quot;:27,&quot;name&quot;:&quot;zhaoyanjun&quot;&#125;,&#123;&quot;age&quot;:28,&quot;name&quot;:&quot;zhaoyanjun2&quot;&#125;]zhaoyanjun2\nI/O 操作\nGroovy的 I/O 操作是在原有Java I/O操作上进行了更为简单方便的封装，并且使用Closure来简化代码编写。虽然比Java看起来简单，但要理解起来其实比较难。\n文本文件读\n在电脑上新建一个文本文件 test.txt ， 内容如下：\n123今天是星期五天气很好明天就要放假了\n下面用 groovy 读取里面的文本\n123456def filePath = &quot;C:/Users/T/Desktop/test.txt&quot;def file = new File(filePath) ;file.eachLine &#123;    println it&#125;\n你没有看错，就是这么简单，groovy 的文件读取操作简单到令人发指。但是这不够，还有跟令人发指的操作，比如：\n1234def filePath = &quot;C:/Users/T/Desktop/test.txt&quot;def file = new File(filePath) ;println file.text //输出文本\n更多用法\n\n指定编码格式\n\n1234567def filePath = &quot;C:/Users/T/Desktop/test.txt&quot;def file = new File(filePath);//指定编码格式为 utf-8file.eachLine(&quot;utf-8&quot;) &#123;    println it  //读取文本&#125;\n\n把小写转成大写\n\n123456def filePath = &quot;C:/Users/T/Desktop/test.txt&quot;def file = new File(filePath);file.eachLine &#123;    println( it.toUpperCase() )&#125;\n文本文件写\n\n方式1\n\n1234567def filePath = &quot;C:/Users/T/Desktop/test.txt&quot;def file = new File(filePath);file.withPrintWriter &#123;    it.println(&quot;测试&quot;)    it.println(&quot;hello world&quot;)&#125;\n\n方式2\n\n12345678def filePath = &quot;C:/Users/T/Desktop/test.txt&quot;def file = new File(filePath);def out = file.newPrintWriter();out.println(&quot;测试&quot;)out.println(&quot;hello world&quot;)out.flush()out.close()\n文件夹操作\n\n遍历文件夹中的文件、文件\n\n123456789101112def filePath = &quot;C:/Users/T/Desktop/123&quot;def file = new File(filePath);//遍历 123 文件夹中文件夹file.eachDir &#123;    println &quot;文件夹：&quot;+it.name&#125;//遍历 123 文件夹中的文件file.eachFile &#123;    println &quot;文件：&quot;+ it.name&#125;\n效果如下：\n1234567文件夹：1文件夹：2文件夹：3文件：1文件：2文件：3文件：4.txt\n深度遍历文件\n123456789101112def filePath = &quot;e:/&quot;def file = new File(filePath);//深度遍历目录,也就是遍历目录中的目录file.eachDirRecurse &#123;    println it.name&#125;//深度遍历文件,包括目录和文件file.eachFileRecurse &#123;    println it.path&#125;\nInputStream\n1234567def filePath = &quot;C:/Users/T/Desktop/test.txt&quot;def file = new File(filePath) ;def ism =  file.newInputStream()//操作ism，最后记得关掉ism.close\n使用闭包操作 inputStream，以后在Gradle里会常看到这种搞法\n123456789def filePath = &quot;C:/Users/T/Desktop/test.txt&quot;def file = new File(filePath) ;file.withInputStream &#123;ism-&gt;    // 操作ism. 不用close。Groovy会自动替你close      ism.eachLine &#123;        println it  //读取文本    &#125;&#125;\n确实够简单，令人发指。我当年死活也没找到withInputStream是个啥意思。所以，请各位开发者牢记Groovy I/O操作相关类的SDK地址：\n\njava.io.File: http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html\njava.io.InputStream: http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html\njava.io.OutputStream: http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/OutputStream.html\njava.io.Reader: http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Reader.html\njava.io.Writer: http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Writer.html\njava.nio.file.Path: http://docs.groovy-lang.org/latest/html/groovy-jdk/java/nio/file/Path.html\n\nxml 解析\n在java中解析xml是非常繁琐的，通常需要用10行代码去解析5行的xml文件，非常不经济。在groovy 中解析xml 就很方便了。\n实例1 解析简单xml\n比如下面一段xml\n1234567&lt;?xml version=&quot;1.0&quot;?&gt;&lt;langs type=&quot;current&quot;&gt;&lt;language&gt;Java&lt;/language&gt;&lt;language&gt;Groovy&lt;/language&gt;&lt;language&gt;JavaScript&lt;/language&gt;&lt;/langs&gt;\ngroovy 解析如下：\n1234567891011//获取 xml 文件的 langs 节点def langs = new XmlParser().parse(&quot;C:/Users/T/Desktop/test.xml&quot;)//获取type 字段的值def type = langs.attribute(&quot;type&quot;)println typelangs.language.each&#123;    println it.text()&#125;\n结果如下：\n1234currentJavaGroovyJavaScript\n实例2 解析复杂 xml\nxml 如下图所示：\n1234567891011121314151617181920&lt;metadata&gt;&lt;groupId&gt;com.yiba.sdk&lt;/groupId&gt;&lt;artifactId&gt;weshareWiFiSDk&lt;/artifactId&gt;&lt;version&gt;2.3.3&lt;/version&gt;&lt;versioning&gt;&lt;latest&gt;2.3.3&lt;/latest&gt;    &lt;versions&gt;    &lt;version&gt;2.2.7&lt;/version&gt;    &lt;version&gt;2.3.0&lt;/version&gt;    &lt;version&gt;2.3.1&lt;/version&gt;    &lt;version&gt;2.3.2&lt;/version&gt;    &lt;version&gt;2.3.3&lt;/version&gt;    &lt;/versions&gt;&lt;/versioning&gt;&lt;/metadata&gt;\n解析代码如下：\n1234567891011121314151617181920212223242526//获取metadata节点def metadata = new XmlParser().parse(&quot;C:/Users/T/Desktop/test1.xml&quot;)//获取metadata下面的 groupId 属性值def groupId = metadata.groupId.text()//获取metadata下面的 artifactId 属性值def artifactId = metadata.artifactId.text()//获取metadata下面的 version 属性值def version = metadata.version.text()println groupId + &quot; &quot; + artifactId + &quot; &quot; + version//获取metadata下面的 versioning 节点def versioning = metadata.versioning//获取versioning 下面的 latest 属性值println versioning.latest.text()//获取versioning 下面的 versions 节点def versions = versioning.versionsversions.version.each&#123;    //遍历 versions 下面的version 值    println &quot;version&quot; + it.text()&#125;\n结果如下：\n1234567com.yiba.sdk weshareWiFiSDk 2.3.32.3.3version2.2.7version2.3.0version2.3.1version2.3.2version2.3.3\n参考\n\nGroovy官方文档\nGradle从入门到实战 - Groovy基础\n\n","plink":"https://blog.ixin.run/posts/1543411658/"},{"title":"Android上的硬件加速","date":"2018-11-27T15:35:38.000Z","date_formatted":{"ll":"2018年11月27日","L":"2018/11/27","MM-DD":"11-27"},"updated":"2021-01-29T12:51:44.621Z","content":"层经接手的一个项目中有一个电子签名功能，总是莫名会出现绘制的签名跑偏的问题，后来经检测发现前人为了使view更好的进行绘制，全局开启了硬件加速。这里就总结一下硬件加速的知识，踩过的坑记一下。\n\n什么是硬件加速\n官方的话：\n硬件加速（Hardware acceleration）就是利用硬件模块来替代软件算法以充分利用硬件所固有的快速特性。硬件加速通常比软件算法的效率要高。\n自己的话：\n都知道CPU很厉害，计算能力超强，但是万物总有一个量，他能力强了你也不能什么都交给他，任务超出承受能力他也是受不了的。这个时候怎么弄？可以交给其他“更专业的人”（GPU）来做，分工明确，让cpu腾出来点空做其他事，这样整体效率就提高了。（不好意思，啰嗦了）\n硬件加速的优缺点\n硬件加速能能够使用GPU来加速2D图形的渲染操作，但是硬件加速并不能支持所有的渲染操作。针对自定义的View有可能会出现渲染错位的情况，如果有自定义的View，在开启硬件加速的设备上操作，出现渲染问题，我们可以关闭硬件加速。\nAndroid上的硬件加速\n在Android API 11之后，开始支持硬件加速，所有的ViewCanvas都会支持GPU,但是硬件加速会占用一定的RAM资源。在API 14（Android 4.0）之后默认是全部开启硬件加速的，如果你的应用全部都是标准的View和Drawable，全局都打开硬件加速是不会有问题的。\n然而硬件加速并不是支持所有的2D图形绘制操作，在Android4.0之后的设备上，有时候我们定制了比较复杂的自定义View，我们的view在刷新的时候有可能会出现花屏或者某些View错位的情况，通过Logcat分析会出现这样的错误：\n09-18 14:34:39.656: DEBUG/OpenGLRenderer(3104): GL error from OpenGLRenderer: 0x501\n从这个日志可以分析出，初步认为可能就是硬件加速导致的问题，必要时关闭硬件加速即可。\n硬件加速的限制\n目前，Android对硬件加速的支持并非完美，有些绘制操作在开启硬件加速的情况下不能正常工作（具体的列表可以参考Android开发者文档）。\n不过Android可以保证内置的组件和应用支持硬件加速。因此，如果应用中只使用了标准UI组件，可以放心开启硬件加速。\n硬件加速的开启和关闭\n由于硬件加速自身并非完美无缺，所以Android提供选项来打开或者关闭硬件加速，默认是关闭。可以在4个级别上打开或者关闭硬件加速。\nApplication级别\n在AndroidManifest内的application标签上可控制全局硬件加速的开启和关闭：\n1&lt;application android:hardwareAccelerated=&quot;true&quot; ...&gt;\nActivity级别\n同样在在AndroidManifest内的activity标签上可控制当前activity的硬件加速的开启和关闭：\n1&lt;activity android:hardwareAccelerated=&quot;false&quot; ...&gt;\nWindow级别\nWindow级别上只能控制硬件加速的开启方法：\n123getWindow().setFlags(        WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,    \tWindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);\nView级别\nView级别上只有关闭硬件加速的方法。\n方法一：\n1myView.setLayerType(View.LAYER_TYPE_HARDWARE, null);\n方法二，使用android:layerType=&quot;software&quot;来关闭硬件加速：\n1234567&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;          android:layout_width=&quot;fill_parent&quot;          android:layout_height=&quot;fill_parent&quot;          android:orientation=&quot;vertical&quot;          android:paddingLeft=&quot;2dp&quot;          android:layerType=&quot;software&quot;          android:paddingRight=&quot;2dp&quot; &gt; \n判断是否支持硬件加速方法\n1234// returns true if the View is attached to a hardware accelerated window. View.isHardwareAccelerated(); // returns true if the Canvas is hardware accelerated.canvas.isHardwareAccelerated();\n理解View的绘制模型\n\n没有硬件加速：invalidate the view hierarchy ------&gt; draw the view hierarchy\n有硬件加速：invalidate the view hierarchy ------&gt; record and update the display list ------&gt; draw the display list\n\n开启硬件加速之后的异常反应\n\n某些UI元素没有显示：可能是没有调用invalidate。\n某些UI元素没有更新：可能是没有调用invalidate。\n绘制不正确：可能使用了不支持硬件加速的操作， 需要关闭硬件加速或者绕过该操作。\n抛出异常：可能使用了不支持硬件加速的操作， 需要关闭硬件加速或者绕过该操作。\n\n总结\n硬件加速开启在目前开发阶段并非是一剂良方，根据使用时机，必要时开启或关闭。事物都有一个推进过程，随着Android的版本升级以及硬件能力的提高，相信一段时间之后，硬件加速可以得到完美的支持。\n","plink":"https://blog.ixin.run/posts/1543332938/"},{"title":"Android设备信息的那些事","date":"2018-11-26T05:03:30.000Z","date_formatted":{"ll":"2018年11月26日","L":"2018/11/26","MM-DD":"11-26"},"updated":"2021-01-29T12:51:44.645Z","content":"Android开发过程中避免不了要获取一些与设备相关的信息，比如deviceId，判断网络类型等。有时候我们到手机设备信息界面看到一个陌生的代号也是一头雾水，虽然有一种似曾相识的感觉，但是确实不知道是干什么，本篇就为你揭开这层面纱。\n\n科普几个概念\n常规\n\nIMEI\nMEID\nIMSI\nICCID\n基带版本\n内核版本\n\nAndroid\n\nDeviceId\nAndroidId\n序列号\n\nIMEI\n国际移动设备识别码（International Mobile Equipment Identity，IMEI），即通常所说的手机通信序列号、手机「串号」，用于在行动电话网络中识别每一部独立的手机等行动通讯装置，共有15位数字。\n手机号码盘输入“*#06#”可显示当前手机的IMEI信息。IMEI作为手机通讯序列号，在某些不包含通信功能设备上自然也就不存在这个值了。另外双卡双待手机可以拿到两个IMEI序列号。\nMEID\n移动设备识别码(Mobile Equipment Identifier)是CDMA手机的身份识别码，也是每台CDMA手机或通讯平板唯一的识别码。通过这个识别码，网络端可以对该手机进行跟踪和监管。用于CDMA制式的手机。MEID的数字范围是十六进制的，和IMEI的格式类似。\n因为MEID是CDMA的身份标识，某些手机不支持CDMA（电信）制式，因此在系统信息界面也就不会显示这个值了，也可以作为全网通和移动联通手机的区分。\nIMSI\n国际移动用户识别码（International Mobile Subscriber Identification Number）是区别移动用户的标志，储存在SIM卡中，可用于区别移动用户的有效信息，长度不超过15位，实际使用的IMSI的长度绝大部分都是15位。\nIMSI结构如下：MCC+MNC+MIN\n其中：\n\nMCC：Mobile Country Code，行动装置国家代码，共3位，中国为460;\nMNC:Mobile Network Code，移动设备网络代码，2位(欧洲标准)或3位(北美标准)，中国电信CDMA系统使用03；\n\n\nAndroid开发过程中区分网络运营商：\n1234567891011121314151617181920public static String getSimOperator() &#123;    TelephonyManager tm = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);    String imsi = tm.getSubscriberId();    String operator = &quot;&quot;;    if (!TextUtils.isEmpty(imsi)) &#123;        if (imsi.startsWith(&quot;46000&quot;) || imsi.startsWith(&quot;46002&quot;) || imsi.startsWith(&quot;46007&quot;)) &#123;            // 中国移动            operator = &quot;中国移动&quot;;        &#125; else if (imsi.startsWith(&quot;46001&quot;) || imsi.startsWith(&quot;46006&quot;)) &#123;            // 中国联通            operator = &quot;中国联通&quot;;        &#125; else if (imsi.startsWith(&quot;46003&quot;) || imsi.startsWith(&quot;46005&quot;)) &#123;            // 中国电信            operator = &quot;中国电信&quot;;        &#125;    &#125;        return operator;&#125;\n当然也可以采用TelephonyManager中的getSimOperator()方法来获取：\n12345678910111213141516171819public static String getSimOperator() &#123;        TelephonyManager tm = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);        String operatorNum = tm.getSimOperator();        String operator = &quot;&quot;;        if (!TextUtils.isEmpty(operatorNum)) &#123;            if (&quot;46000&quot;.equals(operatorNum) || &quot;46002&quot;.equals(operatorNum) || &quot;46007&quot;.equals(operatorNum)) &#123;                // 中国移动                operator = &quot;中国移动&quot;;            &#125; else if (&quot;46001&quot;.equals(operatorNum) || &quot;46006&quot;.equals(operatorNum)) &#123;                // 中国联通                operator = &quot;中国联通&quot;;            &#125; else if (&quot;46003&quot;.equals(operatorNum) || &quot;46005&quot;.equals(operatorNum)) &#123;                // 中国电信                operator = &quot;中国电信&quot;;            &#125;        &#125;        return operator;    &#125;\nICCID\n集成电路卡识别码（Integrate circuit card identity），固化在手机SIM卡中 ICCID为IC卡的唯一识别号码，共有20位数字组成， 其编码格式为：XXXXXX 0MFSS YYGXX XXXX。分别介绍如下： 前六位运营商代码：中国移动的为：898600；898602；898604；898607 ，中国联通的为：898601、898606、898609，中国电信898603。SIM卡的ICCID不正规途径可以进行伪造。\nICCID和IMSI区别：\n\n一张SIM卡，里面有ICCID，也有IMSI。 ICCID是卡的标识，IMSI是用户的标识。\nICCID只是用来区别SIM卡，不作接入网络的鉴权认证。而IMSI在接入网络的时候，会到运营商的服务器中进行验证。\n\n基带版本\n基带版本就是手机的调制解调器使用的驱动版本号，调制解调器主要目的负责着手机的通信功能（打电话，发短信，数据交换等）。\n基带（Baseband）是手机中的一块电路，负责完成移动网络中无线信号的解调、解扰、解扩和解码工作，并将最终解码完成的数字信号传递给上层处理系统进行处理。\n内核版本\n内核版本就是手机的硬件（如主板，GPS，摄像头，WiFi，蓝牙等）驱动集合体的版本号。\nDeviceId\n设备唯一标识，针对Android设备，它根据不同的手机设备返回IMEI，MEID或者ESN码。手机制式为GSM时，返回手机的IMEI；手机制式为CDMA时，返回手机的MEID或ESN。\n开发过程中一般用DeviceId来标识唯一设备，需要预先申请电话权限，获取deviceId方法如下：\n1234public static String getDeviceID() &#123;    TelephonyManager tm = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);    return tm.getDeviceId();&#125;\n但是某些情况下获取DeviceId可能为空，具体原因有：\n\n只有拥有通讯打电话功能的android设备才有IMEI号，WIFI平板获取不到。\nAndroid6.0以上设备获取deviceId需要申请系统信息相关权限，用户不同意权限同样拿不到。\n即使有打电话功能，国内部分厂商自己的系统可能会把deviceId值改变，从而得到的是空值、”null”或类似00…相同的值。\n\nAndroidId\n在设备首次启动时，系统会随机生成一个64位的数字，并把这个数字以16进制字符串的形式保存下来，这个16进制的字符串就是ANDROID_ID，来标识当前系统的唯一性，当设备被恢复出厂设置后该值会被重置。\n如果想要采用AndroidId作为设备唯一ID使用，获取androidId方法如下：\n12345public static String getAndroidId() &#123;    return android.provider.Settings.Secure.getString(            mContext.getContentResolver(),            android.provider.Settings.Secure.ANDROID_ID);&#125;\n但需要考虑以下几种情况：\n\n在Android &lt;=2.1 or Android &gt;=2.3的版本是可靠、稳定的，但在2.2的版本并不是100%可靠的\n。\n厂商定制系统的Bug：不同的设备可能会产生相同的ANDROID_ID，有些设备返回的值为null。\n设备差异：对于CDMA设备，ANDROID_ID和TelephonyManager.getDeviceId() 返回相同的值。\n并且，如果某个Andorid手机被Root过的话，这个ID也可以被改变。\n\n序列号\nSerial Number，或叫SN，即设备生产时确定的一串序列号，例如5JPDU17519001099。\n设备序列号也可作为设备唯一标识，获取SN号方法如下：\n123public static String getSerialNumber() &#123;    return android.os.Build.SERIAL;&#125;\n但有些设备获取SN也不准确（汗！！！）：\n\n对CDMA设备，返回的是一个空值。\n在少数的一些设备上，会返回垃圾数据。对于没有通话功能的设备，它可能会返回一个固定的值。\n\nAndroid获取唯一标识\n某一天产品经理告诉我必须要有一个值来确定唯一设备，但是根据上边的deviceId、androidId、SN号，似乎都不能准备来确定唯一的值，无奈啊。你也可能会说，我也可以根绝wifi MAC地址，蓝牙MAC地址来确定，但是我也可以明确的告诉你，针对wifi MAC地址和蓝牙MAC地址也是受系统影响的，在某时候关闭wifi和蓝牙并不能获取到MAC地址，而且在Android6.0的时候google将wifi MAC地址封闭了，各个设备返回的都是“02:00:00:00:00:00”常量值。\ngoogle的官方文档明确指出wifi地址问题：\n\nMost notably, Local WiFi and Bluetooth MAC addresses are no longer available. The getMacAddress() method of a WifiInfo object and the BluetoothAdapter.getDefaultAdapter().getAddress() method will both return 02:00:00:00:00:00 from now on.\n\n这种情况下我们应该怎么办呢？我也只能说“如果拿不到只能自己造了”，以下是我给出的一种方案，似乎也能满天过海吧。\n思想：\n\nApp启动闪屏页或登录页首先检测电话管理权限和读写权限（为后边获取存储唯一ID做准备）；\n分别判断SD卡和Sharepreference是否保存有之前保存的设备唯一ID:\nSP和SD都有,判断是否一致，不一致，复制SP到SD，取SP值。\nSP和SD有且只有其中一个有，相互复制，然后取值。\nSP和SD都没有：\n\n获取deviceId，若为空，向下取；\n获取SN，若为空，向下取；\nUUID生成一个，分别保存到SD和SP。\n\n\n\n注意：SD卡上保存的时候，路径隐蔽一些，防止被删除。\n以上方法，只要不刷机，获取到的值都是唯一的。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static String getDeviceId0() &#123;    final String DEVICE_ID_SP = &quot;DEVICE_ID&quot;;    //文件名前边加个“.”可隐藏此文件。    final String DEVICE_ID_SD_SDR = &quot;Android/data/.device&quot;;    String spDeviceId = (String) SPUtil.get(SPUtil.SP_GLOBAL, DEVICE_ID_SP);    String sdDeviceId = FileUtil.readFileFromSD(DEVICE_ID_SD_SDR);    String deviceId;    boolean isSaveSP = false;    boolean isSaveSD = false;    //获取deviceId;    if (!IsEmpty.string(spDeviceId) &amp;&amp; !IsEmpty.string(sdDeviceId)) &#123;        deviceId = spDeviceId;        if (!spDeviceId.equals(sdDeviceId)) &#123;            isSaveSD = true;        &#125;    &#125; else if (!IsEmpty.string(spDeviceId) &amp;&amp; IsEmpty.string(sdDeviceId)) &#123;        deviceId = spDeviceId;        isSaveSD = true;    &#125; else if (IsEmpty.string(spDeviceId) &amp;&amp; !IsEmpty.string(sdDeviceId)) &#123;        deviceId = sdDeviceId;        isSaveSP = true;    &#125; else &#123;        deviceId = getDeviceID();        if (IsEmpty.string(deviceId)) &#123;            deviceId = &quot;sn&quot; + getSerialNumber();            if (IsEmpty.string(deviceId)) &#123;                UUID id = UUID.randomUUID();                String[] idd = id.toString().split(&quot;-&quot;);                deviceId = &quot;uu&quot; + idd[0] + idd[1] + idd[2];            &#125;        &#125;        isSaveSP = true;        isSaveSD = true;    &#125;    //存储deviceId;    if (isSaveSP) &#123;        SPUtil.put(SPUtil.SP_GLOBAL, DEVICE_ID_SP, deviceId);    &#125;    if (isSaveSD) &#123;        FileUtil.writeFileToSD(DEVICE_ID_SD_SDR, deviceId);    &#125;    return deviceId;&#125;\nTip\n\n这对手机制式GSM、CDMA、WCDMA等本篇不做过多阐述，可自行研究了解。\nAndroid开发过程中根据TelephonyManager的getLine1Number有些时候并不一定能拿到电话号码，此种情况只能够读取写入到SIM卡的手机号，有些电话卡上的电话号码只存在运营商服务器上（例如移动）。\n\n","plink":"https://blog.ixin.run/posts/1543208610/"},{"title":"那些年Android保活的奇技淫巧","date":"2018-11-22T15:43:26.000Z","date_formatted":{"ll":"2018年11月22日","L":"2018/11/22","MM-DD":"11-22"},"updated":"2021-01-29T12:51:44.652Z","content":"进程保活是android开发者很重要的一堂课。在对外的应用中我们希望自己的应用能够在用户的手机上保留的时间长一点，用来做一些“背后应该做”的事。在对内的应用中更希望应用能够长时间保活，用来进行数据的采集和数据接收发送，保证业务的稳定性。\n\n为什么是那些年\n为什么说是那些年呢？早在4.4之前简直就是一场噩梦般存在，手机上各家应用被各种手段进行金钟罩般保护着，甚至有大神给出的方案称进程永生不死，擂台就那么大一点，最终导致应用装的越多手机越卡。后来google也重视了这个问题，后边的版本慢慢将这些所谓的保活的漏洞补住了一部分，当然目前的各种手段其实最多只是让应用生命力稍微强一点，至于永生不死，也不现实，除非系统帮你。\n如实说，作为一名开发者，虽然也会一些招式，但是我真心不希望这些所谓的保活黑科技出现，因为安卓生态平衡一旦打破，带来的结果将是用户流失，走向消亡。这里本着深明大义的原则做一个保活手段的相关总结，前边也说了目前的保活手段最多帮应用提升一点生命力，永生不现实，这里也是系统分析一下相关思想。\n保活手段\n目前的保活手段可谓是层出不穷，以下是常用的几种手段。\n\n申请电源锁，保持CPU 运转，从而提高应用的生命力。\n提高后台服务service的优先级，尽可能的提高其生命力。\n采用服务前台展示的形式，从而提高其生命力。\n在service的onstartCommand方法里返回STATR_STICK。\n在service的onDestroy方法里自启service。\nroot后成为系统级应用，在Manifest文件添加属性值android:persistent=“true”。\n开机，网络切换、拍照、拍视频时候，利用系统产生的广播唤醒app。\n通过接入各大手机厂商自家的推送服务。\nAlarmManager唤醒。\nJobScheduler定时唤醒。\n双进程，甚至多进程守护。\n长连接心跳唤醒保活。\n1像素点悬浮层。\n无声音乐保活。\n系统白名单。\n\n保活分类\n\n\n按照大众说法可以分为三种类：\n\n黑色保活：利用进程规则或广播拉起，强制应用不容易杀死，导致应用强占内存不放，用户比较反感。\n白色保活：google允许的保活方式，其实也是用户同意的。\n灰色保活：隐式保活，仅仅是提高其生命力，进程杀掉其生命也就结束了。\n\n\n\n按照我自己的说法可以分为两类：\n\n不死：尽可能保证其不被杀死。\n回生：死了通过各种拉活手段将其救活。\n\n\n\n保活手段细说\n例如申请电源锁、利用service生命周期以及startForeground前台保活，这些常见的提升生命力的保活方式我就不提了，以下简单阐述一些其他保活骚操作。\n利用系统静态广播唤醒\n在某种应激下系统会发出一些广播通知，例如开机广播，开屏灭屏广播，锁屏解锁等，可以利用系统级广播来进行拉活app。google已经注意到这种情况，在Android N系统中已去掉了 ACTION_NEW_PICTURE（拍照），ACTION_NEW_VIDEO（拍视频），CONNECTIVITY_ACTION（网络切换）三种广播。另外在4.0以上，一旦被系统强制杀死后也不能接收广播来进行启动了。\n常见的系统静态广播有：\n\n通过接入各大手机厂商自家的推送服务\n一般手机厂商自家的推送进程系统是不会杀的。例如你若想支持小米用户，就接入小米的推送，你若想支持华为的用户，你就接入华为的推送。然后根据推送广播来保护自己的应用。\nAlarmManager唤醒\n\nNote: Beginning with API 19 (KITKAT) alarm delivery is inexact: the OS will shift alarms in order to minimize wakeups and battery use. There are new APIs to support applications which need strict delivery guarantees; see setWindow(int, long, long, PendingIntent) and setExact(int, long, PendingIntent). Applications whose targetSdkVersion is earlier than API 19 will continue to see the previous behavior in which all alarms are delivered exactly when requested.\nYou do not instantiate this class directly; instead, retrieve it through Context.getSystemService(Context.ALARM_SERVICE).\n\ngoogle官方文档这段话大致意思是AlarmManager在4.4之后开始变得不准确，系统为了降低电量消耗和最小化唤醒。在目前的操作系统中一旦应用强制停止后定时唤醒也将不在起作用。\n相关常量：\nAlarmManager主要是使用到了5个关于时间类型的常量：\nELAPSED_REALTIME：表示闹钟在手机睡眠状态下不可用，该状态下闹钟使用相对时间（相对于系统启动开始），状态值为3,使用SystemClock.elapsedRealtime()可获得时间。\nELAPSED_REALTIME_WAKEUP：表示闹钟在睡眠状态下会唤醒系统并执行提示功能，该状态下闹钟也使用相对时间，状态值为2，SystemClock.elapsedRealtime()；\nRTC：表示闹钟在睡眠状态下不可用，该状态下闹钟使用绝对时间（ SystemClock.currentThreadTimeMillis()），即当前系统时间，状态值为1；\nRTC_WAKEUP：表示闹钟在睡眠状态下会唤醒系统并执行提示功能，该状态下闹钟使用绝对时间（SystemClock.currentThreadTimeMillis()），状态值为0；\nAlarmManager.POWER_OFF_WAKEUP：表示闹钟在手机关机状态下也能正常进行提示功能，所以是5个状态中用的最多的状态之一，该状态下闹钟也是用绝对时间，状态值为4；不过本状态好像受SDK版本影响，某些版本并不支持；\n常用方法\n①set(int type, long triggerAtMillis, PendingIntent operation)\n该方法用于设置一次性闹钟，第一个参数表示闹钟类型，第二个参数表示闹钟执行时间，第三个参数表示闹钟响应动作。\n②setExact(int type, long triggerAtMillis, PendingIntent operation)\n设置一个闹钟在规定的时间内准确地发出。（当然准确是不可能准确的）\n③setWindow(int type, long windowStartMillis, long windowLengthMillis, PendingIntent operation)\n大致的参数同前面几个，第三个参数指的是当警报发出时最大延迟时间是多少。\n④setExactAndAllowWhileIdle(int type, long triggerAtMillis, PendingIntent operation)\n同setExact，即使在系统低功耗的情况下也能发出警报。\n⑤setAndAllowWhileIdle(int type, long triggerAtMillis, PendingIntent operation)\n同set。\n⑥setAlarmClock(AlarmManager.AlarmClockInfo info, PendingIntent operation)\n第一个参数表示闹钟的信息当然使用的是绝对时间，第二参数想要执行的意图。\nAlarmManager拉活逻辑\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 每5分钟唤醒一次service * * @param context */public static void setKeepAliveAlarm(Context context, boolean interVal) &#123;    // 防止4.4以下的重复执行setRepeating    if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.KITKAT &amp;&amp; interVal) &#123;        return;    &#125;    // 循环时间    int TIME_INTERVAL = 5 * 60 * 1000;    AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);    // Intent local = new Intent(context, KeepAliveReceiver.class);    Intent local = new Intent(context, &quot;ALERT_KEEP_ACTION&quot;);    local.addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES);// 表示包含未启动的App    PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 999, local, PendingIntent.FLAG_UPDATE_CURRENT);    // 此处必须使用SystemClock.elapsedRealtime，否则闹钟无法接收    long triggerAtMillis = SystemClock.elapsedRealtime();    // 更新开启时间    if (interVal) &#123;        triggerAtMillis += TIME_INTERVAL;    &#125;    // pendingIntent 为发送广播    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;        alarmManager.setExactAndAllowWhileIdle(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtMillis, pendingIntent);    &#125; else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;        alarmManager.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtMillis, pendingIntent);    &#125; else &#123;        // api19以前还是可以使用setRepeating重复发送广播        alarmManager.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtMillis, TIME_INTERVAL, pendingIntent);    &#125;    return;&#125;// 广播接收器public class KeepAliveReceiver extends BroadcastReceiver &#123;    public static final String TAG = KeepAliveReceiver.class.getSimpleName();    @Override    public void onReceive(Context context, Intent intent) &#123;        try &#123;            String action = intent.getAction();            if (!TextUtils.isEmpty(action)) &#123;                if (action.equals(&quot;ALERT_KEEP_ACTION&quot;)) &#123;                    // 定时闹钟发送的保活心跳                    // 在次发送闹钟                    setKeepAliveAlarm(context, true);                    // 处理自己的逻辑                &#125;            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        return;    &#125;&#125;\n参考\n\nhttp://www.52im.net/thread-1135-1-1.html\nhttps://blog.csdn.net/carson_ho/article/details/79522975\n\n","plink":"https://blog.ixin.run/posts/1542901406/"},{"title":"Android开发View坐标了解","date":"2018-11-15T16:05:19.000Z","date_formatted":{"ll":"2018年11月16日","L":"2018/11/16","MM-DD":"11-16"},"updated":"2021-03-04T08:28:02.350Z","content":"Android开发过程中，针对View视图坐标系必要时获取坐标，其重要性不言而喻。坐标系分为屏幕坐标系和View视图坐标系，前者用于真实坐标，后者用于获取相对坐标和宽高。\n\nAndroid视图坐标系\nandroid中的坐标系有两种：一种是Android坐标系，是相对屏幕原点来说的，也可以叫绝对坐标；另外一种是视图坐标系，是根据当前view以及父布局来说的。\nAndroid坐标系\n\n以屏幕左上角原点为中心，x轴向右为正，y轴向下为正。\n视图坐标系\n\n根据view自身相关属性计算view所处坐标。\n获取View的距离和位置\n下面介绍Android View类中用来获取View的距离和位置信息的一些API，这些API大都需要在Attach到Window之后才能获取到预期的结果。所以不能放在构造方法，onCreate()，onMeasure()，onLayout()等方法中执行，一般都需要放到onWindowFocusChanged()里，或者放到某个异步事件中执行。\ngetWidth()/getHeight()\ngetHeight()：获取View自身高度；getWidth()：获取View自身宽度。\ngetTranslationX()/getTranslationY()/getTranslationZ()\nTranslationX和TranslationY是从Android3.0引入的View的属性，TranslationZ则是Android5.0引入的View的属性。它们分别表示将View从其原始位置沿着X，Y，Z轴方向平移的距离。\ngetTop()/getBottom()/getLeft()/getRight()/getElevation()\n通过如下方法可以获得View到其父控件（ViewGroup）的距离：\n\ngetTop()：获取View自身顶边到其父布局顶边的距离\ngetLeft()：获取View自身左边到其父布局左边的距离\ngetRight()：获取View自身右边到其父布局左边的距离\ngetBottom()：获取View自身底边到其父布局顶边的距离\ngetElevation()：获取View Z轴偏移量\n\ngetElevation()的结果则是之前在XML中通过android:elevation配置的值，或者是通过setElevation()设置的值。其中getElevation()只有在Android5.0及之后的系统中才可以使用。\ngetX()/getY()/getZ()\ngetX()/getY()/getZ()同样是用来获取一个view到parent view的距离，和getTop()/getLeft()/getElevation()不同是，getX()/getY()/getZ()会考虑TranslationX，TranslationY和TranslationZ的影响。可以简单的将getTop()/getLeft()/getElevation()结果和getTranslationX()/getTranslationY()/getTranslationZ()结果相加，即可得到getX()/getY()/getZ()的结果。getX()和getY()只有在Android3.0及之后的系统才可以使用，getZ()只有在Android5.0及之后的系统中才可以使用。\ngetScrollX()/getScrollY()\ngetScrollX()/getScrollY()用来获取一个view滑动的距离，一般来说，如果View是不可滑动的，例如TextView，Button等， getScrollX()/getScrollY()获取到的始终是0。如果View是可以纵向滑动的，例如ListView，ScrollView等，getScrollX()获取到的始终是0，getScrollY()获取到的是Y轴滚动的距离。如果View是可以横向滑动的，例如HorizontalScrollView，getScrollY()获取到的始终是0，getScrollX()获取到的是X轴滚动的距离。getScrollX()和getScrollY()的值始终大于等于0。\ngetDrawingRect()\ngetDrawingRect()用来获取一个View的绘制区域，它本身没有返回值，需要传入一个不为null的Rect对象作为输出参数。一般来说，一个View的绘制区域就是从(0, 0)到(width, height)的区域，但如果View是可滑动的，则它的绘制区域还要加上滑动的距离，也就是从(scrollX, scrollY)到(width+scrollX, height+scrollY)的距离。\n需要注意的是getDrawingRect()并没有考虑setScaleX()，setScaleY()和setRotation()的影响，所以它返回的区域大小并不一定会和View当前实际显示的区域大小相同。\ngetLocationOnScreen()和getLocationInWindow()\ngetLocationOnScreen()和getLocationInWindow()返回的都是view左上角的坐标，不同的getLocationOnScreen()得到的是相对于屏幕的坐标，也就是坐标原点在屏幕的左上角。而getLocationInWindow()得到的是相对于当前窗口的坐标，也就是坐标原点在窗口的左上角。\n1234int[] screenLocation = new int [2];int[] windowLocation = new int [2];getLocationInWindow();getLocationOnScreen(windowLocation)\ngetGlobalVisibleRect()和getLocalVisibleRect()\n这两个方法主要用于判断一个 View 是在某个区域的可见性，区别：\n\nView.getGlobalVisibleRect(rect); //以屏幕 左上角 为参考系的\nView.getLocalVisibleRect(rect); //以目标 View 左上角 为参考系\n\n判断是否可见:\n1boolean localVisibleRect = target.getLocalVisibleRect(rect);\n返回值：\n\ntrue : View 全部或者部分 可见\nfalse : View 全部不可见\n\n点击事件MotionEvent提供的坐标方法\n我们看视图坐标系图示中那个深蓝色的点，假设就是我们触摸的点，我们知道无论是View还是ViewGroup，最终的点击事件都会由onTouchEvent(MotionEventevent)方法来处理，MotionEvent也提供了各种获取焦点坐标的方法：\n\ngetX()：获取点击事件距离控件左边的距离，即视图坐标\ngetY()：获取点击事件距离控件顶边的距离，即视图坐标\ngetRawX()：获取点击事件距离整个屏幕左边距离，即绝对坐标\ngetRawY()：获取点击事件距离整个屏幕顶边的的距离，即绝对坐标\n\n几个问题\n\nView 的 getＹ()， getTranslationY() 和 getTop() 之间的联系；\nView 的 scrollTo() 和 scrollBy()；\n\nView的getY()，getTranslationY()和getTop()之间的联系：\ngetY() = getTranslationY()+ getTop();\nscrollTo()和scrollBy()从字面意思我们可以知道scrollTo()是滑动到哪里的意思 ，scrollBy()是相对当前的位置滑动了多少。\n需注意：scrollTo和scrollBy函数的参数和坐标系是“相反的”，比如 scrollTo(-100,0)，View 的内容是向X轴正方向移动的。\nview坐标获取时机\n一般来说，我们要获取View的坐标和高度等，都必须等到View绘制完毕以后才能获取的到，在Activity的onCreate()方法里面是获取不到的，必须等到View绘制完毕以后才能获取地到View的响应的坐标，一般来说，主要有以下两种方法。\n第一种方法，onWindowFocusChanged()方法里面进行调用\n因为onWindowFocusChanged可能会调用多次，所以我们可以用一个唯一标识来控制获取坐标调用一次即可。\n第二种方法,在视图树绘制完成的时候进行测量\n利用view.getViewTreeObserver().addOnGlobalLayoutListener监听view是否整个绘制完毕，然后进行获取坐标。\n参考\n\nhttps://blog.csdn.net/itachi85/article/details/50708391\nhttps://juejin.im/entry/5880209c2f301e006968a342\n\n","plink":"https://blog.ixin.run/posts/1542297919/"},{"title":"AndroidStudio工程目录和项目资源文件介绍","date":"2018-09-15T01:56:36.000Z","date_formatted":{"ll":"2018年9月15日","L":"2018/09/15","MM-DD":"09-15"},"updated":"2021-01-29T12:51:44.619Z","content":"一直想把Android开发工程利器AndroidStudio的工程目录和模块下的资源文件夹和文件简单做一个总结，但是一直没有整，感觉他太简单，但是有时候开发的时候总是想不到利用这些文件的优势，而浪费一些查找的时间。所以还是总一下吧，系统学习很重要。\n\n这里我按照以下几个方面来分层简单阐述以下：\n\n工程外层\n模块内层\n资源文件\n\n工程外层\n\n\n.gradle\nGradle编译系统，版本由wrapper决定，创建项目时自动生成。\n.idea\nAndroidStudio IDE所需要的文件，创建项目时自动生成。\napp\n工程项目主模块，默认app，也可以重命名，但不建议这样做。按照项目开发思想，分模块开发便于维护和扩展，我们的开发主要是在这些模块中进行。\ngradle\nwrapper的jar和配置文件所在位置，我们可以修改配置来修改gradle版本。\nmylibrary\n工程项目子模块，主要是由工程中拆分出来的功能组件，类似这样的可以有多个，我们不能讲所有功能全部写到主木块下，这样太臃肿，不利于维护。\n.gitignore\ngit使用的ignore文件，这个文件是用来将指定的目录或者文件排除在版本之外的。\nbuild.gradle\n工程gradle编译的配置文件，主要是用于声明工程依赖库和开发工具依赖库以及一些其他全局依赖。\ngradle.properties\ngradle相关的全局属性设置，可以在各个模块下共用。\ngradlew\nUnix下的gradle wrapper可执行命令文件。\ngradlew.bat\nwindows下的gradle wrapper可执行命令文件\nlocal.properties\n本地属性设置（签名key设置，android.sdk位置等属性，建议git将此文件忽略上传。\nsettings.gradle\n和设置相关的gradle脚本，主要用于配置模块声明用于模块的正常依赖和模块所属文件夹指定设置。\n.iml\niml文件是所有IntelliJIDEA项目自动生成的文件，AndroidStudio就是有IntelliJIDEA延伸出来的，我们不需要关心或者修改这个文件的内容。\nExternal Libraies\n工程所有依赖。\n\n模块内层\n\n这里以主模块来说，其他模块都类似，模块内的各个目录和设置都是针对当前模块来说的，这也体现出一个分层思想。\n\nbuild\n编译后的文件存在的位置，包括最终生成的apk也在这里面（如果不对apk生成路径设置的话）。\nlibs\n依赖的库文件所在的位置（so、jar和aar），这里延续了eclipse的写法，如果是jni开发工程默认的是jniLibs，需要我们在gradle中配置将jniLibs映射到libs文件夹下。\nsrc\n源代码所在位置，即工程编写区，这里面分三层，androidTest和test主要用模块UI测试和单元测试，main是我们主编写代码区，所有的资源文件都在此目录下，待会会说。\n.gitignore\n模块下的git忽略文件。\nbuild.gradle\n模块gradle配置脚本文件，主要是模块需要的相关依赖的声明和模块编译所需脚本的配置。\nproguard-rules.pro\n模块下混淆配置文件。\n\n资源文件\n\n\nassets\n模块静态资源存放路径，例如一小段音乐、小视频，静态html等，可以在文件夹下继续分目录。需要注意此目录下不会进行预编译，存放的都是静态文件，另外单个文件不要超过1兆。此目录和raw有许多类似，但区别也要弄清楚。\njava\n主要代码编写区，java代码kotlin代码均在此内部编写，不做过多说明。\nres\n主要资源文件存放区，例如动画配置、图片、布局、主题、以及String内容、单位、颜色等等，另外此目录还主要涉及屏幕适配。此目录下的内容建议参看我另外一篇屏幕适配文章结合在一起看，将有最大的收获。\nanim\n模块的自定义view动画配置文件放在此处。\ndrawable\n模块的自定义图片配置文件放在此处。\ndrawable-hdpi\n模块的其他UI图片存放在此处，这里的hdpi、xhdpi主要用于屏幕适配。\nlayout\n模块下的界面布局存放在此处，建议按照功能分层。\nmenu\n模块下某些界面的菜单设置。\nmipmap\n图标存放位置，这里和drawable有区别，官方建议mipmap主要用于启动图标的存放。\nraw\n模块静态资源存放路径，和assets功能类似，但是资源引用方式不同，raw下的资源都是要参与编译生成id的，也是根据id进行引入。另外raw下不可再分目录，单个文件也不受限于1兆。\nvalues\n主要用于颜色、内容、大小、主题、style配置，根据相应的命名和内部的实现方式作区分。\nAndroidManifest\n模块注册表，四大组件均需要在此进行注册才能使用，另外权限的注册、主题的注册、以及图标的设定都要在此文件下实现。\n\n耗费了将近两个小时总结了一下，大概就是这些内容了，本篇的目的就是将工程所需的目录做一个索引式说明，如果想了解更详细的可以翻看我过往的博客总结，一起讨论，一起学习。\n","plink":"https://blog.ixin.run/posts/1536976596/"},{"title":"AndroidStudio项目导入的那些事","date":"2018-05-05T06:05:54.000Z","date_formatted":{"ll":"2018年5月5日","L":"2018/05/05","MM-DD":"05-05"},"updated":"2021-01-29T12:51:44.620Z","content":"公司有一个老项目，曾经因为市场的原因搁置了，最近重新探究决定重启该项目，当然开发任务就由我来主持负责。拿到老项目第一件事，不用说就是先将老项目导入到开发环境中，然后看看具体架构和业务，该抛弃的抛弃该优化的优化。\n\n工欲善其事，必先利其器\n对于AndroidStudio的安装和使用在这里顺便也重申一下，有些童鞋喜欢重装这些开发环境，用以时常给自己冲冲血，一般不是大变化建议还是不用太频繁安装为好，毕竟开发才是首要任务。\n第一次启动AndroidStudio很慢\nAndroid第一次启动时在某种情况下会发现特别慢，这里的某种情况是多重因素的结合：\n\n没有梯子。\n宽带不好。\n电脑老旧。\n\n因为AndroidStudio第一次启动时要进行检查SDK更新，所以上边的第一个条件也算是致命点，程序员不会搬梯子有点说不过去，没有梯子到后边启动项目时下载gradle也是个麻烦事。\n当然没有梯子可以采用禁止检查SDK更新也能顺利启动，解决办法：\n在AndroidStudio安装目录的bin文件夹下找到idea.properties文件，任意记事本工具打开并在文末添加disable.android.first.run=true,然后保存，随后就能顺利启动AndroidStudio了。\nidea.propertie文件位置：\n\nidea.propertie文件添加禁止SDK检查更新：\n\nAndroidStudio运行卡、慢\n这个问题有点牵强了，碰到老人机硬性条件怎么处理，我想只能换电脑换硬盘扩内存了吧，这里给的方案是在硬性条件的基础上进一步提升软性条件进而提升性能。\nAndroidStudio每次更新从google出厂时，google在AndroidStudio内存开销上会定义一些参数，他认为我们的机器都很棒，所以这些参数相应都不高，然后试试并非如此，哈哈。这些参数在哪儿设置呢？在AndroidStudio安装目录的bin文件下（和上边一样）找到studio.exe.vmoptions、studio64.exe.vmoptions这两个文件，前一个是针对32位PC的，后者是针对64位的，如果你的电脑是64位只需要将后者内容中的相关参数调大即可。\nstudio64.exe.vmoptions文件的位置：\n\nstudio64.exe.vmoptions文件内容参数调整实例：\n\nAndroidStudio常用插件\n以下是个人总结的开发过程中常用的插件：\n\nGsonFormat\n快速将json字符串转换成一个Java Bean。\nAndroid ButterKnife Zelezny\n配合ButterKnife实现注解，从此不用写findViewById。\nAndroid Parcelable code generator\nJavaBean序列化，快速实现Parcelable接口。\nGenerateSerialVersionUID\n实现Serializable序列化bean中的serialVersionUID。\nLifecycle Sorter\n可以根据Activity或者fragment的生命周期对其生命周期方法位置进行先后排序，快捷键Ctrl + alt + K。\nCodeGlance\n在右边可以预览代码，实现快速定位。\nFindBugs-IDEA\n查找bug的插件，Android Studio也提供了代码审查的功能（Analyze-Inspect Code…）。\nMaterial Theme UI\n添加Material主题到你的AS。\nMarkdown Navigator\nMarkdown实时预览插件。\nLayoutFormatter\n一键格式化你的XML文件的Android Studio插件。\n\nAndroidStudio常用快捷键\n以下是个人总结的开发过程中常用的快捷键：\n123456789101112131415161718192021222324252627282930313233ctrl + shift + 空格                    代码补全ctrl + shift + enter                   语法结构匹配ctrl +alt + 空格                       代码提示。ctrl +shift +&#x2F;                         段注释ctrl + shift + ?                       xml注释ctrl + &#x2F;                               行注释ctrl + alt + L                         代码格式化ctrl + alt + O                         格式化类库alt + enter                            引入库ctrl + j                               自动代码结构补全Ctrl+P                                 方法参数提示shift + F6                             本类或本类中属性、方法重命名ctrl+shift+r                           全工程内部属性、方法替换ctrl + shift + u                       大小写转换。 （用于全局或静态变量设定）&#x2F;**************搜索**************&#x2F;ctrl + f                               类中搜索双击shift                              全局搜索文件ctrl + shift +f                        全局任意搜索（有些时候与搜狗输入法冲突，可将输入法相关快捷键给屏蔽掉）ctrl + N                               搜索类ctrl + shift + N                       搜索文件ctrl + shift +alt +N                   搜索方法或变量&#x2F;**************代码定位***********&#x2F;ctrl + alt + 左方向（右方向）           代码查看时返回上一处，回退下一处。Alt+ left&#x2F;right                        切换代码视图Alt+ Up&#x2F;Down                           在方法间快速移动定位&#x2F;**************移动复制***********&#x2F;Ctrl+Shift+Up&#x2F;Down                     整块代码向上&#x2F;下移动。（一行，或一个接口实现或一个方法）ctrl + y                               删除整行。ctrl + D                               复制该行到下一行。ctrl +c 、ctrl +v                      整行复制和粘贴\n更多官方推荐默认快捷键请移步：\nhttps://resources.jetbrains.com/storage/products/intellij-idea/docs/IntelliJIDEA_ReferenceCard.pdf\n或者点击菜单上help按钮下的&quot;Keymap Reference&quot;查看。\n项目导入遇到的问题及解决方案\n项目导入过程常见的问题有以下几个：\n\n老项目的支持的SDK编译版本在新环境下要重新下载。\n兼容包v4或v7在新环境下默认的与SDK编译环境不一致。\ngradle版本和gradle插件版本不一致，甚至起初并没有gradle环境需要全新支持（eclipse）。\n导入过程中网络环境问题。\n老项目本身的代码问题，项目中的库在新环境下的兼容问题。\n\n认清几个概念\n1.主Module（Module和model不一样，前者指模块，后者指模型，后者主要用于放一些实体类bean）中的build.gradle，先放一张图：\n\n\n\ncompileSdkVersion\n编译所用的Android SDK Platfom的大版本号，假如此版本号比较低，则编写应用时某些新的方法（Api）不能使用，推荐最新的，时刻屏蔽掉官方准备淘汰的一些API。\n\n\nbuildToolsVersion\n项目构建的版本号，即Android SDK Build-Tools的版本号，其大版本号要&gt;=compileSdkVersion，否则不允许构建，推荐在大版本号和compileSdkVersion保持一致同时选择Revision最高的。\n\n\nminSdkVersion\n允许安装此应用的手机系统最低版本号。\n\n\ntargetSdkVersion\n目标系统的版本号，假如说设置为Android4.4的版本号（ApiLevel为19），则在Android6.0的系统上安装此应用则不能使用运行时权限。此处结合实际情况设置，推荐采用和compileSdkVersion保持一致的版本号。\n\n\nappcompat-v7\nAndroid Support支持库，也叫Android兼容包，主要作用能在低版本的Android系统中运行高版本SDK所带来的新特效（特定框架组件、UI元素），目的是全平台视图效果保持一致。末尾大版本号和compileSdkVersion保持一致，保证能够采兼容到全平台，小版本号可参阅官方文档：https://developer.android.com/topic/libraries/support-library/revisions?hl=zh-CN\nAndroid Support支持库常见是v4和v7（依赖于 v4 支持库），还有v8、v13、v14、v17等。v4库项目引入默认支持，v7最常用，其他的根据实际情况自行添加。注意：Support库的大版本号要与compileSdkVersion的大版本号相同，且所有的库的版本号要相同。\n各类支持库的区别：\nv4：最低支持android1.6，包含ViewPager、Fragment等。\nv7：最低支持android2.3，v7依赖于v4，包含ActionBar、receyclerview等设计支持库(Material Design)：提供了一些符合设计风格的控件，比如悬浮操作按钮。\n其他支持库参考：https://developer.android.com/topic/libraries/support-library/features?hl=zh-CN\n\n\n2.项目中gradle配置：\n\ngradle版本\ngradel是androidstudio默认的构建工具，主要用于项目的构建、依赖、打包、发布等，每次androidstudio版本更新时顺带会把gradle版本也进行更新。\ngradle构建插件版本\ngradle是在maven、ant等前辈构建工具的基础上补齐他们的短板，所运用的平台也不仅仅是android，所以为了更好的服务于android开发，官方根据gradle特定版本范围单独开发一个用于构建android项目的gradle插件。\n\ngradle版本设置：\n\ngradle构建插件版本设置：\n\ngradle和gradle构建插件版本对应关系：\n\n更多可参考官方说明：https://developer.android.google.cn/studio/releases/gradle-plugin#updating-plugin\n3.SDK Manager中相关：\n\nAndroid SDK Platfom\nAndroid开发API支持平台，AndroidStudio初次安装时默认会提示下载最新的SDK，强烈推荐下载安装稳定版最新的版本。compileSdkVersion所对应的就是这里已经下载安装过的某个版本号，一般选择的是稳定版最新的。\nAndroid SDK Build-Tools\nAndroid SDK构建工具，包含：aapt工具，aidl工具等。推荐下载安装最新的。buildToolsVersion所对应的就是Android SDK Build-Tools的版本号，一般大版本号和compileSdkVersion保持一致同时选择Revision最高的。\nAndroid SDK Platform-Tools\n针对pc端和移动端进行交互的一些工具：比如adb工具（通过该工具pc端获取移动端log信息），sqlite3工具（通过该工具查询移动端数据库信息）。结合实际情况更新。\nAndroid SDK Tools\n针对pc平台下使用的工具：比如模拟器，.9patch工具，性能追踪可视化工具traceview。结合实际情况更新。\n\n解决方案\n通过对以上概念的认识，导入老项目也就是分分钟的事了，通常做三件事即可：\n\n备好梯子，没有梯子那就做搬运工吧。\n主Module中的build.gradle，buildToolsVersion、targetSdkVersion、appcompat-v7大版本号依据compileSdkVersion设置，小版本通过下载选择最新的或者依赖官方最新的（结合情况来），minSdkVersion自己看情况设置。\ngradle构建插件版本设置结合与gradle版本的关系设置，gradle的版本选择当前市面较新的（结合当前AndroidStudio的版本）。\n\n通过上边的三步一般都能够解决了，其实还有更简单的方法就是新建一个应用，将老项目中的这些参数全部改成和新项目中的一样，哈哈。然后Sync，必要时Clean、Rebuild一下，当然还有代码上的问题还需要慢慢调试解决。\n有些时候网络慢的原因也可能是google在作怪，可进入settings&gt;Plugins将google analytic upload插件对勾去除，重启androidstudio.\n修改包名便捷方法\n有些时候针对老项目包名并不适合，我们需要进行调整，如果单纯想修改项目某个目录的话可以直接重名项目中的某个Package，如果想调整项目应用的包名，除了修改项目整个包名，还要修改项目的applicationId与包名保持一致，这样打包的应用才能算一个全新的应用。\n两步走：\n1.AndroidManifest修改项目包名\n\n2.主Module中的build.gradle中修改applicationId，并Sync。\n\n以上是针对项目导入过程的一些总结，后边若再有其他问题再来补充吧，至此告一段落，打完收工。\n","plink":"https://blog.ixin.run/posts/1525500354/"},{"title":"Android项目中Git忽略文件.gitignore的写法","date":"2018-05-04T14:51:03.000Z","date_formatted":{"ll":"2018年5月4日","L":"2018/05/04","MM-DD":"05-04"},"updated":"2021-01-29T12:51:44.645Z","content":"又到周五了，这周过的最快，因为只有三天，就总结一个简单的东西吧——Android项目中Git忽略文件.gitignore的写法。\n\n为什么要有忽略文件\n在push项目的时候只需要上传必要的项目代码部分，有些编辑器构建项目时临时生成的或者重要的签名文件是没有必要上传到远程的，即忽略这些文件的上传。这样既能快速的上传项目也保证了远程项目的简洁性，同时也保证了项目的安全性。\n创建git忽略文件\n对于git忽略文件需要做的步骤如下：\n\n在项目目录下找到.gitignore文件（一般有两个地方存在该文件：一是根目录下，一是app目录下），如果没有找到该文件就创建一个 。该文件主要写明需要忽略的文件。\n对于Android项目来说，有一个标准的需要忽略的文件（当然，也可以根据自己的项目而定），在GitHub上去下载Android.gitignore文件。\n\ngit忽略文件写法规则\ngit忽略文件.gitignore的主要写法规则为：\n\n&quot;#&quot;表示注释；\n&quot;*&quot;表示通配符，可多个；\n&quot;/&quot;表示目录；\n&quot;!&quot;表示不忽略匹配到的文件或目录；\n&quot;?&quot;表示通配单个字符；\n&quot;[]&quot;表示包含单个字符的匹配列表；\n\ngit忽略文件不生效解决办法\n把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore只能忽略那些原来没有被追踪的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未被追踪状态），然后再提交：\n123git rm -r --cached .git add .git commit -m &#39;update .gitignore&#39;\n自己的例子\n自己抽取的.gitignore文件：\n12345678910111213141516171819202122232425262728293031323334353637383940414243# Built application files*.apk*.ap_# Files for the ART&#x2F;Dalvik VM*.dex# Java class files*.class# Generated filesbin&#x2F;gen&#x2F;out&#x2F;# Gradle files.gradle&#x2F;build&#x2F;# Local configuration file (sdk path, etc)local.properties# Log Files*.log# Android Studio Navigation editor temp files.navigation&#x2F;# IntelliJ*.iml.idea&#x2F;# External native build folder generated in Android Studio 2.2 and later.externalNativeBuild# MacOS temp files.DS_Store# Keystore files# Uncomment the following line if you do not want to check your keystore files in.#*.jks####################################################################################################\n","plink":"https://blog.ixin.run/posts/1525445463/"},{"title":"TextView局部字体超链接处理方案","date":"2018-04-30T06:42:45.000Z","date_formatted":{"ll":"2018年4月30日","L":"2018/04/30","MM-DD":"04-30"},"updated":"2021-01-29T12:51:44.648Z","content":"还是之前的老项目问题，应法务部门的要求要将之前客户端的相关条款调整一下，每条内容中还有多个条款可方便用户进行点击查看详细内容，本来没啥问题，当去寻找内容所在的时候却发现都是在本地配置的，并且是xml写死的，而且对于TextView中的条款却是采用多个TextView进行组合而成的。擦类，对于产品的要求要多种情况进行变换，还要调整大小屏，在我的思想里这…必须要换了。\n\n问题及解决方案\n针对文本TextVieww中含有多个不同的样式子串或者文本中含有多个超链接的问题其实解决方案还是挺多的。这里就列举几个：\n\n采用html标签对文本多样化设计。\n采用在xml文件中配置autoLink属性。\n采用SpannableStringBuilder进行多样化设置。\n\n1.采用html标签对文本多样化设计\n在代码中可直接采用Html.fromHtml():\n12TextView test_tv = findViewById(R.id.test_tv);test_tv.setText(Html.fromHtml(&quot;&lt;a href=\\&quot;http://www.baidu.com/\\&quot;&gt;地瓜地瓜这里是百度&lt;/a&gt;&quot;));\n还可以直接在xml布局中设置，不过html要写在资源文件String里面。\n123456&lt;TextView    android:id=&quot;@+id/test_tv&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:text=&quot;@string/linktext&quot;    /&gt;\n1234&lt;resources&gt;    &lt;string name=&quot;app_name&quot;&gt;My Application&lt;/string&gt;    &lt;string name=&quot;linktext&quot;&gt;&lt;a href=&quot;http://www.baidu.com/&quot;&gt;地瓜地瓜这里是百度&lt;/a&gt;&lt;/string&gt;&lt;/resources&gt; \n此时点击超链接其实并不起作用，我们还要加上一句话才能跳转到系统浏览器里面：\n1textView.setMovementMethod(LinkMovementMethod.getInstance());\n但是有些时候我们想跳转到自己应用中的webview中怎么办呢？\n所以我们要进行超链接拦截：\n123456789101112131415161718192021test_tv = findViewById(R.id.test_tv);CharSequence charSequence = Html.fromHtml(&quot;地瓜地瓜这里是&lt;a href=\\&quot;http://www.baidu.com/\\&quot;&gt;百度&lt;/a&gt;&quot;);SpannableStringBuilder builder = new SpannableStringBuilder(charSequence);URLSpan[] urlSpans = builder.getSpans(0, charSequence.length(), URLSpan.class);for (URLSpan span : urlSpans) &#123;    int start = builder.getSpanStart(span);    int end = builder.getSpanEnd(span);    int flag = builder.getSpanFlags(span);    final String link = span.getURL();    builder.removeSpan(span); //移除默认的urlspan，去除优先跳到系统默认浏览器而使得拦截失效。    builder.setSpan(new ClickableSpan() &#123;        @Override        public void onClick(View widget) &#123;            // 捕获&lt;a&gt;标签点击事件，及对应超链接link，可在这里做跳转。            Toast.makeText(MainActivity.this, &quot;你点击的URL是&quot; + link, Toast.LENGTH_SHORT).show();        &#125;    &#125;, start, end, flag);&#125;test_tv.setLinksClickable(true);test_tv.setMovementMethod(LinkMovementMethod.getInstance());test_tv.setText(builder);\n以下是收录的一些TextView可以使用的Html标签：\n123456789101112131415161718192021222324252627282930标签      说明  &lt;br&gt;        插入一个换行符。&lt;br&gt;        标签是空标签（意味着它没有结束标签，因此这是错误的：&lt;br&gt;&lt;/br&gt;）    &lt;p&gt;         定义段落。&lt;p&gt;         标签会自动在其前后各添加一个空行    &lt;h1&gt;        定义最大的标题&lt;h2&gt;        ↓&lt;h3&gt;        ↓&lt;h4&gt;        ↓&lt;h5&gt;        ↓&lt;h6&gt;        定义最小的标题&lt;div&gt;       文档分节    &lt;strong&gt;    把文本定义为语气更强的强调的内容。TextView中表现为文本加粗   &lt;b&gt;         文本加粗    &lt;em&gt;        把文本定义为强调的内容。TextView中表现为斜体文本效果。 &lt;cite&gt;      定义引用。TextView中表现为斜体文本效果。    &lt;dfn&gt;       标记那些对特殊术语或短语的定义。TextView中表现为斜体文本效果。 &lt;i&gt;         显示斜体文本效果。   &lt;big&gt;       呈现大号字体效果    &lt;small&gt;     呈现小号字体效果    &lt;strike&gt;    定义删除线样式的文字&lt;font size=&quot;...&quot; color=&quot;...&quot; face=&quot;...&quot;&gt;    规定文本的字体、字体尺寸、字体颜色   color：文本颜色；size：文本大小；face：文本字体&lt;blockquote&gt;    将&lt;blockquote&gt; 与 &lt;/blockquote&gt; 之间的文本从常规文本中分离出来。通常在左、右两边进行缩进，有时使用斜体。    &lt;tt&gt;        呈现类似打字机或者等宽的文本效果    &lt;a&gt;         定义超链接。最重要的属性是 href 属性，它指示链接的目标。 href：指示链接的目标&lt;u&gt;         为文本添加下划线    &lt;sup&gt;       定义上标文本  &lt;sub&gt;       定义下标文本  &lt;img src=&quot;...&quot;&gt; 向网页中嵌入一幅图像。&lt;img&gt;标签并不会在网页中插入图像，而是从网页上链接图像。&lt;img&gt;  标签创建的是被引用图像的占位空间。   src：图像的url；alt：图像的替代文本\n2.采用在xml文件中配置autoLink属性\nTextView有一个叫做autoLink的属性可以将符合指定格式的文本转换为可单击的超链接形式，在帮助文档中也可以发现Android给我们提供了如下几种格式：\n\nnone：表示不进行任何匹配，默认；\nweb：表示匹配web网址，例如http://www.baidu.com；\nemail：表示匹配邮件地址；\nphone：表示匹配电话号码；\nmap：表示匹配地图地址,一般针对google地图；\nall：表示将会匹配web、email、phone、map；\n\n123456&lt;TextView    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:text=&quot;百度的网址是:http://www.baidu.com&quot;    android:autoLink=&quot;web&quot;    /&gt;\n3.采用SpannableString进行多样化设置\n以上是文本中含有超链接地址，开发过程中更多的是后台单独给我传递局部字体的超链接地址，移动端除了单独设置超链接还要调节这些局部字体的大小、颜色等样式，因为原文本中不含超链接地址，所以我们也不用移除原有的span了。这里我们采用SpannableStringBuilder来进行多样化设置。\n123456789101112131415161718192021222324252627/** * 设置超链接 * * @param tv */private void settingLink(TextView tv) &#123;    String content = tv.getText().toString();    String link = &quot;百度&quot;;    String linkUrl = &quot;http://www.baidu.com&quot;;    if (content.indexOf(link) == -1) &#123;        return;    &#125;    final int start = content.indexOf(link);    final int end = start + link.length();    final int flag = Spanned.SPAN_EXCLUSIVE_EXCLUSIVE;    //构建SpannableStringBuilder    SpannableStringBuilder builder = new SpannableStringBuilder(content);    //设置文字的单击事件    builder.setSpan(new CustomUrlSpan(this, linkUrl), start, end, flag);    //设置文字的前景色    builder.setSpan(new ForegroundColorSpan(Color.RED), start, end, flag);    tv.setLinksClickable(true);    tv.setMovementMethod(LinkMovementMethod.getInstance());    tv.setText(builder);&#125;\n默认情况下超链接部分都有一条下划线，为了美观性必要情况下我们要将下划线去掉，所以可以设置匿名内部类ClickableSpan扩充updateDrawState方法处理，这里为了程序功能发展性和模块化单独自定义个内部类继承ClickableSpan做处理：\n123456789101112131415161718192021222324252627/** * 自定义ClickableSpan内部类，单独对点击事件处理 */class CustomUrlSpan extends ClickableSpan &#123;    private Context context;    private String url;    public CustomUrlSpan(Context context, String url) &#123;        this.context = context;        this.url = url;    &#125;    @Override    public void onClick(View widget) &#123;        Intent intent = new Intent(context, WebViewActivity.class);        intent.putExtra(WebViewActivity.WEB_URL, url);        context.startActivity(intent);    &#125;    @Override    public void updateDrawState(TextPaint ds) &#123;        super.updateDrawState(ds);        //去除超链接下划线        ds.setUnderlineText(false);    &#125;&#125;\nSpannableStringBuilder有个亲兄弟——SpannableString。是不是觉得有点熟悉？相信大部分童鞋之前也用过这个。SpannableStringBuilder和SpannableString的区别类似与StringBuilder、String，就是SpannableStringBuilder可以拼接，而SpannableString不可拼接。\nSpannableStringBuilder和SpannableString主要通过使用setSpan(Object what, int start, int end, int flags)改变文本样式，上边的实例主要用的就是这个方法。\n对应的参数：\n\n\nstart： 指定Span的开始位置。\n\n\nend： 指定Span的结束位置，并不包括这个位置。\n\n\nflags：取值有如下四个：\n\nSpannable.SPAN_EXCLUSIVE_INCLUSIVE：开始坐标不包括，结束坐标包括。\nSpannable.SPAN_INCLUSIVE_EXCLUSIVE：开始坐标包括，结束坐标不包括。\nSpannable.SPAN_INCUJSIVE_INCLUSIVE：开始和结束坐标都包括。\nSpannable.SPAN_EXCLUSIVE_EXCLUSIVE：开始和结束坐标都不包括。\n\n\n\nwhat： 对应的各种Span，不同的Span对应不同的样式。已知的可用类有：\n\nBackgroundColorSpan : 文本背景色\nForegroundColorSpan : 文本颜色\nMaskFilterSpan : 修饰效果，如模糊(BlurMaskFilter)浮雕\nRasterizerSpan : 光栅效果\nStrikethroughSpan : 删除线\nSuggestionSpan : 相当于占位符\nUnderlineSpan : 下划线\nAbsoluteSizeSpan : 文本字体（绝对大小）\nDynamicDrawableSpan : 设置图片，基于文本基线或底部对齐\nImageSpan : 图片\nRelativeSizeSpan : 相对大小（文本字体）\nScaleXSpan : 基于x轴缩放\nStyleSpan : 字体样式：粗体、斜体等\nSubscriptSpan : 下标（数学公式会用到）\nSuperscriptSpan : 上标（数学公式会用到）\nTextAppearanceSpan : 文本外貌（包括字体、大小、样式和颜色）\nTypefaceSpan : 文本字体\nURLSpan : 文本超链接\nClickableSpan : 点击事件\n\n\n\n感谢Blankj童鞋将SpannableStringBuilder完美封装成一个工具类，大家可以根据需求进行参考：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391public class SpannableStringUtils &#123;    private SpannableStringUtils() &#123;        throw new UnsupportedOperationException(&quot;u can&#x27;t instantiate me...&quot;);    &#125;    /**     * 获取建造者 * * @return &#123;@link Builder&#125;     */    public static Builder getBuilder(@NonNull CharSequence text) &#123;        return new Builder(text);    &#125;    public static class Builder &#123;        private int defaultValue = 0x12000000;        private CharSequence text;        private int flag;        @ColorInt        private int foregroundColor;        @ColorInt        private int backgroundColor;        @ColorInt        private int quoteColor;        private boolean isLeadingMargin;        private int first;        private int rest;        private boolean isBullet;        private int gapWidth;        private int bulletColor;        private float proportion;        private float xProportion;        private boolean isStrikethrough;        private boolean isUnderline;        private boolean isSuperscript;        private boolean isSubscript;        private boolean isBold;        private boolean isItalic;        private boolean isBoldItalic;        private String fontFamily;        private Alignment align;        private boolean imageIsBitmap;        private Bitmap bitmap;        private boolean imageIsDrawable;        private Drawable drawable;        private boolean imageIsUri;        private Uri uri;        private boolean imageIsResourceId;        @DrawableRes        private int resourceId;        private ClickableSpan clickSpan;        private String url;        private boolean isBlur;        private float radius;        private Blur style;        private SpannableStringBuilder mBuilder;        private Builder(@NonNull CharSequence text) &#123;            this.text = text;            flag = Spanned.SPAN_EXCLUSIVE_EXCLUSIVE;            foregroundColor = defaultValue;            backgroundColor = defaultValue;            quoteColor = defaultValue;            proportion = -1;            xProportion = -1;            mBuilder = new SpannableStringBuilder();        &#125;        /**         * 设置标识 * * @param flag &lt;ul&gt; * &lt;li&gt;&#123;@link Spanned#SPAN_INCLUSIVE_EXCLUSIVE&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link Spanned#SPAN_INCLUSIVE_INCLUSIVE&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link Spanned#SPAN_EXCLUSIVE_EXCLUSIVE&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link Spanned#SPAN_EXCLUSIVE_INCLUSIVE&#125;&lt;/li&gt; * &lt;/ul&gt; * @return &#123;@link Builder&#125;         */        public Builder setFlag(int flag) &#123;            this.flag = flag;            return this;        &#125;        /**         * 设置前景色 * * @param color 前景色 * @return &#123;@link Builder&#125;         */        public Builder setForegroundColor(@ColorInt int color) &#123;            this.foregroundColor = color;            return this;        &#125;        /**         * 设置背景色 * * @param color 背景色 * @return &#123;@link Builder&#125;         */        public Builder setBackgroundColor(@ColorInt int color) &#123;            this.backgroundColor = color;            return this;        &#125;        /**         * 设置引用线的颜色 * * @param color 引用线的颜色 * @return &#123;@link Builder&#125;         */        public Builder setQuoteColor(@ColorInt int color) &#123;            this.quoteColor = color;            return this;        &#125;        /**         * 设置缩进 * * @param first 首行缩进 * @param rest 剩余行缩进 * @return &#123;@link Builder&#125;         */        public Builder setLeadingMargin(int first, int rest) &#123;            this.first = first;            this.rest = rest;            isLeadingMargin = true;            return this;        &#125;        /**         * 设置列表标记 * * @param gapWidth 列表标记和文字间距离 * @param color 列表标记的颜色 * @return &#123;@link Builder&#125;         */        public Builder setBullet(int gapWidth, int color) &#123;            this.gapWidth = gapWidth;            bulletColor = color;            isBullet = true;            return this;        &#125;        /**         * 设置字体比例 * * @param proportion 比例 * @return &#123;@link Builder&#125;         */        public Builder setProportion(float proportion) &#123;            this.proportion = proportion;            return this;        &#125;        /**         * 设置字体横向比例 * * @param proportion 比例 * @return &#123;@link Builder&#125;         */        public Builder setXProportion(float proportion) &#123;            this.xProportion = proportion;            return this;        &#125;        /**         * 设置删除线 * * @return &#123;@link Builder&#125;         */        public Builder setStrikethrough() &#123;            this.isStrikethrough = true;            return this;        &#125;        /**         * 设置下划线 * * @return &#123;@link Builder&#125;         */        public Builder setUnderline() &#123;            this.isUnderline = true;            return this;        &#125;        /**         * 设置上标 * * @return &#123;@link Builder&#125;         */        public Builder setSuperscript() &#123;            this.isSuperscript = true;            return this;        &#125;        /**         * 设置下标 * * @return &#123;@link Builder&#125;         */        public Builder setSubscript() &#123;            this.isSubscript = true;            return this;        &#125;        /**         * 设置粗体 * * @return &#123;@link Builder&#125;         */        public Builder setBold() &#123;            isBold = true;            return this;        &#125;        /**         * 设置斜体 * * @return &#123;@link Builder&#125;         */        public Builder setItalic() &#123;            isItalic = true;            return this;        &#125;        /**         * 设置粗斜体 * * @return &#123;@link Builder&#125;         */        public Builder setBoldItalic() &#123;            isBoldItalic = true;            return this;        &#125;        /**         * 设置字体 * * @param fontFamily 字体 * &lt;ul&gt; * &lt;li&gt;monospace&lt;/li&gt; * &lt;li&gt;serif&lt;/li&gt; * &lt;li&gt;sans-serif&lt;/li&gt; * &lt;/ul&gt; * @return &#123;@link Builder&#125;         */        public Builder setFontFamily(@Nullable String fontFamily) &#123;            this.fontFamily = fontFamily;            return this;        &#125;        /**         * 设置对齐 * &lt;ul&gt; * &lt;li&gt;&#123;@link Alignment#ALIGN_NORMAL&#125;正常&lt;/li&gt; * &lt;li&gt;&#123;@link Alignment#ALIGN_OPPOSITE&#125;相反&lt;/li&gt; * &lt;li&gt;&#123;@link Alignment#ALIGN_CENTER&#125;居中&lt;/li&gt; * &lt;/ul&gt; * * @return &#123;@link Builder&#125;         */        public Builder setAlign(@Nullable Alignment align) &#123;            this.align = align;            return this;        &#125;        /**         * 设置图片 * * @param bitmap 图片位图 * @return &#123;@link Builder&#125;         */        public Builder setBitmap(@NonNull Bitmap bitmap) &#123;            this.bitmap = bitmap;            imageIsBitmap = true;            return this;        &#125;        /**         * 设置图片 * * @param drawable 图片资源 * @return &#123;@link Builder&#125;         */        public Builder setDrawable(@NonNull Drawable drawable) &#123;            this.drawable = drawable;            imageIsDrawable = true;            return this;        &#125;        /**         * 设置图片 * * @param uri 图片uri * @return &#123;@link Builder&#125;         */        public Builder setUri(@NonNull Uri uri) &#123;            this.uri = uri;            imageIsUri = true;            return this;        &#125;        /**         * 设置图片 * * @param resourceId 图片资源id * @return &#123;@link Builder&#125;         */        public Builder setResourceId(@DrawableRes int resourceId) &#123;            this.resourceId = resourceId;            imageIsResourceId = true;            return this;        &#125;        /**         * 设置点击事件 * &lt;p&gt;需添加view.setMovementMethod(LinkMovementMethod.getInstance())&lt;/p&gt; * @param clickSpan 点击事件 * @return &#123;@link Builder&#125;         */        public Builder setClickSpan(@NonNull ClickableSpan clickSpan) &#123;            this.clickSpan = clickSpan;            return this;        &#125;        /**         * 设置超链接 * &lt;p&gt;需添加view.setMovementMethod(LinkMovementMethod.getInstance())&lt;/p&gt; * * @param url 超链接 * @return &#123;@link Builder&#125;         */        public Builder setUrl(@NonNull String url) &#123;            this.url = url;            return this;        &#125;        /**         * 设置模糊 * &lt;p&gt;尚存bug，其他地方存在相同的字体的话，相同字体出现在之前的话那么就不会模糊，出现在之后的话那会一起模糊&lt;/p&gt; * &lt;p&gt;推荐还是把所有字体都模糊这样使用&lt;/p&gt; * * @param radius 模糊半径（需大于0） * @param style 模糊样式&lt;ul&gt; * &lt;li&gt;&#123;@link Blur#NORMAL&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link Blur#SOLID&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link Blur#OUTER&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link Blur#INNER&#125;&lt;/li&gt; * &lt;/ul&gt; * @return &#123;@link Builder&#125;         */        public Builder setBlur(float radius, Blur style) &#123;            this.radius = radius;            this.style = style;            this.isBlur = true;            return this;        &#125;        /**         * 追加样式字符串 * * @param text 样式字符串文本 * @return &#123;@link Builder&#125;         */        public Builder append(@NonNull CharSequence text) &#123;            setSpan();            this.text = text;            return this;        &#125;        /**         * 创建样式字符串 * * @return 样式字符串         */        public SpannableStringBuilder create() &#123;            setSpan();            return mBuilder;        &#125;        /**         * 设置样式         */        private void setSpan() &#123;            int start = mBuilder.length();            mBuilder.append(this.text);            int end = mBuilder.length();            if (foregroundColor != defaultValue) &#123;                mBuilder.setSpan(new ForegroundColorSpan(foregroundColor), start, end, flag);                foregroundColor = defaultValue;            &#125;            if (backgroundColor != defaultValue) &#123;                mBuilder.setSpan(new BackgroundColorSpan(backgroundColor), start, end, flag);                backgroundColor = defaultValue;            &#125;            if (isLeadingMargin) &#123;                mBuilder.setSpan(new LeadingMarginSpan.Standard(first, rest), start, end, flag);                isLeadingMargin = false;            &#125;            if (quoteColor != defaultValue) &#123;                mBuilder.setSpan(new QuoteSpan(quoteColor), start, end, 0);                quoteColor = defaultValue;            &#125;            if (isBullet) &#123;                mBuilder.setSpan(new BulletSpan(gapWidth, bulletColor), start, end, 0);                isBullet = false;            &#125;            if (proportion != -1) &#123;                mBuilder.setSpan(new RelativeSizeSpan(proportion), start, end, flag);                proportion = -1;            &#125;            if (xProportion != -1) &#123;                mBuilder.setSpan(new ScaleXSpan(xProportion), start, end, flag);                xProportion = -1;            &#125;            if (isStrikethrough) &#123;                mBuilder.setSpan(new StrikethroughSpan(), start, end, flag);                isStrikethrough = false;            &#125;            if (isUnderline) &#123;                mBuilder.setSpan(new UnderlineSpan(), start, end, flag);                isUnderline = false;            &#125;            if (isSuperscript) &#123;                mBuilder.setSpan(new SuperscriptSpan(), start, end, flag);                isSuperscript = false;            &#125;            if (isSubscript) &#123;                mBuilder.setSpan(new SubscriptSpan(), start, end, flag);                isSubscript = false;            &#125;            if (isBold) &#123;                mBuilder.setSpan(new StyleSpan(Typeface.BOLD), start, end, flag);                isBold = false;            &#125;            if (isItalic) &#123;                mBuilder.setSpan(new StyleSpan(Typeface.ITALIC), start, end, flag);                isItalic = false;            &#125;            if (isBoldItalic) &#123;                mBuilder.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), start, end, flag);                isBoldItalic = false;            &#125;            if (fontFamily != null) &#123;                mBuilder.setSpan(new TypefaceSpan(fontFamily), start, end, flag);                fontFamily = null;            &#125;            if (align != null) &#123;                mBuilder.setSpan(new AlignmentSpan.Standard(align), start, end, flag);                align = null;            &#125;            if (imageIsBitmap || imageIsDrawable || imageIsUri || imageIsResourceId) &#123;                if (imageIsBitmap) &#123;                    mBuilder.setSpan(new ImageSpan(Utils.context, bitmap), start, end, flag);                    bitmap = null;                    imageIsBitmap = false;                &#125; else if (imageIsDrawable) &#123;                    mBuilder.setSpan(new ImageSpan(drawable), start, end, flag);                    drawable = null;                    imageIsDrawable = false;                &#125; else if (imageIsUri) &#123;                    mBuilder.setSpan(new ImageSpan(Utils.context, uri), start, end, flag);                    uri = null;                    imageIsUri = false;                &#125; else &#123;                    mBuilder.setSpan(new ImageSpan(Utils.context, resourceId), start, end, flag);                    resourceId = 0;                    imageIsResourceId = false;                &#125;            &#125;            if (clickSpan != null) &#123;                mBuilder.setSpan(clickSpan, start, end, flag);                clickSpan = null;            &#125;            if (url != null) &#123;                mBuilder.setSpan(new URLSpan(url), start, end, flag);                url = null;            &#125;            if (isBlur) &#123;                mBuilder.setSpan(new MaskFilterSpan(new BlurMaskFilter(radius, style)), start, end, flag);                isBlur = false;            &#125;            flag = Spanned.SPAN_EXCLUSIVE_EXCLUSIVE;        &#125;    &#125;&#125;\n","plink":"https://blog.ixin.run/posts/1525070565/"},{"title":"Android屏幕适配解决方案","date":"2018-03-27T15:13:17.000Z","date_formatted":{"ll":"2018年3月27日","L":"2018/03/27","MM-DD":"03-27"},"updated":"2021-01-29T12:51:44.623Z","content":"学习android避免不掉要进行屏幕适配，因为android碎片化极其严重，尤其是在国内这种环境下，不受google所约束，奇葩屏幕更是多种多样，由于android的开源性，从小到手表，大到电视以及企业影院屏幕，不得已给开发者更多的任务和困难去进行处理，没办法，来就来了，总结一下吧。\n\n相关概念\n屏幕相关及换算：\n\n屏幕尺寸：\n手机对角线的物理尺寸，单位英寸（inch），1英寸=2.54cm，Android手机常见的尺寸有5寸、5.5寸等。\n屏幕分辨率：\n手机在横向、纵向上的像素点数总和，一般用AxB表示，例如1920x1080，单位是px。\n屏幕像素密度：\n每英寸的像素点数，单位是dpi（dots per inch）。\n\n屏幕尺寸、分辨率、像素密度三者关系：\n\n三个常用单位：\n\n像素:\n画面中最小的点，也叫单位色块，单位是px。\n密度无关像素：\ndensity-independent pixel，叫dp或dip，与终端上的实际物理像素点无关，单位是dp，可以保证在不同屏幕像素密度的设备上显示相同的效果。在Android中，规定以160dpi（即屏幕分辨率为480x320）为基准：1dp=1px。\n独立比例像素：\nscale-independent pixel，叫sp或sip，单位是sp。Android开发时用此单位设置文字大小，可根据系统字体大小首选项进行缩放，如果想保持字体大小不随系统变化可采用dp做单位，推荐使用12sp、14sp、18sp、22sp作为字体设置的大小，不推荐使用奇数和小数，容易造成精度的丢失问题；小于12sp的字体会太小导致用户看不清。\n\n关系表：\n\n\n密度类型\n代表的分辨率(px)\n屏幕像素密度(dpi)\n倍数\n换算（dp/px）\n\n\n\n\n低密度（ldpi）\n320x240\n120\n0.75\n1dp = 0.75px\n\n\n中密度（mdpi）\n480x320\n160\n1\n1dp = 1px\n\n\n高密度（hdpi）\n800x480\n240\n1.5\n1dp = 1.5px\n\n\n超高密度（xhdpi）\n1280x720\n320\n2\n1dp = 2px\n\n\n超超高密度（xxhdpi）\n1920x1080\n480\n3\n1dp = 3px\n\n\n屏幕尺寸匹配\n布局匹配\n灵活运用各种布局方式自适应屏幕\n我们知道android传统通用有5种布局方式：\n\n相对布局(RelativeLayout)\n线性布局(Linearlayout)\n帧布局(FrameLayout)\n表格布局(TableLayout)\n绝对布局(AbsoluteLayout)\n\n开发过程中尽量不要用绝对布局，因为绝对布局是根据元素的具体坐标位置来定的，所以随着屏幕大小不一，其呈现的效果也不一样。其他的布局根据情况来使用，平时开发的过程中尽量使用相对布局RelativeLayout,因为无论屏幕大小，其相对位置是不会变的，因此整体效果也会统一。\n根据屏幕的配置来加载相应的UI布局\n有些时候我们需要为不同屏幕尺寸的设备设计不同的布局，这种情况下项目中一套布局是不行的，通用的做法是采用限定符，常用的限定符有：\n\n尺寸（size）限定符\n最小宽度（Smallest-width）限定符\n布局别名\n屏幕方向（Orientation）限定符\n\n尺寸（size）限定符\n当一款应用想在手机上显示一套布局，在平板或者电视上（&gt;7英寸）显示另外的一套布局使其内容显示更多些，可以使用尺寸限定符（layout-large）通过再创建一个文件来实现。\n12res&#x2F;layout&#x2F;main.xmlres&#x2F;layout-large&#x2F;main.xml\n这里需要注意两套布局文件的命名是一样的，另外内部必要组件的id也要一样。\n最小宽度（Smallest-width）限定符\n上边的layout-large是系统3.2之前推出的，仅仅限于以7英寸为分界，系统3.2之后google为了更精细化推出了最小宽度（Smallest-width）限定符，例如我想实现在宽度600dp以上显示一种布局可采用layout-sw600dp，宽度900dp以上显示另外一种布局可采用layout-sw900dp。\n123res&#x2F;layout&#x2F;main.xml   &#x2F;&#x2F;默认兼容布局res&#x2F;layout-sw600dp&#x2F;main.xml    &#x2F;&#x2F;宽度大于600dp时显示的布局res&#x2F;layout-sw900dp&#x2F;main.xml    &#x2F;&#x2F;宽度大于900dp时显示的布局\n布局别名\n试想一种情况同时拥有低于系统版本3.2的设备和高于系统版本3.2的设备，同时又包含大小屏几套布局，低于3.2的设备我们只能采用layout-large方式，高于3.2我们又建议layout-swxxxdp方式，这维护起来可就繁琐了，要维护好几套。反正都是大小屏，在某种尺寸下layout-large和layout-swxxdp的布局肯定是一样的。所以我们有必要解决一下这种重复文件的问题，通过某种方式使得layout-large和layout-swxxxdp下同时指向一个文件，我们只需要这一个文件即可，这里引入“布局别名”方案。\n针对普通手机适配和大屏适配可同时在layout下添加两个文件：\n12res&#x2F;layout&#x2F;main.xmlres&#x2F;layout&#x2F;main_large.xml\n然后根据系统版本3.2前后分别在values-large和values-swxxxdp下添加如下别名设置：\n1.res/values-large/layout.xml(3.2之前的大屏布局)：\n123&lt;resources&gt; &lt;item name&#x3D;&quot;main&quot; type&#x3D;&quot;layout&quot;&gt;@layout&#x2F;main_large&lt;&#x2F;item&gt;&lt;&#x2F;resources&gt;\n2.res/values-sw600dp/layout.xml(3.2之后的大屏布局)：\n123&lt;resources&gt;&lt;item name&#x3D;&quot;main&quot; type&#x3D;&quot;layout&quot;&gt;@layout&#x2F;main_large&lt;&#x2F;item&gt;&lt;&#x2F;resources&gt;\n屏幕方向（Orientation）限定符\n针对大屏可通过横向布局、纵向布局别名设置。\n针对普通手机适配和大屏下纵屏、横屏适配可同时在layout下添加几个文件：\n123res&#x2F;layout&#x2F;main.xml    &#x2F;&#x2F;默认手机兼容布局res&#x2F;layout&#x2F;main_large_port.xml  &#x2F;&#x2F;大屏纵向布局res&#x2F;layout&#x2F;main_large_land.xml  &#x2F;&#x2F;大屏横向布局\nres/values-large-port/layouts.xml\n（大屏、纵向、单面板带操作栏-Andorid 3.2版本前）\n1234&lt;resources&gt;    &lt;item name&#x3D;&quot;main&quot; type&#x3D;&quot;layout&quot;&gt;@layout&#x2F;main_large_port&lt;&#x2F;item&gt;    &lt;bool name&#x3D;&quot;has_two_panes&quot;&gt;false&lt;&#x2F;bool&gt;&lt;&#x2F;resources&gt;\nres/values-large-land/layouts.xml\n（大屏、横向、双面板、宽-Andorid 3.2版本前）\n1234&lt;resources&gt;    &lt;item name&#x3D;&quot;main&quot; type&#x3D;&quot;layout&quot;&gt;@layout&#x2F;main_large_land&lt;&#x2F;item&gt;    &lt;bool name&#x3D;&quot;has_two_panes&quot;&gt;true&lt;&#x2F;bool&gt;&lt;&#x2F;resources&gt;\nres/values-sw600dp-port/layouts.xml\n（大屏、纵向、单面板带操作栏-Andorid 3.2版本后）\n1234&lt;resources&gt;    &lt;item name&#x3D;&quot;main&quot; type&#x3D;&quot;layout&quot;&gt;@layout&#x2F;main_large_port&lt;&#x2F;item&gt;    &lt;bool name&#x3D;&quot;has_two_panes&quot;&gt;false&lt;&#x2F;bool&gt;&lt;&#x2F;resources&gt;\nres/values-sw600dp-land/layouts.xml\n（大屏、横向、双面板、宽-Andorid 3.2版本后）\n1234&lt;resources&gt;    &lt;item name&#x3D;&quot;main&quot; type&#x3D;&quot;layout&quot;&gt;@layout&#x2F;main_large_land&lt;&#x2F;item&gt;    &lt;bool name&#x3D;&quot;has_two_panes&quot;&gt;true&lt;&#x2F;bool&gt;&lt;&#x2F;resources&gt;\n针对双面板设置可在onCreat里直接通过getResources().getBoolean(R.bool.has_two_panes)获取值来判断是否进行展示双面板。\nTAP\n有些时候我们可能需要在特殊情况下进行限定某些布局或图片的引用，我们要用限定符进行限定，上文“限定符”仅仅针对尺寸匹配用到，按照多种要求这点限定符是远远不够的，这里我就偷个懒，推荐大家看一下官方文档：提供备用资源。\n根据布局组件的相关属性自适应屏幕\n通过属性相关值，使用&quot;wrap_content&quot;、&quot;match_parent&quot;和&quot;weight“来控制视图组件的宽度和高度也是通用的做法，这里就不再详说了。\n图片资源匹配\n针对尺寸情况下图片资源自适应常用的就是自动拉伸位图：Nine-Patch，后缀名是.9.png，是一种被特殊处理过的PNG图片，设计时可以指定图片的拉伸区域和非拉伸区域；使用时，系统就会根据控件的大小自动地拉伸你想要拉伸的部分。androidstudio自带有.9图制作工具。\n用户界面流程匹配\n这种方式主要目的是根据屏幕的相关配置进而改变用户的操作流程。\n举例：\n1.纵屏的时候是一个列表，则点击列表跳转到详情页；横屏的时候左侧是一个列表，右侧是一个内容展示区域，点击左侧列表右侧显示相关内容。\n2.纵屏的时候是一个列表，横屏的时候判断是否是双面板，不是双面板直接销毁当前页面返回到首页。\n屏幕密度匹配\n布局匹配\n从单位说起\ndp：为了使一套布局在不同的密度上显示相同的效果，采用px肯定是不行的了，h5开发的时候采用更多的单位em，即表示相对像素，android开发采用的单位是密度无关像素（dp）,即表示与实际物理像素没有关系，是以480x320像素下160dpi作为基准，1dp = 1px，其他像素下进行换算，因此在基准分辨率下屏幕宽度&gt;=控件宽度总和时，高分辨率下效果整体差不多。\nsp：android建议textview字体单位采用独立比例像素（sp）,这种单位同样与px没有直接关系，并且能跟随系统进行大小缩放，建议采用12sp、14sp、18sp、22sp作为字体设置大小，不推荐奇数和小数，容易造成精度的丢失问题。上边也提到如果想让应用不跟随系统字体大小进行字体缩放，可采用dp作为字体单位。\n解决控件的屏幕尺寸和屏幕密度的适配问题\n上边提到采用dp做单位满足布局匹配的条件是在基准分标率下屏幕宽度&gt;=控件宽度总和，高分辨率下才能正常显示，假如在更低的分辨率下则有可能出现控件重叠的现象，这是不友好的，那么如何解决这个问题呢？\n方案1.采用以父布局为基准子布局百分比的形式\n即控件宽高的采用父布局的百分比形式，具体使用形式可参阅：https://github.com/JulienGenoud/android-percent-support-lib-sample\n方案2.采用分辨率百分比的形式\n编写脚本将长度转换成各分辨率下的长度，缺点是生成的分辨率文件很多并且根据设计稿的长宽去匹配很麻烦。具体可参看鸿阳的Android 屏幕适配方案“百分比引入”部分。\n方案3.采用分辨率百分比变种的形式\n这种方式还是采用百分比，只不过百分比的基准方式和前两种有所不同（思想和第二种相同），试想屏幕最终绘制的时候其原型仍然最终转换成分辨率进行屏幕绘制的。单位dp最终会转换成分辨率，sp最终也会转换成分辨率，所以我们干脆以分辨率为基准进行处理。假设当前设备的分辨率为1280*720，而设计搞的分辨率为1920*1080，只需要将两个分辨率做比得出一个比率，进而在设备上按照比率进行排布。\n系统进行单位转换的入口为TypedValue中的applyDimension函数，传入单位与value将其计算为对应的px数值。\n1234567891011121314151617public static float applyDimension(int unit, float value, DisplayMetrics metrics) &#123;    switch (unit) &#123;        case COMPLEX_UNIT_PX:            return value;        case COMPLEX_UNIT_DIP:            return value * metrics.density;        case COMPLEX_UNIT_SP:            return value * metrics.scaledDensity;        case COMPLEX_UNIT_PT:            return value * metrics.xdpi * (1.0f / 72);        case COMPLEX_UNIT_IN:            return value * metrics.xdpi;        case COMPLEX_UNIT_MM:            return value * metrics.xdpi * (1.0f / 25.4f);    &#125;    return 0;&#125;\n可以看到这个方法中除了采用px为单位没有涉及DisplayMetrics的参数，其他单位都用到了，所以我们可以根据DisplayMetrics的相关参数按照比率重新赋值的方式来进行完美匹配。\n下边我们仍然采用dp为单位：\n123456789101112131415161718192021222324252627282930/** * 重置屏幕密度 */public static void resetDensity(Context context) &#123;    //绘制页面时参照的设计图尺寸    final float DESIGN_WIDTH = 800f;    final float DESIGN_HEIGHT = 1280f;    final float DESTGN_INCH = 5.0f;    //大屏调节因子，范围0~1，因屏幕同比例放大视图显示非常傻大憨，用于调节感官度    final float BIG_SCREEN_FACTOR = 0.8f;    DisplayMetrics dm = context.getResources().getDisplayMetrics();    //确定放大缩小比率    float rate = Math.min(dm.widthPixels, dm.heightPixels) / Math.min(DESIGN_WIDTH, DESIGN_HEIGHT);    //确定参照屏幕密度比率    float referenceDensity = (float) Math.sqrt(DESIGN_WIDTH * DESIGN_WIDTH + DESIGN_HEIGHT * DESIGN_HEIGHT) / DESTGN_INCH / DisplayMetrics.DENSITY_DEFAULT;    //确定最终屏幕密度比率    float relativeDensity = referenceDensity * rate;    if (ORIGINAL_DENSITY == -1) &#123;        ORIGINAL_DENSITY = dm.density;    &#125;    if (relativeDensity &gt; ORIGINAL_DENSITY) &#123;        relativeDensity = ORIGINAL_DENSITY + (relativeDensity - ORIGINAL_DENSITY) * BIG_SCREEN_FACTOR;    &#125;    dm.density = relativeDensity;    dm.densityDpi = (int) (relativeDensity * DisplayMetrics.DENSITY_DEFAULT);    dm.scaledDensity = relativeDensity;&#125;\n注意获取放大缩小比率时是相对应作比的，这样计算出来的屏幕密度是固定的。\n这种方式基本上可以避免控件在低分辨率的情况下出现重叠的现象，因为是相对整个设计图来的，这里只给出了一套高分辨率设计图的方案，如果开发过程中为了考虑到性能和全覆盖采用多套设计图，大家可根据以上思想加以扩展。\nandroid8.0之前，整个应用长宽缩放比率均是采用一套，所以只需要在Application配置一次即可，但是在Android8.0的时候，系统架构调整，由原来的统一现在分配到每个Activity和全局Application中，Activity中设置的时候要注意一定要设置setContentView()之前，Application的设置即设置在onCreat()即可。为了使这个应用产生效果，建议将Activity形式的配置在BaseActivity中。\nActivity中：\n12345678910111213141516171819/** * 使得在“setContentView()&quot;之前生效，所以配置在此方法中。 * @param newBase */@Overrideprotected void attachBaseContext(Context newBase) &#123;    super.attachBaseContext(newBase);    ScreenUtil.resetDensity(this);&#125;/** * 在某种情况下需要Activity的视图初始完毕Application中DisplayMetrics相关参数才能起效果，例如toast. * @param  */@Overridepublic void onAttachedToWindow() &#123;    super.onAttachedToWindow();    ScreenUtil.resetDensity(this.getApplicationContext());&#125;\nApplication中：\n12345@Overridepublic void onCreate() &#123;    super.onCreate();    ScreenUtil.resetDensity(this);&#125;\n图片资源匹配\n针对图片资源一般我们的做法是多套位图进行适配，那目前主流的屏幕来说我们至少需要UI设计师出两套图片（1080p和760p）,但是对于某些大厂我们需要适配多种就需要多套位图了。\nAndroid上图片资源匹配是按照屏幕密度范围自动匹配不同分辨率图片的。\n\n\n密度类型\n代表的分辨率(px)\n屏幕像素密度(dpi)\n\n\n\n\n低密度（ldpi）\n320x240\n120\n\n\n中密度（mdpi）\n480x320\n160\n\n\n高密度（hdpi）\n800x480\n240\n\n\n超高密度（xhdpi）\n1280x720\n320\n\n\n超超高密度（xxhdpi）\n1920x1080\n480\n\n\n注意：针对.9图和某些不需要多套分辨率的图片直接放在drawable文件夹下即可。\n针对mipmap和drawable文件夹的区别，这一点我在14年刚刚接触androidstudio时，也是认为mipmap应该比drawable引用图片的性能处理更好写，但是经翻看官方文档并没有说所有图片都要放在mipmap中，而是建议将android应用的启动图标放在各个mipmap文件夹中，而其他图片还是放在各个drawable文件夹中。\n多套位图的缺点相比大家都很清楚了，第一是耗费UI设计师的时间，第二apk的包非常大，尤其第二个在某些场景也是致命的。有没有更好的解决方案解决这两个缺点呢？\n答案是当然有。解决这个问题就是剔除多套位图的做法，直接在支持最大分辨率的drawable文件夹下放一套大分辨位图，android图片资源引用规则是系统根据设备的屏幕密度优先选取最合适的那套图片，如果找不到则向大一点分辨率文件去寻找图片来适配（为什么选取向大一级的文件夹下去寻找，目的是寻找到大图可以采用缩小处理，至少不会失真，反过来想想也是不可取）。\n有同学这里问了，放大图片同样apk包很大，并且加载图片时特耗内存，这里我推荐一个工具:TinyPng，支持单个图片压缩，也支持多图片同时压缩，再配合目录“解决控件的屏幕尺寸和屏幕密度的适配问题”第三种方案，简直完美。\n参考\n\nhttps://developer.android.com/guide/practices/screens_support?hl=zh-cn#qualifiers\n\n","plink":"https://blog.ixin.run/posts/1522163597/"},{"title":"AndroidStudio配置Terminal窗口及相关命令归总","date":"2018-03-22T16:25:46.000Z","date_formatted":{"ll":"2018年3月23日","L":"2018/03/23","MM-DD":"03-23"},"updated":"2021-01-29T12:51:44.620Z","content":"Terminal大家都熟悉，是一个类似cmd的命令行工具，AndroidStudio中自带，我们可以在上面利用ADB工具的相关命令进行应用程序安装、卸载、文件写入、日志输出等操作，也可以利用Gradle构建工具的相关命令进行项目的构建打包、签名等操作。\n\n我们在第一次安装Android studio的时候Terminal窗口中输入&quot;adb&quot;或&quot;gradle&quot;的时候总是报一个“XXX不是内部或外部命令，也不是可运行的程序或批处理文件”的错误信息，这是因为这两个工具没有在系统变量中配置的原因。这里就简单总结一下Terminal相关配置及一些常用命令便于日后的回顾。\nADB工具配置\nADB全称Android Debug Bridge，是Android的一个调试工具，借助这个工具，我们可以调试开发的程序,还可以对连接到电脑的手机设备或者手机模拟器进行操作，比如安装、卸载app、升级等，总之adb就是连接Android手机与PC端的桥梁，可以让用户在电脑上对手机进行全面的操作。adb.exe在安装的sdk开发包platform-tools目录下。\n上边也说了第一次安装androidstudio，Terminal窗口并不能运行adb命令，需要进行环境变量的配置，其配置过程和配置java一样：\n\n先在系统变量中新建一个变量名字为ANDROID_HOME的变量，值为你的sdk目录。\n\n将SDK中adb目录配置在path变量里，在系统变量的path中后面添加 %ANDROID_HOME%\\platform-tools;\n\n重启android studio，打开Terminal窗口，输入’adb’，若出现adb相关信息，即为可用。\n\nADB常用的命令\n\nadb start-server  //开启PC端的adb server\nadb kill-server  //关闭PC端的adb server\nadb connect 192.168.1.5:5555   //连接手机(5555是手机开放的端口号，可省略）\n，如果连接成功会进行相关的提示，此时在电脑上可以输入adb相关的命令进行调试该手机，如果失败的话，可以先kill-server命令，然后重试连接。\nadb disconnect 192.168.1.5:5555 //调试结束，断开手机连接。\nadb devices  //显示当前运行的全部模拟器\nadb shell pm list packages  //列出手机上所有安装的应用包名\nadb install *.apk  //adb安装apk\nadb -s &lt;设备编号&gt; install *.apk  //多个设备时，指定某设备安装应用。\nadb uninstall apk的包名  //adb卸载apk。\nadb push &lt;本地路径&gt; &lt;远程路径&gt; //从本地向设备中添加文件\nadb push &lt;远程路径&gt; &lt;本地路径&gt; //从设备上拷贝文件到本地\nadb help //显示帮助信息\nadb shell //进入设备的data目录\nexit  //退出adb shell\n\ntap:有些时候通过命令行安装某个应用时，默认是不启动这个应用的，我们可以使用如下命令启动该应用：\n12$ adb shell$ am start -n &#123;应用包名&#125;&#x2F;&#123;应用启动页全路径&#125;\nGradle工具配置\nGradle这个不陌生，作为Android开发主要用于项目的构建，功能很强大，其命令可用于apk的多渠道打包（release,debug）、签名、查看构建信息等，Terminal中使用gradle命令同样也要配置环境变量，gradle的环境变量配置和adb环境变量配置一样，也有如下步骤：\n\n先在系统变量中新建一个变量名字为GRADLE_HOME的变量，值为本地gradle地址，在AndroidStudio安装目录中可找到。\n将SDK中adb目录配置在path变量里，在系统变量的path中后面添加 %GRADLE_HOME%\\bin;\n重启Android Studio，打开Terminal窗口，输入’gradle’,若有gradle先关信息即为成功。\n\nTerminal输入命令gradle和gradlew的区别\n其实细心的同学发现不用配置gradle的环境变量直接可用&quot;gradlew&quot;的命令就可以使用。这两个有什么联系呢？\ngradlew即gradle wrapper,是google推荐的build方式。每个项目都有一个特定版本的gradle用于构建此项目，但是并不是所有的项目都用一个版本，也有可能某个项目所用的gradle版本电脑上并没有下载，这样如果在本地配置gradle，需要配置太多个，太麻烦。在项目gradlew里面配置项目所需要的gradle版本，然后用户只需要运行gradlew（第一次运行）就可以按照配置下载对应的gradle到项目的目录中，仅仅给项目本身用，然后就可以用gradlew命令执行clean、build等操作，和gradle命令一样，太方便了。其实说白了gradlew就相当于gradle的包装。\n\nGradle常用的命令\n\ngradlew -v //版本号\ngradlew clean //清除app目录下的build文件夹\ngradlew build //检查依赖并编译打包\ngradlew assembleDebug //编译并打Debug包\ngradlew assembleRelease //编译并打Release的包\ngradlew installRelease //Release模式打包并安装\ngradlew uninstallRelease //卸载Release模式包\n\n","plink":"https://blog.ixin.run/posts/1521735946/"},{"title":"Android多CPU适配总结","date":"2018-03-21T15:43:59.000Z","date_formatted":{"ll":"2018年3月21日","L":"2018/03/21","MM-DD":"03-21"},"updated":"2021-01-29T12:51:44.622Z","content":"这两天准备重构一个好几年的老项目，项目中使用了NDK，但是莫名的报ABI的错误，最终找出问题是项目中.so文件放的位置不对。ABI的概念之前也了解过，今天总结一下。\n\n理解几个概念\n\nNDK\n即Native Development Kit，原生开发工具集，因此又被Google称为“NDK”，Android开发中NDK允许用户使用类似C / C++之类的原生代码语言执行部分程序。好处是方便调用第三方C/C++开源库，也方便代码的移植。\nJNI\n即Java Native Interface，从字面意思知道充当一个接口的角色，它提供了若干的API实现了Java和其他语言的通信（主要是C&amp;C++）。\nABI\n即Application Binary Interface，应用程序二进制接口。不同的Android 手机有不同的CPU，进而支持不同的指令集，CPU和指令集的每一种组合有它自己的ABI（应用二进制文件），属于“运行时，应用的机器码和系统的交互方式”。\nAPI\n即Application Programming Interface，应用程序编程接口。面向的是与源代码层面或者库函数层面的交互方式，发生在编译期。\n\nAPI和ABI的一个重要的区别就是前者是面向的是源代码，后者站在源代码的角度面向的是驱动不同的cpu架构或者不同的内存分配方式（系统不同或者语言不同有可能内存分配方式也不同）的二进制文件。所以说一套源码下来API相同ABI却很可能不同，后者兼容程度要更为严格。\n\nAndroid支持的CPU架构（ABI）\n\narmeabi\n基于 ARM* v5TE 设备的库，使用软件浮点运算，兼容所有ARM设备，通用性强，速度慢。\narmeabi-v7a\n基于 ARM* v7 设备的库，使用硬件浮点运算，具有高级扩展功能（2010年）。\narm64-v8\n面向第8代、64位ARM处理器的库。\nx86\n面向32位intel处理器（2011年）。（台式机和平板用的较多）\nx86_64\n面向64位intel处理器（2014年）。\nmips\n面向mips架构的处理器。（早期索尼的游戏机，相比intel，其指令系统计算结构更精简）\nmips64\n面向64位mips架构的处理器。\n\nAndroidStudio中使用.so库\n两种形式配置：\n1.和eclipse中工程项目一样，在libs目录下新建armeabi等目录的方式，这种方式不是Androidstudio默认支持的，因此要在gradle中添加指定加载.so库的目录：\n12345sourceSets &#123;    main &#123;        jniLibs.srcDirs &#x3D; [&#39;libs&#39;]    &#125;&#125;\n2.采用AndroidStudio默认的形式，直接在src/main/下新建jniLibs目录，将armeabi等目录放到该目录下即可。另外同级目录下仍可新建jni目录NDK开发用于放置cpp或c文件，即jni和jniLibs可同级存在。\n安装时兼容性检查\n安装到系统中后，so文件会被提取在：data/app/com.xxxxxxxx.app-x/lib/目录下（5.0版本）、/data/app-lib/目录下（4.2版本），其中armeabi和armeabi-v7a会生成arm目录，arm64-v8a会生成arm64目录。\n安装app的时候，如果app使用了so文件，而不存在适合本机cpu架构的so文件，则会报错。例如：在x86模拟器上就必须有x86版本的so文件夹。不然无法安装成功。\n运行时兼容性检查\n1.检查目标目录下是否存在的so库文件。有些时候由于项目中不同ABI文件夹下的.so文件个数不一致，加载后造成某些CPU架构无法正常在提取的目录下读取到相应的.so文件。\n2.检查存在的so文件是否符合当前cpu架构。某些ABI文件夹的.so不符合。\n加载.so文件规则\n当项目中只提供了armeabi目录时，armeabi-v7a、arm64-v8a架构的程序会去armeabi里寻找，当项目中同时也提供了armeabi-v7a、armeabi-v8a目录，系统就不会再去armeabi里面寻找了，如果在这两个目录中找不到则直接报错。\n常见问题\n\nABI目录中虽然放置的.so文件一样，但某些目录下放置却不是最优的.so文件，或者从低版本架构拷贝的。\n使用Android高版本平台版本编译的.so文件运行在低版本的设备上。\n没有为每个支持的CPU架构提供对应的.so文件。\n将.so文件放在错误的地方。\n只提供armeabi架构的.so文件而忽略其他ABIs的。\n\n以上这些问题要么导致报错，要么导致性能低下，即使能运行但在某些老旧的设备上也可能发生错误。\n建议\n这里根据上边的问题在开发的过程中提几条建议：\n\n如果应用程序想安装范围广一些，那么尽可能包含所有的ABI，当然这会导致安装包很大。\n如果考虑到应用的安装范围，比如针对更多的是手机，则可适配armeabi、armeabi-v7、arm64-v8。\n如果考虑到安装包的大小，而不太注重CPU性能，可能面对的都是市面上的新机，可仅仅适配armeabi。\n如果针对多个ABI，则每个ABI目录下的.so文件都是一样的，最好都是针对该ABI的。\nNative Libs Monitor这个应用可以帮助我们理解手机上安装的APK用到了哪些.so文件，以及.so文件来源于哪些函数库或者框架。\n某些时候引用多个第三方库，可能libs文件夹和jniLibs文件夹都放的有，此时会造成冲突，所以尽可能的都放在一个地方。\n某些时候虽然项目中仅有某个abi文件夹，但是项目依赖有第三方库，而项目中没有进行过滤，则有可能会报某个abi下没有相应的库文件错误。\n\n上边选择性的适配ABI可在Gradle中配置：\n12345ndk &#123;    //选择要添加的对应cpu类型的.so库。    abiFilters &#x27;armeabi&#x27;, &#x27;armeabi-v7a&#x27;, &#x27;arm64-v8a&#x27;    // 还可以添加 &#x27;x86&#x27;, &#x27;x86_64&#x27;, &#x27;mips&#x27;, &#x27;mips64&#x27;&#125;\n注意：ndk.abiFilters指定的abi平台的库文件夹及库文件，要么都存在，要么都不存在。\n如果项目还支持ndk开发，可在gradle.properties文件里加入：\n1android.useDeprecatedNdk=true\n注意：NDK是向后兼容的，所以尽可能采用低版本的构建工具进行构建。\nTap:\n\n\n踩过的坑：之前有个项目仅支持armeabi和armeabi-v7a的cpu架构，但是在调试过程中总是报错：\n 1Caused by: java.lang.UnsatisfiedLinkError: dalvik.system.PathClassLoader[DexPathList[[zip file &quot;&#x2F;data&#x2F;app&#x2F;idonic.mobileapp.xxx-1&#x2F;base.apk&quot;],nativeLibraryDirectories&#x3D;[&#x2F;data&#x2F;app&#x2F;idonic.mobileapp.xxx-1&#x2F;lib&#x2F;arm, &#x2F;data&#x2F;app&#x2F;idonic.mobileapp.xxx-1&#x2F;base.apk!&#x2F;lib&#x2F;armeabi-v7a, &#x2F;vendor&#x2F;lib, &#x2F;system&#x2F;lib]]] couldn&#39;t find &quot;libxxx.so&quot;\n自己项目中也只有armeabi库文件夹，根据上边的规则，即使没有armeabi-v7a文件夹运行时也最终会到armeabi文件夹中寻找，不应该啊，后来冥思苦想只有一种可能，就是项目构建后肯定有armeabi-v7a文件夹的存在，立刻解压缩apk果真是这个问题，原来项目中依赖有腾讯的Bugly,构建打包后会释放出armeabi-v7a的文件夹，但是里面只有libBugly.so文件。\n解决这个问题有三点注意：\n\n不要只看项目表面的结构，隐藏的依赖有可能是最大的元凶。\n一定要设置abi过滤器。\n把对应的abi库文件补全。\n\n\n\n有些时候我们运行安装在模拟器上的时候报“Failure [INSTALL_FAILED_NO_MATCHING_ABIS: Failed to extract native libraries, res=-113]”\n具体错误原因：由于使用了native libraries 。该native libraries 不支持当前的cpu的体系结构。\n\nINSTALL_FAILED_NO_MATCHING_ABIS is when you are trying to install an app that has native libraries and it doesn’t have a native library for your cpu architecture. For example if you compiled an app for armv7 and are trying to install it on an emulator that uses the Intel architecture instead it will not work.\n\n简单点说，虽然工程支持运行在某abi架构（例如模拟器x86架构）机器上，但是工程所包含的库却没有该abi架构所支持的库，导致无法安装运行，这在上面阐述很清楚。\n解决这个问题有两种方式：\na.将x86的库文件夹及文件补全。\nb.移除ndk.abiFilters，采用abi分包，构建apk时单独分离出支持x86架构的apk。\n 12345678splits &#123;  abi &#123;    enable true    reset()    include &#39;x86&#39;    universalApk true  &#125;&#125;\n\n\n提到上边构建apk分包，有多种分包形式，可以按照abi支持进行分，也可以按照屏幕密度支持进行分：\n 123456789101112splits &#123;  density &#123;    enable true    reset()    include &quot;mdpi&quot;, &quot;hdpi&quot;  &#125;  abi &#123;    enable true    reset()    include &quot;x86&quot;, &quot;x86_64&quot;  &#125;&#125;\n点击菜单Build &gt; Build APK，然后在工程中build &gt; outputs &gt; apk下可获取到多种形式的apk。具体详细使用可参考官方文档：https://developer.android.com/studio/build/configure-apk-splits\n\n\n参考\n\nhttps://zhuanlan.zhihu.com/p/23102158\nhttps://developer.android.com/studio/build/configure-apk-splits\n\n","plink":"https://blog.ixin.run/posts/1521647039/"},{"title":"Java泛型的认识和理解","date":"2018-03-14T16:08:11.000Z","date_formatted":{"ll":"2018年3月15日","L":"2018/03/15","MM-DD":"03-15"},"updated":"2021-01-29T12:51:44.662Z","content":"针对泛型大家并不陌生，主要是针对某些对象以及方法参数的限定，避免在代码编写的过程中由于类型的不匹配从而造成运行期发生异常，泛型只在编译阶段有用，运行期间则会进行泛型擦除。\n\n什么是泛型\n泛型即“参数化类型”，目的就是将参数类型像参数一样引入到类、方法、接口中来，进而来统一内部使用时的参数类型，JDK1.5引入的。\n举个栗子\n1234567List list = new ArrayList&lt;&gt;();list.add(&quot;test&quot;);list.add(1);for (int i = 0; i &lt; list.size(); i++) &#123;\tString name = (String) list.get(i); // 取出Integer时，运行时出现异常\tSystem.out.println(&quot;name:&quot; + name);&#125;\n以上异常的原因正是因为类型不匹配造成的，因此我们在定义的时候规定一种类型：\n1List&lt;String&gt; list = new ArrayList&lt;String&gt;();\n这样在编译的时候就不允许使用添加integer类型了，取的时候也就大胆放心的去取了，这就是泛型的目的。\n泛型给我们带来了不一样的编程体验，平时在使用泛型的时候不知道具体的泛型参数是什么，那么我们可以这样定义：\n123456789101112public class Cache&lt;T&gt; &#123;    T value;    public Object getValue() &#123;        return value;    &#125;    public void setValue(T value) &#123;        this.value = value;    &#125;&#125;\n使用的时候我们只需将确定的泛型参数传进去即可：\n1234567Cache&lt;String&gt; cache1 = new Cache&lt;String&gt;();cache1.setValue(&quot;123&quot;);String value2 = cache1.getValue();Cache&lt;Integer&gt; cache2 = new Cache&lt;Integer&gt;();cache2.setValue(456);int value3 = cache2.getValue();\n尖括号  中的T被称作是类型参数，用于指代任何类型。出于规范的目的，Java建议我们用单个大写字母来代表类型参数。常见的如：\n\nT 代表一般的任何类。\nE 代表 Element 的意思，或者 Exception 异常的意思。\nK 代表 Key 的意思。\nV 代表 Value 的意思，通常与 K 一起配合使用。\nS 代表 Subtype 的意思，文章后面部分会讲解示意。\n\n总结了一下泛型的优点：\n（1）软件编程扩展\n与普通的 Object 代替一切类型这样简单粗暴而言，泛型使得数据的类别可以像参数一样由外部传递进来。它提供了一种扩展能力。它更符合面向抽象开发的软件编程宗旨。\n（2）类型安全\n通过知道使用泛型定义的变量的类型限制，编译器可以更有效地提高Java程序的类型安全。\n（3）消除强制类型转换\n消除源代码中的许多强制类型转换，这使得代码更加可读，并且减少了出错机会。所有的强制转换都是自动和隐式的。\n（4）提高性能\n泛型使得在参数调用的时候事先判断了参数是否符合标准，避免了在运行时数据调用不规范所进行的一系列处理，保证程序稳定快速运行。\n泛型的使用\n在开发过程中泛型按照使用的情况大致分为三种：\n\n泛型接口\n泛型类\n泛型方法\n\n泛型接口\n1.知道泛型参数的情况下。\n具体泛型参数类：\n12345public class Call &#123;\tpublic Call()&#123;\t\tSystem.out.println(&quot;this is call&quot;);\t&#125;&#125;\n定义接口：\n123public interface GenericInterface&lt;T&gt; &#123;\tT next();&#125;\n接口实现类：\n123456public class GenericClass implements GenericInterface&lt;Call&gt; &#123;\tpublic Call next() &#123;\t\tCall c = new Call();\t\treturn c;\t&#125;&#125;\n主函数功能实现:\n1234public static void main(String[] arg)&#123;\tGenericClass genericClass = new GenericClass();\tgenericClass.next();&#125;\n运行结果：\nthis is call\n2.大部分情况下是事先并不只泛型参数具体类型，此时需要泛型类来确定泛型接口中具体传入的参数类型。\n定义接口：\n123public interface GenericInterface&lt;T&gt; &#123;\tT next(T t);&#125;\n接口实现类：\n12345public class GenericClass&lt;T&gt; implements GenericInterface&lt;T&gt; &#123;    public T next(T t) &#123;\t\treturn t;\t&#125;&#125;\n主函数功能实现:\n1234public static void main(String[] arg)&#123;\tGenericClass&lt;Call&gt; genericClass = new GenericClass&lt;Call&gt;();\tgenericClass.next(new Call());&#125;\n运行结果：\nthis is call\n泛型类\n和泛型接口定义一样：\n1234567public class Test&lt;T&gt; &#123;    T value;        public T getValue()&#123;        return value;    &#125;&#125;\n使用的时候将泛型参数传进去：\n1Test&lt;String&gt; test = new Test&lt;&gt;();\n当然泛型参数也可以不止一个：\n123456789101112public class MultiType &lt;E,T&gt;&#123;    E value1;    T value2;    public E getValue1()&#123;        return value1;    &#125;    public T getValue2()&#123;        return value2;    &#125;&#125;\n泛型方法\n这里的泛型方法特指由方法本身来确定将来传入的参数类型而非像上边引用泛型接口或泛型类的泛型参数。泛型方法可单独对方法定义方法的形参类型和方法的返回类型。\n定义方法的形参类型：\n12345public class Test &#123;    public &lt;T&gt; void testMethod(T t)&#123;    &#125;&#125;\n定义方法的返回类型：\n12345public class Test &#123;    public &lt;T&gt; T  testMethod(T t)&#123;        return t;    &#125;&#125;\n泛型方法与泛型类共存\n123456789public class Test&lt;T&gt;&#123;    public  void testMethod1(T t)&#123;        System.out.println(t.getClass().getName());    &#125;    public  &lt;E&gt; E testMethod2(E e)&#123;        return e;    &#125;&#125;\n这里testMethod1和testMethod2两个方法所接收的参数类型是不一样的。testMethod1属于普通方法，其参数来自于类传入的参数类型决定，testMethod2由将来自身方法的传入的参数来决定参数类型，这里为了代码的方便阅读和避免混淆所以采用T和E来进行区分。\n从上边的一路走来可以看出无论是泛型接口还是泛型类或是泛型方法其将来的传入参数均来源于所在的位置，这里的是对T的声明定义。\n通配符 ？\n？ 是通配符，目的希望泛型能够处理某一范围内的数据类型，也就是说让泛型所表示的参数类型更广一些从而满足泛型限定的对象之间能够正常匹配。\n&lt; ? &gt; 表示类型的无界通配符，意思是目前并不知道参数类型是什么，是对类型的无界限定，使得参数范围更广阔。\n例如：\n1List&lt;?&gt; list = new ArrayList&lt;String&gt;();\n注意List&lt; ? &gt;和List是有区别的，就拿上句代码来说表示的意思是“生成一个集合对象只能放String类型，至于这个集合类型却是未知的”，这也是使用无界通配符不能往里面存任何类型数据 的原因，只能存null。而List list = new ArrayList&lt;String&gt;();表示的意思是“生成一个集合对象只能存放String类型，这个集合本身所限定的范围却是任意都可以”，看出来两者的区别了吧\n1234567List&lt;Child&gt; lsc = new ArrayList&lt;Child&gt;();List&lt;Parent&gt; lsp = new ArrayList&lt;Parent&gt;();lsp = lsc;  //编译器报错不通过List lsc = new ArrayList&lt;Child&gt;();List&lt;Parent&gt; lsp = new ArrayList&lt;Parent&gt;();lsp = lsc;  //编译器可以运行\n另外，通配符不能作为“参数类型”使用：\n12345//errorclass Test&lt;?&gt;&#123;    private ? item1;    private ? item2;&#125;\n通配符的边界\n通配符常用的就是对边界的限定，有界通配符分为两种：\n\n&lt; ? extends T &gt;：是指 “上界通配符（Upper Bounds Wildcards）”，限定的是所有的子类及其本身类型。\n&lt; ? super T &gt;：是指 “下界通配符（Lower Bounds Wildcards）”，限定的是所有的父类及其本身类型。\n\n通配符的边界限定能更好更准确的控制参数类型，便于数据顺利的传入和取出。\n举个栗子：\n这里有一个Fruit类和他的派生类Apple类\n12class Fruit &#123;&#125;class Apple extends Fruit &#123;&#125;\n接着我们设定一个容器，并设定他有存取功能\n123456class Plate&lt;T&gt;&#123;    private T item;    public Plate(T t)&#123;item=t;&#125;    public void set(T t)&#123;item=t;&#125;    public T get()&#123;return item;&#125;&#125;\n我们现在有一个想法就是生成一个用来装“苹果”的“水果盘子”，想像是美好的，现实却是不允许的。\n1Plate&lt;Fruit&gt; p=new Plate&lt;Apple&gt;(new Apple());    // error\n编译器的想法是：苹果属于水果。但是装苹果的盘子却不属于装水果的盘子，其实想想也在理，这之间有一个关系存在，前者属于继承关系，后者仅仅是参数上存在着联系，对于Plate在没有一个参数限定的条件下是不能随意进行等价的。这就是通配符要有一个上下边界的范围限定的原因。\n&lt; ? extends T &gt;\n上界通配符，指的是所有的子类及其本身类型。还是上边的例子变换成Plate&lt; ? extends Fruit &gt;意思就可以是装所有水果的盘子，不一定是哪种水果，有可能是Fruit本身也有可能就是Apple.\n1Plate&lt;？extends Fruit&gt; p=new Plate&lt;Apple&gt;(new Apple());\n这样就说的过去了，总有一个是属于我（苹果）的。接下来就可以调用盘子里的方法了。但是并不是所有的方法都能调用，设定上届通配符可以取数据但是不允许存入数据的，除了null。编译器看到Plate&lt; ? extends Fruit&gt;只知道盘子里将来放的是Fruit或者他的孩子，而具体是什么并不知道，所以编译器在这里仅仅给以一个占位符：CAP#1，来表示捕获一个Fruit或Fruit的子类，具体是什么类不知道，然后无论是想往里插入Apple或者Fruit编译器都不知道能不能和这个CAP#1匹配，所以就都不允许。另外，读取数据时也只能存放在Fruit或者Fruit基类中，因为不能确定到底是哪种类型，否则不得不进行类型判断或者强转了。\n123456789Plate&lt;? extends Fruit&gt; p=new Plate&lt;Apple&gt;(new Apple());//不能存入任何元素p.set(new Fruit());    //Errorp.set(new Apple());    //Errorp.set(null); \t//读取出来的东西只能存放在Fruit或它的基类里。Fruit newFruit1=p.get();Object newFruit2=p.get();Apple newFruit3=p.get();    //Error\n&lt; ? super T &gt;\n下届通配符，指的是Fruit本身以及所有Fruit的基类，有可能是Foot或者Object。但是要明白一点Plate&lt; ? super Fruit &gt;的基类不是Plate&lt; Apple &gt;的基类。\n1Plate&lt;? super Fruit&gt; p=new Plate&lt;Apple&gt;(new Apple());  //Error\n使用下界&lt; ? super Fruit &gt;会使从盘子里取东西的get( )方法部分失效，只能存放到Object对象里，还是因为不能确定到底是哪种类型，只能基类来接收。set( )方法正常。\n12345678Plate&lt;? super Fruit&gt; p=new Plate&lt;Fruit&gt;(new Fruit());//存入元素正常p.set(new Fruit());p.set(new Apple());//读取出来的东西只能存放在Object类里。Apple newFruit3=p.get();    //ErrorFruit newFruit1=p.get();    //ErrorObject newFruit2=p.get();\nextends、super选取\n1.频繁往外读取内容的，适合用上界extends。\n2.经常往里插入的，适合用下界super。\n类型擦除\n泛型只在编译阶段有用，在进入JVM之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。\njava1.5版本之前是没有泛型的，1.5版本引入泛型概念，为了和之前的版本能够很好兼容，这里采用了类型擦数的方式。\n看下面的代码：\n12345List&lt;String&gt; a = new ArrayList&lt;String&gt;();  List b = new ArrayList();  Class c1 = a.getClass();  Class c2 = b.getClass();  System.out.println(c1 == c2); //true  \n上面程序的输出结果为true。所有反射的操作都是在运行时的，既然为true，就证明了编译之后，程序会采取去泛型化的措施，也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦除，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。\n上述结论可通过下面反射的例子来印证：\n12345678910ArrayList&lt;String&gt; a = new ArrayList&lt;String&gt;();  a.add(&quot;CSDN&quot;);  Class c = a.getClass();  try&#123;      Method method = c.getMethod(&quot;add&quot;,Object.class);      method.invoke(a,100);      System.out.println(a);  &#125;catch(Exception e)&#123;      e.printStackTrace();  &#125;  \n因为绕过了编译阶段也就绕过了泛型，输出结果为：\n[CSDN, 100]\n泛型擦除规则\n并不是所有的泛型参数类型擦除后都是Object类型，类型擦除是有规则的：\n\n泛型擦除就是类型变量用第一个限定来替换,如果没有给定限定就用Object替换,例如类Pair中的类型变量没有限定所以用Object替换。\n\n看个例子：\n1234567891011121314public class Interval&lt;T extends Comparable &amp; Serializable&gt; &#123;    private T lower;    private T upper;    public Interval(T first, T second) &#123;        if (first.compareTo(second) &gt; 0)&#123;            lower = second;            upper = first;        &#125;else&#123;            lower = first;            upper = second;        &#125;    &#125;&#125;\n擦除后的原始类：\n12345678public class Interval&#123;  private Comparable lower;  private Comparable upper;  public Interval(Comparable first, Comparable second) &#123;  &#125;&#125;\n此时把限定改为Interval&lt;T extends Serializable &amp; Comparable&gt;则原始类型就用Serializable替换T,而编译器会在需要的时候插入强制类型转换为Comparable,为了提高效率,我们应该把没有方法的接口放在后面。\n翻译泛型方法\n你可能会有疑问，泛型擦除后非限定的类型转换成Object，编译前进行引用时并没有进行类型转换，还能够正常运行，这是怎么回事呢？\n12Pair&lt;Manager&gt; pair = ...;Manager manager = pair.getFirst();\n这里引入&quot;翻译泛型表达式&quot;概念：在程序调用泛型方法的时候，如果返回值被擦除，编译器会插入强制的类型转换。\n擦除后getFirst返回值为Object,编译器会自动插入Manager强制类型转换,所以getFirst()方法会执行如下两个指令：\n\n对原始方法调用getFirst()\n把返回值Object强转成Manager\n\n类型擦除带来的问题\n因为种种原因，Java不能实现真正的泛型，只能使用类型擦除来实现伪泛型，这样虽然不会有类型膨胀的问题，但是也引起了许多新的问题。所以，Sun对这些问题作出了许多限制，避免我们犯各种错误。\n1.类型擦除与多态冲突\n假设有一个超类：\n1234567public class Parent&lt;T&gt;&#123;    public void sayHello(T value)    &#123;        System.out.println(&quot;This is Parent Class, value is &quot; + value);    &#125;&#125;\n以及一个子类：\n1234567public class Child extends Parent&lt;String&gt;&#123;    public void sayHello(String value)    &#123;        System.out.println(&quot;This is Child class, value is &quot; + value);    &#125;&#125;\n最后有以下测试代码，企图实现多态：\n12345678910public class MainApp&#123;    public static void main(String[] args)    &#123;        Child child = new Child();        Parent&lt;String&gt; parent = child;        parent.sayHello(&quot;This is a string&quot;);    &#125;&#125;\n按照泛型类型擦除原则，父类中是sayHello(Object value)，子类中还是sayHello(String value)，这两个根本不是重写关系，而是重载，这不是多态的形式，所以你会感觉冲突了吧，但是结果是可以正常运行，这是怎么回事？\n原因是编译器在Child类中自动生成了一个桥方法：\n1234public void sayHello(Object value)&#123;    sayHello((String) value);&#125;\n可以看出，这个桥方法实际上就是对超类中sayHello(Obejct)的重写。这样做的原因是，当程序员在子类中写下以下这段代码的时候，本意是对超类中的同名方法进行重写，但因为超类发生了类型擦除，所以实际上并没有重写成功，因此加入了桥方法的机制来避免类型擦除与多态发生冲突。\n1234567public class Child extends Parent&lt;String&gt;&#123;    public void sayHello(String value)    &#123;        System.out.println(&quot;This is Child class, value is &quot; + value);    &#125;&#125;\n桥方法并不需要自己手动生成，一切都是编译器自动完成的。\n2.泛型类型变量不能是基本数据类型\n不能用类型参数替换基本类型。就比如，没有ArrayList，只有ArrayList。因为当类型擦除后，ArrayList的原始类型变为Object，但是Object类型不能存储double值，只能引用Double的值。\n3.使用泛型不能在运行时进行类型匹配查询\n例如：若定义ArrayList&lt;String&gt; arrayList=new ArrayList&lt;String&gt;();则不能使用if( arrayList instanceof ArrayList&lt;String&gt;)，此时运行时会报错。因为类型擦除之后，ArrayList只剩下原始类型，泛型信息String不存在了。\n4.不能抛出也不能捕获泛型类的对象\n例如下面的定义将不会通过编译：\n1public class Problem&lt;T&gt; extends Exception&#123;......&#125; \n假如上述代码成立，则：\n123456try&#123;  &#125;catch(Problem&lt;Integer&gt; e1)&#123;  。。  &#125;catch(Problem&lt;Number&gt; e2)&#123;  ...  &#125;   \n根据类型擦除性质，泛型类型擦除后两个catch都变为原始类型Object类型，也就是说两个catch一模一样，这不符合常规，当然不能通过。\n不能在catch条件中使用泛型变量：\n12345678public static &lt;T extends Throwable&gt; void doWork(Class&lt;T&gt; t)&#123;      try&#123;          ...      &#125;catch(T e)&#123; //编译错误          ...      &#125;catch(IndexOutOfBounds e)&#123;      &#125;                           &#125;  \n根据异常捕获的原则，一定是子类在前面，父类在后面，那么上面就违背了这个原则。所以java为了避免这样的情况，禁止在catch子句中使用泛型变量。\n5.泛型类型不能直接实例化\n不能实例化泛型类型:\n1T first = new T(); //ERROR\n类型擦除会使这个操作做成new Object()。\n不能实例化数组\n1234public&lt;T&gt; T[] minMax(T[] a)&#123;      T[] mm = new T[2]; //ERROR      ...  &#125;  \n擦除会使这个方法总是构靠一个Object[2]数组\n6.条件不能与擦除后的原型类产生冲突\n12345class Pair&lt;T&gt;   &#123;      public boolean equals(T value) &#123;          return null;      &#125;  &#125;  \n考虑一个Pair。从概念上，它有两个equals方法：\nbooleanequals(String); //在Pair中定义\nboolean equals(Object); //从object中继承\n擦除后方法变成了：\nboolean equals(Object)\n这与Object.equals方法发生了冲突，补救的办法就是重新命名引发错误的方法。\n7.泛型在静态方法和静态类中的问题\n泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数。\n例如：\n123456public class Test2&lt;T&gt; &#123;        public static T one;   //编译错误        public static  T show(T one)&#123; //编译错误            return null;        &#125;    &#125;    \n因为泛型类中的泛型参数的实例化是在定义对象的时候指定的，而静态变量和静态方法不需要使用对象来调用。对象都没有创建，如何确定这个泛型参数是何种类型，所以当然是错误的。\n静态泛型方法是可以使用泛型参数的：\n12345public class Test2&lt;T&gt; &#123;        public static &lt;T &gt;T show(T one)&#123;//这是正确的            return null;        &#125;    &#125;    \n因为这是一个泛型方法，在泛型方法中使用的T是自己在方法中定义的T，而不是泛型类中的T。\n参考\n\n《Java编程思想》\nhttps://blog.csdn.net/lonelyroamer/article/details/7868820\n\n","plink":"https://blog.ixin.run/posts/1521043691/"},{"title":"Service的生命周期和启动方式等相关总结","date":"2018-02-26T16:02:55.000Z","date_formatted":{"ll":"2018年2月27日","L":"2018/02/27","MM-DD":"02-27"},"updated":"2021-01-29T12:51:44.647Z","content":"Service是安卓开发四大组件中和Activity最相似的组件，与Activity不同的是，Service是没有界面的,一直在后台运行。四大组件都有自己的生命周期，service也不例外，并且service的生命周期最长。\n\n生命周期\nService生命周期中主要包含以下几个方法：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class MyService extends Service &#123;    /**     * 该方法是Service子类必须实现的方法，该方法可返回一个IBinder对象，可用于其他组件与service组件相互通信     * @param intent     * @return     */    @Nullable    @Override    public IBinder onBind(Intent intent) &#123;        return null;    &#125;    /**     * service重新绑定时并且在onUnbind方法返回true的情况下能够执行回调此方法     * @param intent     */    @Override    public void onRebind(Intent intent) &#123;        super.onRebind(intent);    &#125;    /**     * service第一次创建后立即创建回调的方法     */    @Override    public void onCreate() &#123;        super.onCreate();    &#125;    /**     * 其他组件每次调用startService(intent),此方法便会执行一次，用于其他组件向service传值，返回值的设置又能控制自身的重启情况。早期版本是onStart(),现已经过时     * @param intent     * @param flags     * @param startId     * @return     */    @Override    public int onStartCommand(Intent intent, int flags, int startId) &#123;        return super.onStartCommand(intent, flags, startId);    &#125;    /**     * Service关闭之前将会调用该方法     */    @Override    public void onDestroy() &#123;        super.onDestroy();    &#125;    /**     * service解除绑定断开连接时调用该方法。     * @param intent     * @return     */    @Override    public boolean onUnbind(Intent intent) &#123;        return super.onUnbind(intent);    &#125;&#125;\n启动方式\n在Android系统中针对service操作有两种方式：\n\n通过Context的startService()和stopService()，这种方式访问者与service之间没有关联，因此Service和访问者之间无法进行通讯和访问数据，另外即使访问者退出了，service也仍然运行。\n通过Context的bindService()和unbindService(),这种方式访问者与service绑定在一起，能够进行之间的通讯和数据访问，访问者一旦退出，service也终止了。\n\nservice的两种启动方式图：\n\n通过Context的startService()和stopService()\n首先在AndroidManifast注册此服务，这里和Activity注册很相似，也可以设置过滤器，其中android:priority=&quot;1000&quot;表示该服务的优先级设成最大。因为service没有界面所以我们就没必要设置lable,icon等标签了。\n12345&lt;service android:name=&quot;.MyService&quot;&gt;    &lt;intent-filter android:priority=&quot;1000&quot;&gt;        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;    &lt;/intent-filter&gt;&lt;/service&gt;\n开启服务：\n12Intent intent = new Intent(MainActivity.this,MyService.class);startService(intent);\n生命周期走向：onCreat --&gt; onStartCommand\n再次点击开启按钮生命周期走向：onStartCommand\n停止服务：\n12Intent intent = new Intent(MainActivity.this,MyService.class);stopService(intent);\n生命周期走向：onDestroy\n再次点击停止按钮生命周期走向：无\n通过Context的bindService()和unbindService()\n绑定服务调用bindService(Intent intent,ServiceConnection conn,int flags)。第一个参数：要启动的service。第二个参数：该参数是一个ServiceConnection对象，用于监听访问者和service的链接情况。第三个参数：指定绑定时是否自动创建service,一般指定Service.BIND_AUTO_CREATE(service自动创建启动)，不想自动创建可设为0(service此时并没有启动，但是当service启动时也同时绑定了)。\n既然访问者要与service进行通信，总要有一个中间桥梁来来沟通访问者和service。这个中间桥梁就是service中onBind()方法返回的IBinder对象（默认是返回null）。\n12345678910111213private boolean isBind; //判断是否绑定private MyBinder myBinder = new MyBinder();public class MyBinder extends Binder&#123;    public boolean isBind()&#123;        return isBind;    &#125;&#125;  @Overridepublic IBinder onBind(Intent intent) &#123;    Log.e(&quot;TAG&quot;,&quot;+++++++++++++++++++++++++++++onBind&quot;);    isBind = true;    return myBinder;&#125;\n访问者类中建立ServiceConnection对象，内部有两个方法：onServiceConnected()回调表示成功绑定，此时我们可以拿到service中的IBinder对象，进而也就能取到service中我们想要的数据。onServiceDisconnected回调表示断开绑定，注意这里的断开是由于异常终止或其他原因终止，也就是说访问者主动断开是不会回调的（一般情况下都不会回调此方法）。\n1234567891011121314private MyService.MyBinder iBinder;//建立访问者与service的连接private ServiceConnection conn = new ServiceConnection() &#123;    @Override    public void onServiceConnected(ComponentName name, IBinder service) &#123;        Log.e(&quot;TAG&quot;, &quot;+++++++++++++++++++++++++onServiceConnected&quot;);        iBinder = (MyService.MyBinder) service;    &#125;    @Override    public void onServiceDisconnected(ComponentName name) &#123;        Log.e(&quot;TAG&quot;, &quot;+++++++++++++++++++++++++onServiceDisconnected&quot;);    &#125;&#125;;\n以下两个生命周期指示仅仅是绑定和取消绑定并且绑定时自动创建服务的情况。\n绑定服务：\n12Intent intent = new Intent(MainActivity.this, MyService.class);bindService(intent, conn, Service.BIND_AUTO_CREATE);\n生命周期走向：onCreat --&gt; onBind --&gt;&gt;onServiceConnected\n多次绑定无效只能绑定一次。\n取消绑定：\n123if (iBinder!=null &amp;&amp; iBinder.isBind())&#123;    unbindService(conn);&#125;\n生命周期走向：onUnbind --&gt; onDestroy\n多次取消一定要注意取消过绑定了就不能再次取消绑定了，否则报异常错误。另外需注意如果访问者退出了也一定要取消绑定，例如在Activity中的onDestroy中取消绑定，否则会出现内存泄漏。\n组合操作\na.绑定服务时自动创建启动服务（即第三个参数设置成Service.BIND_AUTO_CREATE）\n1.操作：启动服务–&gt;绑定服务–&gt;解除绑定–&gt;停止服务\n生命周期走向：onCreat–&gt;onStartCommand–&gt;onBind–&gt;&gt;onServiceConnected–&gt;onUnbind–&gt;onDestroy\n2.操作：绑定服务–&gt;停止服务\n生命周期走向：onCreat–&gt;onBind–&gt;&gt;onServiceConnected\n3.操作：启动服务–&gt;绑定服务–&gt;停止服务\n生命周期走向：onCreat–&gt;onStartCommand–&gt;onBind–&gt;&gt;onServiceConnected\n4.操作：绑定服务–&gt;启动服务–&gt;解除绑定\n生命周期走向：onCreat–&gt;onBind–&gt;&gt;onServiceConnected–&gt;onStartCommand–&gt;onUnbind\n综上四种操作得出一个结论：无论是启动（停止）服务还是绑定（取消绑定）都要成双成对才能形成一个完善的生命周期。\nb.绑定服务时 不自动创建启动服务（即第三个参数设置成0）\n5.操作：绑定服务\n生命周期走向：无\n6.操作：绑定服务–&gt;启动服务\n生命周期走向：onCreate–&gt;onBind–&gt;onStartCommand–&gt;&gt;onServiceConnected\n综上两种操作得出一个结论：如果绑定服务时不自动创建启动服务而随后再启动服务，此时再启动的同时也绑定了服务。\nc.生命周期中的onUnbind方法返回值的设置。\n7.操作：启动服务–&gt;绑定服务–&gt;解除绑定–&gt;绑定服务–&gt;解除绑定–&gt;停止服务\n返回值默认时，生命周期走向：onCreate–&gt;onStartCommand–&gt;onBind–&gt;&gt;onServiceConnected–&gt;onUnbind–&gt;&gt;onServiceConnected–&gt;onDestroy\n第二次绑定服务时没有调用onBind方法，仅仅调用onServiceConnected,说明也绑定成功了，只是看着有点模糊。第二次解除绑定的时候没有调用onUnbind，当时停止服务时调用onDestroy，说明也取消绑定成功了，不过看着更加模糊。\n返回值为true时，生命周期走向：onCreate–&gt;onStartCommand–&gt;onBind–&gt;&gt;onServiceConnected–&gt;onRebind–&gt;onUnbind–&gt;&gt;onServiceConnected–&gt;onUnbind–&gt;onDestroy\n第二次绑定服务时还是没有调用onBind方法，当时调用onRebind方法，并且取消绑定的时候也调用了onUnbind方法。\n综上对于多次绑定、取消绑定操作。只有在第一次绑定的时候才会调用onBind方法，但是每次都会在访问者连接回调onServiceConnected方法。绑定时生命周期中的onUnbind返回默认，在多次绑定、取消绑定操作的取消绑定的时候是不会调用onUnbind方法的，只有绑定时生命周期中的onUnbind返回true才会调用onUnbind方法，同时绑定过程也会调用onRebind方法。\n\n生命周期中的onStartComand返回值设置\nonStartComand使用时，返回的是一个(int)整形。这个整形可以有四个返回值：start_sticky、start_no_sticky、START_REDELIVER_INTENT、START_STICKY_COMPATIBILITY。\n它们的含义分别是：\n\nSTART_STICKY\n如果service进程被kill掉，保留service的状态为开始状态，但不保留递送的intent对象。随后系统会尝试重新创建service，由于服务状态为开始状态，所以创建服务后一定会调用onStartCommand(Intent,int,int)方法。如果在此期间没有任何启动命令被传递到service，那么参数Intent将为null。\nSTART_NOT_STICKY\n“非粘性的”。使用这个返回值时，如果在执行完onStartCommand后，服务被异常kill掉，系统不会自动重启该服务。\nSTART_REDELIVER_INTENT\n重传Intent。使用这个返回值时，如果在执行完onStartCommand后，服务被异常kill掉，系统会自动重启该服务，并将Intent的值传入。\nSTART_STICKY_COMPATIBILITY\nSTART_STICKY的兼容版本，但不保证服务被kill后一定能重启。\n\n通常情况我们会选择返回一个START_REDELIVER_INTENT，保证service的稳定和数据的完整。\nonStartComand参数flags含义 ：flags表示启动服务的方式。\nAdditional data about this start request. Currently either 0, START_FLAG_REDELIVERY, or START_FLAG_RETRY.\n\nSTART_FLAG_REDELIVERY\n如果你实现onStartCommand()来安排异步工作或者在另一个线程中工作, 那么你可能需要使用START_FLAG_REDELIVERY来让系统重新发送一个intent。这样如果你的服务在处理它的时候被Kill掉, Intent不会丢失.\nSTART_FLAG_RETRY\n表示服务之前被设为START_STICKY，则会被传入这个标记。\n\nIntentService的使用\nIntentService作为service的子类，继承IntentService，却不是一个普通service，它也有service的生命周期，却比一般的service多了一些特殊的功能。我们知道service和Activity很类似，它也有一个主线程，它的主线程同样也不能进行耗时操作，否则会报ANR错误。平时我们用service下载东西或者超时操作都是新建一个子线程。IntentService解决了这个不足，新建IntentService必须要有一个无参的构造方法和onHandleIntent()方法。无参的构造方法要传入一个字符串来命名工作线程（官方指出为了调试用），onHandleIntent()就是来处理耗时操作的。IntentService具有如下特征：\n\nIntentService会创建单独的worker线程来处理Intent请求。IntentService会使用队列来管理所有请求的Intent,每当访问者通过Intent请求启动IntentService，Intentservice会将该Intent加入队列中。然后开启一条新的work线程来处理该Intent。保证同一时刻只处理一个intent请求。\nIntentService会创建单独的worker线程来处理onHandlerIntent()方法实现的代码，开发者无需处理多线程问题。\n当所有请求处理完成后。IntentService就会停止，开发者无需调用stopService()或者stopSelf()来停止IntentService。\n\n12345678910111213141516171819202122232425262728293031public class MyIntentService extends IntentService &#123;    @Override    public void onCreate() &#123;        super.onCreate();        Log.e(&quot;TAG&quot;,&quot;++++++++++++++IntentService+++++++++++++++onCreate&quot;);    &#125;    @Override    public int onStartCommand(Intent intent, int flags, int startId) &#123;        Log.e(&quot;TAG&quot;,&quot;++++++++++++++IntentService+++++++++++++++onStartCommand&quot;);        return super.onStartCommand(intent, flags, startId);    &#125;    /**     *至少要有一个无参构造器，里面的字符串随便命名，只是为了命名工作线程，并且也只是为了调试。     */    public MyIntentService() &#123;        super(&quot;MyIntentService&quot;);    &#125;    @Override    protected void onHandleIntent(Intent intent) &#123;        Log.e(&quot;TAG&quot;,&quot;++++++++++++++IntentService+++++++++++++++onHandleIntent&quot;);    &#125;    @Override    public void onDestroy() &#123;        super.onDestroy();        Log.e(&quot;TAG&quot;,&quot;++++++++++++++IntentService+++++++++++++++onDestroy&quot;);    &#125;&#125;\n启动IntentService和启动一般的service一样：\n12Intent intent = new Intent(MainActivity.this, MyIntentService.class);startService(intent);\n启动一次生命周期走向：onCreat–&gt;onStartCommand–&gt;onHandleIntent–&gt;onDestroy\n如果耗时操作还未完成（此时IntentService还未关闭），多次启动IntentService生命周期走向：onCreat–&gt;onStartCommand–&gt;onHandleIntent–&gt;onStartCommand–&gt;onDestroy\n综上多次启动IntentService每次都调用onStartCommand,但是onHandleIntent只调用一次。通常我们用IntentService做一些耗时的操作，比如下载，可以用Messenger来进行访问者和IntentService之间的通信。\n访问者创建一个Handler来获取IntentService中动作信息:\n12345678910111213141516//接收IntentService中传来的消息    private Handler handler = new Handler() &#123;        public void handleMessage(Message msg) &#123;            switch (msg.what)&#123;                case MyIntentService.HANDLERINTENT_START:                    Toast.makeText(MainActivity.this,&quot;IntentService调用onHandleIntent()方法开始进行计算&quot;,Toast.LENGTH_LONG).show();                    break;                case MyIntentService.HANDLERINTENT_OPERA:                    intentservice_result_tv.setText(msg.arg1+&quot;&quot;);                    break;                case MyIntentService.HANDLERINTENT_FINISH:                    Toast.makeText(MainActivity.this,&quot;IntentService调用onHandleIntent()方法计算过程结束&quot;,Toast.LENGTH_LONG).show();                    break;            &#125;        &#125;    &#125;;\n访问者向IntentService传递Messenger对象：\n123Intent intent = new Intent(MainActivity.this, MyIntentService.class);intent.putExtra(MyIntentService.EXTRA_MESSAGER, new Messenger(handler));startService(intent);\nIntentService中接受到访问者的Messenger对象并进行通信：\n123456789101112131415161718192021222324252627282930313233343536@Override    protected void onHandleIntent(Intent intent) &#123;        Log.e(&quot;TAG&quot;,&quot;++++++++++++++IntentService+++++++++++++++onHandleIntent&quot;);        Bundle extras = intent.getExtras();        Messenger messenger = null;        if(extras != null)&#123;            messenger = (Messenger)extras.get(EXTRA_MESSAGER);        &#125;        //通知计算开始        if (messenger!=null)&#123;            sendMessage(messenger,HANDLERINTENT_START,-1);        &#125;        //通知计算进行中        for (int i=Integer.MIN_VALUE;i&lt;Integer.MAX_VALUE;i++)&#123;            if (i%100000000==0)&#123;                if (messenger!=null)&#123;                    sendMessage(messenger,HANDLERINTENT_OPERA,i);                &#125;            &#125;        &#125;        //通知计算结束        if (messenger!=null)&#123;            sendMessage(messenger,HANDLERINTENT_FINISH,-1);        &#125;    &#125;    public void sendMessage(Messenger mesenger,int what,int result)&#123;        Message msg = Message.obtain( );        msg.what = what;        msg.arg1 = result;        try &#123;            mesenger.send(msg);        &#125; catch (RemoteException e) &#123;            e.printStackTrace();        &#125;    &#125;\n以上就是我对Android四大组件之一Service进行了一个完整总结，这些都是基础部分，基础把握好是一个关键。\n","plink":"https://blog.ixin.run/posts/1519660975/"},{"title":"Activity的生命周期和启动模式","date":"2018-02-26T14:27:49.000Z","date_formatted":{"ll":"2018年2月26日","L":"2018/02/26","MM-DD":"02-26"},"updated":"2021-01-29T12:51:44.611Z","content":"Activity的生命周期和启动模式属于面试必考内容，有些时候可能随着工作经历的增长面试官不会去问这些，但是在面试的过程中或多或少都会牵涉一点，因为这是基础，虽然简单，还是总结一下，以后看着也舒服。\n\nActivity的生命周期图\nActivity的生命周期主要方法分为7个，这里就看图吧，一目了然。\n\nActivity的生命周期走向\n这里假设有两个界面，第一页为A，第二页为B，虽然onSaveInstanceState不被看作Activity生命周期的主要方法，这里也着重提出他的执行地方，因为关系着有些时候Activity重绘时数据恢复的功能。整个执行过程按照下边的步骤执行观察生命周期走向：\n\n刚进第一页\nonCreat -&gt; onStart -&gt; onResume\n按Home键退到后台\nonPause -&gt; onSaveInstanceState -&gt; onStop\n重新回到第一页\nonRestart -&gt; onStart -&gt; onResume\n按电源键关闭屏幕\n和2一样\n按电源键点亮屏幕\n和3一样\n跳转到第二页\nonPause(A) -&gt; onCreat(B) -&gt; onStart(B) -&gt;onResume(B) -&gt; onSaveInstanceState(A) -&gt; onStop(A)\n返回到第一页\nonPause(B) -&gt; onRestart(A) -&gt; onStart(A) -&gt; onResume(A) -&gt; onStop(B) -&gt; onDestroy(B)\n第一页退出\nonPause(A) -&gt; onStop(A) -&gt; onDestory(A)\n\nActivity的可见过程\nActivity的初始过程包括onCreat、onStart、onResume三部分，各个部分有他们自己的使用场景：\n\nonCreat:主要用于view的实例过程，包括布局填充和绘制。\nonStart:界面已经布置完毕，甚至可以说处于“可见”状态，但是此时的Activity是没有灵魂的，没有焦点的，不可操作的。\nonResume:见名知意，就是在onStart僵死的过程后赋予界面焦点，让界面可以进行交互，从此之后Activity便处于活跃状态，这里有一个“从此之后”。\n\n因此，因此界面真正可见是在onWindowFocusChanged()方法执行的时候，面试的时候这个过程容易和面试官产生分歧，静下心慢慢和面试官讲清楚，此关即可通过。\nActivity的启动模式\nActivity的启动方式主要分为四种：\n\nstandard\nsingleTop\nsingleTask\nsingleInstance\n\nstanderd\n既是所谓的标准模式，类似叠罗汉，采用先进后出的实现形式。所有实例都在一个栈中，实例与实例之间都是有先后顺序。例如A&gt;B,若是B销毁必然呈现A.\nsingleTop\n可以理解为栈顶单一模式，既是多个相同的实例在栈顶只能存在一个，不在栈顶的时候无所谓。假如B的启动模式是singTop,例如A&gt;B&gt;B实际是A&gt;B。A&gt;B&gt;C&gt;B&gt;B实际是A&gt;B&gt;C&gt;B。这种形式栈顶的B不再走onCreat重新启动,因为实例之前已经有了，没必要整个重绘界面，但是总归要有一个接口来告诉我有一个同胞同卵兄弟（穿的衣服可能不一样）来顶替我，那这时候我只需要把他的衣服拿过来换上就可以了。挑明:不走onCreat,走onNewIntent。\nsingleTask\n可以理解为栈内单一模式，既是多个相同的实例在栈内只能存在一个，假如B的启动模式是singleTask,例如A&gt;B&gt;C&gt;B实际是A&gt;B,特殊说明这种形式第二个B上边的所有实例都会被销毁，并且也是不再走onCreat,而走onNewIntent。\nsingleInstance\n可以理解为栈内唯一模式，既是一个栈中有且只能有一个实例。比较特殊。假如B的启动模式为singleInstance,例如A&gt;B,那么将开启一个新栈专门存B,A和B不会在同一个栈里.\n启动模式在AndroidManifest文件中注册Activity的时候设置：\n1&lt;activity android:name=&quot;.ui.MainActivity&quot; android:launchMode=&quot;singleTask&quot; android:screenOrientation=&quot;portrait&quot;/&gt;\n这种方式针对全局都有效。但是有些时候又有一定的局限性，假如我们想某个页面在特定的时候或者特定的按钮下启动才会有特定的启动模式，怎么办？这个时候就需要传输跳转时结合intent的各种flag了。\nIntent中的各种FLAG\n\n\nFLAG_ACTIVITY_BROUGHT_TO_FRONT\n如果通过该Flag启动的Activity已经存在，下次再次启动，将只是把该Activity带到前台。假如A启动B时设置该标签，B又启动C,C又启动B（正常启动）,最终栈内的实例是A,C,B.\n\n\nFLAG_ACTIVITY_CLEAR_TOP\n相当于启动模式的singleTask。假设启动B时设置此标记，例如栈中现在是A,B,C,D那么再次启动B后的结果是A,B.\n\n\nFLAG_ACTIVITY_NEW_TASK\n启动一个新的栈来存储启动这个activity。\n\n\nFLAG_ACTIVITY_NO_ANIMATION\n启动Activity时不使用过渡动画\n\n\nFLAG_ACTIVITY_NO_HISTORY\n被启动的Activity将不会记录在栈的历史中，假设启动D设置了此标记，例如之前栈中有A,B,C，现在C启动D，然后在由D启动E，那么此时栈中存在的实例有A,B,C,E.\n\n\nFLAG_ACTIVITY_REORDER_TO_FRONT\n假如当前栈中已经存在所启动的Activity, 例如当前栈内有A,B,C.此时由 C通过该标记启动B,那么最终栈内的顺序是A,C,B.\n\n\nFLAG_ACTIVITY_SINGLE_TOP\n相当于启动模式的singleTop。假设启动B时设置此标记，例如栈中现在是A,B，那么再次启动B后的结果还是A,B.，假如栈中现在是A,B,C,启动B,则是A,B,C,B.\n\n\n至于其他FLAG并不常用，真正用到时查看intent的Flag的Api，可参考：http://blog.csdn.net/javensun/article/details/8700265\n启动之前存在的页面：\n1234Intent intent = new Intent(this,OrderDetialActivity.class);intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP|Intent.FLAG_ACTIVITY_CLEAR_TOP);intent.putExtra(Constants.INTENT_SETRESULT,true);startActivity(intent);\n退出当前账户重新登录：\n123Intent intent = new Intent(context, LoginActivity.class);intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK);startActivity(intent);","plink":"https://blog.ixin.run/posts/1519655269/"},{"title":"View创建的那些事儿","date":"2018-01-29T04:24:17.000Z","date_formatted":{"ll":"2018年1月29日","L":"2018/01/29","MM-DD":"01-29"},"updated":"2021-01-29T12:51:44.649Z","content":"本来是想总结view的绘制测量过程，但是一开始就来个measure、layout、draw总感觉让人有点丈二的和尚摸不着头脑。什么时候添加的这个view？谁控制添加的？它为什么能控制添加？这个view现在在哪呢？等等一系列问题都出来了。\n\n理解几个概念\n在学习研究View创建过程先明白几个概念，帮助后边理清思路，这些包括Activity、ActivityThread、Window、PhoneWindow、WindowManagerService、WindowManager、ViewRootImpl、surface、DecorView。这些都是与view有关的，大部分都是framework层，这里简单介绍一下各自的作用，为后边view的创建及绘制渲染做准备。\n\nActivity：这个都认识，四大组件之一主要用于与用户进行交互处理，每个 Activity 都会获得一个用于绘制其用户界面的窗口,来呈现各种各样的布局。\nActivityThread：主线程或UI线程，主要的作用是根据AMS(ActivityManagerService)负责调度和执行activities、broadcasts和其它操作。\nWindow：往虚的说是视图窗口，往实的说是一个抽象类。它提供了一套标准的UI方法，比如添加背景，标题等等。Window 有三种类型，分别是应用 Window、子 Window 和系统 Window。应用类 Window 对应一个 Acitivity，子 Window 不能单独存在，需要依附在特定的父 Window 中，比如常见的一些 Dialog 就是一个子 Window。\nPhoneWindow：Window的实现类，可以通过实现具体抽象方法去绘制窗口。DecorView作为该类的成员变量，可以在此类中获取DecorView的实例。\nDecorView：FramLayout的子类，作为窗口中最顶层的view，起到一个基础框架作用。内部包含对view的measure、layout、draw、onAttachedToWindow、以及触摸事件处理等等所有与view绘制相关的功能。\nViewRootImpl：作为WindowManager和DecorView之间的纽带，主要作用是协助WindowManager将DecorView添加到Window中，并获取顶层视图的MeasureSpec，然后对ViewGroup和子View进行迭代测量绘制，最终将View展现出来。\nWindowManager：是一个接口，主要用来管理窗口的一些状态、属性、view增加、删除、更新、窗口顺序、消息收集和处理等，继承自接口ViewManager(内含有三个方法addView、updateViewLayout、removeView)，由WindowManagerImpl来进行实现。\nWindowManagerGlobal：WindowManagerImpl内部成员变量，是一个WindowManager全局工具类，WindowManager中View的增加、删除、更新以及WindowManagerService实例的获取等最终处理都是在此工具类中处理的。\nWindowManagerService：位于 Framework 层的窗口管理服务，它的职责就是管理系统中的所有窗口的排布和次序。\nSurface：源码给出的解释Handle onto a raw buffer that is being managed by the screen compositor，Surface中的Canvas成员是专门用于供程序员画图的场所，就像黑板一样；其中的原始缓冲区是用来保存数据的地方；Surface本身的作用类似一个句柄，得到了这个句柄就可以得到其中的Canvas、原始缓冲区以及其它方面的内容，每一个window都对应一个surface，作为窗口的“底板”，窗口上各种绘制排版都是在此底板上展现的。由WindowManagerService进行分配。\n\n屏幕显示过程\n上边提到了Surface扮演着在一块窗口上管理绘图数据的角色。WindowManagerService职责就是管理系统中的所有窗口，每添加一个窗口的过程，其实就是 WindowManagerService 为其分配一块 Surface 的过程，一块块的 Surface 在 WindowManagerService 的管理下有序的排列在屏幕上，Android 才得以呈现出多姿多彩的界面。\n\nUI界面层级结构\nActivity作为四大组件之首承载着view的展示和处理的角色。无论是触发桌面Launcher还是startActivity最终的启动过程都是由ActivityThread来负责支配的。界面启动后，Activity作为一个载体承载window，然后各种视图依次展现。\n上边提到数据缓存区创建因而也就能得到一个window的显示区域，在window内部中又有各种各样的view来呈现多姿多彩的内容，DecorView便是这颗ViewTree的根节点，DecorView包含两部分，TitleView和ContentView，TitleView受主题的限制有时我们不需要显示他，我们自己定义的主要内容显示在ContentView中。\nUI界面架构图:\n\nViewTree结构图:\n\nContentView中展示的View有两种形式，View和ViewGroup，其实最终都归为View，下边是一副view的拓展图，可以帮助更好的理解各种view的来源。\n\n从setContentView说起\n这是一个老生常谈的问题，这里都认识更容起步，setContentView这一部分是将布局文件加载到DecorView中，不涉及DecorView如何填充到Window中（后续再说这一部分）。\n当我们自定义Activity继承自android.app.Activity时候，调用的setContentView()方法是Activity类的，源码如下：\n1234public void setContentView(@LayoutRes int layoutResID) &#123;    getWindow().setContentView(layoutResID);    initWindowDecorActionBar();&#125;\n这里的getWindow()就是PhoneWindow，走的就是PhoneWindow的setContentView()方法。而PhoneWindow是在Activity的attach()方法中进行实例化的：\n12345678910111213141516171819202122232425262728final void attach(Context context,...) &#123;    //绑定上下文    attachBaseContext(context);           mFragments.attachHost(null /*parent*/);    //创建Window的实现类PhoneWindow    mWindow = new PhoneWindow(this, window);    mWindow.setWindowControllerCallback(this);    //绑定回调监听，一旦window有相关动作回调给Activtiy    mWindow.setCallback(this);    mWindow.setOnWindowDismissedCallback(this);      ......       //设置WindowManager    mWindow.setWindowManager(            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),            mToken, mComponent.flattenToString(),            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);    if (mParent != null) &#123;        mWindow.setContainer(mParent.getWindow());    &#125;    //通过getWindowManager获取WindowManager实例WindowManagerImpl    mWindowManager = mWindow.getWindowManager();    mCurrentConfig = config;&#125;\n01#PhoneWindow#setContentView()\n先看一个PhoneWindow的setContentView()源码：\n1234567891011121314151617181920212223242526272829@Overridepublic void setContentView(int layoutResID) &#123;    // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window    // decor, when theme attributes and the like are crystalized. Do not check the feature    // before this happens.    if (mContentParent == null) &#123;        //如果父容器空，初始化父容器        installDecor();         &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;        //如果父容器不为空，移除所有子View        mContentParent.removeAllViews();        &#125;    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;        final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,                getContext());        transitionTo(newScene);    &#125; else &#123;        //一般情况下我们不需要过度动画特性，走这一步进行布局资源文件加载        mLayoutInflater.inflate(layoutResID, mContentParent);        &#125;    mContentParent.requestApplyInsets();    final Callback cb = getCallback();    if (cb != null &amp;&amp; !isDestroyed()) &#123;        //回调方法通知Activity窗口内容发生了改变        cb.onContentChanged();        &#125;    mContentParentExplicitlySet = true;&#125;\nsetContentView最重要的两件事：第一初始化父容器；第二加载布局文件。接着看一下installDecor()方法内部怎么实现的：\n12345678910111213141516171819private void installDecor() &#123;    mForceDecorInstall = false;    if (mDecor == null) &#123;        //1.实例化DecorView        mDecor = generateDecor(-1);        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);        mDecor.setIsRootNamespace(true);        if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) &#123;            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);        &#125;    &#125; else &#123;        mDecor.setWindow(this);    &#125;    if (mContentParent == null) &#123;        //2.生成父容器        mContentParent = generateLayout(mDecor);        ......    &#125;&#125;\n在初始installdecor()方法中同样做了重要的两件事：第一实例化DecorView；第二生成父容器。实例DecoView很简单，源码就是new出来一个，哈哈。关键第二步生成父容器涉及了针对DecorView主题以及TitleView的标题、标题Icon等设定做好多工作。这里可以粗略的看几个重点：\n1234567891011121314151617181920212223242526272829protected ViewGroup generateLayout(DecorView decor) &#123;    // Apply data from current theme.    //获取系统Window主题资源    TypedArray a = getWindowStyle();        ......    //根据主题资源设定父窗口样式    mIsFloating = a.getBoolean(R.styleable.Window_windowIsFloating, false);    int flagsToUpdate = (FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR)            &amp; (~getForcedWindowFlags());    if (mIsFloating) &#123;        setLayout(WRAP_CONTENT, WRAP_CONTENT);        setFlags(0, flagsToUpdate);    &#125; else &#123;        setFlags(FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR, flagsToUpdate);    &#125;    .......        //设置系统状态栏    if (a.getBoolean(R.styleable.Window_windowLightStatusBar, false)) &#123;        decor.setSystemUiVisibility(                decor.getSystemUiVisibility() | View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR);    &#125;        ......    return contentParent;&#125;\n至此，PhoneWindow中setContentView()的初始化父容器过程完毕，接下来分析布局资源文件加载过程。\n02#PhoneWindow#mLayoutInflater.inflate()\nPhoneWindow的setContentView()方法中调用了LayoutInflater的inflate()方法来填充布局，这个方法的源码如下：\n1234567891011121314151617181920public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) &#123;    return inflate(resource, root, root != null);&#125;public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123;    final Resources res = getContext().getResources();    if (DEBUG) &#123;        Log.d(TAG, &quot;INFLATING from resource: \\&quot;&quot; + res.getResourceName(resource) + &quot;\\&quot; (&quot;                + Integer.toHexString(resource) + &quot;)&quot;);    &#125;        //获取Xml解析对象    final XmlResourceParser parser = res.getLayout(resource);    try &#123;        //进一步加载布局资源        return inflate(parser, root, attachToRoot);    &#125; finally &#123;        parser.close();    &#125;&#125;    \n这个方法的主要作用就是为了拿到XmlResourceParser实例对象进行接下来的xml解析，平时我们动态加载自定义view最终也是走的这个方法，接下来看xml解析做的工作：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123;    synchronized (mConstructorArgs) &#123;        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;);        final Context inflaterContext = mContext;        final AttributeSet attrs = Xml.asAttributeSet(parser);        Context lastContext = (Context) mConstructorArgs[0];        mConstructorArgs[0] = inflaterContext;        View result = root;        try &#123;            // Look for the root node.            int type;            while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;                    type != XmlPullParser.END_DOCUMENT) &#123;                // Empty            &#125;                        //如果根节点不是起始结点抛出没有起始标识异常            if (type != XmlPullParser.START_TAG) &#123;                throw new InflateException(parser.getPositionDescription()                        + &quot;: No start tag found!&quot;);            &#125;            //获取结点标签名字            final String name = parser.getName();            if (DEBUG) &#123;                System.out.println(&quot;**************************&quot;);                System.out.println(&quot;Creating root view: &quot;                        + name);                System.out.println(&quot;**************************&quot;);            &#125;                                    //优先处理&lt;morge/&gt;标签            if (TAG_MERGE.equals(name)) &#123;                if (root == null || !attachToRoot) &#123;                    throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;                            + &quot;ViewGroup root and attachToRoot=true&quot;);                &#125;                //解析&lt;morge/&gt;标签下的view并将最终添加到root父容器中                rInflate(parser, root, inflaterContext, attrs, false);            &#125; else &#123;                // Temp is the root view that was found in the xml                //根据根节点标签创建父容器View对象                final View temp = createViewFromTag(root, name, inflaterContext, attrs);                ViewGroup.LayoutParams params = null;                if (root != null) &#123;                    if (DEBUG) &#123;                        System.out.println(&quot;Creating params from root: &quot; +                                root);                    &#125;                    // Create layout params that match root, if supplied                    //获取父容器的layout params                    params = root.generateLayoutParams(attrs);                    if (!attachToRoot) &#123;                        // Set the layout params for temp if we are not                        // attaching. (If we are, we use addView, below)                        //如果attachToRoot为false，调用view的setLayoutParams方法，便于后边的直接返回。                        temp.setLayoutParams(params);                    &#125;                &#125;                if (DEBUG) &#123;                    System.out.println(&quot;-----&gt; start inflating children&quot;);                &#125;                // Inflate all children under temp against its context.                //根据rootView解析所有孩子的布局文件，并将解析的View依次递归合并到temp中                rInflateChildren(parser, temp, attrs, true);                if (DEBUG) &#123;                    System.out.println(&quot;-----&gt; done inflating children&quot;);                &#125;                // We are supposed to attach all the views we found (int temp)                // to root. Do that now.                if (root != null &amp;&amp; attachToRoot) &#123;                    //将最终合并完成的子View（即大儿子temp）添加到root父容器中                    root.addView(temp, params);                &#125;                // Decide whether to return the root that was passed in or the                // top view found in xml.                //如果父容器为空或者attachToRoot为false直接将所有子view合并后的大儿子temp返回                if (root == null || !attachToRoot) &#123;                    result = temp;                &#125;            &#125;        &#125; catch (XmlPullParserException e) &#123;            final InflateException ie = new InflateException(e.getMessage(), e);            ie.setStackTrace(EMPTY_STACK_TRACE);            throw ie;        &#125; catch (Exception e) &#123;            final InflateException ie = new InflateException(parser.getPositionDescription()                    + &quot;: &quot; + e.getMessage(), e);            ie.setStackTrace(EMPTY_STACK_TRACE);            throw ie;        &#125; finally &#123;            // Don&#x27;t retain static reference on context.            mConstructorArgs[0] = lastContext;            mConstructorArgs[1] = null;            Trace.traceEnd(Trace.TRACE_TAG_VIEW);        &#125;        return result;    &#125;&#125;\n这部分主要功能就是解析xml，预先针对父容器通过createViewFromTag()方法生成临时的View(temp),然后并将解析后子View依次合并到tempz中，最终添加到父容器中并返回，有些时候是没有父容器的，例如我们自定义view的动态加载，因此只需要把这部分xml解析组合成View后直接返回即可。接下来看一下递归解析孩子的rInflateChildren()方法:\n1234final void rInflateChildren(XmlPullParser parser, View parent, AttributeSet attrs,        boolean finishInflate) throws XmlPullParserException, IOException &#123;    rInflate(parser, parent, parent.getContext(), attrs, finishInflate);&#125;\nrInflateChildren()内部进一步调用的rInflate()方法：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void rInflate(XmlPullParser parser, View parent, Context context,        AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123;    final int depth = parser.getDepth();    int type;        //开始进行解析    while (((type = parser.next()) != XmlPullParser.END_TAG ||            parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;                    //起始结点标识不是起始标识返回进行下一个结点的解析        if (type != XmlPullParser.START_TAG) &#123;            continue;        &#125;                //获取结点标签名字        final String name = parser.getName();        if (TAG_REQUEST_FOCUS.equals(name)) &#123;            //解析requestFocus标签            parseRequestFocus(parser, parent);          &#125; else if (TAG_TAG.equals(name)) &#123;            //解析tag标签            parseViewTag(parser, parent, attrs);        &#125; else if (TAG_INCLUDE.equals(name)) &#123;            //解析include标签            if (parser.getDepth() == 0) &#123;                throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;);            &#125;            parseInclude(parser, context, parent, attrs);        &#125; else if (TAG_MERGE.equals(name)) &#123;            //处理morge标签，这里直接抛出异常，因为morge标签只能存在最初父级结点上            throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;);        &#125; else &#123;            //如果是其他标签则根据标签生成View,并添加ViewGroup中，这部分进行递归遍历结点之下的结点            final View view = createViewFromTag(parent, name, context, attrs);            final ViewGroup viewGroup = (ViewGroup) parent;            final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);            rInflateChildren(parser, view, attrs, true);            viewGroup.addView(view, params);        &#125;    &#125;    if (finishInflate) &#123;        parent.onFinishInflate();    &#125;&#125;  \n这个过程主要处理子View的xml文件的解析，内部针对四种特殊标签单独处理，然后如果标签下仍然有子view，则继续递归处理。每次根据标签解析出来的view是由createViewFromTag()方法生成的。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778private View createViewFromTag(View parent, String name, Context context, AttributeSet attrs) &#123;    return createViewFromTag(parent, name, context, attrs, false);&#125;View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,        boolean ignoreThemeAttr) &#123;        //如果标签是view，拿到view标签上的class值        if (name.equals(&quot;view&quot;)) &#123;        name = attrs.getAttributeValue(null, &quot;class&quot;);    &#125;    // Apply a theme wrapper, if allowed and one is specified.    //如果该标签与主题相关，需要对context进行包装，将主题信息加入context包装类ContextWrapper    if (!ignoreThemeAttr) &#123;        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);        final int themeResId = ta.getResourceId(0, 0);        if (themeResId != 0) &#123;            context = new ContextThemeWrapper(context, themeResId);        &#125;        ta.recycle();    &#125;        //如果是blink标签返回一个BlinkLayout，它包含的内容会一直闪烁。    if (name.equals(TAG_1995)) &#123;        // Let&#x27;s party like it&#x27;s 1995!        return new BlinkLayout(context, attrs);    &#125;    //设置Factory，来对View做额外的拓展    try &#123;        View view;        if (mFactory2 != null) &#123;            view = mFactory2.onCreateView(parent, name, context, attrs);        &#125; else if (mFactory != null) &#123;            view = mFactory.onCreateView(name, context, attrs);        &#125; else &#123;            view = null;        &#125;        if (view == null &amp;&amp; mPrivateFactory != null) &#123;            view = mPrivateFactory.onCreateView(parent, name, context, attrs);        &#125;                //如果此时不存在Factory，不管Factory还是Factory2，还是mPrivateFactory都不存在，那么会直接对name直接进行解析        if (view == null) &#123;            final Object lastContext = mConstructorArgs[0];            mConstructorArgs[0] = context;            try &#123;                //如果name中包含.即为自定义View，否则为原生的View控件                if (-1 == name.indexOf(&#x27;.&#x27;)) &#123;                    view = onCreateView(parent, name, attrs);                &#125; else &#123;                    view = createView(name, null, attrs);                &#125;            &#125; finally &#123;                mConstructorArgs[0] = lastContext;            &#125;        &#125;        return view;    &#125; catch (InflateException e) &#123;        throw e;    &#125; catch (ClassNotFoundException e) &#123;        final InflateException ie = new InflateException(attrs.getPositionDescription()                + &quot;: Error inflating class &quot; + name, e);        ie.setStackTrace(EMPTY_STACK_TRACE);        throw ie;    &#125; catch (Exception e) &#123;        final InflateException ie = new InflateException(attrs.getPositionDescription()                + &quot;: Error inflating class &quot; + name, e);        ie.setStackTrace(EMPTY_STACK_TRACE);        throw ie;    &#125;&#125;\n这部分内容是最终的解析部分，无论是自定义view还是原生的view都能进行处理，细心的你会发现最终生成view的是onCreateView()方法，其内部其实是creatView(),这是LayoutInflater默认生成view的方式，内部原理是类加载器根据前缀+标签名字去加载相应的对象，有兴趣的同学可看一下这部分源码，共同学习。\n\n到此View创建添加到DecorView这一过程完毕，下部分是DecorView添加至Window过程，然后接下来进行view的测量、布局、绘制，这一整套走完之后才能见到庐山真面目了。\n总结\n文中的源码是android7.0源码。本文主要描述的是view创建添加到DecorView过程，从熟知的setContentView()内部分析大的方面经历的两部分：\n\nPhoneWindow的setContentView()\n\n初始化父容器\n\n实例化DecorView\n生成父容器ContentParent（包含主题、title、titleIcon等对父容器的设置）\n\n\n布局资源文件的加载，直接引申到第二部分\n\n\nPhoneWindow的mLayoutInflater.inflate()。\n\n获取XmlResourceParser实例对象\n通过inflate进一步加载解析\n\n处理父容器结点（优先处理morge标签）\n递归处理子节点\n递归addView(),最终指向父容器的addView()并返回。\n\n\n\n\n\n参考\n\n《Android开发艺术探索》\nhttp://blog.csdn.net/yanbober/article/details/45970721\nhttp://blog.csdn.net/yhaolpz/article/details/68936932\nhttps://juejin.im/entry/58abfa9d0ce463006b1a7b19\nhttp://www.cnblogs.com/jycboy/p/6219915.html#autoid-4-0-0\nhttp://blog.csdn.net/l540675759/article/details/78099702\n\n","plink":"https://blog.ixin.run/posts/1517199857/"},{"title":"数据结构和算法知识归总","date":"2018-01-21T11:46:16.000Z","date_formatted":{"ll":"2018年1月21日","L":"2018/01/21","MM-DD":"01-21"},"updated":"2021-01-29T12:51:44.671Z","content":"","plink":"https://blog.ixin.run/posts/1516535176/"},{"title":"Java开发知识归总","date":"2018-01-21T11:43:38.000Z","date_formatted":{"ll":"2018年1月21日","L":"2018/01/21","MM-DD":"01-21"},"updated":"2021-01-29T12:51:44.671Z","content":"刚毕业时自己是做java web开发的，后来转入android，便一发不可收拾，基础部分是通用的所以不能忘，当然java web也不能忘。\n【更新于2020.03.21】转载请注明出处：https://ixin.run\n\n基础部分\n\n深入理解java面向对象的4大特性尤其是多态\n对封箱、拆箱、向上转型、向下转型的理解\njava的修饰符及其之间的区别\nabstract和接口的共同点和区别\njava异常处理（常见异常类型、自定义异常、异常捕获、异常抛出）\nString、StringBuild和StringBuffer的理解\nJava中对==、equals()、hashcode()三者的理解\njava集合类总结\n深入理解ArrayList和LinkList(原理、区别、速度、扩容)\nHashMap内部实现原理（Fail-fast机制是什么）\njava泛型的理解\n字节流和字符流\njava注解\njava反射\n序列化和反序列化\njson解析和xml解析\njava线程总结\njava类加载机制\njava的内存回收机制\njava中的引用类型及各自作用\n内存溢出和内存泄漏的区别\njava怎样判断一个对象需要回收\n\nIO流及网络\n\nsocket编程\n\nJavaEE\n\nhtml知识总结\njs知识总结\njsp知识总结\nservlet知识点总结\nTomcat知识点总结\nMySql知识点总结\n从输入URL到页面加载发生了什么\n\nJavaWeb框架\n\nSSH框架分工模式\nSSM框架分工模式\n\n友情链接\n\nJava全面学习路线\nhow2j\n\n","plink":"https://blog.ixin.run/posts/1516535018/"},{"title":"Android开发知识归总","date":"2018-01-20T05:33:42.000Z","date_formatted":{"ll":"2018年1月20日","L":"2018/01/20","MM-DD":"01-20"},"updated":"2021-03-15T09:00:04.987Z","content":"一直想着把Android开发这块知识归总一下，今天熬夜终于归总了，面向的是中高级部分，发现自己还有好多漏洞需要去慢慢填充。\n【更新于2021.03.7】转载请注明出处：https://ixin.run\n\nAndroid体系架构\nAndroid核心架构探究学习\n基础开发部分\n1.基础组件\n\nActivity的生命周期和启动模式\nService的生命周期、启动方式、onStartComand返回值及IntentService的使用\nBroadcastReceiver的2种注册方式和2种发射方式\n通知栏Notification的演变\nContentProvider的使用\nFragment生命周期和进出栈管理\n认识Intent和IntentFilter\nWebView总结\nConstraintLayout学习总结\n\n2.View视图\n\n自定义view的实现方式\nView坐标\nView的触摸事件分发机制\nView手势GestureDetector使用\nView滑动冲突解决\nView动画的几种形式\nView的渲染过程\n硬件加速\n\n3.资源文件\n\n工程资源文件介绍\nTheme和Style探究\n\n4.进程间通信\n\n进程间通信实现方式\nAIDL完全探究\nBinder原理\nHandler消息传递机制\nUI线程和非UI线程\n\n5.数据持久化\n\n数据持久化实现形式\nSqlite基本使用\n\n6.多媒体\n\n视频播放\n音频播放与录制\ncamera的使用\n直播流程及实现\n\n7.网络编程\n\nHttp协议原理\nHttpUrlConnection\nVolley原理及实现\nOKHttp原理及实现\nRetrofit原理及实现\n\n8.图片图像处理\n\nGlide的实现原理及使用\nLRU算法\nOpenGl ES渲染\n\n9.Android适配\n\n屏幕适配解决方案\n多CPU适配\n国际化\n\n10.性能优化\n\n布局优化\n列表优化\n线程优化\n电池电量管理\n内存优化\n代码规范\n性能优化相关工具使用\n硬件加速\n\n11.线程\n\n响应式编程Rxjava原理及使用\n\n12.事件总线\n\nEventBus实现原理及使用\n\n13.应用安全\n\nAndroid代码混淆和加固\nAndroid常规应用反编译破解流程\n数据加解密传输存储\nMD5、Base64、RSA、AES和DES认识。\n数据库加密\n权限管理\n热修复\n崩溃信息捕获\n\n14.架构设计\n\nAndroid架构MVC、MVP和MVVM的区别\nButterKnife实现原理及使用\nDataBinding实现原理及使用\nAPT编译时技术\n字节码插装\n组件化\n插件化\n\n15.Jetpack系列\n\nLifecycles\nViewModel\nLiveData\nNavigation\nRoom\n\n16.编译与构建\n\ngradle学习总结\ngroovy语言了解\napk打包签名\n\n17.自动化测试\n\n单元测试、moke测试\nUI测试\n\n18.传感器\n\n基于方向传感器和重力传感器计步器的实现\n\n19.MaterialDesign\n\nMaterialDesign基本组件和作用\n\n20.Android新特性\n\n从android版本4.4以来的变化归总\n\n21.第三方框架\n\n第三方框架归总\n\nAPPLICATION FRAMEWORK\n\n系统开机到桌面呈现都发生了哪些事\nApp启动都发生了哪些事\nContext深入理解\n深入理解ActivityManager\n深入理解WindowsManager\n深入理解PackageManager\n\nANDROID RUNTIME\n\nJVM,Dalvik,ART三种虚拟机的区别\n对Dex文件的认识\n\nLIBRARIES\n\nJNI理解和NDK的使用\n\n友情链接\n\n官方文档：https://developer.android.google.cn/guide/index.html\n官方demo：https://developer.android.google.cn/samples/index.html\n官方blog: https://android-developers.googleblog.com/\n鸿洋：http://blog.csdn.net/lmj623565791\n郭霖：http://blog.csdn.net/guolin_blog/\n刘望舒：http://liuwangshu.cn/\nTrinea：http://a.codekk.com/\n美团点评技术团队：https://tech.meituan.com/\n\n","plink":"https://blog.ixin.run/posts/1516426422/"},{"title":"音视频开发相关基础概念","date":"2018-01-17T10:09:36.000Z","date_formatted":{"ll":"2018年1月17日","L":"2018/01/17","MM-DD":"01-17"},"updated":"2021-01-29T12:51:44.653Z","content":"早前自己仅仅实现过视频播放相关技术方案:VideoView、mediaplayer结合SurfaceView，这只是客户端播放功能。对于视频处理形式分为点播和流媒体播放，同时又包含音视频数据的采集和播放两方面。\n\n理解几个概念\n\n视频\n流媒体\n分辨率\n码流\n帧率\n比特率\n采样率\n\n多媒体格式分类\n\nMPEG\nMPEG Audio Layer 3\nMPEG-4\nMKV\n3GP\nAVI\nMOV\nWAV\nFLV\nRMVB\n\n参考：http://blog.csdn.net/xx326664162/article/details/51784440\n流媒体协议\n\nRTP 传输层以UDP传输，主要传输视频数据。是以固定的数据率在网络上发送数据，客户端也按照这种速度观看影视文件，当影视画面播放过后，就不可以再重复播放，除非重新向服务器端请求数据。\nRTCP 和RTP属于姐妹协议，同一层同一种传输方式，主要传输视频质量。\nRTSP 用来控制声音或影像的多媒体串流协议。\nRTMP Adobe公司为Flash播放器和服务器之间音视频传输开放的协议。\nHLS 主要应用在iOS系统，和上边不同之处是将整个视频流文件分成许多小文件，然后客户端不断下载这些小文件进行播放。\nMMS （Microsoft Media Server）是一种串流媒体传送协议，用来访问并流式接收Windows Media服务器中.asf文件的一种协议。\n\n参考：http://blog.csdn.net/xx326664162/article/details/51781399\nandroid音视频开发流程\n播放流程: 获取流–&gt;解码–&gt;播放\n录制播放流程: 录制音频视频–&gt;剪辑–&gt;编码–&gt;上传服务器\n直播流程: 录制音视频–&gt;编码–&gt;流媒体传输–&gt;服务器—&gt;流媒体传输到其他app–&gt;解码–&gt;播放\n几个重要的环节：\n\n录制音视频 AudioRecord/MediaRecord\n音视频编辑 mp4parser或ffmpeg\n音视频编码 aac&amp;h264\n上传大文件 网络框架,进度监听,断点续传\n流媒体传输 流媒体传输协议rtmp rtsp hls\n音视频解码 aac&amp;h264（MPEG-4Part10，h264的功能分为两层：视频编解码层（VCL）和网络提取层（NAL））\n渲染播放 MediaPlayer\n\n视频编辑可行性开源方案\n\nffmpeg(功能强大，包含libavcodec(音视频解码库)和libavformat（音视频格式转换库）)\nMediaCodec （android自带）\nijkplayer (bilibili开源的)\nmp4parser （软解软编音视频混合）\nVitamio\n\n常见问题\n\nijkplayer播放rtmp直播流，延迟明显\n全屏播放\n有时候会开始直播时出现黑屏 （确定下视频源的编码方式,ijk默认只带了h264解码code）\n一直是只有声音没有图像\n有时候会出现花屏\n解码方式设置\n如何区分点播直播\n是否需要开启硬件加速\n如何设置后台播放\n视频加载速度慢 （大多数根据CDN加速服务的质量）\n怎么静音和非静音\n适配问题,对于不同的cpu架构,需要编译不同的so库\n播放视频有的设备声画不同步\n如何查看m3u8时长\n如何改变播放质量（这个由视频源控制）\n倍速播放\n为什么往前拖动进度条后，还会往后退几秒 （seek只支持关键帧，出现这个情况就是原始的视频文件中i 帧比较少，播放器会在拖动的位置找最近的关键帧）\n怎样添加字幕\n如何设置硬解\n\n参考：https://www.jianshu.com/p/8436c7353296\n开发参考\n\nAndroid使用FFmpeg实现推送视频直播流到服务器\n在各端实现Rtmp和hls视频流的播放 \nandroid mediaplayer属性和方法\nAndroid视图SurfaceView的实现原理分析\n\n","plink":"https://blog.ixin.run/posts/1516183776/"},{"title":"数据结构整体概括","date":"2018-01-12T10:09:36.000Z","date_formatted":{"ll":"2018年1月12日","L":"2018/01/12","MM-DD":"01-12"},"updated":"2021-02-24T13:58:39.553Z","content":"一直想把数据结构系统温故一下，今天先来一个总括，后续慢慢补充。\n\n什么是数据结构\n数据结构是数据元素之间存在的一种或多种特定关系，也是数据的组织形式。在计算机中，数据元素并不是孤立和杂乱无序的，而是具有内在的联系的数据集合。这种集合可能是以“表”的形式存在，可能是“树”的形式存在，还可能是以“图”的形式存在等等。\n数据结构的主要任务就是通过分析描述对象的结构特征，以及元素之间的内在联系并抽象成相应的数据关系，进而把这种逻辑结构表示成计算机可实现的物理结构，从而方便计算机的高效快速处理。\n数据结构的分类\n数据结构目前分为两大类：逻辑结构和物理结构。\n逻辑结构\n逻辑结构是指在数据对象中数据元素之间的相互关系。逻辑结构可分为线性结构和非线性结构。\n线性结构\n有且只有一个开始结点和一个终端结点，并且所有结点都最多只有一个直接前驱和一个直接后继。\n\n\n线性表\n线性表有两种存储方式：顺序存储和链式存储。采用顺序存储结构的线性表叫顺序表（利用数组实现），采用链式存储结构的线性表叫链表。链表又分为：\n\n单链表：只有一个指针域，且指向直接后继节点，最后一个结点的指针域为空。\n循环单链表：最后一个结点指针域指向头结点或链表的第一个结点。\n双向链表：有两个指针域，一个指向直接前驱结点，另一个指向直接后继结点，最后一个结点的next指针域为空。\n双向循环链表：最后一个结点的next指针域指向指向头结点或链表的第一个结点，而第一个结点的prior指针域指向最后一个结点。\n静态链表：上边的四种链表结点之间的关系是由指针实现的，结点的分配与释放都是由函数malloc和free动态实现，因此成为动态链表。静态链表可通过定义一个结构体数组来作为结点空间。结构体中用数组的下标作为指针域，类型不再是指针类型，而是一个整型。\n\n\n\n栈\n栈是一种只允许在线性表一端（栈顶）进行插入和删除操作的特殊线性表。同样也有两种存储方式：顺序存储（顺序栈）和链式存储（链栈）。\n栈的特点：后进先出。\n栈的操作：\n\nInitStack(&amp;S):初始化一个空栈S。\nStackEmpty(S):判断栈是否为空，为空返回1，不为空返回0。\nGetTop(S,&amp;e):返回栈S的栈顶元素给e。\nPushStack(&amp;S,e):栈S插入元素e。\nPopStack(&amp;S,&amp;e):删除栈S的顶端元素，并用e返回值。\nStackLength(S):返回栈S的元素个数。\nCleanStack(S):清空栈s。\n\n\n\n队列\n队列是一种只允许在线性表的一端进行插入操作（队尾）另一端进行删除操作（对头）的特殊线性表。同样也有两种存储方式：顺序存储（顺序队列）和链式存储（链式队列）。还有一种特殊的队列叫双端队列，可以在队的任意一端进行插入和删除。\n两个问题：\n\n\n顺序队列的“假溢出”问题：队头有空间，队尾指针却达到了数组的末尾，继续插入数据将越出数组的下届造成“溢出”，像这种有存储空间而不能进行继续插入元素操作的溢出称为“假溢出”。\n避免假溢出：实现顺序循环队列。当队尾指针rear达到最大值QueueSize-1时，如果要插入新的元素，就把队尾指针rear自动变为0；当对头指针front达到最大值QueueSize-1时，如果要删除一个元素，就要让队头指针front自动变成0。\n\n\n顺序循环队列的队空队满状态相同问题：顺序循环队列在队空状态和队满状态时，队头指针front和队尾指针rear同时都指向同一个位置，即front==rear。为了区分队空队满两种情况，解决方法有两个：\n\n\n设置标志位\n假设标志位为flag，初始时flag=0，当入队列成功flag=1，出队列陈功flag=0。队列为空的判断条件为front==rear&amp;&amp;flag==0，队列满的判断条件为front==rear&amp;&amp;flag==1。\n\n\n少用一个存储单元\n队空的判断条件front==rear，队满的判断条件是front==(rear+1)%QueueSize。\n\n\n\n\n\n\n串：\n串是仅有字符组成的一种特殊的线性表，由零个或多个字符组成的有限序列。理解几个概念：空串、空格串、子串、主串、串长。同样也有两种存储方式：顺序存储（顺序串、堆串）和链式存储（链串）。\n在顺序存储中顺序串是静态分配的，串的连接、插入、替换等操作由于需要事先分配存储空间，可能会由于内存空间不足而出现串的一部分字符被截掉，可采用动态分配存储单元解决。堆串的存储空间是在程序的执行过程中动态分配的，C语言中由函数malloc和free管理堆的存储空间，在内存单元使用完毕后记着释放内存空间。\n链串的存储结构同样也要有一个数值域和指针域，数值域作为一个结点可以存放一个字符也可以存放多个字符，最后一个子串的数值域未填满时可用“#”填充，串长不一定是结点的整数倍。\n相比串的链式存储，串的顺序存储在各种操作中实现更方便，空间利用率更高，所以顺序存储比链式存储更常用。\n串的模式匹配\n串的模式匹配也称为子串的定位操作，即查找子串在主串中出现的位置。设有主串S和子串T，如果在主串S中找到与子串T相同的子串，则返回串T的第一个字符在主串S中的位置，否则返回-1。有以下两种匹配方法：\n\n经典的模式匹配算法（即Brute-Force算法）\n思想：从主串S的第pos个字符开始与子串T的第一个字符进行比较，如果相同则继续比较后续的字符，如果不同则从主串S的pos点的下一个字符重新与串T的第一个字符进行比较。\nBrute-Force算法在每次出现主串与模式串的字符不相等时，主串的指针均需要回退。\n串的改进算法（即KMP算法）\nKMP算法的核心是求模式串中P0、P0P1、P0P1P2、P0…Pi的最大的相同前后缀的长度形成的匹配表，然后根据公式:移动位数 = 已匹配的字符数 - 对应的部分匹配值计算出移动位数，直到完全匹配成功（已匹配字符数与模式串的串长相等）。\nKMP算法根据模式串的next函数值消除主串与模式串的字符不匹配时主串指针的回退，有效提高了模式匹配的效率。\n参考：\n\nhttp://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html\nhttps://www.cnblogs.com/c-cloud/p/3224788.html\nhttps://www.zhihu.com/question/21923021\n\n\n\n\n\n数组：\n数组是由n个类型相同的数据元素组成的有限序列。其中，这n个数据元素占用一块地址连续的存储空间。数组中的数据元素可以是原子类型，如整形、字符型、浮点型等，这种类型的数组称为一维数组；数据元素也可以是线性表，这种类型的数组成为二维数组。\n数组采用的是顺序存储方式。如果要将一个多维的数组存放在一个一维的存储单元里，必须先将多维的数组转换成一个一维的线性序列。存储方式有两种:以行序为主的存储方式和以列序为主的存储方式。\n\n如果数组中大多数元素值相同或值为零且这些元素存在一定的规律，则成为特殊矩阵。如果矩阵中的元素有许多都是零且不具有规律性，则称为稀疏矩阵。为了节省空间可将这类矩阵进行压缩处理。\n特殊矩阵\n\n对称矩阵的压缩存储\n三角矩阵的压缩存储\n对角矩阵的压缩存储\n\n稀疏矩阵\n\n\n广义表：\n\n\n非线性结构\n相对于线性结构，非线性结构就是每个结点可以有不止一个直接前驱和直接后继。\n\n树：\n图：\n\n物理结构\n物理结构又撑为存储结构，是指数据的逻辑结构在计算机中的存储形式，能够正确反应数据元素之间的逻辑关系。物理结构可分为顺序存储结构、链式存储结构、索引存储结构和散列存储结构。\n顺序存储结构\n顺序存储结构是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。\n优点：存储密度大，存储空间利用率高。\n缺点：插入或删除元素时不方便。这里的不方便主要是在数据元素的之间做插入和删除操作造成操作点后边的元素要进行移位。\n功能：顺序表适宜于做查找这样的静态操作。若线性表的长度变化不大，且其主要操作是查找，则采用顺序表。\n链式存储结构\n链式存储是把数据元素放在任意的存储单元中，可以是顺序的也可以是无序的，数据元素的存储关系不能反应其逻辑关系，因此需要一个指针存放数据的地址，进而找到相关联数据元素的位置。\n优点：插入或删除元素时很方便，使用灵活。\n缺点：存储密度小，存储空间利用率低。\n功能：链表宜于做插入、删除这样的动态操作。若线性表的长度变化较大，且其主要操作是插入、删除操作，则采用链表。\n索引存储结构\n除了建立存储节点外，还要另外建立一个索引表来指示这些节点的地址。\n优点：检索速度快。\n缺点：增加了附加的索引表,会占用较多的存储空间\n散列存储结构\n散列存储，又称hash存储，是一种力图将数据元素的存储位置与关键码之间建立确定对应关系进行查找和存储。数据元素由某种算法（一般是先得到hash码，然后与当前数组长度取模）得到一个固定且比数据元素长度更短的散列码作为数组中的下标，然后进行直接查询。\n优点：综合了顺序存储和链式存储的优点，根据散列码快速定位存储位置，查询速度快。\n解决冲突几种方式：\n\n\n开放定址法\n开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。常用的有以下三种方式：\n\n\n线性探测再散列\n公式：fi(key) = (f(key)+di) MOD m (di=1,2,3,......,m-1)\n\n\n二次(平方)探测再散列\n公式：fi(key) = (f(key)+di) MOD m (di = 1^2, -1^2, 2^2, -2^2,......,q^2, -q^2, q &lt;= m/2)\n\n\n伪随机探测再散列\n公式：fi(key) = (f(key)+di) MOD m (di是一个随机数列)\n\n\n上边的key指的是将要查询或存储的元素，f(key)指冲突的散列值，di指为了得到新散列值的位移量，m数组的长度，fi(key)指新散列值。\n参阅：http://www.nowamagic.net/academy/detail/3008050\n\n\n再哈希法\n再哈希法就是在冲突发生时，利用另外一个散列函数再次求出散列函数的地址，直到冲突不再发生为止。即fi(key) = rehash(key), i=1,2,3......,其中rehash表示不同的散列函数。这种方法不易再次发生冲突，但是需要事先构造多个散列函数，而且增加了计算时间。\n\n\n链地址法(拉链法，hashmap原理)\n链地址法就是在符号表的每一个记录中增加一个链域，链域中存放下一个具有相同哈希函数值记录（第一个数据元素）的存储地址，利用链域把若干个发生冲突的记录链接在一个链表内。当链域的值为null时表示没有后继记录了（此处没有存数据元素）。所以此种方法对于发生冲突时的查找和插入操作跟线性表一样了。\n\n\n\n建立一个公共溢出区\n将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表.查找时先与基本表相应位置的元素进行对比，如果相同则查找成功，不相同则到溢出表中进行顺序查找。冲突少的情况下这种方式还是很高效的。\n\n\n数据结构的常用技术\n上边是针对数据结构的逻辑关系和物理存储的解析，这些也是为了更好的程序的创建和高效查询。数据结构的常用技术有两种形式：查找和排序。\n查找\n排序\n","plink":"https://blog.ixin.run/posts/1515751776/"},{"title":"Android开发BroadcastReceiver详解","date":"2017-09-13T13:13:27.000Z","date_formatted":{"ll":"2017年9月13日","L":"2017/09/13","MM-DD":"09-13"},"updated":"2021-01-29T12:51:44.624Z","content":"BroadcastReceiver是Android应用中一个重要的组件，顾名思义，BroadcastReceiver代表广播消息接收器。从代码实现角度来看，BroadcastReceiver非常类似于事件编程中的监听器。与普通事件监昕器不同的是，普通事件监昕器监听的事件源是程序中的对象:而BroadcastReceiver监听的事件源是Android应用中的其他组件。本篇文章就简单讲一下BoardcastReceiver的基本使用。\n\nBroadcastReceiver用于接收程序（包括用户开发的程序和系统内建的程序）所发出的Broadcast Intent. 与应用程序启动Activity、Service相同的是，程序启动BroadcastReceiver也只需要两步：\n\n创建帘要启动的BroadcastReceiver的Intent。\n调用Context的sendBroadcast()等方式来启动指定的BroadcastReceiver。\n\n当应用程序发出一个BroadcastReceiver之后，所有匹配该Intent的BroadcastReceiver都有可能被启动。\n广播接收器声明\n由于BroadcastReceiver本质上属于一个监听器，因此实现BroadcastReceiver的方法也十分简单，只要重写BroadcastReceiver的onReceive(Context context, Intent intent)方法即可。\n123456789101112public class MyBroadcastReceiver extends BroadcastReceiver &#123;        private static final String TAG = &quot;MyBroadcastReceiver&quot;;        @Override        public void onReceive(Context context, Intent intent) &#123;            StringBuilder sb = new StringBuilder();            sb.append(&quot;Action: &quot; + intent.getAction() + &quot;\\n&quot;);            sb.append(&quot;URI: &quot; + intent.toUri(Intent.URI_INTENT_SCHEME).toString() + &quot;\\n&quot;);            String log = sb.toString();            Log.d(TAG, log);            Toast.makeText(context, log, Toast.LENGTH_LONG).show();        &#125;    &#125;\nBroadcastReceiver的onReceive()方法最长执行时间为10秒，如果此方法内的执行超过10秒，系统会认为该程序无响应，所以不要在BroadcastReceiver的onReceive()方法里执行一些耗时的操作；否则会弹出ANR（Application NO Response）对话框。\n两种注册方式\n一旦实现了BroadcastReceiver，接下来就应该指定该BroadcastReceiver能匹配的Intent，此时有两种方式。\nAndroid系统中BroadcastReceiver的注册方式分为动态注册和静态注册两种。动态注册必须在程序运行期动态注册，其实际的注册动作由ContextImpl对象完成；静态注册则是在AndroidManifest.xml中声明的。在基础篇中提到过，因为静态注册耗电、占内存、不受程序生命周期影响，所以Google在Android8.0上禁止了大部分广播的静态注册，以此来减少耗电、增加待机时间、节省内存空间、提升性能。\n\nNote: If your app targets API level 26 or higher, you cannot use the manifest to declare a receiver for implicit broadcasts (broadcasts that do not target your app specifically), except for a few implicit broadcasts that are exempted from that restriction. In most cases, you can use scheduled jobs instead.\n\n静态注册\n也称为饿汉式注册，只需在AndroidManifest.xml文件中配置。例如如下代码:\n123456&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot;  android:exported=&quot;true&quot;&gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;/&gt;        &lt;action android:name=&quot;android.intent.action.INPUT_METHOD_CHANGED&quot; /&gt;    &lt;/intent-filter&gt;&lt;/receiver&gt;\n动态注册\n动态注册我们只需要在程序启动过程中进行注册即可，首先声明一个全局的接收器成员：\nBroadcastReceiver br = new MyBroadcastReceiver();\n然后在Activity的周期中onCreat或者onResume中进行广播接收器的注册：\n123IntentFilter filter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);filter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);this.registerReceiver(br, filter);\n为了内存和安全的需要，在生命周期结束的时候我们要进行解注册，一般这步在生命周期中onstop或onDestroy中实现，需要注意的是解注册过程不可解注册多次。\n1unregisterReceiver(br);\n三种发送方式\n广播发送方式有两种：\n\nNormal Broadcast（普通广播）\nOrdered Broadcast（有序广播）\n\nNormal Broadcast（普通广播）\nNormal Broadcast是完全异步的，可以在同一时刻(逻辑上)被所有接收者接收到， 消息传递的效率比较高。但缺点是接收者不能将处理结果传递给下一个接收者，并且无法终止Broadcast Intent的传播。\n我们常用的sendBroadcast(Intent)就是普通广播。\nOrdered Broadcast（有序广播）\nOrdered broadcasts的接收者按照一定的优先级进行消息的接收。如：A,B,C的优先级依次降低，那么消息先传递给A，在传递给B，最后传递给C。优先级别声明在中，取值为[-1000,1000]数值越大优先级别越高。优先级也可以在代码中通过filter.setPriority(10)方式设置。\n另外Ordered broadcasts的接收者可以通过abortBroadcast()的方式取消广播的传播，也可以通过setResultData或setResultExtras方法将处理的结果存入到Broadcast中，传递给下一个接收者。然后，下一个接收者通过getResultData()或getResultExtras(true)接收高优先级的接收者存入的数据。\n1234567891011121314151617181920212223242526272829303132333435public class FirstReceiver extends BroadcastReceiver &#123;\t\tprivate static final String TAG = &quot;OrderedBroadcast&quot;;\t\t@Override\tpublic void onReceive(Context context, Intent intent) &#123;\t\tString msg = intent.getStringExtra(&quot;msg&quot;);\t\tLog.i(TAG, &quot;FirstReceiver: &quot; + msg);\t\t\t\tBundle bundle = new Bundle();\t\tbundle.putString(&quot;msg&quot;, msg + &quot;@FirstReceiver&quot;);\t\tsetResultExtras(bundle);\t&#125;&#125;...public class SecondReceiver extends BroadcastReceiver &#123;\t\tprivate static final String TAG = &quot;OrderedBroadcast&quot;;\t\t@Override\tpublic void onReceive(Context context, Intent intent) &#123;\t\tString msg = getResultExtras(true).getString(&quot;msg&quot;);\t\tLog.i(TAG, &quot;SecondReceiver: &quot; + msg);\t\t\t\tBundle bundle = new Bundle();\t\tbundle.putString(&quot;msg&quot;, msg + &quot;@SecondReceiver&quot;);\t\t//接着往下传递\t\tsetResultExtras(bundle);\t\t//取消广播\t\t//abortBroadcast();\t&#125;&#125;\n我们注意到，在FirstReceiver和SecondReceiver中最后都使用了setResultExtras方法将一个Bundle对象设置为结果集对象，传递到下一个接收者那里，这样以来，优先级低的接收者可以用getResultExtras获取到最新的经过处理的信息集合。\n接下来我们为这两个广播在AndroidMainfest.xml注册一下，注意优先级：\n123456789101112&lt;receiver android:name=&quot;.FirstReceiver&quot;&gt;\t&lt;intent-filter android:priority=&quot;1000&quot;&gt;\t\t&lt;action android:name=&quot;android.intent.action.MY_BROADCAST&quot;/&gt;\t\t&lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;\t&lt;/intent-filter&gt;&lt;/receiver&gt;&lt;receiver android:name=&quot;.SecondReceiver&quot;&gt;\t&lt;intent-filter android:priority=&quot;999&quot;&gt;\t\t&lt;action android:name=&quot;android.intent.action.MY_BROADCAST&quot;/&gt;\t\t&lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;\t&lt;/intent-filter&gt;&lt;/receiver&gt;\n一切准备就绪我们就开始发送广播了：\n123Intent intent = new Intent(&quot;android.intent.action.MY_BROADCAST&quot;);intent.putExtra(&quot;msg&quot;, &quot;hello receiver.&quot;);sendOrderedBroadcast(intent, &quot;scott.permission.MY_BROADCAST_PERMISSION&quot;);\n有同学问了，sendOrderedBroadcast第二个参数是什么鬼。使用sendOrderedBroadcast方法发送有序广播时，第二个参数是权限参数，如果为null则表示不要求接收者声明指定的权限，如果不为null，则表示接收者若要接收此广播需声明指定权限。这样做是从安全角度考虑的，一般设计到系统的，我们都需要声明权限，例如拦截系统短信，就必须声明接收短信的权限。\n当然我们也可以自定义自己的权限，一般这种主要用在跨应用跨进程或者跨组件的安全着想：\n例如在被调用方进行权限定义：\n123&lt;permission android:protectionLevel=&quot;normal&quot;android:name=&quot;scott.permission.MY_BROADCAST_PERMISSION&quot; /&gt;\n然后将某个组件绑定此权限，并暴露出去：\n12345678&lt;!-- 为receiver绑定自己的权限 --&gt;&lt;receiver android:name=&quot;.FirstReceiver&quot;           android:permission=&quot;scott.permission.MY_CALL_PHONE&quot;&gt;\t&lt;intent-filter android:priority=&quot;999&quot;&gt;\t\t&lt;action android:name=&quot;android.intent.action.MY_BROADCAST&quot;/&gt;\t\t&lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;\t&lt;/intent-filter&gt;&lt;/receiver&gt;\n接下来就可以在调用方进行权限注册和使用了：\n1&lt;uses-permission android:name=&quot;scott.permission.MY_BROADCAST_PERMISSION&quot; /&gt;\n参考\n\nhttps://developer.android.com/guide/components/broadcasts\nhttps://www.jianshu.com/p/bc5ffb349822\n\n","plink":"https://blog.ixin.run/posts/1505308407/"},{"title":"Fragment实现懒加载之setUserVisibleHint探究","date":"2017-07-28T11:59:01.000Z","date_formatted":{"ll":"2017年7月28日","L":"2017/07/28","MM-DD":"07-28"},"updated":"2021-01-29T12:51:44.646Z","content":"一种场景很重要，即使所见即所得，例如页面可见时才加载数据，既节省内存，又能提示用户当前数据正在处理，不必感到迷茫。\n\n场景\n针对Activity，因为是一个整体，所以在生命周期内我们便可以做到所见即所得，但是fragment就不一样了，有时候一个Activity可以包含很多个Fragment，例如FragmentPageAdapter中，一般做法时提前将数据填充到Fragment中，这样在滑动Fragment时能够如丝般顺滑。\n但是这样也有不好的一点，就是Fragment提前就已经把数据加载上了，滑动过程无法自动刷新数据，有同学说了我可以在onResume中实现数据的请求，但是这样不感觉很蹩脚吗？FragmentPagerAdapter或者ViewPager都有预加载的过程，加入提前在onResume()里面加载，数据量大的时候卡顿是有可能的，数据量小的话加载后滑到此Fragment用户根本不知道数据已经加载而造成对数据的不放心。并且开关屏幕显示也会在请求一遍，确实蹩脚。\n那么有没有一种可能，在Fragment滑动到当前tab下的时候再去加载数据，甚至数据非常重要加载过程中屏蔽滑动，并且滑到当前tab下只加载一次。不卖关子了，Fragment有一个专门针对这种懒加载场景的API————setUserVisibleHint(boolean isVisibleToUser)。\n执行过程\n首先setUserVisibleHint()使用范围必须在一组有序的Fragment时（FragmentPageAdapter）才会起作用，单个Fragment是不起作用的，并且该方法调用不一定在Fragment正常的生命周期之内。见源码注释：\n\n在FragmentPageAdapter中，假如有四张fragment，以下将通过日志来分析一下整个执行过程。\n初始时\n先执行setUserVisibleHint，将一次性加载在内存中的每个fragement（默认一次性加载两个Fragment）的该方法执行一遍，先默认都初始为false，最后将可见的那个fragment（第一个）初始为true。然后执行Fragment的生命周期：\nsetUserVisibleHint -------&gt; onAttach、 onCreat…\n日志：\n\n滑动到第二页\n此时该fragment的部分生命周期已经走过（例如：onCreatView），但是该fragment的可见情况发生了变化，所以在第二页的时候只执行了setUserVisibleHint，不再执行onCreatView等生命周期方法。不过滑到第二页的时候顺便把第三页的相关方法初始一下。\n日志：\n\n滑到最后一页\n假如这里一组只有四个Fragment，因为接下来没有第5个Fragment，所以不用进行预加载了，只需要做两步操作：\n\n把前一页的可见性置为false,把本页的可见性置为true。\n把上上一页的生命周期关闭（内存中只允许放两页，所以要把老的fragment出栈）。\n\n日志:\n\n间接跳转\n假如从第四页直接跳到第一页（这里不是滑动，是导航跳转），可见性上先根据第一页的预加载方式进行逐个初始关闭，把第四页关闭，在把第一页打开。生命周期上先预处理第一页第二页的生命开启，接着将第三页第四页的生命关闭。举一反三其他间接跳转也类似。\n日志：\n\n其余情况\n想必看明白的同学根据上边规律也能摸索出其他情况执行过程了。\n从第二页滑动到第三页：\n\n从第一页跳到第三页（点击tab）：\n\n从第三页再滑动到第二页：\n\n第二页灭屏：\n\n亮屏展示第二页：\n\n分析\n综上，其实这里只需要考虑两件事：\n\n设置可见性（初始可见性为false，关闭老页面可见性为false, 开启当前页可见性为true）\n设置生命周期（预加载新的生命周期，关闭老的生命周期）。\n\n因为这两件事是交替变换，可见性为true但生命周期不一定初始化，此时是不能做一些有关界面的数据填充；生命周期准备好了但是可见性为false，加载的数据用户看不到，资源显的浪费。所以在数据加载时要同时考虑这两种情况，这里设置两个全局变量（mIsPrepare：标识生命周期； mIsVisible ：标识可见状态）来标识这两个情况：\n1234567891011121314151617181920212223@Overrideprotected void loadData(Bundle savedInstanceState) &#123;  mIsPrepare = true;  onLazyLoad();&#125;@Overridepublic void setUserVisibleHint(boolean isVisibleToUser) &#123;  super.setUserVisibleHint(isVisibleToUser);  mIsVisible = isVisibleToUser;  onLazyLoad();&#125;private void onLazyLoad() &#123;  if (mIsPrepare) &#123;    // 初始相关数据，以便于在滑动过程中能看到下一页有预处理数据    initData();    if (mIsVisible) &#123;      // 加载最终数据      queryData(true);    &#125;  &#125;&#125;\n","plink":"https://blog.ixin.run/posts/1501243141/"},{"title":"Android架构MVC、MVP和MVVM的区别","date":"2017-02-28T11:39:23.000Z","date_formatted":{"ll":"2017年2月28日","L":"2017/02/28","MM-DD":"02-28"},"updated":"2021-01-29T12:51:44.643Z","content":"Android比较流行的应用架构目前有3种形式：MVC、MVP、MVVM。MVC是最古老的用法，但是随着业务的拓展，框架冗余度也相应变大，以至于到最后不容易维护，近些年逐渐被MVP和MVVM所代替。以下仅仅针对这三种进行图示说明，便于更清楚的理解。\n\nMVC:\n\nM：所有和数据获取相关的，例如网络请求、实体类等。\nV：XML相关的Layout布局。\nC：Activity和Fragment这里作为控制层。\n过程：控制层（Controller）根据Id拿到View中的相关布局，然后与Model沟通获取相关数据，最后将数据关联到View中。控制层（Controller）同样也可以根据View的相关指令，然后去改变Model中数据，供其他地方所使用。\n亲近关系：Controller和Model、Controller和View。\n弊端：Controller最为控制层耦合Model和View很严重，大型项目团队处理问题费时费力。\nMVP:\n\nM：所有和数据获取相关的，例如网络请求、实体类等。\nV：Activity、Fragment以及XML相关的Layout布局。\nP：实现数据获取或改变并通过接口以及回调给View显示这样的中间层。\n过程：View拿到Presenter并实现Presenter中的相关接口，Presenter触发Model进行数据的获取或处理并通过接口回调给View进行界面显示。\n亲近关系：Presenter和Model。\nMVVM:\n\nM：所有和数据获取和传递相关的，例如网络请求等。\nV：Activity、Fragment以及XML相关的Layout布局。\nVM：就是实体类Bean。\n过程：V和VM进行数据绑定，Model进行数据获取改变VM数据从而影响View的显示，View的主动触发也能够改变VM数据从而也能让Model进行处理。\n亲近关系：View和ViewModel。\n参考\n\nhttp://blog.csdn.net/jdsjlzx/article/details/51174396\nhttp://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html\n\n","plink":"https://blog.ixin.run/posts/1488281963/"},{"title":"Java注解小记","date":"2016-12-16T01:34:42.000Z","date_formatted":{"ll":"2016年12月16日","L":"2016/12/16","MM-DD":"12-16"},"updated":"2021-01-29T12:51:44.663Z","content":"谈到注解，java中不可或缺的一章，更是各类框架组成的一部分，给开发者带来了极好的编程体验，代码量少，易阅读，易维护…\n\n什么是注解\nAnnotation(注解)是JDK5.0及以后版本引入的。它的作用是修饰编程元素。编程元素包括：包、类、构造方法、方法、成员变量等。\n注解分类\n按运行机制分：\n\n源码注解： 注解只在源码中存在，编译成class注解就不存在了。\n编译时注解：在源码和.class文件中都存在。 例如JDK中自带的注解。\n运行时注解：只在在运行阶段还会起作用，甚至会影响运行逻辑的注解。\n\n按照注解来源分：\n\n\nJDK自带的注解:\n\n@Override，标示方法的重写。\n@Deprecated，标示此方法或者该成员变量已经过时。\n@Suppbisewarnings()，忽略相关警告。\n\n其中Override、Deprecated属于标识注解，即没有成员的注解，仅用于标识其存在的作用。\nPS:\n针对java中的@Override注解，有些时候我们发现其实不写也是可以的，那么这有什么区别呢？一般来说，写与不写没什么区别，JVM可以自识别。\n写的情况下，即说明子类要覆盖基类的方法，基类必须存在方法（控制类型public，protected，返回值，参数列表类型与子类方法完成一致的方法），否则会报错（找不到被Override的方法）。在不写@Override注解的情况下，当基类存在与子类各种条件都符合的方法是即实现覆盖；如果条件不符合时，则是当成新定义的方法使用。\n所以如果想覆盖基类方法时，最好还是写上@Override注解，这样有利于编译器帮助检查错误 。\nSuppressWarnings注解的常见参数值的简单说明：\n\ndeprecation：使用了不赞成使用的类或方法时的警告；\nunchecked：执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型;\nfallthrough：当 Switch 程序块直接通往下一种情况而没有 Break 时的警告;\npath：在类路径、源文件路径等中有不存在的路径时的警告;\nserial：当在可序列化的类上缺少 serialVersionUID 定义时的警告;\nfinally：任何 finally 子句不能正常完成时的警告;\nall：关于以上所有情况的警告。\n\n\n\n来自第三方的注解:\n\nSpring中包括@Autowired、@Service、@Repository\nMybatis中包括@InsertProvider、@UpdateProvider、@Options\n\n\n\n我们自定义的注解，包括元注解。\n\n\n自定义注解\n注意以下几点：\n\n使用@interface关键字定义注解\n成员以无参无异常方式声明。\n可以用default为成员指定一个默认值。\n成员类型是受限制的，合法的类型包括常规的基本类型以及String，Class、Annotation、enum和前边所有类型的数组。\n如果注解只有一个成员，则成员名必须为value(),在使用时可以忽略成员名和赋值号（=）。\n\n例：\n1234567891011@Target(&#123; ElementType.TYPE &#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface FruitName &#123;\tString value() default &quot;&quot;;&#125;@FrultName(&quot;apple&quot;)public class Apple&#123;&#125;\n什么是元注解\n元注解：给注解进行注解。\n\n@Target({ElementType.METHOD,ElementType.Type})描述的是作用域，作用范围包括如下：\nCONSTRUCTOR（构造方法声明）、FIELD(字段声明)、LOCAL_VARIABLE(局部变量声明)、METHOD(方法声明)、PACKAGE(包声明)、PARAMETER(参数声明)、TYPE(类、接口声明)。\n@Retention(RetentionPolicy.RUNTIME)描述的是生命周期，类型如下：\nSOURCE(只在源码显示，编译时会丢弃)、CLASS(编译时会记录到ClASS中，运行时忽略)、RUNTIME(运行时存在，可以通过反射读取)。\n@Inherited允许子类继承。注意继承只会使类上的注解起作用，对于方法的继承注解是不起作用的。\n@Documented生成javaDoc会生成注解信息。\n\n解析注解\n在自定义注解的时候我们给注解附上必要的值，解析注解是通过反射来获取类、函数或成员上运行时注解信息，以便于相关方法的调用或使用，从而实现动态控制程序运行的逻辑。\n完整栗子\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * 水果颜色注解 *  */@Target(&#123;ElementType.METHOD,ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface FruitColor &#123;\t    /**     * 颜色枚举     */    public enum Color&#123; BULE,RED,GREEN&#125;;        /**     * 颜色属性     */    Color fruitColor() default Color.GREEN;&#125;/** * 水果名字注解 *  */@Target(&#123; ElementType.TYPE &#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface FruitName &#123;\tString value() default &quot;&quot;;&#125;/** * 注解调用类 * @author  * */@FruitName(&quot;apple&quot;)public class Apple &#123;\t@FruitColor(fruitColor = FruitColor.Color.RED)\tprivate String appleColor;\tpublic void setAppleColor(String appleColor) &#123;\t\tthis.appleColor = appleColor;\t&#125;\tpublic String getAppleColor() &#123;\t\treturn appleColor;\t&#125;\tpublic static void main(String[] args) &#123;\t\ttry &#123;\t\t\tClass&lt;?&gt; c = Class.forName(&quot;Apple&quot;);\t\t\t// 判断类上面是否存在注解\t\t\tboolean isExist = c.isAnnotationPresent(FruitName.class);\t\t\tif (isExist) &#123;\t\t\t\t// 拿到注解实例\t\t\t\tFruitName fruitName = c.getAnnotation(FruitName.class);\t\t\t\tSystem.out.println(&quot;水果的名字：&quot; + fruitName.value());\t\t\t&#125;\t\t\t// 仅获取本类的全部属性\t\t\tField[] field = c.getDeclaredFields();\t\t\tfor (Field f : field) &#123;\t\t\t\tboolean isFExist = f.isAnnotationPresent(FruitColor.class);\t\t\t\tif (isFExist) &#123;\t\t\t\t\tFruitColor fruitColor = f.getAnnotation(FruitColor.class);\t\t\t\t\tSystem.out.println(&quot;水果的颜色：&quot;+fruitColor.fruitColor().toString());\t\t\t\t&#125;\t\t\t&#125;\t\t&#125; catch (ClassNotFoundException e) &#123;\t\t\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125;\t&#125;&#125;\n【结果】：\n12水果的名字：apple水果的颜色：RED","plink":"https://blog.ixin.run/posts/1481852082/"},{"title":"Java中对==、equals()、hashcode()三者的理解","date":"2016-12-08T08:57:06.000Z","date_formatted":{"ll":"2016年12月8日","L":"2016/12/08","MM-DD":"12-08"},"updated":"2021-01-29T12:51:44.658Z","content":"以前看了有关==、equals()、hashcode()这三者的区别和使用，当时感觉就这一点知识能够记住，最近用到这块内容脑海中只有一丝印象却不知具体如何，好记性不如赖笔头，遂再重新总结一下，以便日后信手拈来。\n\n==\n对于引用对象而言，比较两个对象引用的是否是同一个对象。比较是的两个引用对象的存储地址是否一样。\n对于基本数据类型而言，比较的就是两个数据的值是否相等。\n12345String a &#x3D; &quot;aaa&quot;;String b &#x3D; &quot;aaa&quot;;String c &#x3D; new String(&quot;aaa&quot;);System.out.println(a&#x3D;&#x3D;b);    &#x2F;&#x2F;比较1System.out.println(a&#x3D;&#x3D;c);     &#x2F;&#x2F;比较2\n结果是：\ntrue\nfalse\n解释：\n\nString a = &quot;aaa&quot;这种方式的时候java首先在内存中寻找&quot;aaa&quot;字符串，如果有，就把aaa的地址给它，如果没有则创建。因此比较1结果返回true;\nString c = new String(“aaa”)这种方式不论内存中是否存在“aaa”都会开辟一个新的空间来存储c对象，比较2两个引用的地址是不一样的，因此返回false;\n\nequals()\n针对对象而言，equals()和==效果是一样的。但是有一个这样的需求：发新书的时候，两个同学都发了一本语文书，这时候根据书的外观和内容我们可以说这两本语文书是一样的。这里的equals()比较的是两个对象的某些属性值是否相等从而判断两个对象(内容)是否相等。\n123String c &#x3D; new string(&quot;aaa&quot;);String d &#x3D; new String(&quot;aaa&quot;);System.out.println(c.equals(d));\n结果是：\ntrue\n深入源码能够发现String类中equals()方法已经进行重写过了。另外JDK中基本数据类型的包装类中equals()方法也已经重写过了，比较的时候都是比较的两个对象的值。\n为什么重写equals()\n就像上边的需求，有些时候仅仅是两个对象的某些属性相同就认为两个对象一样，这个时候我们一般要重写对象的equals()方法，重写的目的就是根据某些特定的属性来判断两个对象的是否相等。\n在重写equals方法时，要注意满足离散数学上的特性：\n\n自反性 ：对任意引用值X，x.equals(x)的返回值一定为true；\n对称性： 对于任何引用值x,y,当且仅当y.equals(x)返回值为true时，x.equals(y)的返回值一定为true;\n传递性：如果x.equals(y)=true, y.equals(z)=true,则x.equals(z)=true；\n一致性：如果参与比较的对象没任何改变，则对象比较的结果也不应该有任何改变；\n非空性：任何非空的引用值X，x.equals(null)的返回值一定为false；\n\nhashCode()\nhashCode()返回的是一个hashCode（hash码），hash码主要用于散列对象作为KEY来标示这个对象的存储位置，功能类似索引一样能够快速查找提取对象。由此可知每个对象的hash码是唯一的（在对象的内存地址基础上经过特定算法返回一个hash码）。\n为什么重写hashcode()\n一般情况下我们是不需要重写hashcode()的，Object.hashCode生成规则也有通用约定：\n\n在一个应用程序执行期间，如果一个对象的equals方法做比较所用到的信息没有被修改的话，那么，对该对象调用hashCode方法多次，它必须始终如一地返回 同一个整数。在同一个应用程序的多次执行过程中，这个整数可以不同，即这个应用程序这次执行返回的整数与下一次执行返回的整数可以不一致。\n如果两个对象根据equals(Object)方法是相等的，那么调用这两个对象中任一个对象的hashCode方法必须产生同样的整数结果。\n如果两个对象根据equals(Object)方法是不相等的，那么调用这两个对象中任一个对象的hashCode方法，不要求必须产生不同的整数结果。然而，程序员应该意识到这样的事实，对于不相等的对象产生截然不同的整数结果，有可能提高散列表（hash table）的性能。\n\n上边可用一句话说明：我们认为两个对象相同，则两个对象的hashcode必定一样。我们重写equals()方法仅仅是判定若干个属性是否相等（这两个对象默认不重写情况下有可能是不一样的，hashcode默认也是不一样），所以要重写hashcode令其在若干属性相等下也一样。\n一般我们在集合（例如list）中存对象时hashcode所扮演的角色并不重要，但是当对象需要放在HashTable、HashMap、HashSet等hash结构的集合时候，我们如果重写equals()方法必须就重写hashcode()方法，因为在hash结构的集合中存储对象就是通过hash算法来散列对象的。假如这里有一些箱子(bucket，一个bucket可存放多个元对象，参考HashMap原理)，hash码可以看成每一个箱子指定的编码，每一个元对象就是根据箱子的编码存入每一个箱子的，所有的箱子加起来就是一个HashSet，HashMap，或 Hashtable对象。当我们想找某一个元对象的时候，我们必须先指定他所在那个箱子的hash码，才能找到那个箱子，然后根据对象的值从那个箱子中拿到这个对象。所以得出的结论是：\n在java集合中判断两个对象是否相同，先判断两个对象的hashcode是否相等，再采用equals()判断两个对象的值是否相等。即：\n\n如果x.equals(y)返回“true”，那么x和y的hashCode()必须相等。\n如果x.equals(y)返回“false”，那么x和y的hashCode()有可能相等，也有可能不等。\n\nequals()和hashcode()重写\n由上可知我们equals()和hashcode()的方法重写是成对的，重写equals()方法必须重写hashcode()方法。\nequals()方法的重写规则：\n\n使用instanceof操作符检查“实参是否为正确的类型”。\n对于类中的每一个“关键域”，检查实参中的域与当前对象中对应的域值。\n[2.1]对于非float和double类型的原语类型域，使用==比较；\n[2.2]对于对象引用域，递归调用equals方法；\n[2.3]对于float域，使用Float.floatToIntBits(afloat)转换为int，再使用==比较；\n[2.4]对于double域，使用Double.doubleToLongBits(adouble) 转换为int，再使用==比较；\n[2.5]对于数组域，调用Arrays.equals方法。\n\nhashcode()方法的重写规则：\n\n把某个非零常数值，例如17，保存在int变量result中；\n对于对象中每一个关键域f（指equals方法中考虑的每一个域）：\n[2.1]boolean型，计算(f ? 0 : 1);\n[2.2]byte,char,short型，计算(int);\n[2.3]long型，计算(int) (f ^ (f&gt;&gt;&gt;32));\n[2.4]float型，计算Float.floatToIntBits(afloat);\n[2.5]double型，计算Double.doubleToLongBits(adouble)得到一个long，再执行[2.3];\n[2.6]对象引用，递归调用它的hashCode方法;\n[2.7]数组域，对其中每个元素调用它的hashCode方法。\n将上面计算得到的散列码保存到int变量c，然后执行 result=37*result+c;\n返回result。\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class TestBean &#123;    private int mInt;    private short mShort;    private char mChar;    private byte mByte;    private boolean mBoolean;    private long mLong;    private float mFloat;    private double mDouble;    private Object mObject;    private TestBean[] mArray;    @Override    public boolean equals(Object o) &#123;        if (this == o) return true;        if (o == null || !(o instanceof TestBean)) return false;        TestBean tb = (TestBean) o;        return tb.mInt == mInt                &amp;&amp;tb.mShort == mShort                &amp;&amp; tb.mChar == mChar                &amp;&amp; tb.mByte == mByte                &amp;&amp; tb.mBoolean == mBoolean                &amp;&amp; tb.mLong == mLong                &amp;&amp; Float.floatToIntBits(tb.mFloat) == Float.floatToIntBits(mFloat)                &amp;&amp; Double.doubleToLongBits(tb.mDouble) == Double.doubleToLongBits(mDouble)                &amp;&amp; ((tb.mObject != null &amp;&amp; tb.mObject.equals(mObject)) || (tb.mObject == null &amp;&amp; mObject == null))                &amp;&amp; Arrays.equals(mArray, tb.mArray);    &#125;    @Override    public int hashCode() &#123;        int result = 17;        result = 31 * result + mInt;        result = 31 * result + (int) mShort;        result = 31 * result + (int) mChar;        result = 31 * result + (int) mByte;        result = 31 * result + (mBoolean ? 0 : 1);        result = 31 * result + (int) (mLong ^ (mLong &gt;&gt;&gt; 32));        result = 31 * result + Float.floatToIntBits(mFloat);        long doubleToLong = Double.doubleToLongBits(mDouble);        result = 31 * result + (int) (doubleToLong ^ (doubleToLong &gt;&gt;&gt; 32));        result = 31 * result + mObject.hashCode();        for (int i = 0; i &lt; mArray.length; i++) &#123;            result = 31 * result + mArray[i].hashCode();        &#125;        return result;    &#125;&#125;\n这里的31和17仅仅作为一个因子，其实取什么值都可以的，hashcode是一个对象存储位置的标示，因子取值的标准就是最终的得到的结果要尽可能的分散。至于为什么都是取的31，这里大概有这几个原因：\n\n31是一个奇素数，奇素数作用就是如果我用一个数字来乘以这个素数，那么最终的出来的结果只能被素数本身和被乘数还有1来整除！。(减少冲突)\n31可以由i*31== (i&lt;&lt;5)-1来表示,现在很多虚拟机里面都有做相关优化.（提高算法效率）\n选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突）\n并且31只占用5bits,相乘造成数据溢出的概率较小。\n\n参考\n\n《Effective Java第二版》\nhttps://juejin.im/entry/5968876df265da6c232898c2\n\n","plink":"https://blog.ixin.run/posts/1481187426/"},{"title":"Android开发序列化Serializable和Parcelable对比和抉择","date":"2016-12-01T12:51:57.000Z","date_formatted":{"ll":"2016年12月1日","L":"2016/12/01","MM-DD":"12-01"},"updated":"2021-01-29T12:51:44.637Z","content":"说起序列化想必都不陌生，无论是远程传输，还是本地存储，只要涉及到二进制流的问题都需要序列化，Android中涉及到的序列化方式有两种：Serializable和Parcelable，本片就针对这两种简单介绍一下。\n\n首先说明序列化是干什么的？\n序列化的作用就是保存一些在内存中的对象的状态，例如当前对象有哪些属性？这些属性此刻的值都有哪些？序列化后我们可以将此刻这种状态下的对象随意传递或者保存到本地文件或者网络传输到远程，并且经过传递后我们还能读出定格在那一刻状态下的相关属性和属性值。另外序列化还有一个好处，就是将对象转化成字节流，传输更加快速。\n什么情况下需要序列化?\n\n想把内存中的对象保存到文件中或者数据库。\n想用套接字在网络上传输此对象（例如聊天内容的传递）。\n想通过RMI(远程方法调用机制)传递对象。\n在Android开发时，Activity间某个状态下对象的传递。\n\n注意以下两点\n\n当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；\n当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；\n\n性能和抉择\nAndroid开发序列化有两种方式：Serializable和Parcelable，Serializable是java中固有的序列化接口，而Parcelable是Android开发中固有的，其设计初衷就是因为Serializable效率太慢的问题。\nSerializable接口是一种标识接口（marker interface，只声明接口不声明方法），这意味着无需实现方法，Java便会对这个对象进行高效的序列化操作。这种方法的缺点是使用了反射，序列化的过程较慢。这种机制会在序列化的时候创建许多的临时对象，容易触发垃圾回收。Parcelable比Serializable传输速度上快十多倍。\nParcelable的性能比Serializable好，因为前者是在内存上进行序列，所以在内存间数据传输时推荐使用Parcelable，如activity间传输数据；而对于持久化，Serializable可将数据持久化方便保存，所以在需要保存或网络传输数据时选择Serializable，不推荐使用Parcelable进行数据持久化操作。\nSerializable使用\nSerializable使用非常简单，在需要序列化的实体类实现Serializable接口即可。\n定义Serializable类\n1234567891011121314151617181920212223242526public class StudentBean implements Serializable&#123;    private static final long serialVersionUID = -627728343585474443L;    private String studentName;    private int studentAge;    public StudentBean(String studentName, int studentAge) &#123;        this.studentName = studentName;        this.studentAge = studentAge;    &#125;    public String getStudentName() &#123;        return studentName;    &#125;    public void setStudentName(String studentName) &#123;        this.studentName = studentName;    &#125;    public int getStudentAge() &#123;        return studentAge;    &#125;    public void setStudentAge(int studentAge) &#123;        this.studentAge = studentAge;    &#125;&#125;\nSerializable在activity之间传值有两种方式：\n第一种传值取值方式：\n12345678910111213//传值StudentBean studentBean = new StudentBean(&quot;张三&quot;,18);Bundle bundle = new Bundle();bundle.putSerializable(&quot;student&quot;,studentBean);Intent intent  = new Intent(MainActivity.this,OtherActivity.class);intent.putExtras(bundle);startActivity(intent);//取值Intent intent = getIntent();Bundle bundle = intent.getExtras();StudentBean studentBean = (StudentBean) bundle.get(&quot;student&quot;);Toast.makeText(this,&quot;名字是：&quot;+studentBean.getStudentName()+&quot;,年龄是：&quot;+studentBean.getStudentAge(),Toast.LENGTH_LONG).show();\n第二种传值取值方式：\n12345678910//传值StudentBean studentBean = new StudentBean(&quot;张三&quot;,18);Intent intent  = new Intent(MainActivity.this,OtherActivity.class);intent.putExtra(&quot;student&quot;,studentBean);startActivity(intent);//取值Intent intent = getIntent();StudentBean studentBean = (StudentBean) intent.getSerializableExtra(&quot;student&quot;);Toast.makeText(this,&quot;名字是：&quot;+studentBean.getStudentName()+&quot;,年龄是：&quot;+studentBean.getStudentAge(),Toast.LENGTH_LONG).show();\n这两种内部实现机制是一样的，第一种采用面向对象的写法显的更加规整。\nSerialVersionUID\n一般实现Serializable类中都会添加一个serialVersionUID，他的作用是一个标识。例如我们需要向硬盘中写入一个对象，如果第二次写入的时候我把这个对象的某个属性删掉或者又添加一个新属性，此时把serialVersionUID进行改变，然后进行写入就不行了，报异常错误，道理很简单：两个实体虽然名字一样，可是版本不一样，系统当然不认。\n其实每次向硬盘写入的时候，同时也会记录当前对象的序列化serialVersionUID的，如果serialVersionUID已存在，再次写入的时候就是看serialVersionUID是否一致，一致就写入，不一致就报异常不让写入。serialVersionUID属于long型，有两种写法：一种是自己定义，另外一种是系统根据类型属性等合成的一个序列值。推荐使用后者，eclipse中如果没有写serialVersionUID会提示让添加的。AndroidStudio默认提示功能关闭的，我们可以这样打开：\n\nFile -&gt; Settings… -&gt; Editor -&gt; Inspections -&gt; Serialization issues[在java类目下] -&gt; Serializable class without ‘serialVersionUID’（选中）\n进入实现了Serializable中的类，选中类名，Alt+Enter弹出提示，然后直接导入完成。\n\nTransient的使用\n有些时候我们并不想让某个元素进行jvm默认序列化，可以采用transient来修饰，例如:private transient int studentAge;\n但有些时候我们又想自己序列化这个元素怎么办？除了用transient来修饰这个元素外，还要在类中进行写入读取签名：\n12345678private void writeObject(ObjectOutputStream stream) throws IOException &#123;    stream.defaultWriteObject(); //把jvm能默认序列化的元素进行序列化操作    stream.writeInt(studentAge); //自己完成studentAge的序列化操作&#125;private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException &#123;    stream.defaultReadObject(); //把jvm能默认反序列化的元素进行反序列化操作    studentAge = stream.readInt(); //自己完成studentAge的反序列操作&#125;\n有同学可能会说，“你似不似洒”，不让默认序列化操作而自己确序列化操作，这不是多此一举嘛。按照其表面确实是多此一举，但是有些情况下这样操作的目的是可以提高读写效率，或者还有其他用途，反正签名是自己写的。我们可以查看ArrayList的源码：\nArrayList中有两个成员变量：\n123456789/** * The number of elements in this list. */int size;/** * The elements in this list, followed by nulls. */transient Object[] array;\n签名是这样的：\n1234567891011121314151617181920private void writeObject(ObjectOutputStream stream) throws IOException &#123;    stream.defaultWriteObject();    stream.writeInt(array.length);   //对数组长度又序列化一遍    for (int i = 0; i &lt; size; i++) &#123;        stream.writeObject(array[i]);  //将默认不能序列化的数组元素一一序列化    &#125;&#125;private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException &#123;    stream.defaultReadObject();    int cap = stream.readInt();   //将数组长度进行反序列化    if (cap &lt; size) &#123;        throw new InvalidObjectException(                &quot;Capacity: &quot; + cap + &quot; &lt; size: &quot; + size);    &#125;    array = (cap == 0 ? EmptyArray.OBJECT : new Object[cap]);    for (int i = 0; i &lt; size; i++) &#123;        array[i] = stream.readObject();   //将默认不能反序列化的数组元素一一反序列化    &#125;&#125;\n从源码可以看出ArrayList的序列化操作是只序列化有效长度的数组元素，同样反序列化操作也是只反序列化有效长度的数组元素。这样很明显在序列化和反序列化操作的时候更加快速，效率更高。\nParcelable的使用：\nParcelable在代码编写上相比Serializable稍微有点复杂，但是考虑到性能优化上该麻烦的时候要勇于去麻烦。\n实现Parcelable要实现四步\n\n重写writeToParcel用于写入数据进行保存。\n重写describeContents用于标记对象中是否含有文件描述符。因为一旦有文件标识符我们就可以获取文件的内容了，这在对象传输过程中是禁止的，很容易产生漏洞，如果有文件标识符我们返回CONTENTS_FILE_DESCRIPTOR,一般默认返回0即可。\n实例化静态内部类对象CREATOR实现接口Parcelable中的接口Creator，修饰符必须是public static final，并且对象名必须是CREATOR,并重写接口中的两个方法:createFromParcel和newArray。前者实现从Parcel容器中读取传递的数据值并封装成Parcelable对象返回逻辑层供对象的数据读取；后者返回一个size大小的新数组。\n根据CREATOR中重写的方法createFromParcel()返回对象Parcel流，并读取数据。\n\n工作机制\n存的时候通过writeToParcel保存对象数据将此刻的对象映射成Parcel流，读的时候通过CREATOR中的实现方法createFromParcel将Parcel流转化成此刻的该类的对象，进而可以得到对象的属性值。存对象和读对象并没有像字典一样有一个标记来进行读取，所以我们只能根据前后顺序保持一致这样的标准来准确读取了。\n定义Parcelable类\n注意一点就是boolean类型，因为Parcel类中没有针对boolean类型的封装，所以这里我们要变换一种写法了。另外AndroidStudio有一个插件：Android parcelable code generator。使用和GsonFormat类似，使用前只需要定义好类中各个属性名即可。\nParcelable类实现如下：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class ChildBean implements Parcelable &#123;    private int childNumber;    private String familyName;    private boolean isLove;    public ChildBean(int num,String familyName,boolean isLove)&#123;        this.childNumber = num;        this.familyName = familyName;        this.isLove = isLove;    &#125;    public String getFamilyName() &#123;        return familyName;    &#125;    public void setFamilyName(String familyName) &#123;        this.familyName = familyName;    &#125;    public boolean isLove() &#123;        return isLove;    &#125;    public void setLove(boolean love) &#123;        isLove = love;    &#125;    public int getChildNumber() &#123;        return childNumber;    &#125;    public void setChildNumber(int childNumber) &#123;        this.childNumber = childNumber;    &#125;    /**     * 写数据进行保存     * @param dest     * @param flags     */    @Override    public void writeToParcel(Parcel dest, int flags) &#123;        dest.writeInt(this.childNumber);        dest.writeString(this.familyName);        dest.writeByte(this.isLove ? (byte) 1 : (byte) 0);    &#125;    @Override    public int describeContents() &#123;        return 0;    &#125;    public static final Creator&lt;ChildBean&gt; CREATOR = new Creator&lt;ChildBean&gt;() &#123;        @Override        public ChildBean createFromParcel(Parcel in) &#123;            return new ChildBean(in);        &#125;        @Override        public ChildBean[] newArray(int size) &#123;            return new ChildBean[size];        &#125;    &#125;;    /**     * 读数据进行恢复     * @param in     */    protected ChildBean(Parcel in) &#123;        this.childNumber =  in.readInt();        this.familyName = in.readString();        this.isLove = in.readByte() != 0;    &#125;&#125;\nParcelable类传值取值\n12345678910//传值ChildBean childBean = new ChildBean(18,&quot;张三&quot;,true);Intent intent  = new Intent(MainActivity.this,OtherActivity.class);intent.putExtra(&quot;child&quot;,childBean);startActivity(intent);//取值Intent intent = getIntent();ChildBean childBean = (ChildBean) intent.getParcelableExtra(&quot;child&quot;);Toast.makeText(this,&quot;个数是：&quot;+childBean.getChildNumber()+&quot;,家庭是：&quot;+childBean.getFamilyName()+&quot;,有爱吗：&quot;+childBean.isLove(),Toast.LENGTH_LONG).show();","plink":"https://blog.ixin.run/posts/1480596660/"},{"title":"Android开发图片缓存框架Glide的总结","date":"2016-11-30T12:21:56.000Z","date_formatted":{"ll":"2016年11月30日","L":"2016/11/30","MM-DD":"11-30"},"updated":"2021-01-29T12:51:44.636Z","content":"前段时间写过一篇图片缓存框架Picasso的用法，对于Picasso有些同学也比较熟悉，采用Lru最近最少缓存策略，并且自带内存和硬盘缓存机制，在图片加载尤其是多图加载着实为大伙省了不少力，在此之前同样也相识有Afinal、Xutil、UniversalImageLoader等优秀的开源框架，今天再总结一个图片加载缓存框架 — Glide，以助自己后边的项目构建舔砖加瓦吧。\n\nGlide简介\nGlide是一个快速高效的开源媒体和图片加载框架，他把媒体解码、内存和磁盘二级缓存还有一些资源缓存池封装成一个个简单的接口，使用很方便，并且Glide也是google推荐使用的图片加载框架。Glide支持下载、解码、展示视频快照和图片资源以及GIF动画，Glide支持插件扩展并使用于任何网络网络引擎，默认情况下采用的是HttpUrlconnection网络加载形式，当然也可以采用Google的volley框架和Square的OkHttp来取代。\nGlide官方说明：https://github.com/bumptech/glide\nGlide特点\n\n使用简单\n可配置度高，自适应程度高\n支持常见图片格式 Jpg png gif webp\n支持多种数据源  网络、本地、资源、Assets 等\n高效缓存策略    支持Memory和Disk图片缓存 默认Bitmap格式采用RGB_565内存使用至少减少一半\n生命周期集成   根据Activity/Fragment生命周期自动管理请求\n高效处理Bitmap  使用Bitmap Pool使Bitmap复用，主动调用recycle回收需要回收的Bitmap，减小系统回收压力\n\nGlide和Picasso对比\nGlide和Picasso在使用上非常相似，之前也总结过Picasso,发现在某些地方甚至可以完全模仿Picasso写Glide，不过二者在核心上还是有一定区别的：\n\nPicasso接收的上下文是Context,而Glide传入的上下文可以有Context、Activity、Fragment。Activity和Fragment有生命周期，因此在某个生命周期阶段图片加载也响应收到控制，更灵活。另外在某些情况下也避免了对象未进行引用而造成的内存泄漏问题。\nGlide默认的图片格式RGB565而Picasso支持的图片格式ARGB8888,尽管前者没有后者图像更清晰（相差不大），但是在内存开销上却比前者少了一半，加载更快\nGlide默认对图片缓存仅仅是展示控件的大小，如果在另外一个不同大小控件上加载相同的图片需要再次下载。Picasso缓存的图片默认是原图，可对原图进行随处展示。\nGlide支持媒体解码，支持GIF动画加载，Picasso不能。\nGlide和Picasso区别不止以上这些，以上只是些典型的区别。对于Glide的使用，下边一一道来。\n\nGlide的基础用法\n1.glide项目引用\n对于Glide这么强大的开源框架，又是google推荐的早已加入到jcenter()仓库中了，所以我们使用的时候只需要在gradle中引用一下仓库的包即可：\n1compile &#39;com.github.bumptech.glide:glide:3.7.0&#39;\n2.绑定生命周期，让Glide加载图片过程根据生命周期管理。\n上边也提到Glide可以根据多种形式绑定上下文，尤其是针对Activity的引用，可用于在生命周期内对图片加载进行控制。\n1234Glide.with(Context context);&#x2F;&#x2F; 绑定ContextGlide.with(Activity activity);&#x2F;&#x2F; 绑定ActivityGlide.with(FragmentActivity activity);&#x2F;&#x2F; 绑定FragmentActivityGlide.with(Fragment fragment);&#x2F;&#x2F; 绑定Fragment\n3.简单加载（这里也可以加载本地和asset，可参考Picasso的简单用法）。\n1Glide.with(this).load(imageUrl).into(imageView);\n4.设置加载前和加载失败时的图片\n1Glide.with(this).load(imageUrl).placeholder(R.mipmap.ic_launcher).error(R.mipmap.ic_launcher).into(imageView);\n5.设置下载优先级\n1Glide.with(this).load(imageUrl).priority(Priority.NORMAL).into(imageView);\n6.设置内存缓存（是否进行内存缓存）\n1Glide.with(this).load(imageUrl).skipMemoryCache(true).into(imageView);\n7.设置磁盘缓存\n1Glide.with(this).load(imageUrl).diskCacheStrategy(DiskCacheStrategy.ALL).into(imageView);\n磁盘缓存策略说明：\n\nALL:缓存源资源和转换后的资源\nNONE:不作任何磁盘缓存\nSOURCE:缓存源资源\nRESULT:缓存转换后的资源\n\n8.设置加载动画\napi中默认也存在动画，这里可以自己设置，并且也支持属性动画\n1Glide.with(this).load(imageUrl).animate(R.anim.item_alpha_in).into(imageView);\n设置淡入动画\n1234Glide.with(this).load(imageUrl).crossFade(1000)        &#x2F;&#x2F;设置淡入动画，并且淡入过度时间为1秒.override(80,80)         &#x2F;&#x2F;最终呈现的像素值80*80.into(imageView3);\n9.设置缩略图\n1Glide.with(this).load(imageUrl).thumbnail(0.1f).into(imageView); &#x2F;&#x2F;显示的图片大小为原图的1&#x2F;10\n10.设置加载尺寸(像素)\n1Glide.with(this).load(imageUrl).override(800, 800).into(imageView);\n11.设置图片适配和转换\nApi提供了centerCrop()、fitCenter()两种适配方式，前者效果是将图片按照最小边充满，最大边裁剪适配，后者效果是将图片按照最大边充满最小边居中空缺适配。\n1Glide.with(this).load(imageUrl).centerCrop().into(imageView);\n也可以自定义Transformation来设置自己的形状，如设置圆角图形，圆角半径单位是dp：\n12345678910111213141516171819202122232425262728293031323334353637public class GlideRoundTransform extends BitmapTransformation &#123;        private float radius = 0f;        public GlideRoundTransform(Context context) &#123;            this(context, 4);        &#125;        public GlideRoundTransform(Context context, int dp) &#123;            super(context);            this.radius = Resources.getSystem().getDisplayMetrics().density * dp;        &#125;        @Override        protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123;            return roundCrop(pool, toTransform);        &#125;        private Bitmap roundCrop(BitmapPool pool, Bitmap source) &#123;            if (source == null) return null;            Bitmap result = pool.get(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);            if (result == null) &#123;                result = Bitmap.createBitmap(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);            &#125;            Canvas canvas = new Canvas(result);            Paint paint = new Paint();            paint.setShader(new BitmapShader(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP));            paint.setAntiAlias(true);            RectF rectF = new RectF(0f, 0f, source.getWidth(), source.getHeight());            canvas.drawRoundRect(rectF, radius, radius, paint);            return result;        &#125;        @Override        public String getId() &#123;            return getClass().getName() + Math.round(radius);        &#125;    &#125;\n设置圆角图片：\n12Glide.with(this).load(imageUrl).transform(newGlideRoundTransform(this,100)).into(imageView);\n也可以自定义圆形图片：\n1234567891011121314151617181920212223242526272829303132333435363738394041public class GlideCircleTransform extends BitmapTransformation &#123;    public GlideCircleTransform(Context context) &#123;        super(context);    &#125;    @Override    protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123;        return circleCrop(pool, toTransform);    &#125;    private static Bitmap circleCrop(BitmapPool pool, Bitmap source) &#123;        if (source == null) return null;        //获取最小边长        int size = Math.min(source.getWidth(), source.getHeight());        //获取圆形图片的宽度和高度        int x = (source.getWidth() - size) / 2;        int y = (source.getHeight() - size) / 2;        // TODO this could be acquired from the pool too        Bitmap squared = Bitmap.createBitmap(source, x, y, size, size);        Bitmap result = pool.get(size, size, Bitmap.Config.ARGB_8888);        if (result == null) &#123;            result = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888);        &#125;        Canvas canvas = new Canvas(result);        Paint paint = new Paint();        paint.setShader(new BitmapShader(squared, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP));        paint.setAntiAlias(true);        float r = size / 2f;   //得到圆形半径        canvas.drawCircle(r, r, r, paint);        return result;    &#125;    @Override    public String getId() &#123;        return getClass().getName();    &#125;&#125;\n设置圆形图片：\n1Glide.with(this).load(imageUrl).transform(new GlideCircleTransform(this)).into(imageView);\n12.设置要下载的内容\n有些时候我们不想直接将加载的图片显示到控件上，或者我们想下载这张图片，又或者我们暂时不想在此处展示这张图片，可以这样处理：\n123456Glide.with(this).load(imageUrl).centerCrop().into(new SimpleTarget&lt;GlideDrawable&gt;() &#123;            @Override            public void onResourceReady(GlideDrawable resource, GlideAnimation&lt;? super GlideDrawable&gt; glideAnimation) &#123;                &#x2F;&#x2F;这里可根据resource自行处理（下载...）            &#125;        &#125;);\n13.设置监听请求接口\n123456789101112Glide.with(this).load(imageUrl).listener(new RequestListener&lt;String, GlideDrawable&gt;() &#123;            @Override            public boolean onException(Exception e, String model, Target&lt;GlideDrawable&gt; target, boolean isFirstResource) &#123;                return false;            &#125;            @Override            public boolean onResourceReady(GlideDrawable resource, String model, Target&lt;GlideDrawable&gt; target, boolean isFromMemoryCache, boolean isFirstResource) &#123;                &#x2F;&#x2F;imageView.setImageDrawable(resource);                return false;            &#125;        &#125;).into(imageView);\n14.设置GIF加载方式\n12Glide.with(this).load(imageUrl).asBitmap().into(imageView);&#x2F;&#x2F;显示gif静态图片Glide.with(this).load(imageUrl).asGif().into(imageView);&#x2F;&#x2F;显示gif动态图片\n15.缓存动态清理\n12Glide.get(this).clearDiskCache(); &#x2F;&#x2F;清理磁盘缓存Glide.get(this).clearMemory(); &#x2F;&#x2F;清理内存缓存\nGlide的高级用法\nGlide内部有一个GlideModule,是用来全局配置Glide的，可进行设置缓存路径，缓存空间，图片格式，自定义cache指示等操作。\n1.GlideModule添加\n自定义一个GlideModule :\n123456789public class MyGlideModule implements GlideModule &#123;    @Override public void applyOptions(Context context, GlideBuilder builder) &#123;        // Apply options to the builder here.    &#125;    @Override public void registerComponents(Context context, Glide glide) &#123;        // register ModelLoaders here.    &#125;&#125;\nAndroidManifest.xml注册:\n123456789&lt;manifest ...&gt;    &lt;!-- ... permissions --&gt;    &lt;application ...&gt;        &lt;meta-data            android:name=&quot;com.mypackage.MyGlideModule&quot;            android:value=&quot;GlideModule&quot; /&gt;        &lt;!-- ... activities and other components --&gt;    &lt;/application&gt;&lt;/manifest&gt;\n混淆处理:\n123-keepnames class com.mypackage.MyGlideModule# or more generally:#-keep public class * implements com.bumptech.glide.module.GlideModule\n多个GlideModule冲突问题\n一般情况下我们一个项目可以有多个library项目，这样就可能有多个GlideModule的存在，但是多个GlideModule存在却会出现冲突，为了避免这种情况发生，一般我们尽量只设置一个GlideModule，当然也可在配置清单中忽略某个GlideMoudle：\n1&lt;meta-data android:name&#x3D;”com.mypackage.MyGlideModule” tools:node&#x3D;”remove” &#x2F;&gt;\n2.GlideModule相关配置\n设置Glide内存缓存大小:\n1234int maxMemory &#x3D; (int) Runtime.getRuntime().maxMemory();&#x2F;&#x2F;获取系统分配给应用的总内存大小int memoryCacheSize &#x3D; maxMemory &#x2F; 8;&#x2F;&#x2F;设置图片内存缓存占用八分之一&#x2F;&#x2F;设置内存缓存大小builder.setMemoryCache(new LruResourceCache(memoryCacheSize));\n有些时候我们也需要获取一下默认的内存缓存大小:\n123MemorySizeCalculator calculator &#x3D; new MemorySizeCalculator(context);  int defaultMemoryCacheSize &#x3D; calculator.getMemoryCacheSize();  int defaultBitmapPoolSize &#x3D; calculator.getBitmapPoolSize(); \n设置Glide磁盘缓存大小和磁盘缓存存放位置:\n1234File cacheDir &#x3D; context.getExternalCacheDir();&#x2F;&#x2F;指定的是数据的缓存地址int diskCacheSize &#x3D; 1024 * 1024 * 30;&#x2F;&#x2F;最多可以缓存多少字节的数据&#x2F;&#x2F;设置磁盘缓存大小和位置builder.setDiskCache(new DiskLruCacheFactory(cacheDir.getPath(), &quot;glide&quot;, diskCacheSize));\n也可以：\n1234&#x2F;&#x2F;存放在data&#x2F;data&#x2F;xxxx&#x2F;cache&#x2F;builder.setDiskCache(new InternalCacheDiskCacheFactory(context, &quot;glide&quot;, diskCacheSize));&#x2F;&#x2F;存放在外置文件浏览器builder.setDiskCache(new ExternalCacheDiskCacheFactory(context, &quot;glide&quot;, diskCacheSize));\n设置图片解码格式:\nGlide默认的图片解码格式是RGB_565相比RGB_8888占内存更小，但是却损失了一部分图片质量，需求根据自己定。\n1234&#x2F;&#x2F;设置图片解码格式builder.setDecodeFormat(DecodeFormat.PREFER_ARGB_8888);&#x2F;&#x2F;设置BitmapPool内存缓存大小builder.setBitmapPool(new LruBitmapPool(memoryCacheSize));\n3.使用ModelLoader自定义数据源：\n有些时候我们需要根据不同的情况加载不同格式的图片，可采用工厂模式来进行选取。\n定义处理URL接口\n123public interface IDataModel &#123;    String buildDataModelUrl(int width, int height);&#125;\n实现处理URL接口\nJpgDataModel:\n12345678910111213public class JpgDataModel implements IDataModel &#123;    private String dataModelUrl;    public JpgDataModel(String dataModelUrl) &#123;        this.dataModelUrl = dataModelUrl;    &#125;    @Override    public String buildDataModelUrl(int width, int height) &#123;        //http://78re52.com1.z0.glb.clouddn.com/resource/gogopher.jpg?imageView2/1/w/200/h/200/format/jpg        return String.format(&quot;%s?imageView2/1/w/%d/h/%d/format/jpg&quot;, dataModelUrl, width, height);    &#125;&#125;\nWebpDataModel:\n12345678910111213public class WebpDataModel implements IDataModel &#123;    private String dataModelUrl;    public WebpDataModel(String dataModelUrl) &#123;        this.dataModelUrl = dataModelUrl;    &#125;    @Override    public String buildDataModelUrl(int width, int height) &#123;        //http://78re52.com1.z0.glb.clouddn.com/resource/gogopher.jpg?imageView2/1/w/200/h/200/format/webp        return String.format(&quot;%s?imageView2/1/w/%d/h/%d/format/webp&quot;, dataModelUrl, width, height);    &#125;&#125;\n设置图片加工工厂\n12345678910111213141516171819202122232425262728public class MyDataLoader extends BaseGlideUrlLoader&lt;IDataModel&gt; &#123;    public MyDataLoader(Context context) &#123;        super(context);    &#125;    public MyDataLoader(ModelLoader&lt;GlideUrl, InputStream&gt; urlLoader) &#123;        super(urlLoader, null);    &#125;    @Override    protected String getUrl(IDataModel model, int width, int height) &#123;        return model.buildDataModelUrl(width, height);    &#125;    /**     */    public static class Factory implements ModelLoaderFactory&lt;IDataModel, InputStream&gt; &#123;        @Override        public ModelLoader&lt;IDataModel, InputStream&gt; build(Context context, GenericLoaderFactory factories) &#123;            return new MyDataLoader(factories.buildModelLoader(GlideUrl.class, InputStream.class));        &#125;        @Override        public void teardown() &#123;        &#125;    &#125;&#125;\n根据不同的要求采用不同的策略加载图片\n1234&#x2F;&#x2F;加载jpg图片Glide.with(this).using(new MyDataLoader(this)).load(new JpgDataModel(imageUrl)).into(imageView);&#x2F;&#x2F;加载webp图片Glide.with(this).using(new MyDataLoader(this)).load(new WebpDataModel(imageUrl)).into(imageView);\n这样每次加载都要.using(),我们也可以不用.using(),方法就是将MyDataLoader的工厂注册到GlideModel中：\n12345678public class MyGlideModule implements GlideModule &#123;    ...    @Override    public void registerComponents(Context context, Glide glide) &#123;        glide.register(IDataModel.class, InputStream.class,             new MyUrlLoader.Factory());    &#125;&#125;\n调用：\n1234&#x2F;&#x2F;加载jpg图片Glide.with(this).load(new JpgDataModel(imageUrl)).into(imageView);&#x2F;&#x2F;加载webp图片Glide.with(this).load(new WebpDataModel(imageUrl)).into(imageView);\n以上是个人对Glide的相关总结，Glide功能不止这些，甚或是还可以自定义图片缓存TAG来实现对图片软删除等操作，这些功能在开发中也是微乎其微了，当然Glide开发团队也是想的周到，以实现程序的健壮性。Glide和Picasso有很多相似之处，了解Picasso的同学可以根据Picasso的相关Api很容易上手Glide，返过来也如此，总之后续继续深入吧。\n","plink":"https://blog.ixin.run/posts/1480508516/"},{"title":"Java反射你知道多少","date":"2016-11-20T09:51:14.000Z","date_formatted":{"ll":"2016年11月20日","L":"2016/11/20","MM-DD":"11-20"},"updated":"2021-01-29T12:51:44.658Z","content":"一直想把java反射原理详细的总结一下，昨天看到一位大虾利用许多小栗子阐述的很清楚，我就顺手拈来着手敲了一遍并加以修正补充和说明，以便日后回顾和深入学习。\n\n定义\nJAVA反射机制(JAVA-Reflect)是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。\n功能\nJava反射机制主要提供了以下功能：\n\n在运行时判断任意一个对象所属的类。\n在运行时构造任意一个类的对象。\n在运行时判断任意一个类所具有的成员变量和方法。\n在运行时调用任意一个对象的方法。\n生成动态代理。\n\nClass类的使用\nClass类是什么？\n在面向对象的世界里，万事万物皆对象。其实在java里面有两样东西不是对象。一个是java的普通的数据类型（他们的包装类属于对象），另外一个就是java的静态成员方法或者变量，这个不是对象而是属于某个类。\n我们平时写的每一个类都是对象，而类又是java.long.Class的实例对象。说明白点就是任何一个类即有自己的对象（本身new出来的），同时本身又是Class的实例对象（能够从Class中得到该类的实例）。\n如何得到Class的实例对象？\n先来看看Class类的源码，了解其内部构造：\n12345/* * Constructor. Only the Java Virtual Machine creates Class * objects. */private Class() &#123;&#125;\n由源码可知，Class类的构造方法是私有的，根据注释我们知道只有java虚拟机才能创建Class类的对象，并且是处于运行时创建，因此我们不能在代码中直接new出一个Class对象。此路是不通了，但是我们有其他路可走，这里有三条路：\n我们先创建一个我们自己的类对象：Demo demo = new Demo();\n\n第一条路,通过类的静态成员变量来获取Class类的实例对象（或者叫Demo类的类类型）：Class c = Demo.class;\n另外，基本的数据类型和引用类型以及void关键字都可用此方式得到它们的类类型。\n第二条路,通过类对象中的getClass()方法来获取。Class c = demo.getClass();\n第三条路,通过Class类中的静态方法forName()来获取，此种形式属于动态加载，在代码中我们无法判定正确与否，只有在运行时才能检测出该类是否存在，调用是否正确。\n\n1234567Class c = null;try&#123;    //这里传入的是全路径，包名路径要写全。    c = Class.forName(&quot;Reflect.Demo&quot;);&#125;catch(Exception e)&#123;    e.printStackTrace();&#125;\n静态加载和动态加载\n编译时刻的加载属于静态加载，运行时刻的加载属于动态加载。平时我们采用new创建的对象都是静态加载类，在编译时候就要进行加载，所以只要有一个对象不存在或者方法错误，则其他的对象也都无法加载了，编译就不能通过。而动态加载常常用于在保证整体框架完善编译能够通过，至于我们添加的参数如何也就只能在运行时才能检测出来，一句话：能通过的都过，不能通过的报出来。\n获取相关类的对象\n通过Class类的实例（Demo类的类类型）来获取Demo类的对象。\n1234567891011Demo demo  = null;try &#123;    //这里要进行强转一下，并且也要进行一些异常处理。    demo = (Demo)c.newInstance();&#125; catch (InstantiationException e1) &#123;    // TODO Auto-generated catch block    e1.printStackTrace();&#125; catch (IllegalAccessException e1) &#123;    // TODO Auto-generated catch block    e1.printStackTrace();&#125;\n这里需要注意的是，通过newInstance()调用的是该类的无参构造方法，假如该类中仅仅写有参构造方法，那么默认的无参构造方法将会被覆盖，所以这段代码也就无法运行下去。\n123java.lang.InstantiationException: Demo at java.lang.Class.newInstance(Unknown Source) at Demo.main(Demo.java:8) \n所以我们平时写一个类的时候，如果预计到将来这个可能类要被反射获取，最好在该类中写一个无参构造方法。\n小栗子\n【栗1】通过一个对象获得完整的包名和类名\n123456789101112package com.reflect;public class Test &#123;    public static void main(String[] args) &#123;        Test test =new Test();        Class&lt;?&gt; c = test.getClass();        System.out.println(c.getName());  //获取包含完整路径的类的名称        System.out.println(c.getSimpleName()); //获取不包含包名的类的名称    &#125;&#125;\n【运行结果】：\n12com.reflect.Test Test\n【栗2】实例化Class类对象\n1234567891011121314151617181920212223package com.reflect;public class Test &#123;    public static void main(String[] args) &#123;         Class&lt;?&gt; c1=null;        Class&lt;?&gt; c2=null;        Class&lt;?&gt; c3=null;        try&#123;            //这里采用包名加类名（全路径写法）            c1=Class.forName(&quot;com.reflect.Test&quot;);        &#125;catch(Exception e)&#123;            e.printStackTrace();        &#125;        c2=new Test().getClass();        c3=Test.class;        System.out.println(&quot;类名称   &quot;+c1.getName());        System.out.println(&quot;类名称   &quot;+c2.getName());        System.out.println(&quot;类名称   &quot;+c3.getName());    &#125;&#125;\n【运行结果】：\n123类名称 com.reflect.Test 类名称 com.reflect.Test 类名称 com.reflect.Test\n【栗3】通过Class实例化其他类的对象\n通过无参构造实例化对象\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.reflect;public class Person &#123;    private String name;    private int age;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;[&quot; + this.name + &quot;  &quot; + this.age + &quot;]&quot;;    &#125;&#125;public class Test &#123;    public static void main(String[] args) &#123;        Class&lt;?&gt; c = null;        try &#123;            c = Class.forName(&quot;com.reflect.Person&quot;);        &#125; catch (ClassNotFoundException e) &#123;            // TODO Auto-generated catch block            e.printStackTrace();        &#125;        Person per = null;        try &#123;            per = (Person) c.newInstance();        &#125; catch (InstantiationException e) &#123;            // TODO Auto-generated catch block            e.printStackTrace();        &#125; catch (IllegalAccessException e) &#123;            // TODO Auto-generated catch block            e.printStackTrace();        &#125;        per.setName(&quot;张三&quot;);        per.setAge(18);        System.out.print(per);    &#125;&#125;\n【运行结果】：\n1[张三 18] \n但是注意一下，当我们把Person中的默认的无参构造函数取消的时候，比如自己定义只定义一个有参数的构造函数之后，会出现错误。\n比如我定义了一个构造函数：\n1234public Person(String name, int age) &#123;        this.age=age;        this.name=name;&#125;\n然后继续运行上面的程序，会出现：\n12345java.lang.InstantiationException: com.reflect.Person    at java.lang.Class.newInstance(Unknown Source)    at com.reflect.Test.main(Test.java:16)Exception in thread &quot;main&quot; java.lang.NullPointerException    at com.reflect.Test.main(Test.java:25)\n所以大家以后再编写使用Class实例化其他类的对象的时候，一定要自己定义无参的构造函数\n【栗4】获取某个类的全部构造函数，并根据这些构造函数实例化该类的一个对象\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.reflect;public class Person &#123;    private String name;    private int age;    public Person() &#123;    &#125;    public Person(String name) &#123;        this.name = name;    &#125;    public Person(int age) &#123;        this.age = age;    &#125;    public Person(String name, int age) &#123;        this.age = age;        this.name = name;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;[&quot; + this.name + &quot;  &quot; + this.age + &quot;]&quot;;    &#125;&#125;public class Test&#123;    public static void main(String[] args) &#123;        Class&lt;?&gt; c = null;        try &#123;            c = Class.forName(&quot;com.reflect.Person&quot;);        &#125; catch (ClassNotFoundException e1) &#123;            // TODO Auto-generated catch block            e1.printStackTrace();        &#125;        Person per1 = null;        Person per2 = null;        Person per3 = null;        Person per4 = null;        // 取得全部的构造函数        Constructor&lt;?&gt;[] cons = c.getConstructors();        for (int i = 0; i &lt; cons.length; i++) &#123;            System.out.println(&quot;cons[&quot; + i + &quot;] : &quot;+cons[i]);            //获取每个构造函数的相关参数类型            Class&lt;?&gt; clazzs[] = cons[i].getParameterTypes();            System.out.print(&quot;该构造函数的参数类型有: (&quot;);            for (int j = 0; j &lt; clazzs.length; j++) &#123;                if (j == clazzs.length - 1)                    System.out.print(clazzs[j].getName());                else                    System.out.print(clazzs[j].getName() + &quot;,&quot;);            &#125;            System.out.println(&quot;)&quot;);        &#125;        /*         * 这里需注意：一定要先把所有构造函数获取到，然后根据获取的构造函数进行对号入座正确的去根据特定的构造函数进行实例化对象。         */        try &#123;            per1 = (Person) cons[3].newInstance();            per2 = (Person) cons[2].newInstance(&quot;张三&quot;);            per3 = (Person) cons[1].newInstance(18);            per4 = (Person) cons[0].newInstance(&quot;张三&quot;, 18);        &#125; catch (InstantiationException e) &#123;            // TODO Auto-generated catch block            e.printStackTrace();        &#125; catch (IllegalAccessException e) &#123;            // TODO Auto-generated catch block            e.printStackTrace();        &#125; catch (IllegalArgumentException e) &#123;            // TODO Auto-generated catch block            e.printStackTrace();        &#125; catch (InvocationTargetException e) &#123;            // TODO Auto-generated catch block            e.printStackTrace();        &#125;        System.out.println(per1);        System.out.println(per2);        System.out.println(per3);        System.out.println(per4);    &#125;&#125;\n【运行结果】：\n123456789101112cons[0] : public com.reflect.Person(java.lang.String,int) 该构造函数的参数类型有: (java.lang.String,int) cons[1] : public com.reflect.Person(int) 该构造函数的参数类型有: (int) cons[2] : public com.reflect.Person(java.lang.String) 该构造函数的参数类型有: (java.lang.String) cons[3] : public com.reflect.Person() 该构造函数的参数类型有: () [null 0] [张三 0] [null 18] [张三 18]\n【栗5】 返回某个类的父类和实现的接口：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.reflect;public interface ISay &#123;    String name = &quot;xinrun&quot;;    int age = 18;    public void sayName();    public void sayAge();&#125;public class Test implements ISay&#123;    public static void main(String[] args) &#123;        Class&lt;?&gt; c = null;        try &#123;            c = Class.forName(&quot;com.reflect.Test&quot;);        &#125; catch (ClassNotFoundException e) &#123;            // TODO Auto-generated catch block            e.printStackTrace();        &#125;        Class&lt;?&gt; superClass = c.getSuperclass();        System.out.println(&quot;Test类的父类是：&quot;+superClass.getName());        // 获取该类中实现的所有接口        Class&lt;?&gt; intes[] = c.getInterfaces();        System.out.println(&quot;Test类中实现的所有接口有：&quot;);        for (int i = 0; i &lt; intes.length; i++) &#123;            System.out.println(intes[i].getName());        &#125;    &#125;    @Override    public void sayName() &#123;        // TODO Auto-generated method stub    &#125;    @Override    public void sayAge() &#123;        // TODO Auto-generated method stub    &#125;&#125;\n【运行结果】：\n123Test类的父类是：java.lang.Object Test类中实现的所有接口有： com.reflect.ISay\n【栗6】获取某个类的全部属性以及本类和父类的公有属性\n123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.reflect;public class BaseClass &#123;    public String baseName;    private int baseAge;&#125;public class Test extends BaseClass&#123;    public String testName;    private int testAge;    public static void main(String[] args) &#123;        Class&lt;?&gt; c = null;        try &#123;            c = Class.forName(&quot;com.reflect.Test&quot;);        &#125; catch (ClassNotFoundException e) &#123;            // TODO Auto-generated catch block            e.printStackTrace();        &#125;        System.out.println(&quot;==========获取本类的全部属性==========&quot;);        //仅获取本类的全部属性        Field[] field = c.getDeclaredFields();        for (int i = 0; i &lt; field.length; i++) &#123;            // 获取属性权限修饰符            int mo = field[i].getModifiers();  //每种修饰符都有特定的编号，然后根据编号得到修饰符的名字。            String priv = Modifier.toString(mo);            // 获取属性类型            Class&lt;?&gt; type = field[i].getType();            System.out.println(priv + &quot; &quot; + type.getName() + &quot; &quot; + field[i].getName() + &quot;;&quot;);        &#125;        System.out.println(&quot;==========获取本类和父类的公有属性==========&quot;);        //获取本类和父类的公有属性（public）        Field[] field1 = c.getFields();        for (int i = 0; i &lt; field1.length; i++) &#123;            // 获取属性权限修饰符            int mo = field1[i].getModifiers();            String priv = Modifier.toString(mo);            // 获取属性类型            Class&lt;?&gt; type = field1[i].getType();            System.out.println(priv + &quot; &quot; + type.getName() + &quot; &quot; + field1[i].getName() + &quot;;&quot;);        &#125;       &#125;&#125;\n【运行结果】：\n123456==========获取本类的全部属性========== public java.lang.String testName; private int testAge; ==========获取本类和父类的公有属性========== public java.lang.String testName; public java.lang.String baseName;\n【栗7】通过反射操作属性\n1234567891011121314151617181920package com.reflect;public class BaseClass &#123;    public String baseName;    private int baseAge;&#125;public class Test extends B aseClass &#123;    public String testName;    private int testAge;    public static void main(String[] args) throws Exception &#123;        Class&lt;?&gt; c = Class.forName(&quot;com.reflect.BaseClass&quot;);        Object obj = c.newInstance();          Field field = c.getDeclaredField(&quot;baseAge&quot;);        field.setAccessible(true); // 因BaseClass中的baseAge属性是私有的，所以必须对其“解锁”才能操作，公有属性就无关紧要了        field.set(obj, 1);        System.out.println(&quot;baseAge的值是： &quot;+field.get(obj));    &#125;&#125;\n【运行结果】：\n1baseAge的值是： 1 \n这里需注意一定要事先搞清楚该属性是什么类型才可赋值。\n【栗8】获取某个类的和父类的公有方法以及方法所抛出的异常\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.reflect;public class BaseClass &#123;    public String baseName;    private int baseAge;    private void basePrivateTest()&#123;        System.out.println(&quot;这是BaseClass的私有方法&quot;);    &#125;    public void basePublicTest()&#123;        System.out.println(&quot;这是BaseClass的无参公有方法&quot;);    &#125;    public void basePublicTest(String name,int age) throws Exception&#123;        System.out.println(&quot;这是BaseClass的含参公有方法,名字是：&quot;+name+&quot;，年龄是：&quot;+age);    &#125;&#125;public class Test extends BaseClass&#123;    public String testName;    private int testAge;    public static void main(String[] args) throws Exception &#123;        Class&lt;?&gt; c = Class.forName(&quot;com.reflect.BaseClass&quot;);                //获取该类以及父类的所有公有方法        Method[] methods = c.getMethods();          //获取该类的所有方法        //Method[] methods = c.getDeclaredMethods();         for (int i = 0; i &lt; methods.length; ++i) &#123;            Class&lt;?&gt; returnType = methods[i].getReturnType();            Class&lt;?&gt; para[] = methods[i].getParameterTypes();            int temp = methods[i].getModifiers();            System.out.print(Modifier.toString(temp) + &quot; &quot;);            System.out.print(returnType.getName() + &quot;  &quot;);            System.out.print(methods[i].getName() + &quot; &quot;);            System.out.print(&quot;(&quot;);            for (int j = 0; j &lt; para.length; ++j) &#123;                System.out.print(para[j].getName() + &quot; &quot; + &quot;arg&quot; + j);                if (j &lt; para.length - 1) &#123;                    System.out.print(&quot;,&quot;);                &#125;            &#125;            //获取该方法的所有异常类            Class&lt;?&gt; exce[] = methods[i].getExceptionTypes();            if (exce.length &gt; 0) &#123;                System.out.print(&quot;) throws &quot;);                for (int k = 0; k &lt; exce.length; ++k) &#123;                    System.out.print(exce[k].getName() + &quot; &quot;);                    if (k &lt; exce.length - 1) &#123;                        System.out.print(&quot;,&quot;);                    &#125;                &#125;            &#125; else &#123;                System.out.print(&quot;)&quot;);            &#125;            System.out.println();        &#125;    &#125;&#125;\n【运行结果】：\n1234567891011public void basePublicTest (java.lang.String arg0,int arg1) throws java.lang.Exception public void basePublicTest () public final native void wait (long arg0) throws java.lang.InterruptedException public final void wait () throws java.lang.InterruptedException public final void wait (long arg0,int arg1) throws java.lang.InterruptedException public final native java.lang.Class getClass () public native int hashCode () public boolean equals (java.lang.Object arg0) public java.lang.String toString () public final native void notifyAll () public final native void notify ()\n【栗9】调用其他类的方法\n1234567891011121314public class Test extends BaseClass &#123;    public String testName;    private int testAge;    public static void main(String[] args) throws Exception &#123;        Class&lt;?&gt; c = Class.forName(&quot;com.reflect.BaseClass&quot;);        //调用BaseClass中的无参方法        Method method = c.getMethod(&quot;basePublicTest&quot;);        method.invoke(c.newInstance());        //调用BaseClass中的有参方法        Method method1 = c.getMethod(&quot;basePublicTest&quot;, String.class, int.class);        method1.invoke(c.newInstance(), &quot;张三&quot;, 18);    &#125;&#125;\n【运行结果】：\n12这是BaseClass的无参共有方法 这是BaseClass的含参共有方法,名字是：张三，年龄是：18\n【栗10】通过反射取得并修改数组的信息和数组大小\n12345678910111213141516171819202122232425262728293031323334353637383940414243package com.reflect;import java.lang.reflect.Array;public class Test extends BaseClass &#123;    public static void main(String[] args) throws Exception &#123;        int[] temp = &#123; 0, 1, 2, 3, 4 &#125;;        System.out.println(&quot;======================获取数组信息===========&quot;);        Class&lt;?&gt; ctC = temp.getClass().getComponentType();        System.out.println(&quot;数组类型： &quot; + ctC.getName());        System.out.println(&quot;数组长度  &quot; + Array.getLength(temp));        System.out.println(&quot;数组的第一个元素: &quot; + Array.get(temp, 0));        Array.set(temp, 0, 100);        System.out.println(&quot;修改之后数组第一个元素为： &quot; + Array.get(temp, 0));        System.out.println(&quot;=======================扩大数组长度===========&quot;);        int[] newTemp = (int[]) arrayInc(temp, 15);        print(newTemp);    &#125;    // 修改数组大小    public static Object arrayInc(Object obj, int len) &#123;        Class&lt;?&gt; arr = obj.getClass().getComponentType();        Object newArr = Array.newInstance(arr, len);        int co = Array.getLength(obj);        System.arraycopy(obj, 0, newArr, 0, co);        return newArr;    &#125;    // 打印新数组    public static void print(Object obj) &#123;        Class&lt;?&gt; c = obj.getClass();        if (!c.isArray()) &#123;            return;        &#125;        System.out.println(&quot;扩展后的数组长度为： &quot; + Array.getLength(obj));        System.out.println(&quot;扩展后的数组为：&quot;);        for (int i = 0; i &lt; Array.getLength(obj); i++) &#123;            System.out.print(Array.get(obj, i) + &quot; &quot;);        &#125;        System.out.println();    &#125;&#125;\n【运行结果】：\n123456789======================获取数组信息=========== 数组类型： int 数组长度 5 数组的第一个元素: 0 修改之后数组第一个元素为： 100 =======================扩大数组长度=========== 扩展后的数组长度为： 15 扩展后的数组为： 100 1 2 3 4 0 0 0 0 0 0 0 0 0 0\n【栗11】动态代理\n首先来看看如何获得类加载器：\n12345678package com.reflect;public class Test &#123;    public static void main(String[] args)&#123;        Test test = new Test();        System.out.println(&quot;类加载器是：&quot;+test.getClass().getClassLoader().getClass().getName());    &#125;&#125;\n【运行结果】：\n1类加载器是：sun.misc.Launcher$AppClassLoader\n在java中有四类加载器：\n1） Bootstrap ClassLoader 负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类。\n2） Extension ClassLoader 用来进行扩展类的加载，一般对应的是jre\\lib\\ext目录中的类。\n3） AppClassLoader 加载classpath指定的类，是最常用的加载器。同时也是java中默认的加载器。\n4） Custom ClassLoader 属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader。\n这一块涉及到JVM的执行和类的生命周期以及类的加载过程，后续专门详细总结一下。\n代理是java设计模式中的一种，分为静态代理和动态代理。什么是代理？给大家举个例子：\n一个人想要告状，他只知道他要告谁，需要准备的文件有哪些，可是他没有经验，为了保证告状赢的成功率他只好找一个律师帮着他告，这个律师除了说出告状者的心声而且还在公堂之上激情四射把自己的毕生所学发挥的淋漓尽致，这些是告状者不具备的。整个告状的过程是律师帮着告，告状人只是为律师提供相关材料和证据。这就是代理。\n静态代理和动态代理的最根本的区别就是静态代理的代理者必须事先明确，而动态代理则是事先不确定代理者可运行时再传入。\n动态代理要先设置一个动态代理处理器并实现InvocationHandler接口，进而在内部得到一个动态代理的方法。用的时候先拿到代理者实例，再调用动态代理方法，整个动态代理过程如下：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364ppackage com.reflect;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * 被代理者和代理者所需要实现的接口 */interface ISay &#123;    void say(String name,int age);&#125;/** * 被代理者 */class Person implements ISay &#123;    @Override    public void say(String name, int age) &#123;        System.out.println(&quot;名字叫&quot; + name + &quot;,年龄&quot; + age);    &#125;&#125;/** * 控制动态代理的处理器 */class MyInvocationHandler implements InvocationHandler &#123;    private Object object = null;    /*     * 获取代理者     */    public Object bind(Object object) &#123;        //得到被代理者实例        this.object = object;        //根据被代理者返回动态代理类实例，第一个参数是指定类加载器，第二个参数是指定代理类需要实现的一系列接口，第三个参数是控制动态代理的处理器本身实例        return Proxy.newProxyInstance(object.getClass().getClassLoader(), object.getClass().getInterfaces(),this);    &#125;    /*     *代理者需要实现的代理方法      *参数一：代理者实例（上边bind方法返回的）；     *参数二：被代理者调用的方法对象     *参数三：被代理者传入的相关参数     */    @Override    public Object invoke(Object proxy, Method method, Object[] args)            throws Throwable &#123;        System.out.println(&quot;代理人说出了这个人的信息：&quot;);        method.invoke(this.object, args);        return null;    &#125;&#125;public class Test &#123;    public static void main(String[] args) throws Exception &#123;        MyInvocationHandler invocationHandler = new MyInvocationHandler();         ISay personProxy = (ISay) invocationHandler.bind(new Person());        personProxy.say(&quot;张三&quot;, 18);    &#125;&#125;\n【运行结果】：\n12代理人说出了这个人的信息： 名字叫张三,年龄18\n【栗12】工厂模式\n工厂模式也是常用的一种设计模式，从字面意思就能差不多明白其原理了，工厂模式就是根据一些特定条件生产出一些”相同功能”的产品来供使用者去选择。\n下面就以选择某个地图导航为例阐述工厂模式：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.reflect;/** * 导航定位接口内含一个定位功能 */interface INavigation &#123;    void location();&#125;/** * 磨具1：百度导航定位 */class Baidu implements INavigation &#123;    @Override    public void location() &#123;        System.out.println(&quot;我是百度，地图牛逼，已确定您的位置。&quot;);    &#125;&#125;/** * 磨具2：高德导航定位 */class Gaode implements INavigation &#123;    @Override    public void location() &#123;        System.out.println(&quot;我是高德，定位准确，已确定您的位置。&quot;);    &#125;&#125;/** * 工厂，根据特定条件或者标示生产不同磨具的产品 */class Factory &#123;    public static INavigation getInstance(String navigationName)&#123;        System.out.println(&quot;选择&quot;+navigationName);        System.out.println(&quot;工厂寻找磨具，准备生产...&quot;);        INavigation navigation = null;        if (&quot;Baidu&quot;.equals(navigationName)) &#123;            navigation = new Baidu();        &#125;else if(&quot;Gaode&quot;.equals(navigationName)) &#123;            navigation = new Gaode();        &#125;        return navigation;    &#125;&#125;public class Test &#123;    public static void main(String[] args)&#123;        INavigation navigation = Factory.getInstance(&quot;Baidu&quot;);        navigation.location();    &#125;&#125;\n【运行结果】:\n123选择Baidu 工厂寻找磨具，准备生产… 我是百度，地图牛逼，已确定您的位置。\n这种写法有个弊端：当我们在添加一个子类的时候，就需要修改工厂类了。如果我们添加太多的子类的时候，改的就会很多。\n稍微修改一下利用反射来实现工厂模式：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.reflect;/** * 导航定位接口内含一个定位功能 */interface INavigation &#123;    void location();&#125;/** * 磨具1：百度导航定位 */class Baidu implements INavigation &#123;    @Override    public void location() &#123;        System.out.println(&quot;我是百度，地图牛逼，已确定您的位置。&quot;);    &#125;&#125;/** * 磨具2：高德导航定位 */class Gaode implements INavigation &#123;    @Override    public void location() &#123;        System.out.println(&quot;我是高德，定位准确，已确定您的位置。&quot;);    &#125;&#125;/** * 工厂，根据特定条件或者标示生产不同磨具的产品 */class Factory &#123;    public static INavigation getInstance(String navigationName)&#123;        System.out.println(&quot;选择&quot;+navigationName);        System.out.println(&quot;工厂寻找磨具，准备生产...&quot;);        INavigation navigation = null;        try &#123;            navigation = (INavigation) Class.forName(navigationName).newInstance();        &#125; catch (InstantiationException e) &#123;            // TODO Auto-generated catch block            e.printStackTrace();        &#125; catch (IllegalAccessException e) &#123;            // TODO Auto-generated catch block            e.printStackTrace();        &#125; catch (ClassNotFoundException e) &#123;            // TODO Auto-generated catch block            e.printStackTrace();        &#125;        return navigation;    &#125;&#125;public class Test &#123;    public static void main(String[] args)&#123;        INavigation navigation = Factory.getInstance(&quot;com.reflect.Baidu&quot;);        navigation.location();    &#125;&#125;\n【运行结果】：\n123选择com.reflect.Baidu 工厂寻找磨具，准备生产… 我是百度，地图牛逼，已确定您的位置。\n这样我们添加任意多个子类的时候工厂类就不需要修改了。但是这里又有一个弊端了：虽然可以通过反射取得接口的实例，但是需要传入完整的包和类名。而且用户也无法知道一个接口有多少个可以使用的子类。\n所以我们可以通过属性文件的形式配置所需要的子类，首先在本地创建一个配置文件navigation.properties，内容是：\n12Gaode&#x3D;com.reflect.GaodeBaidu&#x3D;com.reflect.Baidu\n下面是结合属性文件的工厂模式：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.reflect;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.util.Properties;/** * 导航定位接口内含一个定位功能 */interface INavigation &#123;    void location();&#125;/** * 磨具1：百度导航定位 */class Baidu implements INavigation &#123;    @Override    public void location() &#123;        System.out.println(&quot;我是百度，地图牛逼，已确定您的位置。&quot;);    &#125;&#125;/** * 磨具2：高德导航定位 */class Gaode implements INavigation &#123;    @Override    public void location() &#123;        System.out.println(&quot;我是高德，定位准确，已确定您的位置。&quot;);    &#125;&#125;/** * 工厂，根据特定条件或者标示生产不同磨具的产品 */class Factory &#123;    public static INavigation getInstance(String navigationName)&#123;        System.out.println(&quot;选择&quot;+navigationName);        System.out.println(&quot;工厂寻找磨具，准备生产...&quot;);        INavigation navigation = null;        try &#123;            navigation = (INavigation) Class.forName(navigationName).newInstance();        &#125; catch (InstantiationException e) &#123;            // TODO Auto-generated catch block            e.printStackTrace();        &#125; catch (IllegalAccessException e) &#123;            // TODO Auto-generated catch block            e.printStackTrace();        &#125; catch (ClassNotFoundException e) &#123;            // TODO Auto-generated catch block            e.printStackTrace();        &#125;        return navigation;    &#125;&#125;public class Test &#123;    public static void main(String[] args) throws FileNotFoundException, IOException&#123;        Properties pro=new Properties();        File f=new File(&quot;navigation.properties&quot;);        if(f.exists())&#123;            pro.load(new FileInputStream(f));        &#125;else&#123;            pro.setProperty(&quot;Baidu&quot;, &quot;com.reflect.Baidu&quot;);            pro.setProperty(&quot;Gaode&quot;, &quot;com.reflect.Gaode&quot;);            pro.store(new FileOutputStream(f), &quot;NAVIGATION CLASS&quot;);        &#125;        INavigation navigation = Factory.getInstance(pro.getProperty(&quot;Baidu&quot;));        navigation.location();    &#125;&#125;\n【运行结果】：\n123选择com.reflect.Baidu 工厂寻找磨具，准备生产… 我是百度，地图牛逼，已确定您的位置。\n最后\n总结至此，从上到下算是对java反射有一个清晰的认识，要明白反射最好还是要先弄清类的加载过程，这里仅仅阐述了其使用的方法，所涉及的知识还需慢慢深入，共勉。\n","plink":"https://blog.ixin.run/posts/1479635474/"},{"title":"Android开发之WebView详细总结","date":"2016-10-11T13:18:15.000Z","date_formatted":{"ll":"2016年10月11日","L":"2016/10/11","MM-DD":"10-11"},"updated":"2021-01-29T12:51:44.635Z","content":"WebView是android开发中专门用来加载网页的一种控件，常用于混合式开发，它采用WebKit渲染引擎来显示网页包括控制网页的前进、后退、放大、缩小、执行文本、搜索等功能。WebKit是一种让网页浏览器绘制网页的排版引擎，被用于Apple Safari，其分支也用于基于Chromuim的网页浏览器，详细了解可移步于https://zh.wikipedia.org/zh/WebKit 。\n\n注册\nWebView使用时一般情况下要远程加载，必须在AndroidManifest文件中注册网络权限：\n1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;\n如果还要涉及到定位，还要注册定位权限：\n12&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;/&gt;\n加载方式\n//加载一个网页\n1webView.loadUrl(&quot;http:&#x2F;&#x2F;www.google.com&#x2F;&quot;);\n//加载项目中的一个html页面\n1webView.loadUrl(&quot;file:&#x2F;&#x2F;&#x2F;android_asset&#x2F;test.html&quot;);\n//加载手机本地的一个html页面的方法\n1webView.loadUrl(&quot;content:&#x2F;&#x2F;com.android.htmlfileprovider&#x2F;sdcard&#x2F;test.html&quot;);\n//加载一段Html代码\n12loadData(String data, String mimeType, String encoding);loadDataWithBaseURL(String baseUrl, String data, String mimeType, String encoding, String historyUrl);\n例：webView.loadDataWithBaseURL(null, htmlContent, “text/html”, “UTF-8”,null);\n区别：loadDataWithBaseURL()比loadData()多两个参数，可以指定HTML代码片段中相关资源的相对根路径，也可以指定历史Url。两个方法的其余三个参数相同。但是loadData()中的html data中不能包含’#', ‘%’, ‘’, '?'四中特殊字符，使用时我们需要用UrlEncoder编码为%23, %25, %27, %3f 。\nWebSettings\nWebSettings类主要针对webview做一些相关的设置，包括自适应屏幕、缩放设置、js脚本控制、网页数据缓存等。\n123456789101112131415161718192021WebSettings webSettings = webView.getSettings();// 设置自适应屏幕webSettings.setUseWideViewPort(true);           //设置成webview推荐使用的窗口，可任意比例缩放webSettings.setLoadWithOverviewMode(true);      //设置成webview加载的页面大小的模式，// 设置缩放网页webSettings.setSupportZoom(true);               //是否支持屏幕双击缩放，但是下边的是前提webSettings.setBuiltInZoomControls(true);       //是否支持内置按钮缩放和手势“捏”缩放，如果设为false则webview不支持缩放功能webSettings.setDisplayZoomControls(false);      //是否隐藏原生的缩放控件// 设置可以执行Javascript脚本webSettings.setJavaScriptEnabled(true);// 设置缓存网页数据webSettings.setDomStorageEnabled(true);         //开启 DOM storage API 功能webSettings.setDatabaseEnabled(true);           //开启 database storage API 功能webSettings.setAppCacheEnabled(true);           //开启 Application Caches 功能// 设置支持多窗口,要复写 WebChromeClient的onCreateWindow方法webSettings.setSupportMultipleWindows(true);    //支持多窗口webSettings.setJavaScriptCanOpenWindowsAutomatically(true);  //支持js打开新窗口// 支持自动加载图片webSettings.setLoadsImagesAutomatically(true);// 设置编码格式webSettings.setDefaultTextEncodingName(&quot;utf-8&quot;);\n缓存设置\nwebview中的缓存模式有四种：\n\nLOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据\nLOAD_DEFAULT: （默认）根据cache-control决定是否从网络上取数据。\nLOAD_NO_CACHE: 不使用缓存，只从网络获取数据.\nLOAD_CACHE_ELSE_NETWORK，只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据。\n\n根据网络合理加载网络数据：\n1234567if (NetStatusUtil.isConnected(getApplicationContext())) &#123;    webSettings.setCacheMode(WebSettings.LOAD_DEFAULT);//有网，根据cache-control决定是否从网络上取数据。&#125; else &#123;    webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); //没网，则从本地获取，即离线加载&#125;String appCachePath = getApplicationContext().getCacheDir().getAbsolutePath();webSettings.setAppCachePath(appCachePath);      //设置缓存数据目录\n字体大小控制\nAndroid版本4.0之前WebView支持字体大小分为5中：\n\nSMALLEST(50%),\nSMALLER(75%),\nNORMAL(100%),\nLARGER(150%),\nLARGEST(200%);\n\n设定字体大小：\n1webSettings.setTextSize(TextSize.SMALLER);\nAndroid4.0之后WebView使用起来更加灵活，可采用setTextZoom(int)设置字体大小，参数默认是100。上边的方法已经舍弃。\nWebViewClient\n主要展示webview网页加载的一个过程，用于帮助webview处理一些请求事件和通知。\n123456789101112131415161718192021222324252627282930313233343536373839WebViewClient webViewClient = new WebViewClient()&#123;    //超链接加载,打开网页时不调用系统浏览器，而是在本WebView中显示。也可捕获超链接url,做相关操作    @Override    public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;        view.loadUrl(url);        return true;    //返回true表示在当前浏览器中加载    &#125;    //网页开始加载    @Override    public void onPageStarted(WebView view, String url, Bitmap favicon) &#123;        super.onPageStarted(view, url, favicon);    &#125;    //网页加载结束    @Override    public void onPageFinished(WebView view, String url) &#123;        super.onPageFinished(view, url);    &#125;    //网页加载失败    @Override    public void onReceivedError(WebView view, WebResourceRequest request, WebResourceError error) &#123;        super.onReceivedError(view, request, error);    &#125;    //对Https的支持    @Override    public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) &#123;        handler.proceed();    &#125;    //针对页面中每一个资源都会调用一次，用于捕获页面资源    @Override    public void onLoadResource(WebView view, String url) &#123;        super.onLoadResource(view, url);    &#125;&#125;;\nWebView调用：\n1webView.setWebViewClient(webViewClient);\nWebChromeClient\nWebChromeClient主要辅助WebView处理Javascript的对话框、网站图标、网站title、加载进度等。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778WebChromeClient webChromeClient = new WebChromeClient()&#123;    //获取网页加载进度    @Override    public void onProgressChanged(WebView view, int newProgress) &#123;        if (newProgress &lt; 100) &#123;            String progress = newProgress + &quot;%&quot;;        &#125; else &#123;        &#125;        super.onProgressChanged(view, newProgress);    &#125;    //=========捕获网页标题信息==========================================================    //获取标题    @Override    public void onReceivedTitle(WebView view, String title) &#123;        super.onReceivedTitle(view, title);    &#125;    //获取标题ICON    @Override    public void onReceivedIcon(WebView view, Bitmap icon) &#123;        super.onReceivedIcon(view, icon);    &#125;    //=========捕获弹框信息==========================================================    //警告框    @Override    public boolean onJsAlert(WebView view, String url, String message, JsResult result) &#123;        if(message!=null)&#123;            //TODO            //捕获网页中弹框信息            Toast.makeText(getApplicationContext(), message, Toast.LENGTH_LONG).show();        &#125;        result.cancel();   //        return true;       //表示确认进行捕获    &#125;       //确认框，会返回布尔值类型，通过这个值可判断点击时是确定还是取消，确定为true，取消为false    @Override    public boolean onJsConfirm(WebView view, String url, String message, JsResult result) &#123;        return super.onJsConfirm(view, url, message, result);    &#125;    //输入框，会返回输入框中的值，点击取消返回null    @Override    public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) &#123;        return super.onJsPrompt(view, url, message, defaultValue, result);    &#125;    //=========HTML5定位==========================================================    //需要先加入权限    //&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;/&gt;    //&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;/&gt;    @Override    public void onGeolocationPermissionsHidePrompt() &#123;        super.onGeolocationPermissionsHidePrompt();    &#125;    @Override    public void onGeolocationPermissionsShowPrompt(final String origin, final GeolocationPermissions.Callback callback) &#123;        callback.invoke(origin, true, false);  //注意个函数，第二个参数就是是否同意定位权限，第三个是是否希望内核记住        super.onGeolocationPermissionsShowPrompt(origin, callback);    &#125;    //=========HTML5多窗口=========================================================    //WebSettings要支持多窗口    @Override    public boolean onCreateWindow(WebView view, boolean isDialog, boolean isUserGesture, Message resultMsg) &#123;        WebView.WebViewTransport transport = (WebView.WebViewTransport) resultMsg.obj;        transport.setWebView(webView);        resultMsg.sendToTarget();        return true;    &#125;    @Override    public void onCloseWindow(WebView window) &#123;        super.onCloseWindow(window);    &#125;&#125;;\nWebView调用：\n1webView.setWebChromeClient(webChromeClient);\n支持文件下载\n12345678DownloadListener downloadListener = new DownloadListener() &#123;    @Override    public void onDownloadStart(String url, String userAgent, String contentDisposition, String mimetype, long contentLength) &#123;        Uri uri = Uri.parse(url);        Intent intent = new Intent(Intent.ACTION_VIEW, uri);        startActivity(intent);    &#125;&#125;;\nWebView调用：\n1webView.setDownloadListener(downloadListener);\nJS交互\njs交互说白了就两种形式，一种是由webview中的java方法去调用html中的js方法。另一种是html调用webview中java方法。注意在android4.2之前webview有一个漏洞，外部可通过反射来获取手机的联系方式等隐私，4.2以上官方已经修复，可在每个交互方法上添加一个注解“@JavascriptInterface”便可解决，漏洞详情可参阅：http://blog.csdn.net/leehong2005/article/details/11808557\nwebview设置对js的支持：\n1webSettings.setJavaScriptEnabled(true);\nwebview添加js交互接口：\n1webView.addJavascriptInterface(new JSInterface(),&quot;jsinterface&quot;);\n封装js交互类：\n1234567891011121314151617181920212223242526272829303132333435363738class JSInterface &#123;        //js中可以通过：window.jsinterface.JS2Java();调用java无参方法。        @JavascriptInterface        public void JS2Java()&#123;            runOnUiThread(new Runnable() &#123;                @Override                public void run() &#123;                    Toast.makeText(WebViewActivity.this,&quot;js调用java无参方法。&quot;,Toast.LENGTH_SHORT).show();                &#125;            &#125;);        &#125;        //js中可以通过：window.jsinterface.JS2Java(&#x27;hello java&#x27;);调用java有参方法,并传参&#x27;hello java&#x27;。        @JavascriptInterface        public void JS2Java(final String str)&#123;            runOnUiThread(new Runnable() &#123;                @Override                public void run() &#123;                    Toast.makeText(WebViewActivity.this,&quot;js调用java有参方法，js传递的参数是：&quot;+str,Toast.LENGTH_SHORT).show();                &#125;            &#125;);        &#125;        //Java调用JS中的无参方法        @JavascriptInterface        public void Java2JS()&#123;            webView.loadUrl(&quot;javascript: fromJS1()&quot;);            Log.e(&quot;TAG&quot;,&quot;java调用js中的无参方法&quot;);        &#125;        //Java调用JS中的有参方法，并传参数给js        @JavascriptInterface        public void Java2JS(final String str)&#123;            webView.loadUrl(&quot;javascript: fromJS2(&#x27;&quot;+str+&quot;&#x27;)&quot;);            Log.e(&quot;TAG&quot;,&quot;java调用js中的有参方法&quot;);        &#125;    &#125;\nwebview调用js中的方法:\n1234567//调用js有参方法        js_has_args_bt.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                new JSInterface().Java2JS(&quot;hello js&quot;);            &#125;        &#125;);\nWebView相关方法\n\n前进，后退\ngoBack()       //后退\ngoForward()    //前进\ngoBackOrForward(intsteps) //以当前的index为起始点前进或者后退到历史记录中指定的steps，如果steps为负数则为后退，正数则为前进\ncanGoForward()  //是否可以前进\ncanGoBack()     //是否可以后退\n清除缓存\nclearCache(true)   //清除网页访问留下的缓存，由于内核缓存是全局的因此这个方法不仅仅针对webview而是针对整个应用程序.\nclearHistory()     //清除当前webview访问的历史记录，只会webview访问历史记录里的所有记录除了当前访问记录.\nclearFormData()    //清除自动完成填充的表单数据，不会清除WebView存储到本地的数据。\nWebView状态\nonResume()   //激活WebView为活跃状态，能正常执行网页的响应\nonPause()    //WebView处于暂停状态，onPause动作通知内核暂停所有的动作，比如DOM的解析、plugin的执行、JavaScript执行。\npauseTimers()    //暂停所有webview的layout，parsing，javascripttimer。降低CPU功耗。\nresumeTimers()   //恢复pauseTimers时的动作。\ndestroy()    //销毁，关闭了Activity时，音乐或视频，还在播放。就必须销毁。\n重新加载网页\nreload()\n重新加载网页将会重新调用WebClient类中的方法。\n判断WebView滚动到顶端还是低端\n\n123456// 已经处于底端if (webView.getContentHeight() * webView.getScale() == (webView.getHeight() + webView.getScrollY())) &#123;&#125;// 处于顶端if(webView.getScrollY() == 0)&#123;&#125;\n\n退到后台关闭暂停音乐视频播放\n\n123456789public void onPause() &#123;       super.onPause();       webView.onPause();   &#125;public void onResume() &#123;       super.onResume();       webView.onResume();   &#125;\n\n设置手机返回按键监听\n\n12345678public boolean onKeyDown(int keyCode, KeyEvent event) &#123;    if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; webView.canGoBack()) &#123;        webView.goBack();        return true;    &#125;    finish();    return super.onKeyDown(keyCode, event);&#125;\n\nActivity退出销毁WebView\n这一步主要防止内存溢出，webview调用destory时,自定义webview仍绑定在Activity上.这是由于自定义webview构建时传入了该Activity的context对象,因此需要先从父容器中移除webview,然后再销毁webview。\n\n123456789101112@Overrideprotected void onDestroy() &#123;    if (webView != null) &#123;        webView.loadDataWithBaseURL(null, &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);        webView.clearHistory();        ((ViewGroup) webView.getParent()).removeView(webView);        webView.destroy();        webView = null;    &#125;    super.onDestroy();&#125;\n以上是个人总结WebView掌握的知识点，其他细节请移步官方文档查阅清楚，另外在系统级别4.4以上有一个开源引擎crosswalk对H5支持很好，可参阅crosswalk官方文档https://crosswalk-project.org/ 进行学习。\n","plink":"https://blog.ixin.run/posts/1476191895/"},{"title":"TCP/IP协议三次握手和四次挥手大白话解说","date":"2016-09-20T12:33:01.000Z","date_formatted":{"ll":"2016年9月20日","L":"2016/09/20","MM-DD":"09-20"},"updated":"2021-03-15T04:16:08.122Z","content":"昨天晚上被一位师傅问到了TCP/IP的工作机制，心里很清楚三次握手，然而对于四次挥手却忘了，这是大学习里学过的，奋而翻阅书籍和网络对之前所学的做一个温顾，算是夯实自我吧。\nTCP(Transmission Control Protocol)网络传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议，数据传输前建立连接的工作要经过三次握手，数据传输后断开连接的工作要经过四次挥手。\n\n工作过程\nTCP标志位：\nTCP共有6个标志位，分别是：\n\nSYN(synchronous),建立联机。\nACK(acknowledgement),确认。\nPSH(push),传输。\nFIN(finish),结束。\nRST(reset),重置。\nURG(urgent),紧急。\n\n图解三次握手和四次挥手的过程：\n\n三次握手建立连接阐述：\n第一次握手：客户端要和服务端进行通信，首先要告知服务端一声，遂发出一个SYN=1的连接请求信号,“服务端哥哥，我想给你说说话”。\n第二次握手：当服务端接收到客户端的连接请求，此时要给客户端一个确认信息，“我知道了（ACK）,我这边已经准备好了，你现在能连吗（SYN）”。\n第三次握手：当客户端收到了服务端的确认连接信息后，要礼貌的告知一下服务端，“好的，咱们开始联通吧（ACK）”。\n到此整个建立连接的过程已经结束，接下来就是双方你一句我一句甚至同时交流传递信息的过程了。\n四次挥手断开连接阐述：\n第一次挥手：双方交流的差不多了，此时客户端也已经结尾了，接下来要断开通信连接，所以告诉服务端“我说完了（FIN）”，此时自身形成等待结束连接的状态。\n第二次挥手：服务端知道客户端已经没话说了，服务端此时还有两句心里话要给客户端说，“我知道你说完了（ACK），我再给你说两句，&amp;*……%￥”。\n第三次挥手：此时客户端洗耳恭听继续处于等待结束的状态，服务器端也说完了，自身此时处于等待关闭连接的状态，并对告诉客户端，“我说完了，咱们断了吧（FIN）”。\n第四次挥手：客户端收知道服务端也说完了，也要告诉服务端一声（ACK），因为连接和断开要双方都按下关闭操作才能断开，客户端同时又为自己定义一个定时器，因为不知道刚才说的这句话能不能准确到达服务端（网络不稳定或者其他因素引起的网络原因），默认时间定为两个通信的最大时间之和，超出这个时间就默认服务器端已经接收到了自己的确认信息，此时客户端就关闭自身连接，服务器端一旦接收到客户端发来的确定通知就立刻关闭服务器端的连接。\n到此为止双方整个通信过程就此终结。这里要声明一下：断开链接不一定就是客户端，谁都可以先发起断开指令，另外客户端和服务端是没有固定标准的，谁先发起请求谁就是客户端。\n问题：\n\n为什么断开链接的时候客户端设置的定时器时间等待要2MSL(两个通信报文的最大时间)？\n这个问题也很好理解，当客户端最终告诉服务器端断开确认的时候，他不知道自己的发出的指令是否能准确的一次性被服务器接收。假如服务器没有接收到（这已经耗费了一个报文的最大通信时间了），服务器端将会重新发起一个结束通话的指令（FIN）到客户端，客户端又接收到了服务器发来的结束通信指令将继续给服务器进行一个确认，有人会说那要是客户端发出的确认信息服务端没收到，而服务端重发的断开指令客户端也没收到怎么办，说实话我也无奈，遇到这种情况咱们干脆认为网确实不行了。\n为什么建立连接要三次握手而断开连接要四次挥手?\n说起这个，打一个比喻，目前祖国正在高速发展高铁，建立连接的过程正如上海到北京打通一条高铁线，TCP通信过程是一个全双工模式，即在这条高铁线上要有两个轨道，即能从上海发车到北京又能从北京发车到上海，甚至两边可以同时发车。所以断开连接前提就是要保证两条轨道都没有车，然后双方才能各自发起断开动作。\n\n双方各自工作流程图：\n客户端工作流程：\n\n注意：在TIME_WAIT状态中，如果TCP client端最后一次发送的ACK丢失了，它将重新发送。TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。\n服务器端工作流程：\n\n附加\nSYN网络攻击：\n原理：\n在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。\n检测：\nSYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了。windows下打开cmd,输入命令：”netstat -n -p TCP“，查看是否有大量的”SYN_RECEIVED“状态。\n以下图片是表明正常的。\n\n","plink":"https://blog.ixin.run/posts/1474374781/"},{"title":"Java开发揭开socket编程的面纱","date":"2016-08-29T15:37:25.000Z","date_formatted":{"ll":"2016年8月29日","L":"2016/08/29","MM-DD":"08-29"},"updated":"2021-01-29T12:51:44.661Z","content":"socket编程大家应该听的很多了，socket又称为“套接字”，用于描述IP地址和端口，是一个通信链的句柄，最主要的特点便是设定IP和端口，保证了程序的双向互通性。应用程序通常通过&quot;套接字&quot;向网络发出请求或者应答网络请求。\n\n什么是socket?\n网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个Socket。Socket通常用来实现客户方和服务方的连接。Socket是TCP/IP协议的一个十分流行的编程界面，一个Socket由一个IP地址和一个端口号唯一确定。socket另外也支持UDP报文协议的传输。java中最主要的形式是根据TCP/IP协议进行socket通信。\n两个协议\n在学习socket编程之前先弄明白两个协议：TCP/IP协议和UDP协议。\nTCP：Transmission Control Protocol 传输控制协议，TCP是一种面向连接（连接导向）的、可靠的、基于字节流的运输层（Transport layer）通信协议。\nUDP：User Datagram Protocol的简称，是一种无连接的协议，每个数据报都是一个独立的信息，包括完整的源地址或目的地址，它在网络上以任何可能的路径传往目的地，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。另外UDP传输数据时是有大小限制的，每个被传输的数据报必须限定在64KB之内。\n说起TCP/IP我们不得已又要想到经典的三次握手：\n第一次握手：客户端尝试连接服务器，向服务器发送syn包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入SYN_SEND状态等待服务器确认。\n第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。\n第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。\n\nSocket在OSI网络七层协议上的位置：\n\n什么是IP？什么是端口？\n上边也指出了一个socket是有一个IP和一个端口号来确定的，那么什么是IP?什么是端口呢？\nIP地址\n每台联网的电脑都有一个唯一的IP地址，标着这台电脑在网络上的位置。\nIP分为IPV4和IPV6。我们常用的IPV4长度是32位的，分为4段，每段8位，十进制数字表示，每段数字的范围是0~255。IPV6长度是128位，分为8段，每段16位。\n特殊IP地址：\n127.0.0.1\n指的是本机，主要作用是预留下作为测试使用，用于网络软件测试以及本地机进程间通信。在Windows系统下，该地址还有一个别名叫 “localhost”。\n10.*.*.*\n172.16.*.*――172.31.*.*\n192.168.*.*\n上面三个网段是私有地址，可以用于自己组网使用，这些地址主要用于企业内部网络中，但不能够在Internet网上使用，Internet网没有这些地址的路由，而使用这三个网段的计算机要上网必须要通过地址翻译（NAT），将私有地址翻译成公用合法的IP地址。\n0.0.0.0\n所有不清楚的主机和目的网络都用此来代替，代表这类情况的一个集合，严格意义上来说，0.0.0.0已经不是真正意义上的ip地址了。\n255.255.255.255\n有限广播地址，在主机不知道本机所处的网络时（如主机的启动过程中），只能采用有限广播方式，通常由无盘工作站启动时使用，希望从网络IP地址服务器处获得一个IP地址。 当广播地址包含一个有效的网络号和主机号，技术上就称为直接广播地址。\n169.254.*.*\n如果你的主机使用了DHCP功能自动获得一个ip地址，那么当你的DHCP服务器发生故障或响应时间太长而超出系统规定的一个时间，windows系统会为你分配这样一个地址。如果你发现你的主机ip地址是个诸如此类的地址，很不幸，十有八九是你的网络不能正常运行了。\n端口\n在网络上有很多电脑，这些电脑一般运行了多个网络程序。每种网络程序都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的网络程序。\n端口常规分三种形式：\n1.公认端口（WellKnownPorts）：从0到1023，它们紧密绑定（binding）于一些服务。通常这些端口的通讯明确表明了某种服务的协议。例如：80端口实际上总是HTTP通讯。\n2.注册端口（RegisteredPorts）：从1024到49151。它们松散地绑定于一些服务。也就是说有许多服务绑定于这些端口，这些端口同样用于许多其它目的。例如：许多系统处理动态端口从1024左右开始。\n3.动态和/或私有端口（Dynamicand/orPrivatePorts）：从49152到65535。理论上，不应为服务分配这些端口。实际上，机器通常从1024起分配动态端口。\n所以我们常常设置端口的时候最好设成1023之后的。\n常用端口：21( FTP) ,25 (SMTP) ,110 (POP3) ,80(HTTP), 443(HTTPS)\nsocket编程的具体流程\n有了以上的基础，对于socket编程的学习即可事半功倍了，socket编程的具体流程如下：\n\n下面我以用户登录案例来阐述socket通信的这一过程，上边也指出socket通信不仅仅根据TCP/IP协议来进行数据传输还可以根据UDP协议数据传输。根据上图我们知道服务器至少要有两个socket才能与客户端进行三次握手，第一个的socket叫ServerSocket，用来监听等待客户端的链接，第二个socket就是常规的socket,用于对客户端数据的接受和反馈。\n根据TCP/IP协议进行socket通信模拟用户登录\n服务器端：\n12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 服务器端 */public class Server &#123; public static void main(String[] args) &#123;  try &#123;   //1.创建一个服务器端socket即ServerSocket,指定绑定的端口，并监听此端口   ServerSocket  serverSocket = new ServerSocket(8888);   System.out.println(&quot;+++++++++++++++++服务器即将启动，等待客户端的链接+++++++++++++&quot;);   //2.调用accept()方法开始监听，等待客户端的连接。   Socket socket = serverSocket.accept();      //3.获取输入流，并读取客户端信息   InputStream is = socket.getInputStream();   //获取字节输入流   InputStreamReader isr = new InputStreamReader(is); //将字节输入流转换成字符流   BufferedReader br = new BufferedReader(isr); //为输入流添加缓冲   String info = null;   while((info = br.readLine())!=null)&#123;   //循环读取客户端的信息    System.out.println(&quot;我是服务器，客户端说：&quot;+info);   &#125;   socket.shutdownInput();  //关闭输入流      //4.获取输出流，响应客户端的请求   OutputStream os = socket.getOutputStream();   PrintWriter pw = new PrintWriter(os);   pw.write(&quot;谢谢你告诉我账户和密码。&quot;);   pw.flush();   socket.shutdownOutput();      //5.关闭资源   pw.close();   os.close();   br.close();   isr.close();   is.close();   socket.close();   serverSocket.close();  &#125; catch (IOException e) &#123;   // TODO Auto-generated catch block   e.printStackTrace();  &#125; &#125;&#125;\n客户端：\n12345678910111213141516171819202122232425262728293031323334353637383940/** * 客户端 */public class Client &#123; public static void main(String[] args) &#123;  try &#123;   // 1.创建客户端Socket,指定服务器端的IP地址和端口号。   Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888);      // 2.获取输出流，向服务器端发送信息。   OutputStream os = socket.getOutputStream(); // 字节输出流   PrintWriter pw = new PrintWriter(os); // 将输出流包装成打印流   pw.write(&quot;账户是admin;密码是123。&quot;);   pw.flush();   socket.shutdownOutput(); // 关闭输出流      //3.获取输入流，读取服务器的响应信息。   InputStream is = socket.getInputStream();   InputStreamReader isr = new InputStreamReader(is);   BufferedReader br = new BufferedReader(isr);   String info = null;   while ((info = br.readLine())!=null) &#123;    System.out.println(&quot;我是客户端，服务器说：&quot;+info);   &#125;   socket.shutdownInput();      // 4.关闭资源   br.close();   isr.close();   is.close();   pw.close();   os.close();   socket.close();  &#125; catch (UnknownHostException e) &#123;   e.printStackTrace();  &#125; catch (IOException e) &#123;   e.printStackTrace();  &#125; &#125;&#125;\n运行时先开启服务端在开启客户端，运行结果如下：\n服务端显示：\n\n客户端显示：\n\n多线程多客户端模拟用户登陆\n实际应用中不会这么简单的一个服务器对应一个客户端，而最常见的是一个服务器形成一个服务中心多个客户端进行连接，这就要用到多线程机制了。也就是在服务器端开启多个线程，每个线程去去单独应对每一个连接的客户端。\n很容易想到启动多少个客户端咱们就启动多少个线程，而ServerSocket一次只能监听一个客户端的连接，所以这里要创建一个死循环让其不间断的一个一个的去监听。又因为处于死循环状态，服务器一直处于工作状态不能自主关闭，所以也就不能调用serverScoket.close()了。\n服务器端子线程类：\n用于对每个连接的客户端进行通信。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 服务器端子线程 */public class ServerThread extends Thread &#123; private Socket socket = null;  //拿到连接客户端的socket public ServerThread(Socket socket) &#123;  this.socket = socket; &#125; @Override public void run() &#123;  super.run();  InputStream is = null;  InputStreamReader isr = null;  BufferedReader br = null;  OutputStream os = null;  PrintWriter pw = null;  try &#123;   //获取输入流，并读取客户端信息   is = socket.getInputStream(); // 获取字节输入流   isr = new InputStreamReader(is); // 将字节输入流转换成字符流   br = new BufferedReader(isr); // 为输入流添加缓冲   String info = null;   while ((info = br.readLine()) != null) &#123; // 循环读取客户端的信息    System.out.println(&quot;我是服务器，客户端说：&quot; + info);   &#125;   socket.shutdownInput(); // 关闭输入流   //获取输出流，响应客户端的请求   os = socket.getOutputStream();   pw = new PrintWriter(os);   pw.write(&quot;谢谢你告诉我账户和密码。&quot;);   pw.flush();   socket.shutdownOutput();     &#125; catch (IOException e) &#123;   e.printStackTrace();  &#125; finally &#123;   //关闭资源   try &#123;    if (pw != null)     pw.close();    if (os != null)     os.close();    if (br != null)     br.close();    if (isr != null)     isr.close();    if (is != null)     is.close();    if (socket != null)     socket.close();   &#125; catch (IOException e) &#123;    e.printStackTrace();   &#125;  &#125; &#125;&#125;\n服务器端：\n1234567891011121314151617181920212223242526272829303132/** * 服务器端 */public class Server &#123; public static void main(String[] args) &#123;  try &#123;   //创建一个服务器端socket即ServerSocket,指定绑定的端口，并监听此端口   ServerSocket  serverSocket = new ServerSocket(8888);   Socket socket = null;   //记录客户端的数量   int count = 0;   System.out.println(&quot;+++++++++++++++++服务器即将启动，等待客户端的链接+++++++++++++&quot;);   //创建一个死循环，循环监听等待客户端的链接。   while(true)&#123;    //调用accept()方法开始监听，等待客户端的连接。    socket = serverSocket.accept();    //创建一个服务器线程    ServerThread serverThread = new ServerThread(socket);    serverThread.setPriority(4);  //设置线程优先级，范围是[1-10],默认是5。适当的降低线程优先级，有助于提高运行速度。    //启动线程    serverThread.start();       count++; //统计客户端的数量    System.out.println(&quot;当前客户端连接的数量：&quot;+count);   &#125;      //serverSocket.close(); //因为创建了死循环所以ServerSocket一直处于工作状态，所以ServerSocket也就无法关闭了。  &#125; catch (IOException e) &#123;   e.printStackTrace();  &#125; &#125;&#125;\n客户端：\n和上边的客户端一样。\n运行时还是先开启服务器端在开启客户端，并开启多个客户端，控制台查看连接情况：\n\n根据UDP协议进行socket通信模拟用户登录\n使用UDP协议进行数据传输时，首先需要将要传输的数据定义成数据报（Datagram），在数据报中指明数据所要达到的Socket(主机地址和端口号)，然后再将数据报发送出去。这里的端口连接和数据的接受发送不在是上边TCP形式的ServerSocket和Socket了,这里要使用到的有两个类：\n\nDatagramSocket:进行端到端通信的类，用于服务器端创建端口和接收数据包和客服端发送数据包。\nDatagramPacket:表示数据报包，是UDP通信的数据单元。\n\n下面看一下具体过程：\n服务器端：\n12345678910111213141516171819202122232425262728293031323334353637/** * UDP形式的服务器端 */public class UDPServer &#123; public static void main(String[] args) throws IOException &#123;  //创建服务器端DatagramSocket，指定端口  DatagramSocket datagramSocket = new DatagramSocket(8888);  System.out.println(&quot;+++++++++UDP++++++++服务器即将启动，等待客户端的链接+++++++++++++&quot;);   /*   * 服务器接收客户端的发送来的数据   */  //创建数据报，用于接受客户端发送来的数据。  byte[] data = new byte[1024];  DatagramPacket packet = new DatagramPacket(data, data.length);  //接收客户端发送来的数据  datagramSocket.receive(packet);//在接收数据前此方法一直处于阻塞状态。  //读取客户端发送来的数据信息  String info = new String(data, 0, packet.getLength());  System.out.println(&quot;我是服务器，客户端说：&quot; + info);   /*   * 服务器响应客户端的请求   */  //定义客户端的地址，端口，发送的数据。  InetAddress address = packet.getAddress();  int port = packet.getPort();  byte[] data2 = &quot;谢谢你告诉我账号和密码&quot;.getBytes();  //创建数据报，封装响应信息  DatagramPacket packet2 = new DatagramPacket(data2, 0, data2.length,address, port);  //响应客户端  datagramSocket.send(packet2);   //关闭socket  datagramSocket.close(); &#125;&#125;\n客户端：\n123456789101112131415161718192021222324252627282930313233343536/** * UDP形式的客户端 */public class UDPClient &#123; public static void main(String[] args) throws IOException &#123;  //创建客户端DatagramSocket，用于将来向服务器端发送数据报和接收服务器端的响应数据报  DatagramSocket datagramSocket = new DatagramSocket();   /*   * 向服务器端发送数据   */  //定义服务器的地址，端口号，数据。  InetAddress address = InetAddress.getByName(&quot;127.0.0.1&quot;);  int port = 8888;  byte[] data = &quot;账户是admin，密码是123&quot;.getBytes();  //创建数据报，封装发送的数据信息。  DatagramPacket packet = new DatagramPacket(data, 0, data.length,address, port);  //发送数据  datagramSocket.send(packet);   /*   * 接收服务器端响应数据   */  //创建数据报，用于接收服务器端的响应数据。  byte[] data2 = new byte[1024];  DatagramPacket packet2 = new DatagramPacket(data2, data2.length);  //接收服务器端响应的数据  datagramSocket.receive(packet2);  //读取服务器端响应的数据  String info = new String(data2, 0, packet2.getLength());  System.out.println(&quot;我是客户端，服务器说：&quot; + info);   //关闭socket  datagramSocket.close(); &#125;&#125;\n运行时还是先开启服务端再开启客户端，运行结果如下：\n服务端显示：\n\n客户端显示：\n\n到此为止相信对socket通信有一定了解了吧，这里仍然需要说明一下：\n在多线程模拟用户登录时由于创建了一个死循环去不断的监听客户端的链接情况，这里建议创建子线程的时候设置一个合适的优先级，serverThread.setPriority(4)。适当的降低线程优先级有助于提升运行时速度。\ndemo下载\n","plink":"https://blog.ixin.run/posts/1472485045/"},{"title":"Android开发之Intent及IntentFilter的探究学习","date":"2016-08-01T06:07:34.000Z","date_formatted":{"ll":"2016年8月1日","L":"2016/08/01","MM-DD":"08-01"},"updated":"2021-01-29T12:51:44.631Z","content":"Intent在android开发过程中再熟悉不过了，调用系统相机，调用系统电话，页面跳转，数据传递…其实这些都是基本的，也是在开发过程中用到最多的，但是更深一层你又知道多少呢，所以还是总结一下吧，日后顺手拈来。\n\n什么是Intent\nIntent在字面意思是指“意图”，在安卓开发中担任着启动某个组件和组件之间通信传递数据的重要角色。IntentFilter作为“意图”过滤器，其主要作用负责过滤掉组件无法响应和处理的Intent，只将自己关心的Intent接收进来进行处理，一个被启动的组件可以有多个IntentFilter,每个IntentFilter相互独立，使用时只要其中一个过滤器验证通过即可，除了广播可在代码中注册过滤器，其他组件必须AndroidManifest.xml文件中进行声明。\nIntent&amp;IntentFilter属性\nIntent对象大致可包含Component、Action、Category、Data、Type、Extra和Flag这7种属性。\nIntentFilter包含Action,Category,Data这三种属性。\n意图分类\n“意图”分为显式意图和隐式意图。\n显式Intent\n显式Intent是指从表面上明确看出启动某个组件，包括包名和类名。另外强调，从安卓5.0以后启动service必须采用显式Intent方式来启动。\n\n\n可采用intent七个属性中的Component属性，需要接受一个ComponentName类，里面有三个构造函数，其本质都是一样，指定包名和类名来确定一个组件。\n 1234Intent intent = new Intent();ComponentName componentName = new ComponentName(&quot;com.example.apptest&quot;,&quot;com.example.apptest.SecondActivity&quot;);intent.setComponent(componentName);startActivity(intent);\n注意后边的类名，一定要把整个路径写全。\n\n\n可采用Intent的setClass、setClassName等方法也能确定启动某个组件，和Component用法一样。\n\n\n其实上边1和2的方式如果在同一个app下都可简化成：\n12Intent intent = new Intent(MainActivity.this,SecondActivity.class);startActivity(intent);\n隐式Intent\n凡是不能从表面明确看出到底启动的是哪个组件，都属于隐式Intent，配合IntentFilter一起使用。\n\n\nAction,Category属性与IntentFilter配置。\n前边已经说过，IntentFilter中有三个属性，其中Action、Category其实就是一个普通的字符串，Action代表该Intent所有完成的一个“动作”，Category则用于为Action增加额外的附加类信息。通常两个是结合着使用的。\n 123Intent intent = new Intent();intent.setAction(&quot;com.example.apptest.goto&quot;);startActivity(intent);\n上边隐式启动另一个Activity，其实默认隐藏了intent.addCategory(“android.intent.category.DEFAULT”)这个句。所以AndroidManifest.xml文件中进行声明：\n 1234&lt;intent-filter&gt;    &lt;action android:name=&quot;com.example.apptest.goto&quot;/&gt;    &lt;category android:name = &quot;android.intent.category.DEFAULT&quot;  /&gt;&lt;/intent-filter&gt;\n一个intent对象只能设置一个action，可以设置多个category，一个intentFilter可以设置多个action,多个category，并且至少要有一个&lt;category android:name = &quot;android.intent.category.DEFAULT&quot;/&gt;属性。\n\n\nData,Type属性与IntentFilter配置。\nData属性通常用于向Action属性提供操作的数据，Data接受的是一个Uri对象，Uri格式包含四个部分：scheme、host、port、path，例如：run://www.example.com:8080/index，其中的scheme就是run，host就是www.example.com，port就是8080，path就是/index。\nData和Tyep属性在添加的时候很特别，如果intent先设置了Data属性将覆盖Type属性(过滤器将不会过滤type属性)，如果intent先设置了Type属性将覆盖Data属性(过滤器中将不会过滤data属性)，如果两个都想设置，则应该调用intent的setDataAndType()方法。\n 123456Intent intent = new Intent();intent.setAction(&quot;com.example.apptest.goto&quot;);//intent.setType(&quot;run/gege&quot;);//intent.setData(Uri.parse(&quot;http://www.example.com:8080/index&quot;));intent.setDataAndType(Uri.parse(&quot;http://www.example.com:8080/index&quot;),&quot;run/gege&quot;);startActivity(intent);\n在过滤器里设置type属性是包含在data属性里面的：\n 123456789&lt;intent-filter&gt;    &lt;action android:name=&quot;com.example.apptest.goto&quot;/&gt;    &lt;category android:name = &quot;android.intent.category.DEFAULT&quot;  /&gt;    &lt;data android:mimeType=&quot;run/gege&quot;        android:scheme=&quot;http&quot;        android:host=&quot;www.example.com&quot;        android:port=&quot;8080&quot;        android:path=&quot;/index&quot;/&gt;&lt;/intent-filter&gt;\n特殊说明：如果在过滤器中没有指定android:host属性，那么后边的android:port、android:path元素即使intent指明了也不会起作用的。\n\n\nIntent使用\n目前我们所接触的intent能够启动三种组件：Activity、Service、BroadcastRecever。除了常规项目开发中显式或者隐式的启动本应用的一个组件外，intent还常常用来启动系统组件，另外intent还可设置Extra属性用于在多个组件之间进行数据传值和数据交换，还可设置Flag属性用于控制组件启动方式和一些动态指令。\nAndroid内部提供了大量标准的Action和Category常量。\n其中用于启动Activity的标准Aciton及对应的字符串如下表所示：\n\n其中用于启动Activity的标准Category及对应的字符串如下表所示：\n\nIntent调用系统组件使用例子\n\n安装已经存在的apk 1234String filePath=&quot;mnt/sdcard/abc.apk&quot;;Intent intent = new  Intent(Intent.ACTION_VIEW);intent.setDataAndType(Uri.parse(&quot;file://&quot; + filePath),&quot;application/vnd.android.package-archive&quot;);startActivity(intent);\n\n卸载某个应用 1234String packageName=&quot;org.adw.launcher2&quot; //包名，指定该应用Uri packageUri = Uri.parse(&quot;package:&quot;+packageName);Intent uninstallIntent = new Intent(Intent.ACTION_DELETE, packageUri);startActivity(uninstallIntent);\n\n查看某个应用的信息 123Uri uri=Uri.parse(&quot;package:&quot;+packageName);//包名，指定该应用Intent intent=new Intent(&quot;android.settings.APPLICATION_DETAILS_SETTINGS&quot;, uri);startActivity(intent);\n\n浏览某个网址 1234Uri uri = Uri.parse(&quot;http://xxxxxxxxxxxxxxxxxxxxxxxx&quot;);  Intent intent   = new Intent(Intent.ACTION_VIEW,uri);intent.setClassName(&quot;com.android.browser&quot;, &quot;com.android.browser.BrowserActivity&quot;);  //用系统浏览器打开网页startActivity(intent);\n\n跳到系统设置界面 123Intent intent=new Intent();intent.setClassName(&quot;com.android.settings&quot;,&quot;com.android.settings.Settings&quot;);startActivity(intent);\n\n回到桌面 123Intent intent = new Intent(Intent.ACTION_MAIN);intent.addCategory(Intent.CATEGORY_HOME);startActivity(intent);\n\n跳到系统拨号界面 123Intent intent= new Intent(Intent.ACTION_DIAL);  intent.setClassName(&quot;com.android.contacts&quot;,&quot;com.android.contacts.DialtactsActivity&quot;);startActivity(intent);\n\n跳到系统通话记录界面 123Intent intent =new Intent(); intent.setAction(&quot;android.intent.action.CALL_BUTTON&quot;); startActivity(intent);\n\n跳到系统拨号界面拨打电话 123Uri uri = Uri.parse(&quot;tel:xxxxxx&quot;);   Intent intent = new Intent(Intent.ACTION_DIAL, uri);      startActivity(intent);\n\n直接拨打电话12Intent intentPhone = new Intent(Intent.ACTION_CALL, Uri.parse(&quot;tel:&quot; + phoneNumber));startActivity(intentPhone);\n\n跳到系统联系人界面123Intent intent = new Intent();intent.setClassName(&quot;com.android.contacts&quot;,&quot;com.android.contacts.activities.PeopleActivity&quot;);startActivity(intent);\n\n跳到系统搜索界面123Intent intent=new Intent();intent.setClassName(&quot;com.android.quicksearchbox&quot;, &quot;com.android.quicksearchbox.SearchActivity&quot;);startActivity(intent);\n\n跳到短信收件箱界面123Intent intent = new Intent();intent.setClassName(&quot;com.android.mms&quot;,&quot;com.android.mms.ui.ConversationList&quot;);startActivity(intent);\n\n跳到编辑短信界面123Intent intent = new Intent(Intent.ACTION_VIEW);intent.setType(&quot;vnd.android-dir/mms-sms&quot;);startActivity(intent);\n\n\nIntent中的各种FLAG\n\nFLAG_ACTIVITY_BROUGHT_TO_FRONT\n如果通过该Flag启动的Activity已经存在，下次再次启动，将只是把该Activity带到前台。假如A启动B时设置该标签，B又启动C,C又启动B（正常启动），最终栈内的实例是A，C，B。\nFLAG_ACTIVITY_CLEAR_TOP\n相当于启动模式的singleTask。假设启动B时设置此标记，例如栈中现在是A,B,C,D那么再次启动B后的结果是A，B。\nFLAG_ACTIVITY_NEW_TASK\n启动一个新的栈来存储启动这个activity。\nFLAG_ACTIVITY_NO_ANIMATION\n启动Activity时不使用过渡动画\nFLAG_ACTIVITY_NO_HISTORY\n被启动的Activity将不会记录在栈的历史中，假设启动D设置了此标记，例如之前栈中有A,B,C，现在C启动D，然后在由D启动E，那么此时栈中存在的实例有A，B，C，E.\nFLAG_ACTIVITY_REORDER_TO_FRONT\n假如当前栈中已经存在所启动的Activity, 例如当前栈内有A，B，C。此时由 C通过该标记启动B,那么最终栈内的顺序是A，C，B。\nFLAG_ACTIVITY_SINGLE_TOP\n相当于启动模式的singleTop。假设启动B时设置此标记，例如栈中现在是A，B，那么再次启动B后的结果还是A，B。假如栈中现在是A，B，C，启动B，则是A，B，C，B。\n\n至于其他FLAG并不常用，真正用到时请搬梯子查阅官方intent的Api：\nhttps://developer.android.com/reference/android/content/Intent.html\n","plink":"https://blog.ixin.run/posts/1470031654/"},{"title":"Android开发之进程间通信AIDL的探究和学习","date":"2016-07-30T05:20:29.000Z","date_formatted":{"ll":"2016年7月30日","L":"2016/07/30","MM-DD":"07-30"},"updated":"2021-03-10T01:15:14.488Z","content":"AIDL（Android Interface Definition Language），顾名思义就是android接口定义语言，用于生成可以在Android设备上两个进程之间进行进程间通信（interprocess communication, IPC）的代码。\n进程间通信场景\n我们知道android应用程序语言的许多思想来自java，而且又基于linux内核，android系统的中每一个应用程序都是一个虚拟机，android在定义之初便规定进程内的线程之间是可以通信的，而进程与进程之间是封闭的，这样做的目的是为了保证每个应用程序内部数据的稳定性和安全性，也不至于一个程序挂掉而另外一个程序也挂掉。但是非要程序与程序之间进行通信怎么办呢，这种需求又很常见，因此google便定义了AIDL这种语言规范，用来解决这个问题。\n\n\nNote: Using AIDL is necessary only if you allow clients from different applications to access your service for IPC and want to handle multithreading in your service. If you do not need to perform concurrent IPC across different applications, you should create your interface by implementing a Binder or, if you want to perform IPC, but do not need to handle multithreading, implement your interface using a Messenger. Regardless, be sure that you understand Bound Services before implementing an AIDL.\n\n以上英文是官方文档，我们根据文档说明可以得到以下信息：\n\n条件：有IPC、有多线程、有多个应用程序。方式：AIDL。\n条件：没有IPC、没有多线程、有多个应用程序。方式：Binder。\n条件：有IPC、没有多线程。方式：Messenger。\n\n所以针对进程间通信，我们要视情况而取合适的方式去解决。这样才会不耽误功夫。如果使用AIDL,在此之前一定要理解服务，因为一般是在服务中实现aidl中的方法的。\nAIDL参数约束\nAIDL其实和接口类似，区别就是前者可以进程间通信，另外AIDL对入参和方法也有一些限定，如下：\n\naidl文件中只能定义方法，不能定义静态变量。\naidl文件支持的数据类型：\n\n基本数据类型(int, byte, char, float, boolean, …)\nString\nCharSequence\nArray\nList\nMap\nParcelable\n\n\n\n另外AIDL也支持入参类型为特殊关键字in, out, inout，例如：\n12void copyArray(in byte[] source, out byte[] dest);void sort(inout int[] source);\n\nin表示由客户端设置，修饰输入参数，非基本类型的输入参数必须使用in修饰。\nout表示由服务器端设置，修饰输出参数，非基本类型的输出参数必须使用out修饰。\ninout表示既是输入参数，也是输出参数。\n\nAIDL实现计算器\n下面我就以一个计算器的例子来看AIDL是如何使用的，在这里我要建两个应用程序。一个作为客户端，一个作为服务端。客户端用于显示输入的数据和结果，服务端用于数据的计算。\n\n创建服务端\n创建服务端，并建立添加aidl文件。AndroidStudio与Eclipse建立aidl稍有不同，eclipse中sdk中没有集成相关快速建立aidl文件的插件，需要我们手动新建aidl包，手动添加aidl文件，androidstudio中可直接在相应model右键菜单新建文件下寻找到创建aidl文件。\n12345678910111213// IMyAidlInterface.aidlpackage com.example.aidltest; // Declare any non-default types here with import statements interface IMyAidlInterface &#123;    /**     * Demonstrates some basic types that you can use as parameters     * and return values in AIDL.     */    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,            double aDouble, String aString);&#125;\n默认添加aidl格式中有一个basicTypes()方法，这个方法只是告诉你aidl支持哪些参数传入，除了支持这几种类型外，还支持序列化parcelable的传递。另外说明一下，我们知道aidl从表面上看是只是一个接口文件，后缀名是.aidl,这在编译的过程中adt是不认的，只有编译成.java的java文件才能使用。Eclipse中支持自动编译。但是AndroidStudio中是不支持自动编译的，所以我们要手动编译一下（Rebuild）。\n12345678910// IMyAidlInterface.aidlpackage com.example.aidltest; // Declare any non-default types here with import statements interface IMyAidlInterface &#123;    //计算两个int数值的和；   int add(int num1,int num2);&#125;\n编译过后，我们就开一个service，在service中去实现aidl中的方法,别忘了配置文件中注册此服务。\n1234567891011121314151617181920public class IMyService extends Service &#123;     /**     * 当客户端绑定到该服务的时候，执行此方法。     * @param intent     * @return     */    @Override    public IBinder onBind(Intent intent) &#123;        return iBinder;    &#125;     private IBinder iBinder = new IMyAidlInterface.Stub() &#123;        @Override        public int add(int num1, int num2) throws RemoteException &#123;            Log.e(&quot;服务端&quot;,&quot;收到了客户端的请求，输入的参数是：&quot;+num1+&quot;和&quot;+num2);            return num1+num2;        &#125;    &#125;;&#125;\n创建客户端\n因为AIDL作为客户端和服务端通信的中间桥梁，所以我们必须保证客户端和服务端的AIDL一模一样，所以我在创建客户端后将服务端的AIDL所在的包和类全部拷贝到客户端来。\n界面这里就不提了，放张图：\n\n客户端的逻辑处理：\n\n先绑定服务端的service。\n拿到服务端的service。\n调用服务端的service，并获取结果，显示结果。\n客户端退出时结束服务端service的绑定。\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class MainActivity extends AppCompatActivity &#123;    private EditText num1_et,num2_et;    private Button result_bt;    private TextView result_tv;     IMyAidlInterface iMyAidlInterface;     private ServiceConnection conn = new ServiceConnection() &#123;         //绑定远程服务的时候        @Override        public void onServiceConnected(ComponentName name, IBinder service) &#123;            //拿到了远程的服务            iMyAidlInterface = IMyAidlInterface.Stub.asInterface(service);        &#125;         //断开远程服务的时候        @Override        public void onServiceDisconnected(ComponentName name) &#123;            //回收资源            iMyAidlInterface = null;        &#125;    &#125;;     @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        initView();        result_bt.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                String num1 = num1_et.getText().toString().trim();                String num2 = num2_et.getText().toString().trim();                if (TextUtils.isEmpty(num1)||TextUtils.isEmpty(num2))&#123;                    Toast.makeText(MainActivity.this,&quot;参数不能为空&quot;,Toast.LENGTH_SHORT).show();                &#125;else &#123;                    try &#123;                        //调用远程服务获取结果                        int res = iMyAidlInterface.add(Integer.valueOf(num1),Integer.valueOf(num2));                        result_tv.setText(res+&quot;&quot;);                    &#125; catch (RemoteException e) &#123;                        e.printStackTrace();                        Toast.makeText(MainActivity.this,&quot;获取结果失败，检查参数格式是否正确。&quot;,Toast.LENGTH_SHORT).show();                    &#125;                &#125;            &#125;        &#125;);         //绑定服务端的service        bindService();    &#125;     private void initView() &#123;        num1_et = (EditText) findViewById(R.id.num1_et);        num2_et = (EditText) findViewById(R.id.num2_et);        result_bt = (Button) findViewById(R.id.result_bt);        result_tv = (TextView) findViewById(R.id.result_tv);    &#125;     private void bindService() &#123;        //绑定服务端的服务,由于服务端和客户端不在一个进程，所以我们需要直接指定服务端的包名和类名，注意类名要写全。        Intent intent = new Intent();        intent.setComponent(new ComponentName(&quot;com.example.aidltest&quot;,&quot;com.example.aidltest.IMyService&quot;));        bindService(intent,conn, Context.BIND_AUTO_CREATE);    &#125;     @Override    protected void onDestroy() &#123;        super.onDestroy();        //断开服务端的service        unbindService(conn);    &#125;&#125;\n验证结果\n查看进程间通信是否成功。先后开启服务端和客户端，输入相关参数，然后在服务端控制台中看到服务端service接受到的两个参数：\n\n客户端界面展示结果：\n\nAIDL实现过程分析\n我们来看一下AIDL文件编译后的java文件，分析一下其本质，代码如下\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package com.example.aidltest;// Declare any non-default types here with import statementspublic interface IMyAidlInterface extends android.os.IInterface &#123;    /**     * Local-side IPC implementation stub class.     */    public static abstract class Stub extends android.os.Binder implements com.example.aidltest.IMyAidlInterface &#123;        private static final java.lang.String DESCRIPTOR = &quot;com.example.aidltest.IMyAidlInterface&quot;;        /**         * Construct the stub at attach it to the interface.         */        public Stub() &#123;            this.attachInterface(this, DESCRIPTOR);        &#125;        /**         * Cast an IBinder object into an com.example.aidltest.IMyAidlInterface interface,         * generating a proxy if needed.         */        public static com.example.aidltest.IMyAidlInterface asInterface(android.os.IBinder obj) &#123;            if ((obj == null)) &#123;                return null;            &#125;            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);            if (((iin != null) &amp;&amp; (iin instanceof com.example.aidltest.IMyAidlInterface))) &#123;                return ((com.example.aidltest.IMyAidlInterface) iin);            &#125;            return new com.example.aidltest.IMyAidlInterface.Stub.Proxy(obj);        &#125;        @Override        public android.os.IBinder asBinder() &#123;            return this;        &#125;        @Override        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123;            switch (code) &#123;                case INTERFACE_TRANSACTION: &#123;                    reply.writeString(DESCRIPTOR);                    return true;                &#125;                case TRANSACTION_add: &#123;                    data.enforceInterface(DESCRIPTOR);                    int _arg0;                    _arg0 = data.readInt();                    int _arg1;                    _arg1 = data.readInt();                    int _result = this.add(_arg0, _arg1);                    reply.writeNoException();                    reply.writeInt(_result);                    return true;                &#125;            &#125;            return super.onTransact(code, data, reply, flags);        &#125;        private static class Proxy implements com.example.aidltest.IMyAidlInterface &#123;            private android.os.IBinder mRemote;            Proxy(android.os.IBinder remote) &#123;                mRemote = remote;            &#125;            @Override            public android.os.IBinder asBinder() &#123;                return mRemote;            &#125;            public java.lang.String getInterfaceDescriptor() &#123;                return DESCRIPTOR;            &#125;            /**             * 计算两个int数值的和；             * @param num1             * @param num2             * @return             * @throws android.os.RemoteException             */            @Override            public int add(int num1, int num2) throws android.os.RemoteException &#123;                android.os.Parcel _data = android.os.Parcel.obtain();                android.os.Parcel _reply = android.os.Parcel.obtain();                int _result;                try &#123;                    _data.writeInterfaceToken(DESCRIPTOR);                    _data.writeInt(num1);                    _data.writeInt(num2);                    mRemote.transact(Stub.TRANSACTION_add, _data, _reply, 0);                    _reply.readException();                    _result = _reply.readInt();                &#125; finally &#123;                    _reply.recycle();                    _data.recycle();                &#125;                return _result;            &#125;        &#125;        static final int TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);    &#125;    //计算两个int数值的和；    public int add(int num1, int num2) throws android.os.RemoteException;&#125;\n通过上边编译后的文件可以看出，AIDL文件从表面上看是一个接口，编译过后形成java文件还是一个接口。\n这个文件看起来很繁杂，我们将其相关代码合并一下，从整体来看就一个抽象类Stub和一个将要实现的方法add。add方法有两个作用：一个就是在服务端service里面进行实现，另一个就是客户端进行传值。抽象类Stub是继承于系统的Binder，又实现了aidl接口中方法，其构造方法就是客户端绑定服务端service时返回的Binder。\n接口类中asInterface()方法目的就是客户端根据上一步返回的Bandler从而拿到服务端的service(通过内部类Proxy获取)。接下来onTransact()方法目的是服务端service实现add()方法是对参数的限制和结果接收。\n看到这一切应该就豁然开朗了吧，其实AIDL使用起来很简单，关键是要理解其内部的一个过程，这也是理解进程间通信的必经之路。\n","plink":"https://blog.ixin.run/posts/1469856029/"},{"title":"什么是进程，什么是线程","date":"2016-07-28T05:03:39.000Z","date_formatted":{"ll":"2016年7月28日","L":"2016/07/28","MM-DD":"07-28"},"updated":"2021-01-29T12:51:44.673Z","content":"提到进程和线程，大家都有所了解，但是据其概念又比较抽象不容易掌握。计算机科学是人类进步的结晶，但是也是为人类服务，所以千万不要被我们自己创造的东西绕进去而最终不知道这玩意到底是啥，所以提炼升华转成大白话最重要。\n\n什么是进程？\n进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。\n进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的代码，还包括当前的活动，通过程序计数器的值和处理寄存器的内容来表示。\n什么是线程？\n线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。\n进程 VS 线程\n简单的说，进程是指在操作系统中正在运行的一个应用程序，线程是指进程内独立执行某个任务的一个单元。进程注重某项功能或活动的实现，而线程是实现这个功能或活动的具体步骤（同步过程和异步过程），前者是后者的集合体。\n线程与进程有很多类似的性质，因此人们习惯上也称线程为轻量级进程（ lightweightprocess, LWP），也是CPU调度和分派的基本单元；而传统意义上的进程则被称为重量级进程（heavyweight process, HWP），从现代的角度来看，它就是只拥有一个线程的进程。如果进程有多个控制线程，那么它就能同时执行多个任务。他们之间的关系可以简单的由下图表示：\n\n1）进程是静态的，其实就是指开启的一个程序；而线程是动态的，是真正执行的单元，执行的过程。其实我们平时看到的进程，是线程在执行着，因为线程是作为进程的一个单元存在的。\n2）同样作为基本的执行单元，线程是划分得比进程更小的执行单位。\n3）每个进程都有一段专用的内存区域。与此相反，线程却共享内存单元（包括代码和数据），通过共享的内存单元来实现数据交换、实时通信与必要的同步操作。\n下面，主要从调度、并发性、系统开销、拥有资源等方面来对线程和进程进行比较：\n调度\n在传统的操作系统中，CPU调度和分派的基本单位是进程。而在引入线程的操作系统中，则把线程作为CPU调度和分派的基本单位，进程则作为资源拥有的基本单位，从而使传统进程的两个属性分开，线程便能轻装运行，这样可以显著地提高系统的并发性。同一进程中线程的切换不会引起进程切换，从而避免了昂贵的系统调用。但是在由一个进程中的线程切换到另一进程中的线程时，依然会引起进程切换。\n并发性\n在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间也可以并发执行，因而使操作系统具有更好的并发性，从而能更有效地使用系统资源和提高系统的吞吐量。例如，在一个未引入线程的单CPU操作系统中，若仅设置一个文件服务进程，当它由于某种原因被封锁时，便没有其他的文件服务进程来提供服务。在引入了线程的操作系统中，可以在一个文件服务进程中设置多个服务线程。当第一个线程等待时，文件服务进程中的第二个线程可以继续运行；当第二个线程封锁时，第三个线程可以继续执行，从而显著地提高了文件服务的质量以及系统的吞吐量。\n系统开销\n不论是引入了线程的操作系统，还是传统的操作系统，进程都是拥有系统资源的一个独立单位，它可以拥有自己的资源。一般地说，线程自己不拥有系统资源（也有一点必不可少的资源），但它可以访问其隶属进程的资源。亦即一个进程的代码段、数据段以及系统资源（如已打开的文件、I/O设备等），可供同一进程的其他所有线程共享。\n拥有资源\n由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的进程的CPU环境的设置。而线程切换只需保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。此外，由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现也变得比较容易。在有的系统中，线程的切换、同步和通信都无需操作系统内核的干预。\n顺便说一些\n\n\n在单核计算机里，有一个资源是无法被多个程序并行使用的：CPU。\n没有操作系统的情况下，一个程序一直独占着全都cpu。如果要有两个任务来共享同一个cpu，程序员就需要仔细地为程序安排好运行计划–某时刻cpu和由程序A来独享，下一时刻cpu由程序B来独享，而这种安排计划后来成为OS的核心组件，被单独名命为“scheduler”，即“调度器”，它关心的只是怎样把单个cpu的运行拆分成一段一段的“运行片”，轮流分给不同的程序去使用，而在宏观上，因为分配切换的速度极快，就制造出多程序并行在一个cpu上的假象。\n\n\n在单核计算机里，有一个资源可以被多个程序共用，然而会引出麻烦：内存。\n在一个只有调度器，没有内存管理组件的操作系统上，程序员需要手工为每个程序安排运行的空间 – 程序A使用物理地址0x00-0xff,程序B使用物理地址0x100-0x1ff，等等。然而这样做有个很大的问题：每个程序都要协调商量好怎样使用同一个内存上的不同空间，软件系统和硬件系统千差万别，使这种定制的方案没有可行性。\n为了解决这个麻烦，计算机系统引入了“虚拟地址”的概念，从三方面入手来做：\n\n硬件上，CPU增加了一个专门的模块叫MMU，负责转换虚拟地址和物理地址。\n操作系统上，操作系统增加了另一个核心组件：memory management，即内存管理模块，它管理物理内存、虚拟内存相关的一系列事务。\n应用程序上，发明了一个叫做【进程】的模型，（注意）每个进程都用【完全一样的】虚拟地址空间，然而经由操作系统和硬件MMU协作，映射到不同的物理地址空间上。不同的【进程】，都有各自独立的物理内存空间，不用一些特殊手段，是无法访问别的进程的物理内存的。\n\n\n\n现在，不同的应用程序可以不关心底层的物理内存分配，也不关心CPU的协调共享了。然而还有一个问题存在：有一些程序，想要共享CPU，【并且还要共享同样的物理内存】，这时候，一个叫【线程】的模型就出现了，它们被包裹在进程里面，在调度器的管理下共享CPU，拥有同样的虚拟地址空间，同时也共享同一个物理地址空间，然而，它们无法越过包裹自己的进程，去访问别一个进程的物理地址空间。\n\n\n进程之间怎样共享同一个物理地址空间呢？不同的系统方法各异，符合posix规范的操作系统都提供了一个接口，叫mmap，可以把一个物理地址空间映射到不同的进程中，由不同的进程来共享。\n\n\n参考\n\n进程——百度百科\n线程——百度百科\n进程与线程的一个简单解释——阮一峰\n\n","plink":"https://blog.ixin.run/posts/1469682219/"},{"title":"Android开发Handler消息机制探究","date":"2016-07-27T07:41:45.000Z","date_formatted":{"ll":"2016年7月27日","L":"2016/07/27","MM-DD":"07-27"},"updated":"2021-01-29T12:51:44.627Z","content":"我们知道一个应用启动时系统会为其创建一个进程，而每一个Activity启动的时候又会形成一个线程，这个线程叫主线程，又叫UI线程。Android的主线程是不安全的，因为从主线程中可以创建多个子线程来分配任务，一个activity的所有view都是唯一的，都有唯一的标识，如果在每个子线程中更新view，我们不能预知线程执行结果的先后顺序，也就无法预知什么时候才能更新view，所以造成结果就是view更新时的冲突问题。这也就是为什么从安卓2.0之后官方规定只能在主线程中更新界面了，子线程执行结果后通知主线程更新界面的桥梁便需要handler来帮忙，本篇深入探究一下handle的工作机制。\n\nHandler是什么\n上边提到Android中子线程执行结果后需要通知主线程去更新界面，中间的桥梁就是handler，一句话说明白handler就是线程之间通信的桥梁。\nHandler重要有两个作用：\n\n在一个线程中发送消息。\n在另外一个线程中接收消息。\n\nHandler的使用\nHandler类中包含如下方法用于发送和处理消息：\n\nvoid handlerMessage(Message msg)：处理消息的方法,该方法通常用于被重写。\nfinal boolean hasMessage(int what)：检查消息队列中是否包含what属性为指定值的消息。\nfinal boolean hasMessage(int what,Object object)：检查消息队列中是否包含what属性为指定且object属性为指定指定对象的消息。\n多个重载的obtainMessage()：从消息池中获取消息（消息池中没有则会重新生成一个，也可以用“Message.obtain()”来代替）\nsendEmptyMessage(int what)：发送空消息。\nfinal boolean sendEmptyMessageDelayed(int what,long delayMillis)：指定多少毫秒之后发送空消息。\nfinal boolean sendMessage(Message msg)：立即发送消息。\nfinal boolean sendMessageDelayed(Message msg,long delayMillis)：指定多少毫秒之后发送消息。\n\n口说无凭，栗子先行\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MainActivity extends AppCompatActivity &#123;     private Handler handler;     @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        new MyThread1().start();        new MyThread2().start();    &#125;     class MyThread1 extends Thread &#123;         @Override        public void run() &#123;            super.run();             Looper.prepare();             handler = new Handler()&#123;                @Override                public void handleMessage(Message msg) &#123;                    super.handleMessage(msg);                    System.out.println( &quot;threadName--&quot; + Thread.currentThread().getName() + &quot;messageWhat-&quot;+ msg.what );                &#125;            &#125;;             Looper.loop();        &#125;    &#125;     class MyThread2 extends Thread &#123;        @Override        public void run() &#123;            super.run();             try &#123;                sleep( 4000 );            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;             handler1.sendEmptyMessage(0) ;        &#125;    &#125;&#125;\n眼尖的同学可能会看到创建Handler对象时上边下边分别来了一个“Looper.prepare()”、“Looper.loop()”，并且这两行去掉后程序直接报异常，但是我们平时在开发过程并没有写这两句也一样运行完好怎么回事呢？接下来通过Handler的工作原理为这些疑惑解开面纱。\nHandler的工作原理\n为了更好的理解Handler的工作原理，先介绍一下与Handler一起工作的几个组件。\n\nMessage: Handler接收和处理的消息对象。\nLooper:每个线程只能拥有一个Looper。它的loop方法负责读取MessageQueue中的消息，之后把消息交给发送该消息的Handler处理。\nMessageQueue:消息队列，使用先进先出的方式来管理Message。程序创建Looper对象时会在它的构造器中创建MessageQueue对象。\n\nLooper构造器：\n12345private Looper() &#123;    mQueue = new MessageQueue();    mRun = true;    mThread = Thread.currentThread();&#125;\n该构造器使用了private进行修饰，我们平时使用过程中不能直接通过此构造器创建一个实例。这个构造器同时也告诉我们在初始化Looper时会创建一个与之关联的MessageQueue，负责管理消息的存储队列。\nHandler主要作用就是发送消息和处理消息，Handler发送消息必须被送到指定线程的消息队列MessageQueue，所以在Handler创建之前必须要有一个属于该线程的MessageQueue的实例对象，而MessageQueue却是由Looper初始化时进行实例化的，所以在Handler创建之前必须要有一个该线程所属的Looper的存在，这就回归到之前所提的为什么要在Handler创建前后分别进行追加“Looper.prepare()”、“Looper.loop()”的疑惑了。\nLooper.prepare()\n线程中创建Handler对象必须要先创建一个Looper，而我们自主创建Looper对象直接调用它的prepare()方法即可：\n12345678910public static void prepare() &#123;    prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123;    if (sThreadLocal.get() != null) &#123;        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);    &#125;    sThreadLocal.set(new Looper(quitAllowed));&#125;\nprepare方法还有一个作用就是保证每个线程只有一个Looper对象，其原理就是从ThreadLocal中判断当前线程是否已经存在了一个Looper，如果有则抛出异常，告诉你Looper有了不用再创建了。针对ThreadLocal的认识，我后边也会重点研究一下。\nAndroid的UI更新必须在主线程。主UI线程中系统已经初始化了一个Looper对象，因此在主线程中直接new一个Handler对象即可，如果我们希望在子线程中创建Handler对象来更新UI，则需要传入主线程Looper：\n1234567Handler mainHandler = new Handler(Looper.getMainLooper());mainHandler.post(new Runnable() &#123;    @Override    public void run() &#123;        //在主线程中更新UI    &#125;&#125;);\n消息的发送\n消息的发送是由Handler处理的，并且发送消息的形式有多样，但是最终都会走到一个sendMessageAtTime这个方法内：\n12345678910public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;    MessageQueue queue = mQueue;    if (queue == null) &#123;        RuntimeException e = new RuntimeException(                this + &quot; sendMessageAtTime() called with no mQueue&quot;);        Log.w(&quot;Looper&quot;, e.getMessage(), e);        return false;    &#125;    return enqueueMessage(queue, msg, uptimeMillis);&#125;\nhandler在发送message的时候首先要找到handler所引用的消息队列，然后才把消息排在消息队列里。\n1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;    msg.target = this;    if (mAsynchronous) &#123;        msg.setAsynchronous(true);    &#125;    return queue.enqueueMessage(msg, uptimeMillis);&#125;\n准备存入消息队列的消息首先要先设定一个target，并且指向该handler自己，目的就是为了在处理消息环节中，Message能找到正确的Handler，以便准确的被抽取和向下分发。\nLooper.loop()\n“Looper.prepare()”是创建消息管理器和消息队列，而“Looper.loop()”则是对消息的依次抽取和分发。loop()方法使用一个死循环不断抽取MessageQueue中的消息，并将取出的消息分发给该消息对应的Handler进行处理：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */public static void loop() &#123;    final Looper me = myLooper();    if (me == null) &#123;        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;);    &#125;    final MessageQueue queue = me.mQueue;    // Make sure the identity of this thread is that of the local process,    // and keep track of what that identity token actually is.    Binder.clearCallingIdentity();    final long ident = Binder.clearCallingIdentity();    for (;;) &#123;        Message msg = queue.next(); // might block        if (msg == null) &#123;            // No message indicates that the message queue is quitting.            return;        &#125;        // This must be in a local variable, in case a UI event sets the logger        final Printer logging = me.mLogging;        if (logging != null) &#123;            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +                    msg.callback + &quot;: &quot; + msg.what);        &#125;        final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;        final long traceTag = me.mTraceTag;        if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));        &#125;        final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();        final long end;        try &#123;            msg.target.dispatchMessage(msg);            end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();        &#125; finally &#123;            if (traceTag != 0) &#123;                Trace.traceEnd(traceTag);            &#125;        &#125;        if (slowDispatchThresholdMs &gt; 0) &#123;            final long time = end - start;            if (time &gt; slowDispatchThresholdMs) &#123;                Slog.w(TAG, &quot;Dispatch took &quot; + time + &quot;ms on &quot;                        + Thread.currentThread().getName() + &quot;, h=&quot; +                        msg.target + &quot; cb=&quot; + msg.callback + &quot; msg=&quot; + msg.what);            &#125;        &#125;        if (logging != null) &#123;            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);        &#125;        // Make sure that during the course of dispatching the        // identity of the thread wasn&#x27;t corrupted.        final long newIdent = Binder.clearCallingIdentity();        if (ident != newIdent) &#123;            Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;                    + Long.toHexString(ident) + &quot; to 0x&quot;                    + Long.toHexString(newIdent) + &quot; while dispatching to &quot;                    + msg.target.getClass().getName() + &quot; &quot;                    + msg.callback + &quot; what=&quot; + msg.what);        &#125;        msg.recycleUnchecked();    &#125;&#125;\n消息的分发\n123456789101112131415/** * Handle system messages here. */public void dispatchMessage(Message msg) &#123;    if (msg.callback != null) &#123;        handleCallback(msg);    &#125; else &#123;        if (mCallback != null) &#123;            if (mCallback.handleMessage(msg)) &#123;                return;            &#125;        &#125;        handleMessage(msg);    &#125;&#125;\n到这一步也算是最后一步消息即将传递到位，只等回调出来了。\n注意\n平时使用Handler过程中，我们要格外注意性能和内存泄漏问题。\n\n\n消息发送有可能是很频繁的，每发送一条消息，我们就要创建一个Message对象，如果发送过快势必会不断的创建新对象导致内存消耗问题。所以我们平时创建对象一般不采用new的形式，而是从消息池中取出来一个“存在”的，有两种方式：\n\nMessage msg = handler.obtainMessage();\nMessage msg = Message.obtain();\n\n\n\n消息发送有可能是缓慢的，此时Handler会持有当前类的引用，这就导致内存无法及时回收进而内存泄漏。针对这个问题要三个手段进行配合最好：\na. Handler定义采用静态内部类的形式定义，脱离类引用的束缚。\nb. Handler内部引用当前类时采用弱引用形式引用，以便于及时回收。\nc. 当前类销毁时取消一切Handler的消息发送。\n\n\n以上是我对Handler的认识，不准确之处望各位同学指出。\n","plink":"https://blog.ixin.run/posts/1469605305/"},{"title":"JAVA设计模式之代理模式","date":"2016-06-15T08:12:56.000Z","date_formatted":{"ll":"2016年6月15日","L":"2016/06/15","MM-DD":"06-15"},"updated":"2021-01-29T12:51:44.656Z","content":"说起Java代理模式，不明其理可能一头雾水，明白了也就很简单了。举一个生活中最典型的例子：律师代替原告打官司，来看一下过程：\n\n原告准备做哪些事：原告可以提供很多材料给律师，目的是打官司赢地皮。\n律师二次包装：律师利用自身丰厚的经验根据这些材料帮着打。\n原告有信息不愿透漏：律师只能根据原告提供的信息进行辩论，原告也许有暗黑的一面，不愿意让律师说出来。\n\n最终结果：律师能否打赢，注重看律师的水平，当然离不开原告所提供资料的充分和真实。\n\n代理模式定义\n代理模式(Proxy Pattern)：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。\n在某些情况下，一个客户不想或者不能直接引用一个对 象，此时可以通过一个称之为“代理”的第三者来实现 间接引用。代理对象可以在客户端和目标对象之间起到 中介的作用，并且可以通过代理对象去掉客户不能看到 的内容和服务或者添加客户需要的额外服务。\n移动端开发的时候最常见的一种代理形式就是远程加载图片，可以先加载一个小图，根据用户意愿如果用户愿意加载原图再开启线程进行加载大图，这里的小图就是代理者。\n代理模式结构\n按照代理模式定义只需要两个角色即可，一个是的源对象，另一个是代理者。但是通常代理者需要代替源对象做一些事情，所以我们需要把这部分共有的功能给抽象出来，这样还有一个好处就是可以很好地隐藏和保护被代理者。结构如图：\n\n代理模式的使用环境\n\n远程(Remote)代理：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又叫做大使(Ambassador)。\n虚拟(Virtual)代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。\nCopy-on-Write代理：它是虚拟代理的一种，把复制（克隆）操作延迟到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。\n保护(Protect or Access)代理：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。\n缓冲(Cache)代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。\n防火墙(Firewall)代理：保护目标不让恶意用户接近。\n同步化(Synchronization)代理：使几个用户能够同时使用一个对象而没有冲突。\n智能引用(Smart Reference)代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。\n\n静态代理和动态代理\n按照代理类生成的时间我们可以将代理模式分为静态代理和动态代理。\n静态代理，就是程序员事先已经将代理类实现并编译，然后在主程序运行时直接调用即可。\n动态代理，代理类字节码在程序运行期间由jvm根据反射机制动态生成，代理者和被代理者的关系是在程序运行中确定的。\n静态代理的两种实现：\n1.静态代理的采用继承方式的实现过程：\n123456789101112131415161718192021222324252627282930313233343536373839package com.reflect;/** * 被代理者和代理者所需要实现的接口 */interface ISay &#123;\tvoid say(String name, int age);&#125;/** * 被代理者 */class Person implements ISay &#123;\t@Override\tpublic void say(String name, int age) &#123;\t\tSystem.out.println(&quot;名字叫&quot; + name + &quot;,年龄&quot; + age);\t&#125;&#125;/** * 代理者 */class ProxyPerson extends Person &#123;\t// 重写父类的方法\t@Override\tpublic void say(String name, int age) &#123;\t\tSystem.out.println(&quot;代理人说出了这个人的信息：&quot;);\t\tsuper.say(name, age);\t&#125;&#125;public class Test &#123;\tpublic static void main(String[] args) &#123;\t\tISay proxyPerson = new ProxyPerson();\t\tproxyPerson.say(&quot;张三&quot;, 18);\t&#125;&#125;\n上边只是一个代理对象，假如有多个代理对象并且有一个先后运行的顺序，那么采用继承的方式将显的有点笨拙了。静态代理可以看做是一个嵌套运行对象方法的模式，知道了这一点，我们还可以采用聚合的方式去写，这样会显的相对灵活些。\n2.静态代理的采用聚合方式的实现过程：\n12345678910111213141516171819202122232425262728293031323334353637383940414243package com.reflect;/** * 被代理者和代理者所需要实现的接口 */interface ISay &#123;\tvoid say(String name, int age);&#125;/** * 被代理者 */class Person implements ISay &#123;\t@Override\tpublic void say(String name, int age) &#123;\t\tSystem.out.println(&quot;名字叫&quot; + name + &quot;,年龄&quot; + age);\t&#125;&#125;/** * 代理者 */class ProxyPerson implements ISay &#123;\tprivate Person person;\t\tpublic ProxyPerson(Person person)&#123;\t\tthis.person = person;\t&#125;\t@Override\tpublic void say(String name, int age) &#123;\t\tSystem.out.println(&quot;代理人说出了这个人的信息：&quot;);\t\tperson.say(name, age);\t&#125;&#125;public class Test &#123;\tpublic static void main(String[] args) &#123;\t\tISay proxyPerson = new ProxyPerson(new Person());\t\tproxyPerson.say(&quot;张三&quot;, 18);\t&#125;&#125;\n静态代理的优缺点：\n优点：层次分明，如果需要增加更多的代理功能只需要关注代理类即可，另外在程序运行时要先进行编译，保证程序的准确性。\n缺点：\n\n代理对象的一个接口只服务于一种类型的对象，如果要代理的对象很多，势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。\n如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。\n\n动态代理实现过程：\n动态代理似乎正是为了上边静态代理那两大缺点做准备的。动态代理的将代理类中的所有的代理方法全部封装到一个方法中，处理起来更加便捷。另外在某种情况下更是减少部分代理类的代码的编写。\n动态代理实现过程主要分三步：\n\n实现InvocationHandler接口创建处理器类，并在其内部重写invoke()方法，将来所有的要代理的方法都要在此方法中进行调用。\n获取被代理者的实例。\n拿到被代理者的方法对象调用代理方法。\n\n动态代理的代码实现过程：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.reflect;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;&#x2F;** * 被代理者和代理者所需要实现的接口 *&#x2F;interface ISay &#123;    void say(String name,int age);&#125;&#x2F;** * 被代理者 *&#x2F;class Person implements ISay &#123;    @Override    public void say(String name, int age) &#123;        System.out.println(&quot;名字叫&quot; + name + &quot;,年龄&quot; + age);    &#125;&#125;&#x2F;** * 控制动态代理的处理器 *&#x2F;class MyInvocationHandler implements InvocationHandler &#123;    private Object object &#x3D; null;    &#x2F;*     * 获取代理者     *&#x2F;    public Object bind(Object object) &#123;        &#x2F;&#x2F;得到被代理者实例        this.object &#x3D; object;        &#x2F;&#x2F;根据被代理者返回动态代理类实例，第一个参数是指定类加载器，第二个参数是指定代理类需要实现的一系列接口，第三个参数是控制动态代理的处理器本身实例        return Proxy.newProxyInstance(object.getClass().getClassLoader(), object.getClass().getInterfaces(),this);    &#125;    &#x2F;*     *代理者需要实现的代理方法      *参数一：代理者实例（上边bind方法返回的）；     *参数二：被代理者调用的方法对象     *参数三：被代理者传入的相关参数     *&#x2F;    @Override    public Object invoke(Object proxy, Method method, Object[] args)            throws Throwable &#123;        System.out.println(&quot;代理人说出了这个人的信息：&quot;);        method.invoke(this.object, args);        return null;    &#125;&#125;public class Test &#123;    public static void main(String[] args) throws Exception &#123;        MyInvocationHandler invocationHandler &#x3D; new MyInvocationHandler();         ISay proxyPerson&#x3D; (ISay) invocationHandler.bind(new Person());        proxyPerson.say(&quot;张三&quot;, 18);    &#125;&#125;\n动态代理代理者对象生成分析\n看到上面代码有同学可能会问，那动态代理的代理者对象是如何生成的呢？我们不妨逆势而上而观之，先从传入参数下手，依次向上推。从底层得知其实获取代理者对象也就四步：\n第一步：实现InvocationHandler接口创建自己的调用处理器，将来作为代理者有参构造器的一个参数。\n1InvocationHandler h = new InvocationHandler();\n第二步：根据被代理者classload()和相关代理接口获取代理者Class类实例。\n1Class&lt;?&gt; cl = getProxyClass0(loader, interfaces);\n第三步：根据第二步拿到的代理者实例对象获取代理者内部构造函数。\n1Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);\n第四步：根据代理者内部构造函数最终拿到代理者对象。\n1cons.newInstance(new Object[] &#123;h&#125; );\n最终得到代理者对象其实就是这一句：\n1Object object = Proxy.newProxyInstance(object.getClass().getClassLoader(), object.getClass().getInterfaces(),this);\n总结\n以上就是我对代理模式的认识，代理模式的优点就是能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。当然缺点也是存在的，由于在客户端和真实主角之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，并且实现代理模式更多的是需要额外的工作，这种情况下有些代理模式的实现却显得非常复杂了。\n","plink":"https://blog.ixin.run/posts/1465978376/"},{"title":"Android开发之单元测试初探","date":"2016-06-12T06:36:07.000Z","date_formatted":{"ll":"2016年6月12日","L":"2016/06/12","MM-DD":"06-12"},"updated":"2021-01-29T12:51:44.635Z","content":"从androidstudio1.5开始新建安卓项目中有两个测试包,androidTest和test。其中前者是针对设备进行的测试，即官方支持的UI测试，后者是直接在本机上进行测试即最常见的本地单元测试。在androidStudio1.5之前只有前者，单元测试要自己重建，如图：\n\n\nAndroid项目中的单元测试\nandroid测试一般有三种形式：\n\nlocal tests  本地单元测试，不依赖Android framework（单纯的JunitTest）或使用 Mockito 模拟依赖对象(需要进行类注解修改测试运行器)，直接运行在JVM上，以最大限度的减少时间。\ninstrumented tests  必须要运行在Android设备，官方原始测试方式（测试用例写起来比较庞大）\nUI Test  使用UI测试框架模拟用户交互来进行测试（espresso、uiautomator）\n\nJUnit单元测试\n先说一下单元测试，在Java工程中目前最常用就是Junit4的使用了。使用前要先将junit的jar包导入到项目中。在进行androidstudio中开发时就不需要了，因为我们可以在gradle中直接引入依赖`testCompile ‘junit:junit:4.12’。\n单元测试可以测试那些内容？\n这里需要说明的是Android studio的单元测试由于只是模拟Android开发环境，但是其不是真正的Android开发环境，所以不能测试UI功能，不能测试需要硬件支持的功能（比如蓝牙，wifi等），不能测试App跳转等等，以下是主要功能：\n\n测试一些数据性的功能，比如加载网络数据。\n测试SharedPerferences，测试数据库，测试函数等。\n工具类的测试，比如验证时间，转化格式，正则验证等等。\n\n一个Demo\n在Android工程项目中假设有一个类需要进行单元测试：\n123456789101112131415161718public class Calculate &#123;public int add(int a,int b)&#123;    return a+b;&#125;public int subtract(int a, int b)&#123;    return a-b;&#125;public int multiply(int a, int b)&#123;    return a*b;&#125;public int divide(int a, int b)&#123;    return a/b;&#125;&#125;\n然后我们建立测试类，只需在打开的类中右键选择Go To -&gt; Test 新建一个测试类即可：\n\n其中@Befor/@After打勾会在测试类中初始的时候添加这两个方法（这两个方法后边再讲）。下边待测试方法勾选上，点击ok即可。\n上边是视图创建的方式，当然我们也可以在test-&gt;java包下新建一个源代码目录并自己创建一个测试类，功能一样:\n123456789101112131415161718192021222324252627282930public class CalculateTest &#123;@Beforepublic void setUp() throws Exception &#123;&#125;@Afterpublic void tearDown() throws Exception &#123;&#125;@Testpublic void add() throws Exception &#123;    assertEquals(&quot;加法错误&quot;, 5, new Calculate().add(1,2));&#125;@Testpublic void subtract() throws Exception &#123;    assertEquals(&quot;减法错误&quot;, 1, new Calculate().subtract(2,2));&#125;@Testpublic void multiply() throws Exception &#123;    assertEquals(&quot;乘法错误&quot;, 4, new Calculate().multiply(2,2));&#125;@Testpublic void divide() throws Exception &#123;    assertEquals(&quot;除法错误&quot;, 3, new Calculate().divide(6,2));&#125;&#125;\n初始的时候所有的方法内部其实都是空的，以上方法内部采用assertEquals（断言）来进行测试，这里有两种形式（一般情况采用方式1即可）：\n1234567//方式1//参数1：期望值。参数2：实际值assertEquals(double expected, double actual) //方式2//参数1：控制台提示错误信息。参数2：期望值。参数3：实际值。assertEquals(String message, long expected, long actual)\n**运行：**直接在方法名上右键或者在类名上进行run就可以了。\n划重点：你以为这里运行通过了就没什么事儿了吗？如果这样想就错了，因为单元测试不是证明你的方法是对于项目是否是切实可行的，而是证明这个方法能否不报错，所以我们在写测试用例的时候要认真，有可能本来是可以通过的，但是你的测试用例写错了，同样也报错，这就尴尬了。\n创建单元测试类注意点\n以下是创建单元测试类需要注意的几个地方：\n\n在项目根目录test-&gt;java包下新建一个源代码目录来存放我们的测试代码。\n测试类的包名应该和被测试类的包名保持一致。\n测试单元中每个方法必须可以独立测试，测试方法间不能有任何的依赖关系。\n测试类使用Test作为类名的后缀。（不是必须）\n测试方法建议使用test作为方法名的前缀。（不是必须）\n所有的待测试的方法都是采用注解@Test修饰的。\n所有的测试方法都是public void修饰的,不带任何参数。\n测试判断采用assertEquals断言进行判断。\n\nJunit单元测试常用方法\n@Test(expected = xxx.class)\n有些时候我们在单元测试方法中会感觉预期有一个异常出现，但是我们又感觉他不重要想忽略他以保证执行通过，则可以用@Test(expected = xxx.class)，后边跟的是异常的类名。有一点注意如果异常的地方在循环体内只会执行一次哦。\n1234567@Test(expected = ArithmeticException.class)public void test()&#123;    while (true)&#123;        System.out.println(&quot;+++++++++++++++++++test&quot;);        assertEquals(3, new Calculate().divide(9, 0));    &#125;&#125;\n@Test(timeout = 2000)\n有些时候我们在测试方法里可能写一些耗时的操作，或者循环操作，但是我们不知道什么时候终止，这个时候可以采用@Test(timeout = 2000)来处理，后边跟的是可执行时间，单位为毫秒。如果超时了执行也就不能通过了，这个时候会报TestTimedOutException异常错误，告诉开发者超时了需要进行处理。\n12345678@Test(timeout = 2000)public void test()&#123;    try &#123;        Thread.sleep(5000);    &#125; catch (InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;\n@Before 在每个test方法执行前都要执行一次。\n@After 在每个test方法执行后都要执行一次。\n这两个注解也是上面初始创建时选择勾选的两个方法注解。主要是为了每个测试方法执行前后的一个初始处理和结束处理。\n@BeforeClass 在所有单元测试方法执行前执行，static修饰。\n@AfterClass 在所有单元测试方法执行后执行，static修饰。\n这两个注解所在的方法一定要用static修饰，@BeforeClass：测试类被运行就会被加载，在内存中只有一份实例，适合加载配置文件；@AfterClass：用于资源的清理，如关闭数据库。\n@Ignore\n所修饰的测试方法会被测试运行器忽略。\n@RunWith(xx.class)\n修改测试运行器，JUnit4默认的测试运行器是org.junit.runner.Runner.class。\n如果采用mockito来测试需要修改为MockitoJUnitRunner.class，同时需要在gradle中dependencies下引入依赖testCompile 'org.mockito:mockito-core:1.10.19'，另外测试注解也不再是@Test了，mockito第三方库很多，具体看自己的业务情况。\n如果是UI Test，也和上面一样，需要引入依赖，并修改测试运行器，具体用法也要结合第三方官方文档。\n如果是instrumented tests，需要将测试运行器修改为AndroidJUnitRunner.class,需要在gradle中依赖：testInstrumentationRunner 'android.support.test.runner.AndroidJUnitRunner'。\n@Suite.SuiteClasses({xxx0.class,xxx1.class})\n如果有多个测试类想一次性测试完，可以建一个“空”的suite类，然后采用@Suite.SuiteClasses({})注解，将要测试的测试类添加到里面，另外追加测试运行器为@Suite(Suite.class)，运行这个suite类即可。\n1234@RunWith(Suite.class)@Suite.SuiteClasses(&#123;CalculateTest.class, Calculate2Test.class &#125;)public class SuiteTest &#123;&#125;\nMockito单元测试\n上边JUnit单元测试主要功能就是验证某个方法的结果是否正常，有些功能方法在输入参数后却不能立刻获取其结果不能紧接着往下测试，Mock测试刚好能解决这一问题。“Mock”顾名思义就是模拟、模仿。Mockito是常用的第三方Mock测试框架，补充JUnit缺失的测试死角。\n依赖\nMockito测试也是建立在JUnit基础上的，据最新官方文档版本引入依赖：testCompile 'org.mockito:mockito-core:2.+\n使用场景\n\n\n模拟一个对象\n 12345@Testpublic void add() throws Exception &#123;    Calculate calculate = mock(Calculate.class);    System.out.println(&quot;++++++++++结果:&quot;+calculate.add(1,2));&#125;\n注：这里mock(xxx.class)需要静态导入包，包括后边的when（）、anyInt()…方法。上面仅仅是对一个对象进行了模拟，并没有对其方法进行模拟（Stubbing，也叫“打桩”），所以下边的打印结果还是0。\n\n\n模拟方法调用的返回值\n 1234567@Testpublic void add() throws Exception &#123;    Calculate calculate = mock(Calculate.class);    when(calculate.add(1,2)).thenReturn(4);    System.out.println(&quot;++++++++++结果&quot;+calculate.add(1,2));     //结果返回4    assertEquals(&quot;加法错误&quot;, 5, calculate.add(1,2));    //上边抛出异常，此处将不再执行&#125;\n\n\n模拟抛出异常\n有返回值的方式：\n 1when(calculate.add(1,2)).thenThrow(new RuntimeException());\n无返回值（兼容有返回值的形式）的方式：\n 12doThrow(new RuntimeException(&quot;出错了&quot;)).when(calculate).add(1,2);calculate.add(1,2);\n二者的区别：\nwhen()后边传入的是具体的对象,所以不能传入无返回值的方法调用。前一个方式是直接抛出异常，后一个方式是先定义异常，再抛出异常。\n\n\n模拟方法调用时参数匹配\n 123456@Testpublic void add() throws Exception &#123;    Calculate calculate = mock(Calculate.class);    when(calculate.add(anyInt(),anyInt())).thenReturn(5);     //anyInt()代表任意整数    System.out.println(&quot;++++++++++结果&quot;+calculate.add(1,2));   //结果返回5&#125;\n\n\n验证某个方法调用次数\n 123456789101112@Testpublic void add() throws Exception &#123;    Calculate calculate = mock(Calculate.class);    calculate.add(1, 2);    calculate.add(1, 2);    verify(calculate, times(2)).add(1,2);  //验证是否调用两次。    verify(calculate, never()).add(1,2);   //验证是否调用过      verify(calculate, atLeastOnce()).add(1,2);   //验证最少调用一次    verify(calculate, atLeast(2)).add(1,2);   //验证最少调用两次    verify(calculate, atMost(5)).add(1,2);    //验证最多调用5次    reset(calculate);  //重置mock，以上calculate.add()将被清空&#125;\nverify(calculate)表示默认调用次数是一次，多次需要添加times()。\n\n\n自定义参数匹配器\n采用argThat(new IsInteger());，IsInteger()是自定义参数适配器，实现ArgumentMatcher接口，具体用法参阅ArgumentMatcher。\n\n\n校验调用顺序\n 123456789101112131415161718@Testpublic void add() throws Exception &#123;    Calculate calculate = mock(Calculate.class);    calculate.add(1,2);    calculate.divide(1,2);    //验证一个对象的多个方法的执行顺序    InOrder inOrder = inOrder(calculate);    inOrder.verify(calculate).add(1,2);    inOrder.verify(calculate).divide(1,2);    Calculate calculate1 = mock(Calculate.class);    calculate.add(1,2);    calculate1.add(1,2);    //验证不同对象的方法的执行顺序    InOrder inOrder1 = inOrder(calculate,calculate1);    inOrder1.verify(calculate).add(1,2);    inOrder1.verify(calculate1).add(1,2);&#125;\n\n\n返回结果拦截\n 12345678910111213@Testpublic void add() throws Exception &#123;Calculate calculate = mock(Calculate.class);    when(calculate.add(1,2)).thenAnswer(new Answer() &#123;        @Override        public Object answer(InvocationOnMock invocation) throws Throwable &#123;            Object[] args = invocation.getArguments();  //获取所有参数            Object mock = invocation.getMock();   //获取mock对象            return (int)args[0]+1;        &#125;    &#125;);    System.out.println(&quot;+++++++++++++++&quot;+calculate.add(1,2));&#125;\n\n\n验证是否超时\n 1234567@Testpublic void add() throws Exception &#123;Calculate calculate &#x3D; mock(Calculate.class);calculate.add(1,2);calculate.add(1,2);verify(calculate, timeout(100).times(2)).add(1,2);&#125;\n\n\nMock详情\n12345@Testpublic void add() throws Exception &#123;Calculate calculate &#x3D; mock(Calculate.class);Mockito.mockingDetails(calculate).isMock();&#125;\n\n\n虽然mock补齐了JUnit不能及时返回结果的缺点，但是始终不能测试private、static、final做mock测试，这可以借助第三方框架Powermock进行解决。果做本地单元测试最好的组合就是JUnit+mock+Powermock。\n参考\n\nmockito英文文档：https://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/Mockito.html\nmockito中文文档：https://github.com/hehonghui/mockito-doc-zh?spm=5176.100239.blogcont58770.6.YeQEAQ\nPowermock官方文档：https://github.com/powermock/powermock/wiki/Mockito\nJUnit+mock+Powermock：https://yq.aliyun.com/articles/58770\n一个给力的mock框架：https://github.com/easy-mock/easy-mock\n\n","plink":"https://blog.ixin.run/posts/1465713367/"},{"title":"Android开发权限处理和自定义权限","date":"2016-04-01T02:40:11.000Z","date_formatted":{"ll":"2016年4月1日","L":"2016/04/01","MM-DD":"04-01"},"updated":"2021-01-29T12:51:44.638Z","content":"早在Android6.0之前，权限这一块是不需要处理的，只需要用到哪些权限在Manifest里注册一下，然后在安装的时候简单声明一下。但是从6.0开始为了用户的隐私和安全，Google引入了动态权限申请机制，将所有权限分成了正常权限和危险权限，应用的相关功能每次在使用危险权限时需要动态的申请并得到用户的授权才能使用。\n\n设计模式\nAndroid 是一个权限分隔的操作系统，其中每个应用都有其独特的系统标识（Linux 用户 ID 和组 ID）。系统各部分也分隔为不同的标识。Linux 据此将不同的应用以及应用与系统分隔开来。\n其他更详细的安全功能通过“权限”机制提供，此机制会限制特定进程可以执行的具体操作，并且根据 URI 权限授权临时访问特定的数据段。\n安全架构\nAndroid 安全架构的中心设计点是：在默认情况下任何应用都没有权限执行对其他应用、操作系统或用户有不利影响的任何操作。这包括读取或写入用户的私有数据（例如联系人或电子邮件）、读取或写入其他应用程序的文件、执行网络访问、使设备保持唤醒状态等。\n由于每个 Android 应用都是在进程沙盒中运行，因此应用必须显式共享资源和数据。它们的方法是声明需要哪些权限来获取基本沙盒未提供的额外功能。应用以静态方式声明它们需要的权限，然后 Android 系统提示用户同意。\n应用签署\n所有 APK（.apk 文件）都必须使用证书签署，其私钥由开发者持有。此证书用于识别应用的作者。证书不需要由证书颁发机构签署；Android 应用在理想情况下可以而且通常也是使用自签名证书。证书在 Android 中的作用是识别应用的作者。\n众所周知，Android应用想要顺利安装在系统上需要两个条件：包名和签名。包名确定应用的唯一，而签名确定应用的可安装性。签名是必须的，即使开发者不手动设置签名（直接运行项目），系统也会自动生成一个临时签名。\n用户 ID 和文件访问\n在安装时，Android 为每个软件包提供唯一的 Linux 用户 ID。此 ID 在软件包在该设备上的使用寿命期间保持不变。在不同设备上，相同软件包可能有不同的 UID；重要的是每个软件包在指定设备上的 UID 是唯一的。\n由于在进程级实施安全性，因此任何两个软件包的代码通常都不能在同一进程中运行，因为它们需要作为不同的 Linux 用户运行。您可以在每个软件包的 AndroidManifest.xml 的 manifest 标记中使用 sharedUserId 属性，为它们分配相同的用户 ID。这样做以后，出于安全目的，两个软件包将被视为同一个应用，具有相同的用户 ID 和文件权限。请注意，为保持安全性，只有两个签署了相同签名（并且请求相同的 sharedUserId）的应用才被分配同一用户 ID。\n使用权限\n基本 Android 应用默认情况下未关联权限，这意味着它无法执行对用户体验或设备上任何数据产生不利影响的任何操作。要利用受保护的设备功能，必须在应用清单中包含一个或多个  标记。\n例如，需要监控传入的短信的应用要指定：\n12345&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    package=&quot;com.android.app.myapp&quot; &gt;    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_SMS&quot; /&gt;    ...&lt;/manifest&gt;\n权限分类\n系统权限分为几个保护级别。需要了解的两个最重要保护级别是正常权限和危险权限：\n\n正常权限涵盖应用需要访问其沙盒外部数据或资源，但对用户隐私或其他应用操作风险很小的区域。例如，设置时区的权限就是正常权限。如果应用声明其需要正常权限，系统会自动向应用授予该权限。\n危险权限涵盖应用需要涉及用户隐私信息的数据或资源，或者可能对用户存储的数据或其他应用的操作产生影响的区域。例如，能够读取用户的联系人属于危险权限。如果应用声明其需要危险权限，则用户必须明确向应用授予该权限。\n\n另外，有许多权限其行为方式与正常权限及危险权限都不同，这类我把给他归属为特殊权限。例如， SYSTEM_ALERT_WINDOW 和 WRITE_SETTINGS 特别敏感，因此大多数应用不应该使用它们。如果某应用需要其中一种权限，必须在清单中声明该权限，并且发送请求用户授权的 intent。系统将向用户显示详细管理屏幕，以响应该 intent。\n权限组\n所有危险的 Android 系统权限都属于权限组。如果设备运行的是 Android 6.0（API 级别 23），并且应用的 targetSdkVersion 是 23 或更高版本，则当用户请求危险权限时系统会发生以下行为：\n\n如果应用请求其清单中列出的危险权限，而应用目前在权限组中没有任何权限，则系统会向用户显示一个对话框，描述应用要访问的权限组。对话框不描述该组内的具体权限。例如，如果应用请求 READ_CONTACTS 权限，系统对话框只说明该应用需要访问设备的联系信息。如果用户批准，系统将向应用授予其请求的权限。\n如果应用请求其清单中列出的危险权限，而应用在同一权限组中已有另一项危险权限，则系统会立即授予该权限，而无需与用户进行任何交互。例如，如果某应用已经请求并且被授予了 READ_CONTACTS 权限，然后它又请求 WRITE_CONTACTS，系统将立即授予该权限。\n\n危险权限和权限组：\n\n相关方法\nContextCompat.checkSelfPermission\n检查应用是否具有某个危险权限。如果应用具有此权限，方法将返回 PackageManager.PERMISSION_GRANTED，并且应用可以继续操作。如果应用不具有此权限，方法将返回 PackageManager.PERMISSION_DENIED，且应用必须明确向用户要求权限。\nActivityCompat.requestPermissions\n应用可以通过这个方法动态申请权限，调用后会弹出一个对话框提示用户授权所申请的权限。\nActivityCompat.shouldShowRequestPermissionRationale\n如果应用之前请求过此权限但用户拒绝了请求，此方法将返回 true。如果用户在过去拒绝了权限请求，并在权限请求系统对话框中选择了 Don't ask again 选项，此方法将返回 false。如果设备规范禁止应用具有该权限，此方法也会返回 false。\nonRequestPermissionsResult\n当应用请求权限时，系统将向用户显示一个对话框。当用户响应时，系统将调用应用的 onRequestPermissionsResult() 方法，向其传递用户响应，处理对应的场景。\n具体示例\nActivity中申请\n12345678910111213141516171819202122232425262728293031323334353637public void onCameraClick(View view) &#123;//判断权限是否已经同意if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) &#123;//1.还未同意requestCameraPermission();    &#125; else &#123;//2.已同意Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);        startActivity(intent);    &#125;&#125;private void requestCameraPermission() &#123;//判断“不在提醒”复选框是否展示if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.CAMERA)) &#123;//3.复选框显示时的请求ActivityCompat.requestPermissions(GooglePermissionActivity.this, new String[]&#123;Manifest.permission.CAMERA&#125;, REQUEST_CAMERA);        &#125; else &#123;//4.复选框不显示时的请求ActivityCompat.requestPermissions(GooglePermissionActivity.this, new String[]&#123;Manifest.permission.CAMERA&#125;, REQUEST_CAMERA);        &#125;//如果需要针对“不在提醒”复选框显示时做一些处理用上边的方式，否者干脆直接请求权限（个人推荐后者）//        ActivityCompat.requestPermissions(GooglePermissionActivity.this, new String[]&#123;Manifest.permission.CAMERA&#125;, REQUEST_CAMERA);&#125;@Overridepublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123;if (requestCode == REQUEST_CAMERA) &#123;if (grantResults.length &gt;0&amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123;//5.回调权限申请成功Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);            startActivity(intent);        &#125; else &#123;//6.回调权限申请拒绝Toast.makeText(this, &quot;相机开启被拒绝，请到系统设置中开启相机权限。&quot;, Toast.LENGTH_LONG).show();        &#125;    &#125; &#125;\n下边是图示（手绘的，请见谅）：\n\nFragment中申请\n在fragment中权限处理需要注意以下两点：\n\n在Fragment中申请权限，不要使用ActivityCompat.requestPermissions， 直接使用Fragment的requestPermissions方法，否则会回调到Activity的onRequestPermissionsResult方法中。\n如果在Fragment中嵌套Fragment，在子Fragment中使用requestPermissions方法，onRequestPermissionsResult不会回调回来，建议使用getParentFragment().requestPermissions方法，这个方法会回调到父Fragment中的onRequestPermissionsResult，加入以下代码可以把回调透传到子Fragment：  123456789101112@OverridepublicvoidonRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults)&#123;super.onRequestPermissionsResult(requestCode, permissions, grantResults);    List&lt;Fragment&gt; fragments = getChildFragmentManager().getFragments();if (fragments != null) &#123;for (Fragment fragment : fragments) &#123;if (fragment != null) &#123;                fragment.onRequestPermissionsResult(requestCode,permissions,grantResults);            &#125;        &#125;    &#125;&#125;\n\n\n自定义权限\n在android系统的安全模型中，应用程序在默认的情况下不可以执行任何对其他应用程序，系统或者用户带来负面影响的操作。如果应用需要执行某些操作，就需要声明使用这个操作对应的权限。\n一般情况下我们都是注册系统权限来满足对系统相关组件的操作，我们还可以自定义属于我们自己app的权限来满足来自其他程序安全的交互通信。\n自定权限实现过程\n权限声明\n12345&lt;permission    android:name=&quot;com.bigrun.permissionforandroidm.customerpermission1&quot;    android:description=&quot;@string/hello_world&quot;    android:label=&quot;@string/app_name&quot;    android:protectionLevel=&quot;normal&quot; /&gt;\n自定义权限中标示说明：\n\nandroid:name：权限的唯一标识，一般都是使用 包名加权限名 。(必写)\nandroid:label：对权限的一个简短描述。\nandroid:description：对权限的描述，一般是两句话，第一句话描述这个权限所针对的操作，第二句话告诉用户授予app这个权限会带来的后果 。\nandroid:permissionGroup：权限所属权限组的名称 。\nandroid:protectionLevel：权限的等级。(必写)\n\n权限的等级分为如下四个：\n\nnormal：是最低的等级，声明此权限的app，系统会默认授予次权限，不会提示用户 。\ndangerous：权限对应的操作有安全风险，系统在安装声明此类权限的app时会提示用户 ，在android6.0以上会出现运行时提示权限申请对话框。\nsignature：此权限的申请若想正常使用必须保证两个应用的签名一致。\nsignatureOrSystem：与signature类似，只是增加了rom中自带的app的声明 。\n\n指定某个组件启动时使用此权限\n这里我们指定程序的主程序拥有此权限：\n12345&lt;activity android:name=&quot;.TestActivity&quot; android:permission=&quot;com.bigrun.permissionforandroidm.customerpermission1&quot;&gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;    &lt;/intent-filter&gt;&lt;/activity&gt;\n作为启动界面，一定要有一个过滤器设置其启动方式为主界面启动。\n在另一个应用中去启动此界面\n注册上一个应用程序的自定义权限：\n1&lt;uses-permission android:name=&quot;com.example.customerpermission1&quot;/&gt;\n启动上一个应用程序：\n1234Intent intent = new Intent();ComponentName componentName = new ComponentName(&quot;com.bigrun.permissionforandroidm&quot;,&quot;com.bigrun.permissionforandroidm.TestActivity&quot;);intent.setComponent(componentName);startActivity(intent);\n自定义权限组\n自定义权限中，我们也可以设定一个权限组：\n1234567891011&lt;permission-group    android:name=&quot;com.bigrun.permissionforandroidm.customerpermissiongroup&quot;    android:description=&quot;@string/hello_world&quot;    android:label=&quot;@string/app_name&quot; /&gt;&lt;permission    android:name=&quot;com.bigrun.permissionforandroidm.customerpermission1&quot;    android:description=&quot;@string/hello_world&quot;    android:label=&quot;@string/app_name&quot;    android:permissionGroup=&quot;com.bigrun.permissionforandroidm.customerpermissiongroup&quot;    android:protectionLevel=&quot;normal&quot; /&gt;\n在另外一个app中同样要注册这个权限组：\n12&lt;uses-permission android:name=&quot;com.bigrun.permissionforandroidm.customerpermission1&quot;/&gt;&lt;permission-tree android:name=&quot;com.kifile.test.permission&quot;/&gt;\n总结\n大家可以看到，其实在权限处理这块还是挺繁琐的，总不能为了一个相机的启动我们都要写这么大一堆代码，本篇主要目的讲的是运行时权限的一个申请过程，注意是过程，开发过程中注重敏捷开发，没必要关注内部细节，还是应了那句话——不会偷懒的程序员不是好程序员。其实google也知道很繁琐，不得已自己专门封装了一个库——Easypermissions。当然我们也有更简单的方式，gayhub从来不缺人才——RxPermissions。\n如果上边大佬们的库你不喜欢，也可以自己造一个，我这里给一个思路，就是把上边权限请求的过程封装到一个Fragment中，该Fragment是无界面的！无界面的！无界面的！（回声三连），然后自己定义的弹框什么的都可以在里面实现。\n参考\n\nhttps://developer.android.com/guide/topics/security/permissions.html?hl=zh-cn\nhttps://github.com/googlesamples/easypermissions\nhttps://github.com/tbruyelle/RxPermissions\n\n","plink":"https://blog.ixin.run/posts/1459478411/"},{"title":"Android核心架构探究学习","date":"2015-08-28T09:28:50.000Z","date_formatted":{"ll":"2015年8月28日","L":"2015/08/28","MM-DD":"08-28"},"updated":"2021-03-15T04:24:39.305Z","content":"谈起Android架构，很多人都知道Android是java开发的，以为Android就是java的一个儿子，这也只是站在表层去看问题。Android是一个系统，作为一个现在都快发展到6.0的系统，内部必有一个庞大的核心体系，就像一个舞台，要有支柱，要有台面，才能撑起各种演员和设备在其上面配合着表演。\nAndroid系统的底层是建立在Linux系统之上的，系统架构总共分为4层5块。从上往下4层分别是：应用程序层、应用程序框架层、函数库层、Linux内核层。5块分别指APPLICATIONS、APPLICATIONS FRAMWORK、LIBRARIES、ANDROID RUNTIME、LINUX KERNEL，这都和前边一一对应，其中ANDROID RUNTIME是在函数库层额外开出的android运行时虚拟机。\n这4层采用一种软件叠层（Software Stack）的方式进行构建，层与层之间相互分离又分工明确，确保层与层之间的低耦合，保证系统的稳定性。\n\nAndroid系统体系结构图\n\n上图Android4.4之前的结构图，在Android5.0之后安卓引入了ART模式代替之前Dalvik虚拟机。\n依着4层结构从上到下逐层阐述\n1. APPLICATIONS（应用程序层）\nAndroid系统会包含一系列核心应用程序，既是我们常说的系统应用，包含电子邮件客户端、SMS短信程序、联系人、浏览器、地图、日历等等，国内第三方厂商例如小米，魅族又在原生的基础上去除那些需要翻墙的系统应用换成自己的应用。这些系统应用和我们在市场上下载的应用没啥两样，都是遵从android设计模式根据java api编写的，只不过前者属于系统级权限全开，用起来省时省心。\n2. APPLICATION FRAMEWORK（应用程序框架）\n这一层对安卓开发者是重中之重，Framework层为安卓开发者提供了众多的API接口，开发者通过调用这些各种功能的API来构造所要创建的APP，从而满足业务上的需求。学习android的众多知识都在这一层上呈现，包括四大组件Activity、Service、BroadcastRecever、ContentProvider。Framework就这Android Api的工具库，所有的Api差不多都是用Java实现的，同时在底层又包含JNI的方法，JNI用C/C++编写接口，通过函数表查询核心库层的底层方法，最终访问到Linux内核。JNI是在Dalvik虚拟机启动时加载进去的，Dalvik虚拟机去寻址JNI方法，然后再用JNI接口去调用core lib层的本地方法。从而满足了Java层到系统内核层的通信。至于为什么用java编写这一层，为什么不用c/c++接着往上写，具体原因大概开发者也能想到，java的跨平台和内存回收机制这个优点是c/c++目前来时无法取代的，这样极大的满足了安卓的灵活性和易开发性（大部分java开发者很容易上手），便于安卓的快速拓展。\n下边列出一些Framework API的说明：\n\nActivity Manager: 用来管理应用程序生命周期并提供常用的导航回退功能。\nWindows Manager:提供一些我们访问手机屏幕的方法。屏幕的透明度、亮度、背景。\nContent Providers:使得应用程序可以访问另一个应用程序的数据（如联系人数据库)， 或者共享它们自己的数据。\nView System:可以用来构建应用程序， 它包括列表（Lists)，网格（Grids)，文本框（Text boxes)，按钮（Buttons)， 甚至可嵌入的web浏览器。\nNotificatio Manager:使得应用程序可以在状态栏中显示自定义的提示信息。\nPackage Manager:提供对系统的安装包的访问。包括安装、卸载应用，查询permission相关信息，查询Application相关信息等。\nTelephone Manager:主要提供了一系列用于访问与手机通讯相关的状态和信息的方法，查询电信网络状态信息，sim卡的信息等。\nResource Manager:提供非代码资源的访问，如本地字符串，图形，和布局文件（Layout files )。\nLocation Manager:提供设备的地址位置的获取方式。很显然，GPS导航肯定能用到位置服务。\nXMPP Service:可扩展通讯和表示协议。前身为Jabber，提供即时通信服务。例如推送功能,Google Talk。\n\n这些只是图上给出的总括，还有很多Api,这里不在一一列出，有些自己还没有完全领会，后边慢慢学习。\n3. LIBRARIES（函数库）\nAndroid包含一套被不同组件所使用的C/C++库的集合。一般情况安卓开发者是不能直接调用这套C/C++库集，上边也说了JNI是连接Java和C/C++的桥梁。\n下边列出一些核心库说明：\n\nSurface Manager:管理对显示子系统的访问，并可以对多个应用程序的2D和3D图层提供无缝整合。\nMedia Framework:基于PacketVideo的OpenCORE，支持播放和录制许多流行的音频和视频格式，以及查看静态图片，主要MPEG4、MP3、AAC、AMR、JPG、PNG等多媒体格式。\nSQLite:供所有应用程序使用的功能强大的轻量级关系数据库。\nOpenGL ES：是一套基于OpenGL ES API实现的3D系统，这套3D库既可以使用硬件3D加速，也可以使用软件3D加速，可谓软硬通吃。\nFreeType:位图和向量字体的显示。\nSGL:底层2D图形引擎。\nWebKit:内部含有一个libwebcore.so库，是一个开源的Web浏览器引擎，该引擎为Android浏览器提供支持，也为Android WebView提供支持，用于嵌入到应用程序中进行网页浏览。\nlibC:一个从BSD系统派生出来的标准C系统库，并且专门为嵌入式系统Linux设备调试过的。\n\n4. ANDROID RUNTIME（Android运行时）\n这一块主要由两部分组成:Android核心库集和虚拟机。Android核心库集主要包含Java核心库中绝大部分的功能，虚拟机主要负责运行Android应用程序。\nAndroid4.4引入了ART模式，Android5.0全面推开，并淘汰Dalvik。Dalvick和ART的主要区别是对应用程序的编译过程，前者采用JIT(Just-in-time)解释器进行动态编译并执行的方式去运行应用程序，导致应用程序在执行的时候cpu配合内存高效率运行，从而在一些低级处理器和内存的机子上导致“卡”、“慢”等特点。后者采用AOT(Ahead-of-time)在程序安装时进行预编译，编译过程缓慢，内存占用高，但是一旦程序安装成功运行速度将得到一个质的提升，因为减少了动态编译的过程，从而提升运行效率。除此之外ART还对ARM和x86和MIPS架构的支持，并且完全兼容64位系统。\n5. LINUX KERNEL（Linux内核）\nAndroid系统建立在Linux2.6之上，Linux内核提供了安全性，内存管理，进程管理，网络协议栈和驱动模型等核心系统服务，除此之外,Linux内核也是系统硬件和软件叠层的抽象层，是沟通硬件和软件的桥梁。\nAndroid为什么会选择Linux\n成熟的操作系统有很多，但是Android为什么选择采用Linux内核呢?这就与Linux的一些特性有关了，比如：\n\n强大的内存管理和进程管理方案\n基于权限的安全模式\n支持共享库\n经过认证的驱动模型\nLinux本身就是开源项目\n\n同时Android又不是Linux，Android在Linux的基础上进行了多处调整，并且增加了一些专属于Android的驱动程序，比如说Android电源管理、低内存管理器(Low Memory Killer) 、匿名共享内存(Ashmem) 、Android Alarm等等。\n参考\n\nhttps://developer.android.com/guide/platform/index.html\n\n","plink":"https://blog.ixin.run/posts/1440754130/"},{"title":"关于","date":"2021-01-29T12:51:44.678Z","date_formatted":{"ll":"2021年1月29日","L":"2021/01/29","MM-DD":"01-29"},"updated":"2021-01-29T12:51:44.678Z","content":"我是谁\nXinRun，目前主要从事移动互联网领域的开发工作，现居上海。\n博客宗旨\nixin.run，一个程序员的故事，专注移动互联网。本博客不定时发布一些有关程序员开发技术方面的学习和总结，非常乐意与大家一起分享交流，文章中若有错误欢迎批评指正，一起学习一同进步。\n博客搭建:\n\nHexo框架\n阿里云域名\nVercel部署\n不蒜子统计\nGoogle分析\nDisqus评论\n\n特殊说明：评论系统采用的是Disqus，在每篇技术文章后边，只有墙外可见可评哦。\n联系方式\ne-mail: runxinluo2015@163.com\ngithub: @iXinRun\n\n","plink":"https://blog.ixin.run/about/"},{"title":"知识进阶","date":"2021-03-15T04:16:08.124Z","date_formatted":{"ll":"2021年3月15日","L":"2021/03/15","MM-DD":"03-15"},"updated":"2021-03-15T04:16:08.124Z","content":"\nThis is the area of knowledge I want to learn and already know, and it’s going on.\n\n#Technology\n\n\n归总分类\n文章数目\n\n\n\n\nAndroid\n61篇\n\n\nJava\n17篇\n\n\n算法\n2篇\n\n\n","plink":"https://blog.ixin.run/system/"}]