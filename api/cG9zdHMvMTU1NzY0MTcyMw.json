{"title":"Android开发之UI线程和非UI线程","date":"2019-05-12T06:15:23.000Z","date_formatted":{"ll":"2019年5月12日","L":"2019/05/12","MM-DD":"05-12"},"link":"posts/1557641723","comments":true,"tags":["线程间通信"],"categories":["Android"],"updated":"2021-01-29T12:51:44.634Z","content":"<p>这里又是老生畅谈的话了，前边已经有多篇文章针对线程进行探究解释，Android开发过程中线程的体现更是淋漓尽致。Android开发过程中涉及到的线程从大类上分可以归为两类：UI线程和非UI线程。本篇就根据这两类做一个总结。</p>\n<a id=\"more\"></a>\n<p>谈到线程，首先顺带讲一下Android上进程的相关知识，进程和线程是相辅相成的，前边我也写过一篇针对进程和线程概括性的解释——<a href=\"https://blog.ixin.run/posts/1469682219\" target=\"_blank\">《什么是进程，什么是线程》</a>，这里就针对Android上面向开发的做一个记录总结。</p>\n<p>当某个应用组件启动且该应用没有运行其他任何组件时，Android 系统会使用单个执行线程为应用启动新的 Linux 进程。默认情况下，同一应用的所有组件在相同的进程和线程（称为“主”线程）中运行。 如果某个应用组件启动且该应用已存在进程（因为存在该应用的其他组件），则该组件会在此进程内启动并使用相同的执行线程。 但是，您可以安排应用中的其他组件在单独的进程中运行，并为任何进程创建额外的线程。</p>\n<h2 id=\"进程\">进程<a title=\"#进程\" href=\"#进程\"></a></h2>\n<p>默认情况下，同一应用的所有组件均在相同的进程中运行，且大多数应用都不会改变这一点。 但是，如果您发现需要控制某个组件所属的进程，则可在清单文件中执行此操作。</p>\n<p>各类组件元素的清单文件条目<activity>、<service>、<receiver>和<provider>均支持 android:process 属性，此属性可以指定该组件应在哪个进程运行。此外，<application> 元素还支持 android:process 属性，以设置适用于所有组件的默认值。</p>\n<p>如果内存不足，而其他为用户提供更紧急服务的进程又需要内存时，Android 可能会决定在某一时刻关闭某一进程。在被终止进程中运行的应用组件也会随之销毁。 当这些组件需要再次运行时，系统将为它们重启进程。</p>\n<h2 id=\"进程生命周期\">进程生命周期<a title=\"#进程生命周期\" href=\"#进程生命周期\"></a></h2>\n<p>Android 系统将尽量长时间地保持应用进程，但为了新建进程或运行更重要的进程，最终需要移除旧进程来回收内存。 为了确定保留或终止哪些进程，系统会根据进程中正在运行的组件以及这些组件的状态，将每个进程放入“重要性层次结构”中。 必要时，系统会首先消除重要性最低的进程，然后是重要性略逊的进程，依此类推，以回收系统资源。</p>\n<p>重要性层次结构一共有 5 级。以下列表按照重要程度列出了各类进程（第一个进程最重要，将是最后一个被终止的进程）：</p>\n<ol>\n<li>\n<p><strong>前台进程</strong><br>\n用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：</p>\n<ul>\n<li>托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法）</li>\n<li>托管某个 Service，后者绑定到用户正在交互的 Activity</li>\n<li>托管正在“前台”运行的 Service（服务已调用 startForeground()）</li>\n<li>托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）</li>\n<li>托管正执行其 onReceive() 方法的 BroadcastReceiver</li>\n</ul>\n</li>\n</ol>\n<p>通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。</p>\n<ol start=\"2\">\n<li>\n<p><strong>可见进程</strong><br>\n没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程：</p>\n<ul>\n<li>托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况。</li>\n<li>托管绑定到可见（或前台）Activity 的 Service。</li>\n</ul>\n</li>\n</ol>\n<p>可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。</p>\n<ol start=\"3\">\n<li>\n<p><strong>服务进程</strong><br>\n正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。</p>\n</li>\n<li>\n<p><strong>后台进程</strong><br>\n包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。 有关保存和恢复状态的信息，请参阅 Activity文档。</p>\n</li>\n<li>\n<p><strong>空进程</strong><br>\n不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。</p>\n</li>\n</ol>\n<h2 id=\"主线程（ui线程）\">主线程（UI线程）<a title=\"#主线程（ui线程）\" href=\"#主线程（ui线程）\"></a></h2>\n<p>应用启动时，系统会为应用创建一个名为“主线程”的执行线程。 此线程非常重要，因为它负责将事件分派给相应的用户界面小部件，其中包括绘图事件。 此外，它也是应用与 Android UI 工具包组件（来自 android.widget 和 android.view 软件包的组件）进行交互的线程。因此，主线程有时也称为 UI 线程。</p>\n<p>系统不会为每个组件实例创建单独的线程。运行于同一进程的所有组件均在 UI 线程中实例化，并且对每个组件的系统调用均由该线程进行分派。 因此，响应系统回调的方法（例如，报告用户操作的 onKeyDown() 或生命周期回调方法）始终在进程的 UI 线程中运行。</p>\n<h3 id=\"主线程是不安全的\">主线程是不安全的<a title=\"#主线程是不安全的\" href=\"#主线程是不安全的\"></a></h3>\n<p>android主线程是不安全的，这句话是不是经常听到？上边也说了所有相关的UI更新操作均在主线程（UI线程），为什么都要在主线程中完成呢？这里就是主线程不全性导致的，其实主线程的不安全性就是指的UI刷新界面展示的不安全性。前边一篇文章<a href=\"https://blog.ixin.run/posts/1469605305\" target=\"_blank\">《Android开发Handler消息机制探究》</a>开篇提到，从主线程中可以创建多个子线程来分配任务，一个activity的所有view都是唯一的，都有唯一的标识，如果在每个子线程中更新view，我们不能预知线程执行结果的先后顺序，也就无法预知什么时候才能更新view，所以造成结果就是view更新时的冲突问题。官方也是为了规避这种多线程执行无序导致冲突的问题，所以从安卓2.0之后规定只能在主线程中更新界面了。</p>\n<h3 id=\"单线程模式下必须遵守两条规则\">单线程模式下必须遵守两条规则<a title=\"#单线程模式下必须遵守两条规则\" href=\"#单线程模式下必须遵守两条规则\"></a></h3>\n<p>现在又有一个新问题了，既然都要在主线程中去执行有关界面的更新操作，主线程势必给人感觉比较“重”，在应用执行繁重的任务以响应用户交互时，除非正确实现应用，否则这种单线程模式可能会导致性能低下。 具体地讲，如果 UI 线程需要处理所有任务，则执行耗时很长的操作（例如，网络访问或数据库查询）将会阻塞整个 UI。 一旦线程被阻塞，将无法分派任何事件，包括绘图事件。 从用户的角度来看，应用显示为挂起。 更糟糕的是，如果 UI 线程被阻塞超过几秒钟时间（目前大约是 5 秒钟），用户就会看到一个让人厌烦的“应用无响应”(ANR) 对话框。如果引起用户不满，他们可能就会决定退出并卸载此应用。</p>\n<p>因此，您不得通过工作线程操纵 UI，而只能通过 UI 线程操纵用户界面。 因此，Android 的单线程模式必须遵守两条规则：</p>\n<ol>\n<li>不要阻塞UI线程</li>\n<li>不要在UI线程之外访问Android UI 组件（工具包）</li>\n</ol>\n<h2 id=\"工作线程（非ui线程）\">工作线程（非UI线程）<a title=\"#工作线程（非ui线程）\" href=\"#工作线程（非ui线程）\"></a></h2>\n<p>根据上述单线程模式，要保证应用UI的响应能力，关键是不能阻塞 UI 线程。 如果执行的操作不能很快完成，则应确保它们在单独的线程（“后台”或“工作”线程）中运行。</p>\n<h3 id=\"如何从非ui线程访问ui线程\">如何从非UI线程访问UI线程<a title=\"#如何从非ui线程访问ui线程\" href=\"#如何从非ui线程访问ui线程\"></a></h3>\n<p>以下代码演示了一个点击侦听器从单独的线程下载图像并将其显示在ImageView中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            Bitmap b = loadImageFromNetwork(<span class=\"string\">&quot;http://example.com/image.png&quot;</span>);</span><br><span class=\"line\">            mImageView.setImageBitmap(b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>乍看起来，这段代码似乎运行良好，因为它创建了一个新线程来处理网络操作。 但是，它违反了单线程模式的第二条规则：<strong>不要在UI线程之外访问Android UI组件（工具包）</strong> ，此示例从工作线程（而不是UI线程）修改了ImageView。 这可能导致出现不明确、不可预见的行为，但要跟踪此行为困难而又费时。</p>\n<p>为解决此问题，Android 提供了几种途径来从其他线程访问 UI 线程：</p>\n<ul>\n<li>使用Handler实现线程之间的通信</li>\n<li>Activity.runOnUiThread(Runnable)</li>\n<li>View.post(Runnable)</li>\n<li>View.postDelayed(Runnable, long)</li>\n</ul>\n<p>例如，您可以通过使用 View.post(Runnable) 方法修复上述代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Bitmap bitmap =</span><br><span class=\"line\">                    loadImageFromNetwork(<span class=\"string\">&quot;http://example.com/image.png&quot;</span>);</span><br><span class=\"line\">            mImageView.post(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    mImageView.setImageBitmap(bitmap);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"asynctask\">AsyncTask<a title=\"#asynctask\" href=\"#asynctask\"></a></h3>\n<p>少量情况下非UI线程访问UI线程可以采用上边的<code>Activity.runOnUiThread(Runnable)</code>、<code>View.post(Runnable)</code>，多的情况下可以采用Handler+Thread方式，但是这种也不好，代码量太大。好在Android官方给我们封了一个可以异步处理并在UI线程中回调的类——AsyncTask，AsyncTask可以正确，方便地使用UI线程。此类允许您执行后台操作并在UI线程上发布结果，而无需操作线程和/或处理程序。</p>\n<p>AsyncTask的设计其实也是围绕一个辅助类Thread和Handler，AsyncTask主要用于短时间内的异步回调操作，如果长时间执行线程，还是强烈建议采用各种API <code>java.util.concurrent包</code>，如<code>Executor</code>， <code>ThreadPoolExecutor</code>和<code>FutureTask</code>。</p>\n<h3 id=\"asynctask的泛型参数\">AsyncTask的泛型参数<a title=\"#asynctask的泛型参数\" href=\"#asynctask的泛型参数\"></a></h3>\n<p>AsyncTask&lt;Params,Progress,Result&gt;是一个抽象类,通常用于被继承.继承AsyncTask需要指定如下三个泛型参数:</p>\n<ul>\n<li>Params:启动任务执行时输入的参数类型.</li>\n<li>Progress:后台任务执行中返回进度值的类型.</li>\n<li>Result:后台任务执行完成后返回结果的类型.</li>\n</ul>\n<h3 id=\"asynctask主要方法\">AsyncTask主要方法<a title=\"#asynctask主要方法\" href=\"#asynctask主要方法\"></a></h3>\n<p>AsyncTask主要有如下几个方法:</p>\n<ul>\n<li>doInBackground:必须重写,异步执行后台线程要完成的任务,耗时操作将在此方法中完成.</li>\n<li>onPreExecute:执行后台耗时操作前被调用,通常用于进行初始化操作.</li>\n<li>onPostExecute:当doInBackground方法完成后,系统将自动调用此方法,并将doInBackground方法返回的值传入此方法.通过此方法进行UI的更新.</li>\n<li>onProgressUpdate:当在doInBackground方法中调用publishProgress方法更新任务执行进度后,将调用此方法.通过此方法我们可以知晓任务的完成进度.</li>\n</ul>\n<h3 id=\"asynctask使用遵循规则及缺点\">AsyncTask使用遵循规则及缺点<a title=\"#asynctask使用遵循规则及缺点\" href=\"#asynctask使用遵循规则及缺点\"></a></h3>\n<p>使用AsyncTask时必须遵循如下规则：</p>\n<ul>\n<li>必须在UI线程中创建AsyncTask的实例</li>\n<li>必须在UI线程中调用AsyncTask的execute()方法</li>\n<li>重写的四个方法是系统自动调用的，不应手动调用</li>\n<li>每个AsyncTask只能被执行一次，多次调用将会引发异常</li>\n</ul>\n<p>AsyncTask使用时虽然很简单，并且块化好管理，但是AsyncTask也有一定的缺点，使用的过程中也要格外在意：</p>\n<ol>\n<li>线程池中已经有128个线程，缓冲队列已满，如果此时向线程提交任务，将会抛出RejectedExecutionException。过多的线程会引起大量消耗系统资源和导致应用FC的风险。</li>\n<li>AsyncTask不会随着Activity的销毁而销毁，直到doInBackground()方法执行完毕。如果我们的Activity销毁之前，没有取消 AsyncTask，这有可能让我们的AsyncTask崩溃(crash)。因为它想要处理的view已经不存在了。所以，我们总是必须确保在销毁活动之前取消任务。如果在doInBackgroud里有一个不可中断的操作，比如BitmapFactory.decodeStream()，调用了cancle() 也未必能真正地取消任务。关于这个问题，在4.4后的AsyncTask中，都有判断是取消的方法isCancelled()。</li>\n<li>如果AsyncTask被声明为Activity的非静态的内部类，那么AsyncTask会保留一个对创建了AsyncTask的Activity的引用。如果Activity已经被销毁，AsyncTask的后台线程还在执行，它将继续在内存里保留这个引用，导致Activity无法被回收，引起内存泄露。</li>\n<li>屏幕旋转或Activity在后台被系统杀掉等情况会导致Activity的重新创建，之前运行的AsyncTask会持有一个之前Activity的引用，这个引用已经无效，这时调用onPostExecute()再去更新界面将不再生效。</li>\n</ol>\n<h3 id=\"asynctask简单使用\">AsyncTask简单使用<a title=\"#asynctask简单使用\" href=\"#asynctask简单使用\"></a></h3>\n<p>以下是一个AsyncTask创建声明的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DownloadFilesTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">AsyncTask</span>&lt;<span class=\"title\">URL</span>, <span class=\"title\">Integer</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Long <span class=\"title\">doInBackground</span><span class=\"params\">(URL... urls)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = urls.length;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> totalSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">            totalSize += Downloader.downloadFile(urls[i]);</span><br><span class=\"line\">            publishProgress((<span class=\"keyword\">int</span>) ((i / (<span class=\"keyword\">float</span>) count) * <span class=\"number\">100</span>));</span><br><span class=\"line\">            <span class=\"comment\">// Escape early if cancel() is called</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isCancelled()) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> totalSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onProgressUpdate</span><span class=\"params\">(Integer... progress)</span> </span>&#123;</span><br><span class=\"line\">        setProgressPercent(progress[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onPostExecute</span><span class=\"params\">(Long result)</span> </span>&#123;</span><br><span class=\"line\">        showDialog(<span class=\"string\">&quot;Downloaded &quot;</span> + result + <span class=\"string\">&quot; bytes&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>声明好后，只需要在主线程中简单执行execute即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> DownloadFilesTask().execute(url1, url2, url3);</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<ul>\n<li><a href=\"https://developer.android.com/guide/components/processes-and-threads.html\">https://developer.android.com/guide/components/processes-and-threads.html</a></li>\n<li><a href=\"https://developer.android.com/reference/android/os/AsyncTask.html\">https://developer.android.com/reference/android/os/AsyncTask.html</a></li>\n<li>《疯狂Android讲义》——李刚</li>\n</ul>\n","prev":{"title":"Android开发之Context认识和运用","link":"posts/1557933993"},"next":{"title":"Java线程之ThreadLocal探讨","link":"posts/1557641270"},"plink":"https://blog.ixin.run/posts/1557641723/","toc":[{"id":"进程","title":"进程","index":"1"},{"id":"进程生命周期","title":"进程生命周期","index":"2"},{"id":"主线程（ui线程）","title":"主线程（UI线程）","index":"3","children":[{"id":"主线程是不安全的","title":"主线程是不安全的","index":"3.1"},{"id":"单线程模式下必须遵守两条规则","title":"单线程模式下必须遵守两条规则","index":"3.2"}]},{"id":"工作线程（非ui线程）","title":"工作线程（非UI线程）","index":"4","children":[{"id":"如何从非ui线程访问ui线程","title":"如何从非UI线程访问UI线程","index":"4.1"},{"id":"asynctask","title":"AsyncTask","index":"4.2"},{"id":"asynctask的泛型参数","title":"AsyncTask的泛型参数","index":"4.3"},{"id":"asynctask主要方法","title":"AsyncTask主要方法","index":"4.4"},{"id":"asynctask使用遵循规则及缺点","title":"AsyncTask使用遵循规则及缺点","index":"4.5"},{"id":"asynctask简单使用","title":"AsyncTask简单使用","index":"4.6"}]},{"id":"参考","title":"参考","index":"5"}],"reward":true,"copyright":{"author":"i猩人","link":"<a href=\"https://blog.ixin.run/posts/1557641723/\" title=\"Android开发之UI线程和非UI线程\">https://blog.ixin.run/posts/1557641723/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}