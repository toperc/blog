{"title":"Android开发之单元测试初探","date":"2016-06-12T06:36:07.000Z","date_formatted":{"ll":"2016年6月12日","L":"2016/06/12","MM-DD":"06-12"},"link":"post/1465713367","comments":true,"tags":["单元测试"],"categories":["Android"],"updated":"2021-01-14T08:08:54.897Z","content":"<p>从androidstudio1.5开始新建安卓项目中有两个测试包,androidTest和test。其中前者是针对设备进行的测试，即官方支持的UI测试，后者是直接在本机上进行测试即最常见的本地单元测试。在androidStudio1.5之前只有前者，单元测试要自己重建，如图：<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/5E99E10A73F041BD8421DCC2593DA919?method=download&amp;shareKey=ef016b2d142019ce2373b6507a54f0db\" alt=\"android项目中的单元测试\"></p>\n<a id=\"more\"></a>\n<h2 id=\"android项目中的单元测试\">Android项目中的单元测试<a title=\"#android项目中的单元测试\" href=\"#android项目中的单元测试\"></a></h2>\n<p>android测试一般有三种形式：</p>\n<ol>\n<li>local tests  本地单元测试，不依赖Android framework（单纯的JunitTest）或使用 Mockito 模拟依赖对象(需要进行类注解修改测试运行器)，直接运行在JVM上，以最大限度的减少时间。</li>\n<li>instrumented tests  必须要运行在Android设备，官方原始测试方式（测试用例写起来比较庞大）</li>\n<li>UI Test  使用UI测试框架模拟用户交互来进行测试（espresso、uiautomator）</li>\n</ol>\n<h2 id=\"junit单元测试\">JUnit单元测试<a title=\"#junit单元测试\" href=\"#junit单元测试\"></a></h2>\n<p>先说一下单元测试，在Java工程中目前最常用就是Junit4的使用了。使用前要先将junit的jar包导入到项目中。在进行androidstudio中开发时就不需要了，因为我们可以在gradle中直接引入依赖`testCompile ‘junit:junit:4.12’。</p>\n<h3 id=\"单元测试可以测试那些内容？\">单元测试可以测试那些内容？<a title=\"#单元测试可以测试那些内容？\" href=\"#单元测试可以测试那些内容？\"></a></h3>\n<p>这里需要说明的是Android studio的单元测试由于只是模拟Android开发环境，但是其不是真正的Android开发环境，所以不能测试UI功能，不能测试需要硬件支持的功能（比如蓝牙，wifi等），不能测试App跳转等等，以下是主要功能：</p>\n<ul>\n<li>测试一些数据性的功能，比如加载网络数据。</li>\n<li>测试SharedPerferences，测试数据库，测试函数等。</li>\n<li>工具类的测试，比如验证时间，转化格式，正则验证等等。</li>\n</ul>\n<h3 id=\"一个demo\">一个Demo<a title=\"#一个demo\" href=\"#一个demo\"></a></h3>\n<p>在Android工程项目中假设有一个类需要进行单元测试：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Calculate</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a+b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">subtract</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a-b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">multiply</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a*b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">divide</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a/b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们建立测试类，只需在打开的类中右键选择Go To -&gt; Test 新建一个测试类即可：<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/DF391C57B2794747BC54F25C7A1E6957?method=download&amp;shareKey=7b155430194971c1e8d0811dcaa1d624\" alt=\"junit视图创建测试类\"></p>\n<p>其中@Befor/@After打勾会在测试类中初始的时候添加这两个方法（这两个方法后边再讲）。下边待测试方法勾选上，点击ok即可。</p>\n<p>上边是视图创建的方式，当然我们也可以在test-&gt;java包下新建一个源代码目录并自己创建一个测试类，功能一样:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CalculateTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Before</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUp</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@After</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">tearDown</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    assertEquals(<span class=\"string\">&quot;加法错误&quot;</span>, <span class=\"number\">5</span>, <span class=\"keyword\">new</span> Calculate().add(<span class=\"number\">1</span>,<span class=\"number\">2</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subtract</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    assertEquals(<span class=\"string\">&quot;减法错误&quot;</span>, <span class=\"number\">1</span>, <span class=\"keyword\">new</span> Calculate().subtract(<span class=\"number\">2</span>,<span class=\"number\">2</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">multiply</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    assertEquals(<span class=\"string\">&quot;乘法错误&quot;</span>, <span class=\"number\">4</span>, <span class=\"keyword\">new</span> Calculate().multiply(<span class=\"number\">2</span>,<span class=\"number\">2</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">divide</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    assertEquals(<span class=\"string\">&quot;除法错误&quot;</span>, <span class=\"number\">3</span>, <span class=\"keyword\">new</span> Calculate().divide(<span class=\"number\">6</span>,<span class=\"number\">2</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>初始的时候所有的方法内部其实都是空的，以上方法内部采用assertEquals（断言）来进行测试，这里有两种形式（一般情况采用方式1即可）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方式1</span></span><br><span class=\"line\"><span class=\"comment\">//参数1：期望值。参数2：实际值</span></span><br><span class=\"line\">assertEquals(<span class=\"keyword\">double</span> expected, <span class=\"keyword\">double</span> actual) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//方式2</span></span><br><span class=\"line\"><span class=\"comment\">//参数1：控制台提示错误信息。参数2：期望值。参数3：实际值。</span></span><br><span class=\"line\">assertEquals(String message, <span class=\"keyword\">long</span> expected, <span class=\"keyword\">long</span> actual)</span><br></pre></td></tr></table></figure>\n<p>**运行：**直接在方法名上右键或者在类名上进行run就可以了。</p>\n<p><strong>划重点：<strong>你以为这里运行通过了就没什么事儿了吗？如果这样想就错了，因为</strong>单元测试不是证明你的方法是对于项目是否是切实可行的，而是证明这个方法能否不报错</strong>，所以我们在写测试用例的时候要认真，有可能本来是可以通过的，但是你的测试用例写错了，同样也报错，这就尴尬了。</p>\n<h3 id=\"创建单元测试类注意点\">创建单元测试类注意点<a title=\"#创建单元测试类注意点\" href=\"#创建单元测试类注意点\"></a></h3>\n<p>以下是创建单元测试类需要注意的几个地方：</p>\n<ul>\n<li>在项目根目录test-&gt;java包下新建一个源代码目录来存放我们的测试代码。</li>\n<li>测试类的包名应该和被测试类的包名保持一致。</li>\n<li>测试单元中每个方法必须可以独立测试，测试方法间不能有任何的依赖关系。</li>\n<li>测试类使用Test作为类名的后缀。（不是必须）</li>\n<li>测试方法建议使用test作为方法名的前缀。（不是必须）</li>\n<li>所有的待测试的方法都是采用注解@Test修饰的。</li>\n<li>所有的测试方法都是public void修饰的,不带任何参数。</li>\n<li>测试判断采用assertEquals断言进行判断。</li>\n</ul>\n<h3 id=\"junit单元测试常用方法\">Junit单元测试常用方法<a title=\"#junit单元测试常用方法\" href=\"#junit单元测试常用方法\"></a></h3>\n<p><strong>@Test(expected = xxx.class)</strong><br>\n有些时候我们在单元测试方法中会感觉预期有一个异常出现，但是我们又感觉他不重要想忽略他以保证执行通过，则可以用@Test(expected = xxx.class)，后边跟的是异常的类名。有一点注意如果异常的地方在循环体内只会执行一次哦。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test(expected = ArithmeticException.class)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;+++++++++++++++++++test&quot;</span>);</span><br><span class=\"line\">        assertEquals(<span class=\"number\">3</span>, <span class=\"keyword\">new</span> Calculate().divide(<span class=\"number\">9</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>@Test(timeout = 2000)</strong><br>\n有些时候我们在测试方法里可能写一些耗时的操作，或者循环操作，但是我们不知道什么时候终止，这个时候可以采用@Test(timeout = 2000)来处理，后边跟的是可执行时间，单位为毫秒。如果超时了执行也就不能通过了，这个时候会报TestTimedOutException异常错误，告诉开发者超时了需要进行处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test(timeout = 2000)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>@Before</strong> 在每个test方法执行前都要执行一次。<br>\n<strong>@After</strong> 在每个test方法执行后都要执行一次。<br>\n这两个注解也是上面初始创建时选择勾选的两个方法注解。主要是为了每个测试方法执行前后的一个初始处理和结束处理。</p>\n<p><strong>@BeforeClass</strong> 在所有单元测试方法执行前执行，static修饰。<br>\n<strong>@AfterClass</strong> 在所有单元测试方法执行后执行，static修饰。<br>\n这两个注解所在的方法一定要用static修饰，@BeforeClass：测试类被运行就会被加载，在内存中只有一份实例，适合加载配置文件；@AfterClass：用于资源的清理，如关闭数据库。</p>\n<p><strong>@Ignore</strong><br>\n所修饰的测试方法会被测试运行器忽略。</p>\n<p><strong>@RunWith(xx.class)</strong><br>\n修改测试运行器，JUnit4默认的测试运行器是<code>org.junit.runner.Runner.class</code>。<br>\n如果采用mockito来测试需要修改为<code>MockitoJUnitRunner.class</code>，同时需要在gradle中dependencies下引入依赖<code>testCompile 'org.mockito:mockito-core:1.10.19'</code>，另外测试注解也不再是@Test了，mockito第三方库很多，具体看自己的业务情况。<br>\n如果是UI Test，也和上面一样，需要引入依赖，并修改测试运行器，具体用法也要结合第三方官方文档。<br>\n如果是instrumented tests，需要将测试运行器修改为<code>AndroidJUnitRunner.class</code>,需要在gradle中依赖：<code>testInstrumentationRunner 'android.support.test.runner.AndroidJUnitRunner'</code>。</p>\n<p><strong>@Suite.SuiteClasses({xxx0.class,xxx1.class})</strong><br>\n如果有多个测试类想一次性测试完，可以建一个“空”的suite类，然后采用@Suite.SuiteClasses({})注解，将要测试的测试类添加到里面，另外追加测试运行器为@Suite(Suite.class)，运行这个suite类即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(Suite.class)</span></span><br><span class=\"line\"><span class=\"meta\">@Suite</span>.SuiteClasses(&#123;CalculateTest.class, Calculate2Test.class &#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SuiteTest</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"mockito单元测试\">Mockito单元测试<a title=\"#mockito单元测试\" href=\"#mockito单元测试\"></a></h2>\n<p>上边JUnit单元测试主要功能就是验证某个方法的结果是否正常，有些功能方法在输入参数后却不能立刻获取其结果不能紧接着往下测试，Mock测试刚好能解决这一问题。“Mock”顾名思义就是模拟、模仿。Mockito是常用的第三方Mock测试框架，补充JUnit缺失的测试死角。</p>\n<h3 id=\"依赖\">依赖<a title=\"#依赖\" href=\"#依赖\"></a></h3>\n<p>Mockito测试也是建立在JUnit基础上的，据最新官方文档版本引入依赖：<code>testCompile 'org.mockito:mockito-core:2.+</code></p>\n<h3 id=\"使用场景\">使用场景<a title=\"#使用场景\" href=\"#使用场景\"></a></h3>\n<ol>\n<li>\n<p>模拟一个对象</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    Calculate calculate = mock(Calculate.class);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;++++++++++结果:&quot;</span>+calculate.add(<span class=\"number\">1</span>,<span class=\"number\">2</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：这里mock(xxx.class)需要静态导入包，包括后边的when（）、anyInt()…方法。上面仅仅是对一个对象进行了模拟，并没有对其方法进行模拟（Stubbing，也叫“打桩”），所以下边的打印结果还是0。</p>\n</li>\n<li>\n<p>模拟方法调用的返回值</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    Calculate calculate = mock(Calculate.class);</span><br><span class=\"line\">    when(calculate.add(<span class=\"number\">1</span>,<span class=\"number\">2</span>)).thenReturn(<span class=\"number\">4</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;++++++++++结果&quot;</span>+calculate.add(<span class=\"number\">1</span>,<span class=\"number\">2</span>));     <span class=\"comment\">//结果返回4</span></span><br><span class=\"line\">    assertEquals(<span class=\"string\">&quot;加法错误&quot;</span>, <span class=\"number\">5</span>, calculate.add(<span class=\"number\">1</span>,<span class=\"number\">2</span>));    <span class=\"comment\">//上边抛出异常，此处将不再执行</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>模拟抛出异常<br>\n有返回值的方式：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">when(calculate.add(<span class=\"number\">1</span>,<span class=\"number\">2</span>)).thenThrow(<span class=\"keyword\">new</span> RuntimeException());</span><br></pre></td></tr></table></figure>\n<p>无返回值（兼容有返回值的形式）的方式：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doThrow(<span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;出错了&quot;</span>)).when(calculate).add(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">calculate.add(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<p>二者的区别：<br>\nwhen()后边传入的是具体的对象,所以不能传入无返回值的方法调用。前一个方式是直接抛出异常，后一个方式是先定义异常，再抛出异常。</p>\n</li>\n<li>\n<p>模拟方法调用时参数匹配</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    Calculate calculate = mock(Calculate.class);</span><br><span class=\"line\">    when(calculate.add(anyInt(),anyInt())).thenReturn(<span class=\"number\">5</span>);     <span class=\"comment\">//anyInt()代表任意整数</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;++++++++++结果&quot;</span>+calculate.add(<span class=\"number\">1</span>,<span class=\"number\">2</span>));   <span class=\"comment\">//结果返回5</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>验证某个方法调用次数</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    Calculate calculate = mock(Calculate.class);</span><br><span class=\"line\">    calculate.add(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    calculate.add(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    verify(calculate, times(<span class=\"number\">2</span>)).add(<span class=\"number\">1</span>,<span class=\"number\">2</span>);  <span class=\"comment\">//验证是否调用两次。</span></span><br><span class=\"line\">    verify(calculate, never()).add(<span class=\"number\">1</span>,<span class=\"number\">2</span>);   <span class=\"comment\">//验证是否调用过  </span></span><br><span class=\"line\">    verify(calculate, atLeastOnce()).add(<span class=\"number\">1</span>,<span class=\"number\">2</span>);   <span class=\"comment\">//验证最少调用一次</span></span><br><span class=\"line\">    verify(calculate, atLeast(<span class=\"number\">2</span>)).add(<span class=\"number\">1</span>,<span class=\"number\">2</span>);   <span class=\"comment\">//验证最少调用两次</span></span><br><span class=\"line\">    verify(calculate, atMost(<span class=\"number\">5</span>)).add(<span class=\"number\">1</span>,<span class=\"number\">2</span>);    <span class=\"comment\">//验证最多调用5次</span></span><br><span class=\"line\">    reset(calculate);  <span class=\"comment\">//重置mock，以上calculate.add()将被清空</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>verify(calculate)表示默认调用次数是一次，多次需要添加times()。</p>\n</li>\n<li>\n<p>自定义参数匹配器<br>\n采用<code>argThat(new IsInteger());</code>，IsInteger()是自定义参数适配器，实现ArgumentMatcher接口，具体用法参阅ArgumentMatcher。</p>\n</li>\n<li>\n<p>校验调用顺序</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    Calculate calculate = mock(Calculate.class);</span><br><span class=\"line\">    calculate.add(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">    calculate.divide(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"comment\">//验证一个对象的多个方法的执行顺序</span></span><br><span class=\"line\">    InOrder inOrder = inOrder(calculate);</span><br><span class=\"line\">    inOrder.verify(calculate).add(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">    inOrder.verify(calculate).divide(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Calculate calculate1 = mock(Calculate.class);</span><br><span class=\"line\">    calculate.add(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">    calculate1.add(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"comment\">//验证不同对象的方法的执行顺序</span></span><br><span class=\"line\">    InOrder inOrder1 = inOrder(calculate,calculate1);</span><br><span class=\"line\">    inOrder1.verify(calculate).add(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">    inOrder1.verify(calculate1).add(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>返回结果拦截</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">Calculate calculate = mock(Calculate.class);</span><br><span class=\"line\">    when(calculate.add(<span class=\"number\">1</span>,<span class=\"number\">2</span>)).thenAnswer(<span class=\"keyword\">new</span> Answer() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">answer</span><span class=\"params\">(InvocationOnMock invocation)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">            Object[] args = invocation.getArguments();  <span class=\"comment\">//获取所有参数</span></span><br><span class=\"line\">            Object mock = invocation.getMock();   <span class=\"comment\">//获取mock对象</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>)args[<span class=\"number\">0</span>]+<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;+++++++++++++++&quot;</span>+calculate.add(<span class=\"number\">1</span>,<span class=\"number\">2</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>验证是否超时</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void add() throws Exception &#123;</span><br><span class=\"line\">Calculate calculate &#x3D; mock(Calculate.class);</span><br><span class=\"line\">calculate.add(1,2);</span><br><span class=\"line\">calculate.add(1,2);</span><br><span class=\"line\">verify(calculate, timeout(100).times(2)).add(1,2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>Mock详情</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void add() throws Exception &#123;</span><br><span class=\"line\">Calculate calculate &#x3D; mock(Calculate.class);</span><br><span class=\"line\">Mockito.mockingDetails(calculate).isMock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>虽然mock补齐了JUnit不能及时返回结果的缺点，但是始终不能测试private、static、final做mock测试，这可以借助第三方框架<a href=\"https://github.com/powermock/powermock\" target=\"_blank\">Powermock</a>进行解决。果做本地单元测试最好的组合就是JUnit+mock+Powermock。</p>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<ul>\n<li>mockito英文文档：<a href=\"https://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/Mockito.html\">https://static.javadoc.io/org.mockito/mockito-core/2.8.47/org/mockito/Mockito.html</a></li>\n<li>mockito中文文档：<a href=\"https://github.com/hehonghui/mockito-doc-zh?spm=5176.100239.blogcont58770.6.YeQEAQ\">https://github.com/hehonghui/mockito-doc-zh?spm=5176.100239.blogcont58770.6.YeQEAQ</a></li>\n<li>Powermock官方文档：<a href=\"https://github.com/powermock/powermock/wiki/Mockito\">https://github.com/powermock/powermock/wiki/Mockito</a></li>\n<li>JUnit+mock+Powermock：<a href=\"https://yq.aliyun.com/articles/58770\">https://yq.aliyun.com/articles/58770</a></li>\n<li>一个给力的mock框架：<a href=\"https://github.com/easy-mock/easy-mock\">https://github.com/easy-mock/easy-mock</a></li>\n</ul>\n","prev":{"title":"JAVA设计模式之代理模式","link":"post/1465978376"},"next":{"title":"Android开发权限处理和自定义权限","link":"post/1459478411"},"plink":"https://blog.ixin.run/post/1465713367/","toc":[{"id":"android项目中的单元测试","title":"Android项目中的单元测试","index":"1"},{"id":"junit单元测试","title":"JUnit单元测试","index":"2","children":[{"id":"单元测试可以测试那些内容？","title":"单元测试可以测试那些内容？","index":"2.1"},{"id":"一个demo","title":"一个Demo","index":"2.2"},{"id":"创建单元测试类注意点","title":"创建单元测试类注意点","index":"2.3"},{"id":"junit单元测试常用方法","title":"Junit单元测试常用方法","index":"2.4"}]},{"id":"mockito单元测试","title":"Mockito单元测试","index":"3","children":[{"id":"依赖","title":"依赖","index":"3.1"},{"id":"使用场景","title":"使用场景","index":"3.2"}]},{"id":"参考","title":"参考","index":"4"}],"reward":true,"copyright":{"custom":"转载请注明出处，谢谢支持。"}}