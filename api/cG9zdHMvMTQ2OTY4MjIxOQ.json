{"title":"什么是进程，什么是线程","date":"2016-07-28T05:03:39.000Z","date_formatted":{"ll":"2016年7月28日","L":"2016/07/28","MM-DD":"07-28"},"link":"posts/1469682219","comments":true,"categories":["计算机基础"],"updated":"2021-01-29T12:51:44.673Z","content":"<p>提到进程和线程，大家都有所了解，但是据其概念又比较抽象不容易掌握。计算机科学是人类进步的结晶，但是也是为人类服务，所以千万不要被我们自己创造的东西绕进去而最终不知道这玩意到底是啥，所以提炼升华转成大白话最重要。</p>\n<a id=\"more\"></a>\n<h2 id=\"什么是进程？\">什么是进程？<a title=\"#什么是进程？\" href=\"#什么是进程？\"></a></h2>\n<p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</p>\n<p>进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的代码，还包括当前的活动，通过程序计数器的值和处理寄存器的内容来表示。</p>\n<h2 id=\"什么是线程？\">什么是线程？<a title=\"#什么是线程？\" href=\"#什么是线程？\"></a></h2>\n<p>线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>\n<h2 id=\"进程-vs-线程\">进程 VS 线程<a title=\"#进程-vs-线程\" href=\"#进程-vs-线程\"></a></h2>\n<p>简单的说，进程是指在操作系统中正在运行的一个应用程序，线程是指进程内独立执行某个任务的一个单元。进程注重某项功能或活动的实现，而线程是实现这个功能或活动的具体步骤（同步过程和异步过程），前者是后者的集合体。</p>\n<p>线程与进程有很多类似的性质，因此人们习惯上也称线程为轻量级进程（ lightweightprocess, LWP），也是CPU调度和分派的基本单元；而传统意义上的进程则被称为重量级进程（heavyweight process, HWP），从现代的角度来看，它就是只拥有一个线程的进程。如果进程有多个控制线程，那么它就能同时执行多个任务。他们之间的关系可以简单的由下图表示：<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/500F0F82E95F4F78A8E43F625EA059C9?method=download&amp;shareKey=e7f53a6b494cc4227bef0ac0e221c8a6\" alt=\"线程也是进程\"></p>\n<p>1）进程是静态的，其实就是指开启的一个程序；而线程是动态的，是真正执行的单元，执行的过程。其实我们平时看到的进程，是线程在执行着，因为线程是作为进程的一个单元存在的。<br>\n2）同样作为基本的执行单元，线程是划分得比进程更小的执行单位。<br>\n3）每个进程都有一段专用的内存区域。与此相反，线程却共享内存单元（包括代码和数据），通过共享的内存单元来实现数据交换、实时通信与必要的同步操作。</p>\n<p>下面，主要从调度、并发性、系统开销、拥有资源等方面来对线程和进程进行比较：</p>\n<h3 id=\"调度\">调度<a title=\"#调度\" href=\"#调度\"></a></h3>\n<p>在传统的操作系统中，CPU调度和分派的基本单位是进程。而在引入线程的操作系统中，则把线程作为CPU调度和分派的基本单位，进程则作为资源拥有的基本单位，从而使传统进程的两个属性分开，线程便能轻装运行，这样可以显著地提高系统的并发性。同一进程中线程的切换不会引起进程切换，从而避免了昂贵的系统调用。但是在由一个进程中的线程切换到另一进程中的线程时，依然会引起进程切换。</p>\n<h3 id=\"并发性\">并发性<a title=\"#并发性\" href=\"#并发性\"></a></h3>\n<p>在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间也可以并发执行，因而使操作系统具有更好的并发性，从而能更有效地使用系统资源和提高系统的吞吐量。例如，在一个未引入线程的单CPU操作系统中，若仅设置一个文件服务进程，当它由于某种原因被封锁时，便没有其他的文件服务进程来提供服务。在引入了线程的操作系统中，可以在一个文件服务进程中设置多个服务线程。当第一个线程等待时，文件服务进程中的第二个线程可以继续运行；当第二个线程封锁时，第三个线程可以继续执行，从而显著地提高了文件服务的质量以及系统的吞吐量。</p>\n<h3 id=\"系统开销\">系统开销<a title=\"#系统开销\" href=\"#系统开销\"></a></h3>\n<p>不论是引入了线程的操作系统，还是传统的操作系统，进程都是拥有系统资源的一个独立单位，它可以拥有自己的资源。一般地说，线程自己不拥有系统资源（也有一点必不可少的资源），但它可以访问其隶属进程的资源。亦即一个进程的代码段、数据段以及系统资源（如已打开的文件、I/O设备等），可供同一进程的其他所有线程共享。</p>\n<h3 id=\"拥有资源\">拥有资源<a title=\"#拥有资源\" href=\"#拥有资源\"></a></h3>\n<p>由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的进程的CPU环境的设置。而线程切换只需保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。此外，由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现也变得比较容易。在有的系统中，线程的切换、同步和通信都无需操作系统内核的干预。</p>\n<h2 id=\"顺便说一些\">顺便说一些<a title=\"#顺便说一些\" href=\"#顺便说一些\"></a></h2>\n<ol>\n<li>\n<p>在单核计算机里，有一个资源是无法被多个程序并行使用的：<strong>CPU</strong>。<br>\n没有操作系统的情况下，一个程序一直独占着全都cpu。如果要有两个任务来共享同一个cpu，程序员就需要仔细地为程序安排好运行计划–某时刻cpu和由程序A来独享，下一时刻cpu由程序B来独享，而这种安排计划后来成为OS的核心组件，被单独名命为“scheduler”，即“调度器”，它关心的只是怎样把单个cpu的运行拆分成一段一段的“运行片”，轮流分给不同的程序去使用，而在宏观上，因为分配切换的速度极快，就制造出多程序并行在一个cpu上的假象。</p>\n</li>\n<li>\n<p>在单核计算机里，有一个资源可以被多个程序共用，然而会引出麻烦：<strong>内存</strong>。<br>\n在一个只有调度器，没有内存管理组件的操作系统上，程序员需要手工为每个程序安排运行的空间 – 程序A使用物理地址0x00-0xff,程序B使用物理地址0x100-0x1ff，等等。然而这样做有个很大的问题：每个程序都要协调商量好怎样使用同一个内存上的不同空间，软件系统和硬件系统千差万别，使这种定制的方案没有可行性。</p>\n<p>为了解决这个麻烦，计算机系统引入了“虚拟地址”的概念，从三方面入手来做：</p>\n<ul>\n<li>硬件上，CPU增加了一个专门的模块叫MMU，负责转换虚拟地址和物理地址。</li>\n<li>操作系统上，操作系统增加了另一个核心组件：memory management，即内存管理模块，它管理物理内存、虚拟内存相关的一系列事务。</li>\n<li>应用程序上，发明了一个叫做【进程】的模型，（注意）每个进程都用【完全一样的】虚拟地址空间，然而经由操作系统和硬件MMU协作，映射到不同的物理地址空间上。不同的【进程】，都有各自独立的物理内存空间，不用一些特殊手段，是无法访问别的进程的物理内存的。</li>\n</ul>\n</li>\n<li>\n<p>现在，不同的应用程序可以不关心底层的物理内存分配，也不关心CPU的协调共享了。然而还有一个问题存在：有一些程序，想要共享CPU，【并且还要共享同样的物理内存】，这时候，一个叫【线程】的模型就出现了，它们被包裹在进程里面，在调度器的管理下共享CPU，拥有同样的虚拟地址空间，同时也共享同一个物理地址空间，然而，它们无法越过包裹自己的进程，去访问别一个进程的物理地址空间。</p>\n</li>\n<li>\n<p>进程之间怎样共享同一个物理地址空间呢？不同的系统方法各异，符合posix规范的操作系统都提供了一个接口，叫mmap，可以把一个物理地址空间映射到不同的进程中，由不同的进程来共享。</p>\n</li>\n</ol>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<ul>\n<li><a href=\"https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B/382503?fr=aladdin\" target=\"_blank\">进程——百度百科</a></li>\n<li><a href=\"https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B/103101?fr=aladdin\" target=\"_blank\">线程——百度百科</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html\" target=\"_blank\">进程与线程的一个简单解释——阮一峰</a></li>\n</ul>\n","prev":{"title":"Android开发之进程间通信AIDL的探究和学习","link":"posts/1469856029"},"next":{"title":"Android开发Handler消息机制探究","link":"posts/1469605305"},"plink":"https://blog.ixin.run/posts/1469682219/","toc":[{"id":"什么是进程？","title":"什么是进程？","index":"1"},{"id":"什么是线程？","title":"什么是线程？","index":"2"},{"id":"进程-vs-线程","title":"进程 VS 线程","index":"3","children":[{"id":"调度","title":"调度","index":"3.1"},{"id":"并发性","title":"并发性","index":"3.2"},{"id":"系统开销","title":"系统开销","index":"3.3"},{"id":"拥有资源","title":"拥有资源","index":"3.4"}]},{"id":"顺便说一些","title":"顺便说一些","index":"4"},{"id":"参考","title":"参考","index":"5"}],"reward":true,"copyright":{"author":"i猩人","link":"<a href=\"https://blog.ixin.run/posts/1469682219/\" title=\"什么是进程，什么是线程\">https://blog.ixin.run/posts/1469682219/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}