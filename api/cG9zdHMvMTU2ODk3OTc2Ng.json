{"title":"JVM（一）内存分配","date":"2019-09-20T11:42:46.000Z","date_formatted":{"ll":"2019年9月20日","L":"2019/09/20","MM-DD":"09-20"},"link":"posts/1568979766","comments":true,"tags":["JVM","内存分配"],"categories":["Java"],"updated":"2021-01-29T12:51:44.657Z","content":"<p>Java内存分配无论是处于正常开发计算过程还是绞尽脑汁思考内存回收都需要深入理解的，本文所属范畴是JVM，不应该先来个类加载和运行机制吗，为什么先研究内存分配呢？老实说因为这块很接近我们的开发，越接近后边的深入越容易理解。在了解JVM内存分配之前我们先简单熟悉一下Java HotSpot VM，因为我们经常挂在嘴边的JVM目前就是这家伙。</p>\n<a id=\"more\"></a>\n<h2 id=\"java-hotspot-vm\">Java HotSpot VM<a title=\"#java-hotspot-vm\" href=\"#java-hotspot-vm\"></a></h2>\n<p>提起HotSpot VM，相信所有Java程序员都知道，它是Sun JDK和OpenJDK中所带的虚拟机，也是目前使用范围最广的Java虚拟机。 但不一定所有人都知道的是，这个目前看起来“血统纯正”的虚拟机在最初并非由Sun公司开发，而是由一家名为“Longview Technologies”的小公司设计的；甚至这个虚拟机最初并非是为Java语言而开发的，它来源于Strongtalk VM，而这款虚拟机中相当多的技术又是来源于一款支持Self语言实现“达到C语言50%以上的执行效率”的目标而设计的虚拟机，Sun公司注意到了这款虚拟机在JIT编译上有许多优秀的理念和实际效果，在1997年收购了Longview Technologies公司，从而获得了HotSpot VM。</p>\n<p>HotSpot VM既继承了Sun之前两款商用虚拟机的优点（如前面提到的准确式内存管理），也有许多自己新的技术优势，如它名称中的HotSpot指的就是它的热点代码探测技术（其实两个VM基本上是同时期的独立产品，HotSpot还稍早一些，HotSpot一开始就是准确式GC，而Exact VM之中也有与HotSpot几乎一样的热点探测。 为了Exact VM和HotSpot VM哪个成为Sun主要支持的VM产品，在Sun公司内部还有过争论，HotSpot打败Exact并不能算技术上的胜利）， HotSpot VM的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知JIT编译器以方法为单位进行编译。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发标准编译和OSR（栈上替换）编译动作。通过编译器与解释器恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无须等待本地代码输出才能执行程序，即时编译的时间压力也相对减小，这样有助于引入更多的代码优化技术，输出质量更高的本地代码。</p>\n<p>在2006年的JavaOne大会上，Sun公司宣布最终会把Java开源，并在随后的一年，陆续将JDK的各个部分（其中当然也包括了HotSpot VM）在GPL协议下公开了源码，并在此基础上建立了OpenJDK。这样，HotSpot VM便成为了SunJDK和OpenJDK两个实现极度接近的JDK项目的共同虚拟机。</p>\n<p>在2008年和2009年，Oracle公司分别收购了BEA公司和Sun公司，这样Oracle就同时拥有了两款优秀的Java虚拟机：JRockit VM和HotSpot VM。 Oracle公司宣布在不久的将来（大约应在发布JDK8的时候）会完成这两款虚拟机的整合工作，使之优势互补。整合的方式大致上是在HotSpot的基础上，移植JRockit的优秀特性，譬如使用JRockit的垃圾回收器与MissionControl服务，使用HotSpot的JIT编译器与混合的运行时系统。</p>\n<p>更多JVM可参看这篇文章：<a href=\"https://blog.csdn.net/qq_36582604/article/details/81564905\">https://blog.csdn.net/qq_36582604/article/details/81564905</a></p>\n<h2 id=\"jvm内存分配\">JVM内存分配<a title=\"#jvm内存分配\" href=\"#jvm内存分配\"></a></h2>\n<p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域存储不同类型的数据，这些区域的内存分配和销毁的时间也不同，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（第2版）》的规定，Java虚拟机管理的内存包括五个运行时数据区域，如下图所示：<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/A74808AB38464E6B9AA3FD2BE814FD29?method=download&amp;shareKey=8171c69104954c8c7bdcdb19f4a88621\" alt=\"jvm内存分配\"></p>\n<h3 id=\"方法区（method-area）\">方法区（Method Area）<a title=\"#方法区（method-area）\" href=\"#方法区（method-area）\"></a></h3>\n<p>方法区（Method Area）是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息（包括类的名称、方法信息、成员变量信息）、常量、静态变量、以及编译器编译后的代码等数据。当方法区无法满足内存分配需求时，将抛出OutOfMemeryError异常。</p>\n<h3 id=\"堆（heap）\">堆（Heap）<a title=\"#堆（heap）\" href=\"#堆（heap）\"></a></h3>\n<p>Java堆是Java虚拟机所管理的内存中最大的一块，在虚拟机启动时创建，此内存区域的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区(TLAB)。Java堆可以处于物理上不连续的内存空间，只要逻辑上连续即可，在实现上，既可以实现固定大小的，也可以是扩展的。如果堆中没有足够的内存分配给实例，并且堆也无法再拓展时，将会抛出OutOfMemeryError异常。</p>\n<p>堆是运行时动态分配内存，对象在没有引用变量指向它的时候，才变成垃圾，但是仍然占着内存，在程序空闲的时候（没有工作线程运行，GC线程优先级最低）或者堆内存不足的时候（GC线程被触发），被垃圾回收器释放掉，由于要在运行时动态分配内存，存取速度较慢。</p>\n<h3 id=\"虚拟机栈（vm-stack）\">虚拟机栈（VM Stack）<a title=\"#虚拟机栈（vm-stack）\" href=\"#虚拟机栈（vm-stack）\"></a></h3>\n<p>虚拟机栈就是Java中的方法执行的内存模型，每个方法在执行的同时都会创建一个<strong>栈帧</strong>，这个栈帧用于存储<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>指向当前方法所属的类的运行时常量池的引用</strong>、<strong>方法返回地址</strong>等信息，每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>\n<p>局部变量表用来存储方法中的局部变量，包括方法中声明的变量以及函数形参。对于基本数据类型的变量，则直接存储它的值，对于引用类型的变量，则存的是指向对象的引用。局部变量表的大小在编译器就可以确定其大小，并且在程序执行期间局部变量表的大小是不会改变的。</p>\n<p>程序中的所有计算过程都是在借助于操作数栈来完成的。</p>\n<p>指向运行时常量池的引用，因为在方法执行的过程中有可能需要用到类中的常量，所以必须要有一个引用指向当前方法所属的类的运行时常量池。</p>\n<p>方法返回地址，当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。</p>\n<p>在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。</p>\n<h3 id=\"本地方法栈（native-method-stack）\">本地方法栈（Native Method Stack）<a title=\"#本地方法栈（native-method-stack）\" href=\"#本地方法栈（native-method-stack）\"></a></h3>\n<p>本地方法栈与虚拟机栈的作用相似，它们之间的区别在于java虚拟机栈为虚拟机执行java方法（字节码）服务，而本地方法栈为虚拟机栈使用到的Native方法服务（在SUN HotSpot虚拟机中将虚拟机栈和本地方法栈合二为一）。</p>\n<h3 id=\"程序计数器（program-counter-register）\">程序计数器（Program Counter Register）<a title=\"#程序计数器（program-counter-register）\" href=\"#程序计数器（program-counter-register）\"></a></h3>\n<p>程序计数器是一块较小的内存空间，它可以看做当前线程所执行的字节码的行号指示器，在jvm中，虚拟机通过改变程序计数器的值来选取下一条需要执行的字节码的指令，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖它。</p>\n<p>在java多线程中是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程的指令，每一条线程都需要一个独立的程序计数器，各个计数器之间不相互影响，独立存储，因为这类内存区域称为“线程私有”的内存。此内存区域是唯一一个在jvm中没有规定任何OutOfMemoryError情况的区域。</p>\n<h2 id=\"常量池\">常量池<a title=\"#常量池\" href=\"#常量池\"></a></h2>\n<p>常量池是jvm的一块特殊的内存空间。在java用于保存在编译器一确定的已变异的class文件中的一份数据，它包括了关于类、方法、接口等中的常量，也包括字符串常量。<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/7D5916E7A564442F9222E6DE18C2CB9B?method=download&amp;shareKey=45fd947c399bff47bdb07b0219dce91d\" alt=\"jvm常量池\"></p>\n<p>常量池的版本变化：</p>\n<ul>\n<li>Java6和6之前，常量池是存放在方法区中的。</li>\n<li>Java7，将常量池是存放到了堆中，常量池就相当于是在永久代中，所以永久代存放在堆中。</li>\n<li>Java8之后，取消了整个永久代区域，取而代之的是元空间。没有再对常量池进行调整。</li>\n</ul>\n<p>Java中的常量池分为三种类型：</p>\n<ul>\n<li>类文件中常量池（The Constant Pool）</li>\n<li>运行时常量池（The Run-Time Constant Pool）</li>\n<li>String常量池</li>\n</ul>\n<h3 id=\"类文件中常量池\">类文件中常量池<a title=\"#类文件中常量池\" href=\"#类文件中常量池\"></a></h3>\n<p>所处区域：堆<br>\n诞生时间：编译时<br>\n内容概要：符号引用和字面量</p>\n<p>class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量的符号引用。</p>\n<p>下面对字面量和符号引用进行说明</p>\n<p><strong>字面量</strong><br>\n字面量类似与我们平常说的常量，主要包括：</p>\n<ol>\n<li>文本字符串：就是我们在代码中能够看到的字符串，例如String a = “aa”。其中”aa”就是字面量。</li>\n<li>被final修饰的变量。</li>\n</ol>\n<p><strong>符号引用</strong><br>\n主要包括以下常量：</p>\n<ol>\n<li>类和接口和全限定名：例如对于String这个类，它的全限定名就是java/lang/String。</li>\n<li>字段的名称和描述符：所谓字段就是类或者接口中声明的变量，包括类级别变量（static)和实例级的变量。</li>\n<li>方法的名称和描述符。所谓描述符就相当于方法的参数类型+返回值类型。</li>\n</ol>\n<h3 id=\"运行时常量池\">运行时常量池<a title=\"#运行时常量池\" href=\"#运行时常量池\"></a></h3>\n<p>所处区域：内存的元空间<br>\n诞生时间：JVM运行时<br>\n内容概要：class文件元信息描述，编译后的代码数据，引用类型数据，类文件常量池。</p>\n<p>所谓的运行时常量池其实就是将编译后的类信息放入运行时的一个区域中，用来动态获取类信息。</p>\n<p>运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。</p>\n<h3 id=\"字符串常量池\">字符串常量池<a title=\"#字符串常量池\" href=\"#字符串常量池\"></a></h3>\n<p>所处区域：堆<br>\n诞生时间：类加载完成</p>\n<p>字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的）。</p>\n<p><strong>四段解析</strong></p>\n<p>解析1：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str1 &#x3D; new String(&quot;1&quot;);</span><br><span class=\"line\">解析：首先此行代码创建了两个对象，在执行前会在常量池中创建一个&quot;1&quot;的对象，然后执行该行代码时new一个&quot;1&quot;的对象存放在堆区中；然后str1指向堆区中的对象；</span><br><span class=\"line\"></span><br><span class=\"line\">str1.intern();</span><br><span class=\"line\">解析：该行代码首先查看&quot;1&quot;字符串有没有存在在常量池中，此时存在则直接返回该常量，这里返回后没有引用接受他，【假如不存在的话在 jdk1.6中会在常量池中建立该常量，在jdk1.7以后会把堆中该对象的引用放在常量池中】</span><br><span class=\"line\"></span><br><span class=\"line\">String str2 &#x3D; &quot;1&quot;;</span><br><span class=\"line\">解析：此时&quot;1&quot;已经存在在常量池中，str2指向常量池中的对象；</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(str1 &#x3D;&#x3D; str2);  &#x2F;&#x2F;结果是 false or true？</span><br><span class=\"line\">解析：str1指向堆区的对象，str2指向常量池中的对象，两个引用指向的地址不同，输入false；</span><br><span class=\"line\"></span><br><span class=\"line\">String str3 &#x3D; new String(&quot;2&quot;) + new String(&quot;2&quot;);</span><br><span class=\"line\">解析：此行代码执行的底层执行过程是 首先使用StringBuffer的append方法将&quot;2&quot;和&quot;2&quot;拼接在一块，然后调用toString方法new出“22”；所以此时的“22”字符串是创建在堆区的；</span><br><span class=\"line\"></span><br><span class=\"line\">t3.intern();</span><br><span class=\"line\">解析：此行代码执行时字符串常量池中没有&quot;22&quot;,所以此时在jdk1.6中会在字符串常量池中创建&quot;22&quot;,而在jdk1.7以后会把堆中该对象的引用放在常量池中；</span><br><span class=\"line\"></span><br><span class=\"line\">String str4 &#x3D; &quot;22&quot;;</span><br><span class=\"line\">解析：此时的str4在jdk1.6中会指向方法区，而在jdk1,7中会指向堆区；</span><br><span class=\"line\">　　</span><br><span class=\"line\">System.out.println(str3 &#x3D;&#x3D; str4); &#x2F;&#x2F;结果是 false or true？</span><br><span class=\"line\">解析：很明显了 jdk1.6中为false 在jdk1.7中为true；</span><br><span class=\"line\">　　</span><br></pre></td></tr></table></figure>\n<p>解析2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str1 &#x3D; &quot;aaa&quot;;</span><br><span class=\"line\">解析：str1指向方法区；</span><br><span class=\"line\"></span><br><span class=\"line\">String str2 &#x3D; &quot;bbb&quot;;</span><br><span class=\"line\">解析： str2 指向方法区</span><br><span class=\"line\"></span><br><span class=\"line\">String str3 &#x3D; &quot;aaabbb&quot;;</span><br><span class=\"line\">解析：str3指向方法区</span><br><span class=\"line\"></span><br><span class=\"line\">String str4 &#x3D; str1 + str2;</span><br><span class=\"line\">解析：此行代码上边已经说过原理。str4指向堆区</span><br><span class=\"line\"></span><br><span class=\"line\">String str5 &#x3D; &quot;aaa&quot; + &quot;bbb&quot;;</span><br><span class=\"line\">解析：该行代码重点说明一下，jvm对其有优化处理，也就是在编译阶段就会将这两个字符串常量进行拼接，也就是&quot;aaabbb&quot;;所以他是在方法区中的；’</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(str3 &#x3D;&#x3D; str4); &#x2F;&#x2F; false or true</span><br><span class=\"line\">解析：很明显 为false， 一个指向堆, 一个指向方法区</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(str3 &#x3D;&#x3D; str4.intern()); &#x2F;&#x2F; true or false</span><br><span class=\"line\">解析：jdk1.6中str4.intern会把“aaabbb”放在方法区，1.7后在堆区，所以在1.6中会是true 但是在1.7中是false</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(str3 &#x3D;&#x3D; str5);&#x2F;&#x2F; true or false</span><br><span class=\"line\">解析：都指向字符串常量区，字符串长常量区在方法区，相同的字符串只存在一份，其实这个地方在扩展一下，因为方法区的字符串常量是共享的，在两个线程同时共享这个字符串时，如果一个线程改变他会是怎么样的呢，其实这种场景下是线程安全的，jvm会将改变后的字符串常量在字符串常量池中重新创建一个处理，可以保证线程安全</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>解析3：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String t1 &#x3D; new String(&quot;2&quot;);</span><br><span class=\"line\">解析：创建了两个对象，t1指向堆区</span><br><span class=\"line\"></span><br><span class=\"line\">String t2 &#x3D; &quot;2&quot;;</span><br><span class=\"line\">解析：t2指向字符串常量池</span><br><span class=\"line\"></span><br><span class=\"line\">t1.intern();</span><br><span class=\"line\">解析:字符串常量池已经存在该字符串，直接返回；</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(t1 &#x3D;&#x3D; t2); &#x2F;&#x2F;false or true</span><br><span class=\"line\">解析：很明显 false</span><br><span class=\"line\"></span><br><span class=\"line\">String t3 &#x3D; new String(&quot;2&quot;) + new String(&quot;2&quot;);</span><br><span class=\"line\">解析：过程同问题1 t3指向堆区</span><br><span class=\"line\"></span><br><span class=\"line\">String t4 &#x3D; &quot;22&quot;;</span><br><span class=\"line\">解析：t4 在1.6 和 1.7中指向不同</span><br><span class=\"line\"></span><br><span class=\"line\">t3.intern();</span><br><span class=\"line\">解析： 字符串常量池中已经存在该字符串 直接返回</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(t3 &#x3D;&#x3D; t4); &#x2F;&#x2F;false or true</span><br><span class=\"line\">解析： 很明显为 false 指向不同的内存区</span><br></pre></td></tr></table></figure>\n<p>解析4：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer a &#x3D; 1;</span><br><span class=\"line\">Integer b &#x3D; 2;</span><br><span class=\"line\">Integer c &#x3D; 3;</span><br><span class=\"line\">Integer d &#x3D; 3;</span><br><span class=\"line\">Integer e &#x3D; 321;</span><br><span class=\"line\">Integer f &#x3D; 321;</span><br><span class=\"line\">Long g &#x3D; 3L;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(c &#x3D;&#x3D; d);</span><br><span class=\"line\">解析：由于常量池的作用，c与d指向的是同一个对象(注意此时的&#x3D;&#x3D;比较的是对象，也就是地址，而不是数值)。因此为true</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.Println(e &#x3D;&#x3D; f);</span><br><span class=\"line\">解析：由于321超过了127，因此常量池失去了作用，所以e和f数值虽然相同，但不是同一个对象，以此为false。</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(c &#x3D;&#x3D; (a + b));</span><br><span class=\"line\">解析：此时&#x3D;&#x3D;两边有算术运算，会进行拆箱，因此此时比较的是数值，而并非对象。因此为true。</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(c.equals(a+b));</span><br><span class=\"line\">解析：c与a+b的数值相等，为true。</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(g &#x3D;&#x3D; (a + b));</span><br><span class=\"line\">解析：由于&#x3D;&#x3D;两边有算术运算，所以比较的是数值，因此为true。</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(g.equals(a + b));</span><br><span class=\"line\">解析：Long类型的equal在比较是时候，会先判断a+b是否为Long类型，显然a+b不是，因此false</span><br></pre></td></tr></table></figure>\n<p>这个地方存在一些知识点：</p>\n<ol>\n<li>内存中有一个java基本类型封装类的常量池。这些类包括Byte, Short, Integer, Long, Character, Boolean。需要注意的是，Float和Double这两个类并没有对应的常量池。</li>\n<li>上面5种整型的包装类的对象是存在范围限定的；范围在-128~127存在在常量池，范围以外则在堆区进行分配。</li>\n<li>在周志明的那本虚拟机中有这样一句话：包装类的<code>==</code>运行符在不遇到算术运算的情况下不会自动拆箱，以及他们的equals()方法不处理数据类型的关系，通俗的讲也就是<code>==</code>两边如果有算术运算，那么自动拆箱和进行数据类型转换处理，比较的是数值等不等。</li>\n<li>Long的equals方法会先判断是否是Long类型。</li>\n<li>无论是Integer还是Long，他们的equals方法比较的是数值。</li>\n</ol>\n<h2 id=\"总结\">总结<a title=\"#总结\" href=\"#总结\"></a></h2>\n<p>理解JVM内存分配对开发者来说是有很重要的意义，有同学说了无非就是一些概念，其实我们了解这块内容其真正目的是为了知道数据真正是存在哪里的，这对后边的程序计算以及内存管理回收有很大帮助，否则看着很对实际是错的，也就是说我们必须根据计算机规则来走。</p>\n","prev":{"title":"Java垃圾回收（一）四种对象引用类型","link":"posts/1569136070"},"next":{"title":"位运算的那些事（三）位掩码","link":"posts/1567003105"},"plink":"https://blog.ixin.run/posts/1568979766/","toc":[{"id":"java-hotspot-vm","title":"Java HotSpot VM","index":"1"},{"id":"jvm内存分配","title":"JVM内存分配","index":"2","children":[{"id":"方法区（method-area）","title":"方法区（Method Area）","index":"2.1"},{"id":"堆（heap）","title":"堆（Heap）","index":"2.2"},{"id":"虚拟机栈（vm-stack）","title":"虚拟机栈（VM Stack）","index":"2.3"},{"id":"本地方法栈（native-method-stack）","title":"本地方法栈（Native Method Stack）","index":"2.4"},{"id":"程序计数器（program-counter-register）","title":"程序计数器（Program Counter Register）","index":"2.5"}]},{"id":"常量池","title":"常量池","index":"3","children":[{"id":"类文件中常量池","title":"类文件中常量池","index":"3.1"},{"id":"运行时常量池","title":"运行时常量池","index":"3.2"},{"id":"字符串常量池","title":"字符串常量池","index":"3.3"}]},{"id":"总结","title":"总结","index":"4"}],"reward":true,"copyright":{"author":"i猩人","link":"<a href=\"https://blog.ixin.run/posts/1568979766/\" title=\"JVM（一）内存分配\">https://blog.ixin.run/posts/1568979766/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}