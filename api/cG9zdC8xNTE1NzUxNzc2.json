{"title":"数据结构整体概括","date":"2018-01-12T10:09:36.000Z","date_formatted":{"ll":"2018年1月12日","L":"2018/01/12","MM-DD":"01-12"},"link":"post/1515751776","comments":true,"tags":["数据结构"],"categories":["数据结构和算法"],"updated":"2021-01-14T08:08:54.917Z","content":"<p>一直想把数据结构系统温故一下，今天先来一个总括，后续慢慢补充。</p>\n<a id=\"more\"></a>\n<h2 id=\"什么是数据结构\">什么是数据结构<a title=\"#什么是数据结构\" href=\"#什么是数据结构\"></a></h2>\n<p>数据结构是数据元素之间存在的一种或多种特定关系，也是数据的组织形式。在计算机中，数据元素并不是孤立和杂乱无序的，而是具有内在的联系的数据集合。这种集合可能是以“表”的形式存在，可能是“树”的形式存在，还可能是以“图”的形式存在等等。</p>\n<p>数据结构的主要任务就是通过分析描述对象的结构特征，以及元素之间的内在联系并抽象成相应的数据关系，进而把这种逻辑结构表示成计算机可实现的物理结构，从而方便计算机的高效快速处理。</p>\n<h2 id=\"数据结构的分类\">数据结构的分类<a title=\"#数据结构的分类\" href=\"#数据结构的分类\"></a></h2>\n<p>数据结构目前分为两大类：逻辑结构和物理结构。</p>\n<h3 id=\"逻辑结构\">逻辑结构<a title=\"#逻辑结构\" href=\"#逻辑结构\"></a></h3>\n<p>逻辑结构是指在数据对象中数据元素之间的相互关系。逻辑结构可分为线性结构和非线性结构。</p>\n<h4 id=\"线性结构\">线性结构<a title=\"#线性结构\" href=\"#线性结构\"></a></h4>\n<p>有且只有一个开始结点和一个终端结点，并且所有结点都最多只有一个直接前驱和一个直接后继。</p>\n<ul>\n<li>\n<p><strong>线性表</strong><br>\n线性表有两种存储方式：顺序存储和链式存储。采用顺序存储结构的线性表叫<strong>顺序表</strong>（利用数组实现），采用链式存储结构的线性表叫<strong>链表</strong>。链表又分为：</p>\n<ul>\n<li><strong>单链表</strong>：只有一个指针域，且指向直接后继节点，最后一个结点的指针域为空。</li>\n<li><strong>循环单链表</strong>：最后一个结点指针域指向头结点或链表的第一个结点。</li>\n<li><strong>双向链表</strong>：有两个指针域，一个指向直接前驱结点，另一个指向直接后继结点，最后一个结点的next指针域为空。</li>\n<li><strong>双向循环链表</strong>：最后一个结点的next指针域指向指向头结点或链表的第一个结点，而第一个结点的prior指针域指向最后一个结点。</li>\n<li><strong>静态链表</strong>：上边的四种链表结点之间的关系是由指针实现的，结点的分配与释放都是由函数malloc和free动态实现，因此成为动态链表。静态链表可通过定义一个结构体数组来作为结点空间。结构体中用数组的下标作为指针域，类型不再是指针类型，而是一个整型。</li>\n</ul>\n</li>\n<li>\n<p><strong>栈</strong><br>\n栈是一种只允许在线性表一端（栈顶）进行插入和删除操作的特殊线性表。同样也有两种存储方式：顺序存储（<strong>顺序栈</strong>）和链式存储（<strong>链栈</strong>）。<br>\n栈的特点：后进先出。<br>\n栈的操作：</p>\n<ul>\n<li>InitStack(&amp;S):初始化一个空栈S。</li>\n<li>StackEmpty(S):判断栈是否为空，为空返回1，不为空返回0。</li>\n<li>GetTop(S,&amp;e):返回栈S的栈顶元素给e。</li>\n<li>PushStack(&amp;S,e):栈S插入元素e。</li>\n<li>PopStack(&amp;S,&amp;e):删除栈S的顶端元素，并用e返回值。</li>\n<li>StackLength(S):返回栈S的元素个数。</li>\n<li>CleanStack(S):清空栈s。</li>\n</ul>\n</li>\n<li>\n<p><strong>队列</strong><br>\n队列是一种只允许在线性表的一端进行插入操作（队尾）另一端进行删除操作（对头）的特殊线性表。同样也有两种存储方式：顺序存储（<strong>顺序队列</strong>）和链式存储（<strong>链式队列</strong>）。还有一种特殊的队列叫<strong>双端队列</strong>，可以在队的任意一端进行插入和删除。</p>\n<p>两个问题：</p>\n<ul>\n<li>\n<p><strong>顺序队列的“假溢出”问题</strong>：队头有空间，队尾指针却达到了数组的末尾，继续插入数据将越出数组的下届造成“溢出”，像这种有存储空间而不能进行继续插入元素操作的溢出称为“假溢出”。</p>\n<p>避免假溢出：实现顺序循环队列。当队尾指针rear达到最大值QueueSize-1时，如果要插入新的元素，就把队尾指针rear自动变为0；当对头指针front达到最大值QueueSize-1时，如果要删除一个元素，就要让队头指针front自动变成0。</p>\n</li>\n<li>\n<p><strong>顺序循环队列的队空队满状态相同问题</strong>：顺序循环队列在队空状态和队满状态时，队头指针front和队尾指针rear同时都指向同一个位置，即front==rear。为了区分队空队满两种情况，解决方法有两个：</p>\n<ul>\n<li>\n<p>设置标志位<br>\n假设标志位为flag，初始时flag=0，当入队列成功flag=1，出队列陈功flag=0。队列为空的判断条件为<code>front==rear&amp;&amp;flag==0</code>，队列满的判断条件为<code>front==rear&amp;&amp;flag==1</code>。</p>\n</li>\n<li>\n<p>少用一个存储单元<br>\n队空的判断条件<code>front==rear</code>，队满的判断条件是<code>front==(rear+1)%QueueSize</code>。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>串</strong>：<br>\n串是仅有字符组成的一种特殊的线性表，由零个或多个字符组成的有限序列。理解几个概念：空串、空格串、子串、主串、串长。同样也有两种存储方式：顺序存储（<strong>顺序串</strong>、<strong>堆串</strong>）和链式存储（<strong>链串</strong>）。</p>\n<p>在顺序存储中顺序串是静态分配的，串的连接、插入、替换等操作由于需要事先分配存储空间，可能会由于内存空间不足而出现串的一部分字符被截掉，可采用动态分配存储单元解决。堆串的存储空间是在程序的执行过程中动态分配的，C语言中由函数malloc和free管理堆的存储空间，在内存单元使用完毕后记着释放内存空间。</p>\n<p>链串的存储结构同样也要有一个数值域和指针域，数值域作为一个结点可以存放一个字符也可以存放多个字符，最后一个子串的数值域未填满时可用“#”填充，串长不一定是结点的整数倍。<br>\n相比串的链式存储，串的顺序存储在各种操作中实现更方便，空间利用率更高，所以顺序存储比链式存储更常用。</p>\n<p><strong>串的模式匹配</strong><br>\n串的模式匹配也称为子串的定位操作，即查找子串在主串中出现的位置。设有主串S和子串T，如果在主串S中找到与子串T相同的子串，则返回串T的第一个字符在主串S中的位置，否则返回-1。有以下两种匹配方法：</p>\n<ul>\n<li>经典的模式匹配算法（即<strong>Brute-Force算法</strong>）<br>\n思想：从主串S的第pos个字符开始与子串T的第一个字符进行比较，如果相同则继续比较后续的字符，如果不同则从主串S的pos点的下一个字符重新与串T的第一个字符进行比较。<br>\nBrute-Force算法在每次出现主串与模式串的字符不相等时，主串的指针均需要回退。</li>\n<li>串的改进算法（即<strong>KMP算法</strong>）<br>\nKMP算法的核心是求模式串中P0、P0P1、P0P1P2、P0…Pi的<strong>最大的相同前后缀的长度</strong>形成的匹配表，然后根据公式:<code>移动位数 = 已匹配的字符数 - 对应的部分匹配值</code>计算出移动位数，直到完全匹配成功（已匹配字符数与模式串的串长相等）。<br>\nKMP算法根据模式串的next函数值消除主串与模式串的字符不匹配时主串指针的回退，有效提高了模式匹配的效率。<br>\n参考：\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html\">http://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html</a></li>\n<li><a href=\"https://www.cnblogs.com/c-cloud/p/3224788.html\">https://www.cnblogs.com/c-cloud/p/3224788.html</a></li>\n<li><a href=\"https://www.zhihu.com/question/21923021\">https://www.zhihu.com/question/21923021</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>数组</strong>：<br>\n数组是由n个类型相同的数据元素组成的有限序列。其中，这n个数据元素占用一块地址连续的存储空间。数组中的数据元素可以是原子类型，如整形、字符型、浮点型等，这种类型的数组称为一维数组；数据元素也可以是线性表，这种类型的数组成为二维数组。<br>\n数组采用的是顺序存储方式。如果要将一个多维的数组存放在一个一维的存储单元里，必须先将多维的数组转换成一个一维的线性序列。存储方式有两种:以行序为主的存储方式和以列序为主的存储方式。<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/6E31E0D5EBED4712B1A29BBDC7AB722C?method=download&amp;shareKey=b094199284344b818aacb2c9fcc6a90c\" alt=\"\"></p>\n<p>如果数组中大多数元素值相同或值为零且这些元素存在一定的规律，则成为特殊矩阵。如果矩阵中的元素有许多都是零且不具有规律性，则称为稀疏矩阵。为了节省空间可将这类矩阵进行压缩处理。</p>\n<p><strong>特殊矩阵</strong></p>\n<ul>\n<li>对称矩阵的压缩存储</li>\n<li>三角矩阵的压缩存储</li>\n<li>对角矩阵的压缩存储</li>\n</ul>\n<p><strong>稀疏矩阵</strong></p>\n</li>\n<li>\n<p><strong>广义表</strong>：</p>\n</li>\n</ul>\n<h4 id=\"非线性结构\">非线性结构<a title=\"#非线性结构\" href=\"#非线性结构\"></a></h4>\n<p>相对于线性结构，非线性结构就是每个结点可以有不止一个直接前驱和直接后继。</p>\n<ul>\n<li><strong>树</strong>：</li>\n<li><strong>图</strong>：</li>\n</ul>\n<h3 id=\"物理结构\">物理结构<a title=\"#物理结构\" href=\"#物理结构\"></a></h3>\n<p>物理结构又撑为存储结构，是指数据的逻辑结构在计算机中的存储形式，能够正确反应数据元素之间的逻辑关系。物理结构可分为顺序存储结构、链式存储结构、索引存储结构和散列存储结构。</p>\n<h4 id=\"顺序存储结构\">顺序存储结构<a title=\"#顺序存储结构\" href=\"#顺序存储结构\"></a></h4>\n<p>顺序存储结构是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。</p>\n<p>优点：存储密度大，存储空间利用率高。<br>\n缺点：插入或删除元素时不方便。这里的不方便主要是在数据元素的之间做插入和删除操作造成操作点后边的元素要进行移位。<br>\n功能：顺序表适宜于做查找这样的静态操作。若线性表的长度变化不大，且其主要操作是查找，则采用顺序表。</p>\n<h4 id=\"链式存储结构\">链式存储结构<a title=\"#链式存储结构\" href=\"#链式存储结构\"></a></h4>\n<p>链式存储是把数据元素放在任意的存储单元中，可以是顺序的也可以是无序的，数据元素的存储关系不能反应其逻辑关系，因此需要一个指针存放数据的地址，进而找到相关联数据元素的位置。</p>\n<p>优点：插入或删除元素时很方便，使用灵活。<br>\n缺点：存储密度小，存储空间利用率低。<br>\n功能：链表宜于做插入、删除这样的动态操作。若线性表的长度变化较大，且其主要操作是插入、删除操作，则采用链表。</p>\n<h4 id=\"索引存储结构\">索引存储结构<a title=\"#索引存储结构\" href=\"#索引存储结构\"></a></h4>\n<p>除了建立存储节点外，还要另外建立一个索引表来指示这些节点的地址。</p>\n<p>优点：检索速度快。<br>\n缺点：增加了附加的索引表,会占用较多的存储空间</p>\n<h4 id=\"散列存储结构\">散列存储结构<a title=\"#散列存储结构\" href=\"#散列存储结构\"></a></h4>\n<p>散列存储，又称hash存储，是一种力图将数据元素的存储位置与关键码之间建立确定对应关系进行查找和存储。数据元素由某种算法（一般是先得到hash码，然后与当前数组长度取模）得到一个固定且比数据元素长度更短的散列码作为数组中的下标，然后进行直接查询。</p>\n<p>优点：综合了顺序存储和链式存储的优点，根据散列码快速定位存储位置，查询速度快。</p>\n<p>解决冲突几种方式：</p>\n<ul>\n<li>\n<p><strong>开放定址法</strong><br>\n开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。常用的有以下三种方式：</p>\n<ul>\n<li>\n<p>线性探测再散列<br>\n公式：<code>fi(key) = (f(key)+di) MOD m (di=1,2,3,......,m-1)</code></p>\n</li>\n<li>\n<p>二次(平方)探测再散列<br>\n公式：<code>fi(key) = (f(key)+di) MOD m (di = 1^2, -1^2, 2^2, -2^2,......,q^2, -q^2, q &lt;= m/2)</code></p>\n</li>\n<li>\n<p>伪随机探测再散列<br>\n公式：<code>fi(key) = (f(key)+di) MOD m (di是一个随机数列)</code></p>\n</li>\n</ul>\n<p>上边的<code>key</code>指的是将要查询或存储的元素，<code>f(key)</code>指冲突的散列值，<code>di</code>指为了得到新散列值的位移量，<code>m</code>数组的长度，<code>fi(key)</code>指新散列值。<br>\n参阅：<a href=\"http://www.nowamagic.net/academy/detail/3008050\">http://www.nowamagic.net/academy/detail/3008050</a></p>\n</li>\n<li>\n<p><strong>再哈希法</strong><br>\n再哈希法就是在冲突发生时，利用另外一个散列函数再次求出散列函数的地址，直到冲突不再发生为止。即<code>fi(key) = rehash(key), i=1,2,3......</code>,其中<code>rehash</code>表示不同的散列函数。这种方法不易再次发生冲突，但是需要事先构造多个散列函数，而且增加了计算时间。</p>\n</li>\n<li>\n<p><strong>链地址法</strong>(拉链法，hashmap原理)<br>\n链地址法就是在符号表的每一个记录中增加一个链域，链域中存放下一个具有相同哈希函数值记录（第一个数据元素）的存储地址，利用链域把若干个发生冲突的记录链接在一个链表内。当链域的值为null时表示没有后继记录了（此处没有存数据元素）。所以此种方法对于发生冲突时的查找和插入操作跟线性表一样了。<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/7BE39F9960E646D18A77579075506A29?method=download&amp;shareKey=3a68df98cd4222c508e64484eb22c129\" alt=\"\"></p>\n</li>\n<li>\n<p><strong>建立一个公共溢出区</strong><br>\n将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表.查找时先与基本表相应位置的元素进行对比，如果相同则查找成功，不相同则到溢出表中进行顺序查找。冲突少的情况下这种方式还是很高效的。</p>\n</li>\n</ul>\n<h2 id=\"数据结构的常用技术\">数据结构的常用技术<a title=\"#数据结构的常用技术\" href=\"#数据结构的常用技术\"></a></h2>\n<p>上边是针对数据结构的逻辑关系和物理存储的解析，这些也是为了更好的程序的创建和高效查询。数据结构的常用技术有两种形式：查找和排序。</p>\n<h3 id=\"查找\">查找<a title=\"#查找\" href=\"#查找\"></a></h3>\n<h3 id=\"排序\">排序<a title=\"#排序\" href=\"#排序\"></a></h3>\n","prev":{"title":"音视频开发相关基础概念","link":"post/1516183776"},"next":{"title":"Android开发BroadcastReceiver详解","link":"post/1505308407"},"plink":"https://blog.ixin.run/post/1515751776/","toc":[{"id":"什么是数据结构","title":"什么是数据结构","index":"1"},{"id":"数据结构的分类","title":"数据结构的分类","index":"2","children":[{"id":"逻辑结构","title":"逻辑结构","index":"2.1"},{"id":"物理结构","title":"物理结构","index":"2.2"}]},{"id":"数据结构的常用技术","title":"数据结构的常用技术","index":"3","children":[{"id":"查找","title":"查找","index":"3.1"},{"id":"排序","title":"排序","index":"3.2"}]}],"reward":true,"copyright":{"custom":"转载请注明出处，谢谢支持。"}}