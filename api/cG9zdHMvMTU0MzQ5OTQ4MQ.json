{"title":"Android开发Gradle配置总结","date":"2018-11-29T13:51:21.000Z","date_formatted":{"ll":"2018年11月29日","L":"2018/11/29","MM-DD":"11-29"},"link":"posts/1543499481","comments":true,"tags":["Gradle"],"categories":["Android"],"updated":"2021-01-29T12:51:44.626Z","content":"<p>前段时间总结了一篇<a href=\"https://blog.ixin.run/posts/1543411658/\" target=\"_blank\">Gradle之Groovy语言</a>，也是站在巨人的肩膀上的一个记录。早在Gradle之前有ant和maven打包构建工具。ant是一个古老的打包构建工具，功能性单一；maven比较有名的是maven仓库，用于依赖和管理项目中所用的jar库，简单便捷，但Maven编译规则是用XML来编写的，不利于程序的扩展性编程。至于为什么又来了一个gradle，相比已经知道答案了，这家伙就是一个加强版AK47，取众家之所长，简直就是编译打包的一个利器，目前AS默认的编译打包工具就是他。今天就简单谈谈AS上gradle的认识和配置，做一个总结。</p>\n<a id=\"more\"></a>\n<h2 id=\"android项目中gradle位置\">Android项目中Gradle位置<a title=\"#android项目中gradle位置\" href=\"#android项目中gradle位置\"></a></h2>\n<p>Android项目中Gradle位置有三个地方，每个地方的功能又不一样，这三个位置分别是：</p>\n<ul>\n<li>/settings.gradle</li>\n<li>/build.gradle</li>\n<li>/app/build.gradle</li>\n</ul>\n<p>以上的三个属于构建的知识点，还有一个针对gradle版本和gradle插件版本的设置，详情可查看之前写过的一篇<a href=\"https://blog.ixin.run/posts/1525500354/\" target=\"_blank\">AndroidStudio项目导入的那些事</a>。</p>\n<h2 id=\"项目根目录的settings.gradle\">项目根目录的settings.gradle<a title=\"#项目根目录的settings.gradle\" href=\"#项目根目录的settings.gradle\"></a></h2>\n<p>/settings.gradle 主要功能引入工程模块分支，在这里声明过后，代表属于项目的一部分了，接下来才可以做其他事，例如主模块依赖其他子模块，这里要搞清楚。</p>\n<p>新建工程默认只有一行代码，即：<code>include ':app'</code>，因为新建项目中只有一个主模块“app”，如果后边我们新创建模块，则可以接着在后边追加：<code>include ':app','myLibrary'</code>。</p>\n<p>这里也有一些高级用法，有些时候我们喜欢用“project”模式预览工程，特别想把某些module放在一个文件夹下，这样便于管理，我们可以这样操作：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include <span class=\"string\">&#x27;myLibrary0&#x27;</span></span><br><span class=\"line\">project (<span class=\"string\">&#x27;:myLibrary0&#x27;</span>).projectDir = <span class=\"keyword\">new</span> File(<span class=\"string\">&#x27;librarys/myLibrary1&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>第一行的include和上边是一样的用于引入模块，“myLibrary0”是myLibrary1别名，myLibrary1在项目根目录新建文件夹libarays下，这样说应该清楚了，后边同属性的其他模块也可以采用别名的形式放在librarys下（根据自己项目所需），后边如果主模块app需要依赖这些模块可直接依赖别名。</p>\n<h2 id=\"项目根目录的build.gradle\">项目根目录的build.gradle<a title=\"#项目根目录的build.gradle\" href=\"#项目根目录的build.gradle\"></a></h2>\n<p>项目根目录下的build.gradle相对内容稍微多些，主要功能是声明一些远程library的仓库，仓库声明了，我们才能依赖此仓库里的lib。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Top-level build file where you can add configuration options common to all sub-projects/modules.</span></span><br><span class=\"line\"></span><br><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        google()</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath <span class=\"string\">&#x27;com.android.tools.build:gradle:3.3.2&#x27;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> Do not place your application dependencies here; they belong</span></span><br><span class=\"line\">        <span class=\"comment\">// in the individual module build.gradle files</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">allprojects &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        google()</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">task clean(<span class=\"attr\">type:</span> Delete) &#123;</span><br><span class=\"line\">    delete rootProject.buildDir</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有四个节点，下面就针对这个几个子节点各个说明一下：</p>\n<ul>\n<li>buildscript.repositories<br>\n这里主要声明gradle脚本自身需要的资源。什么意思？就是我在写gradle脚本时内部可能需要一些类库，好比如Java上的import，主要帮助gradle方法块能够正常执行，不针对项目。</li>\n<li>buildscript.dependencies<br>\n这里主要声明一些项目中所用的插件，例如gradle构建插件版本，我们项目中数据库采用的greendao，也需要在这里声明一下greendao插件的版本：<code>classpath 'org.greenrobot:greendao-gradle-plugin:3.2.0'</code></li>\n<li>allprojects.repositories<br>\n细心的同学可能发现了怎么这里和buildscript.repositories一样，哈哈，好多地方其实针对这两处讲的并不清楚。这里不是和buildscript.repositories一模一样，allprojects.repositories主要声明我们自己整个项目工程的依赖仓库，比如说我们项目工程中会用到google库的相关依赖，例如databanding，我们就要在这里声明google()，再比如我们项目需要依赖我们公司自己的maven库，那么就要在这里声明公司自己的maven仓库地址。最早的时候AS在这两个地方默认只是mavenCentral()，后来换成了jcenter()，因为jcenter()比mavenCentral()更丰富，是当前世界上最大的Java和Android开源软件构件仓库，并且兼容maven，再后来为了丰富依赖库的来源，AS又默认加入了google()。</li>\n<li>task clean<br>\ntask clean声明了一个任务，任务名叫clean（也可以改为其它），任务类型是Delete，可以用gradle命令执行，就会删除rootProject.buildDir下的文件。想要知道当前项目有多少个task可以在Terminal中执行：  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.&#x2F;gradlew tasks（Mac、Linux）</span><br><span class=\"line\"></span><br><span class=\"line\">gradlew tasks（Windows）</span><br></pre></td></tr></table></figure>\ntask更高级用法可以编写AS插件，AS菜单栏上Build-&gt;Clean Project就是一条task任务，这个可自行学习。</li>\n</ul>\n<h2 id=\"模块下的build.gradle\">模块下的build.gradle<a title=\"#模块下的build.gradle\" href=\"#模块下的build.gradle\"></a></h2>\n<p>模块下的build.gradle是针对当前模块的相关编译设置，例如release和debug模式下混淆声明、abiFilters兼容，以及模块下需要第三方工具依赖声明等设置。另外工程主模块和子模块的模块声明形式也不一样，工程主模块（app）的声明是<code>apply plugin: 'com.android.application'</code>，工程子模块（library）的声明是<code>apply plugin: 'com.android.library'</code>，根绝这两个声明应该也可以想到二者的区别了。以下是工程主模块默认的相关构建设置：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;com.android.application&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    compileSdkVersion <span class=\"number\">28</span></span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        applicationId <span class=\"string\">&quot;com.ixinrun.myapplication&quot;</span></span><br><span class=\"line\">        minSdkVersion <span class=\"number\">15</span></span><br><span class=\"line\">        targetSdkVersion <span class=\"number\">28</span></span><br><span class=\"line\">        versionCode <span class=\"number\">1</span></span><br><span class=\"line\">        versionName <span class=\"string\">&quot;1.0&quot;</span></span><br><span class=\"line\">        testInstrumentationRunner <span class=\"string\">&quot;android.support.test.runner.AndroidJUnitRunner&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buildTypes &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            minifyEnabled <span class=\"literal\">false</span></span><br><span class=\"line\">            proguardFiles getDefaultProguardFile(<span class=\"string\">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class=\"string\">&#x27;proguard-rules.pro&#x27;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(<span class=\"attr\">dir:</span> <span class=\"string\">&#x27;libs&#x27;</span>, <span class=\"attr\">include:</span> [<span class=\"string\">&#x27;*.jar&#x27;</span>])</span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.android.support:appcompat-v7:28.0.0&#x27;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.android.support.constraint:constraint-layout:1.1.3&#x27;</span></span><br><span class=\"line\">    testImplementation <span class=\"string\">&#x27;junit:junit:4.12&#x27;</span></span><br><span class=\"line\">    androidTestImplementation <span class=\"string\">&#x27;com.android.support.test:runner:1.0.2&#x27;</span></span><br><span class=\"line\">    androidTestImplementation <span class=\"string\">&#x27;com.android.support.test.espresso:espresso-core:3.0.2&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>android节点下主要是声明当前模块下的版本设定（如果是主模块即指当前app的版本了），构建插件版本设定，以及构建类型设置（release，debug，自定义），还有风味多渠道打包设置等。</p>\n<h3 id=\"defaultconfig\">defaultConfig<a title=\"#defaultconfig\" href=\"#defaultconfig\"></a></h3>\n<p>针对android节点下的compileSdkVersion、buildToolsVersion，以及子节点defaultConfig下的minSdkVersion、targetSdkVersion等相关设置可参见我之前的文章《<a href=\"https://blog.ixin.run/posts/1525500354/\" target=\"_blank\">AndroidStudio项目导入的那些事</a>》，里面有详细说明，这里就不多说了。</p>\n<p>典型的65536问题。android可执行文件“.dex”中的Java方法数引用超过65536就会报<code>com.android.dex.DexIndexOverflowException:method IDnotin[0,0xffff]:65536</code>的错误，相信不少同学已经踩过这个坑了。我们可以在defaultConfig里添加<code>multiDexEnabled true</code>，然后Application继承自MultiDexApplication，在dependencies依赖<code>implementation 'com.android.support:multidex:1.0.3'</code>即可。</p>\n<p>某种情况下我们的app只能限定在abi为armeabi或armeabi-v7的CPU架构模式下，例如公司的内部应用，因为对接很多三方厂商的东西，为此需要更加低廉的限制来降低风险。我们也可以在defaultConfig里进行限制：<code>ndk &#123; abiFilters 'armeabi' &#125;</code>。当然，这里是全局的设定，我们也可以对我们的release、debug包单独区分限制，这个后边的“buildTypes”里的设置会讲到。</p>\n<p>我们也可以对AndroidManifest部分参数在defaultConfig进行替换，为了更好的方便管理，或者动态改变，毕竟gradle可以写脚本嘛，例如我们想把我们AndroidManifest里的appname在gradle里限制，把极光推送的众多的applicationId和appkey也在gradle里限定，可以在defaultConfig（也可以对release、debug包单独处理，和上边一样）这样处理：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">manifestPlaceholders = [</span><br><span class=\"line\">                <span class=\"attr\">app_name     :</span> <span class=\"string\">&quot;@string/app_name&quot;</span>,</span><br><span class=\"line\">                <span class=\"comment\">//极光推送部分</span></span><br><span class=\"line\">                <span class=\"symbol\">JPUSH_PKGNAME:</span> applicationId,  </span><br><span class=\"line\">                <span class=\"attr\">JPUSH_APPKEY :</span> <span class=\"string\">&quot;xxxxxxxxxxxxxxxxxxxxx&quot;</span></span><br><span class=\"line\">        ]</span><br></pre></td></tr></table></figure>\n<p>然后在AndroidManifest做相应的映射：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">android:</span>label=<span class=\"string\">&quot;$&#123;app_name&#125;&quot;</span></span><br><span class=\"line\">...</span><br><span class=\"line\"> &lt;receiver</span><br><span class=\"line\">            <span class=\"symbol\">android:</span>name=<span class=\"string\">&quot;.modules.common.push.MyJPushMessageReceiver&quot;</span></span><br><span class=\"line\">            <span class=\"symbol\">android:</span>enabled=<span class=\"string\">&quot;true&quot;</span></span><br><span class=\"line\">            <span class=\"symbol\">android:</span>exported=<span class=\"string\">&quot;false&quot;</span>&gt;</span><br><span class=\"line\">            &lt;intent-filter&gt;</span><br><span class=\"line\">                &lt;action <span class=\"attr\">android:</span>name=<span class=\"string\">&quot;cn.jpush.android.intent.RECEIVE_MESSAGE&quot;</span> /&gt;</span><br><span class=\"line\">                &lt;category <span class=\"attr\">android:</span>name=<span class=\"string\">&quot;$&#123;JPUSH_PKGNAME&#125;&quot;</span> /&gt;</span><br><span class=\"line\">            &lt;/intent-filter&gt;</span><br><span class=\"line\"> &lt;/receiver&gt;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h3 id=\"buildtypes\">buildTypes<a title=\"#buildtypes\" href=\"#buildtypes\"></a></h3>\n<p>这里主要设置编译类型，我们知道一般打包有两种：release和debug。release主要是指我们的线上正式包，而debug就是我们测试环境下的包了。因此release和debug这里基本设置都是相同，只是参数不一样，例如release模式下我们需要混淆，避免我们的源码泄露，提高安全性；debug模式下为了更好将日志输出和调试，我们需要关闭混淆和开启运行时调试。</p>\n<ul>\n<li>debuggable true  //开启运行时调试</li>\n<li>zipAlignEnabled true  //Zipalign 优化</li>\n<li>minifyEnabled true  //开启删除无用代码，配合proguardFiles开启混淆</li>\n<li>shrinkResources true //在编译过程中用来检测并删除无用资源文件，需要配合minifyEnabled二者都为true才生效。</li>\n<li>proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘<a href=\"http://proguard-rules.pro\">proguard-rules.pro</a>’ //定义混淆文件，“proguard-android.txt”是Android默认的，我们不用管，项目中的“<a href=\"http://proguard-rules.pro\">proguard-rules.pro</a>”是我们主要自定义设置的。</li>\n<li>signingConfig signingConfigs.releaseConfig //签名设置，可以为release和debug设置不同的签名，其中的“signingConfigs.releaseConfig”是我们在gradle中设置的签名闭包，形式如下：  <figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//打包签名配置</span></span><br><span class=\"line\">signingConfigs&#123;</span><br><span class=\"line\">    releaseConfig&#123;</span><br><span class=\"line\">        storeFile file(KEY_PATH)</span><br><span class=\"line\">        storePassword KEY_PASS</span><br><span class=\"line\">        keyAlias ALIAS_NAME</span><br><span class=\"line\">        keyPassword ALIAS_PASS</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    debugConfig&#123;</span><br><span class=\"line\">        storeFile file(KEY_PATH)</span><br><span class=\"line\">        storePassword KEY_PASS</span><br><span class=\"line\">        keyAlias ALIAS_NAME</span><br><span class=\"line\">        keyPassword ALIAS_PASS</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>以上我们常用的设置，也可以在release和debug模式下设置项目的接口host地址，便于请求区分线上数据和测试数据来源，还可以加上我们的编译打包时间：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设置在release或debug模式下</span></span><br><span class=\"line\">buildConfigField(<span class=\"string\">&quot;String&quot;</span>, <span class=\"string\">&quot;BUILD_TIME&quot;</span>, getDate())</span><br><span class=\"line\">buildConfigField(<span class=\"string\">&quot;String&quot;</span>, <span class=\"string\">&quot;BASE_URL&quot;</span>, <span class=\"string\">&quot;\\&quot;http://www.baidu.com/\\&quot;&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">....</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取当前时间，gradle中的一个闭包方法体，需要设置在android闭包外。</span></span><br><span class=\"line\">String getDate() &#123;</span><br><span class=\"line\">    Date date = <span class=\"keyword\">new</span> Date()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;\\&quot;&quot;</span> + date.format(<span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>) + <span class=\"string\">&quot;\\&quot;&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上边仅仅说了release和debug模式，假如接口方说了这段时间demo环境暂时被占用，而线上的环境我们也不能拿来直接测，怎么办呢？此时接口方又说你可以用我的调试环境，后边都可以一直用，和demo环境一样，只是地址不一样。这是一个突破口，此时我们可以再建一个类型“dev”，我们直接copy于debug类型即可：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dev &#123;</span><br><span class=\"line\">    initWith(debug)</span><br><span class=\"line\">    matchingFallbacks = [<span class=\"string\">&#x27;dev&#x27;</span>, <span class=\"string\">&#x27;debug&#x27;</span>, <span class=\"string\">&#x27;release&#x27;</span>]</span><br><span class=\"line\">    buildConfigField(<span class=\"string\">&quot;String&quot;</span>, <span class=\"string\">&quot;BASE_URL&quot;</span>, <span class=\"string\">&quot;\\&quot;http://www.baidu0.com/\\&quot;&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中initWith(debug)意思就是和debug设置一样，然后下边buildConfigField再对参数覆盖重写。这里说一下matchingFallbacks，我们的工程不可能只有app主模块，肯定还有其他library等子模块，当我们采用dev构建类型编译打包的时候，我们的library也会融入到我们的打包环境中，都是一对一对应的，假如我们library下的gradle中没有dev类型，那么按照matchingFallbacks匹配规则会利用下一级&quot;debug&quot;形式规则打包。如果没有matchingFallbacks匹配规则，则会直接找不到dev类型，从而报错。</p>\n<h3 id=\"productflavors\">productFlavors<a title=\"#productflavors\" href=\"#productflavors\"></a></h3>\n<p>productFlavors是指风味设置，大白话就是我们的多渠道打包。早在gradle2.0时代是不需要加入flavorDimensions风味维度的，gradle3.0加入是为了更加细致区分打包渠道，更直观的说2.0时代只是注重某个品牌下的包，3.0时代又可以区分哪个品牌哪种机型下的包，例如专供小米品牌下小米9提供的包，甚至我们还可以设置针对某个系统版本打包的维度。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flavorDimensions <span class=\"string\">&quot;company&quot;</span>,<span class=\"string\">&quot;channel&quot;</span></span><br><span class=\"line\">productFlavors&#123;</span><br><span class=\"line\">    companyA&#123;</span><br><span class=\"line\">        dimension <span class=\"string\">&quot;company&quot;</span></span><br><span class=\"line\">        buildConfigField <span class=\"string\">&quot;String&quot;</span>,<span class=\"string\">&quot;FLAVOR_NAME&quot;</span>,<span class=\"string\">&quot;\\&quot;companyA\\&quot;&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    companyB&#123;</span><br><span class=\"line\">        dimension <span class=\"string\">&quot;company&quot;</span></span><br><span class=\"line\">        buildConfigField <span class=\"string\">&quot;String&quot;</span>,<span class=\"string\">&quot;FLAVOR_NAME&quot;</span>,<span class=\"string\">&quot;\\&quot;companyB\\&quot;&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    channelA&#123;</span><br><span class=\"line\">        dimension <span class=\"string\">&quot;channel&quot;</span></span><br><span class=\"line\">        buildConfigField <span class=\"string\">&quot;String&quot;</span>,<span class=\"string\">&quot;FLAVOR_NAME&quot;</span>,<span class=\"string\">&quot;\\&quot;channelA\\&quot;&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    channelB&#123;</span><br><span class=\"line\">        dimension <span class=\"string\">&quot;channel&quot;</span></span><br><span class=\"line\">        buildConfigField <span class=\"string\">&quot;String&quot;</span>,<span class=\"string\">&quot;FLAVOR_NAME&quot;</span>,<span class=\"string\">&quot;\\&quot;channelB\\&quot;&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"dependencies\">dependencies<a title=\"#dependencies\" href=\"#dependencies\"></a></h3>\n<p>dependencies闭包里都是项目相关的依赖库，其实没啥说的。这里主要说一下gradle3.0后官方推荐用implementation和api的设置。早在gradle3.4之前我们依赖库所用的方式是compile，使用起来很简单，但是有一个不安全因素，比如我们依赖library，我们同时也可以看到library所依赖的第三方库的方法，本来我只需要看到这个library的几个方法既可，但是现在却让我看到很多没有用的方法，开发过程中针对新人很容易加重编写耦合。而后来的implementation和api的设置可以很好的处理这个弊端，也给我们的组件化过程锦上添花。</p>\n<p>那么implementation和api有什么区别呢？这两个是一个封闭一个开放，前者封闭，后者开放，后者的作用其实和compile完全一样的。假如现有模块app、library1、library2，其中app依赖library1，library1依赖library2，有以下两种区别:</p>\n<ol>\n<li>library1和library2依赖关系是implementation，则app不能看到和使用library2中的方法。</li>\n<li>library1和library2依赖关系是api，则app可以使用library2中的公开方法。</li>\n</ol>\n<p>implementation和api在项目开发需要根据具体情况灵活运用。</p>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<ul>\n<li><a href=\"https://docs.gradle.org/4.4/dsl/\" target=\"_blank\">Gradle DSL 学习</a></li>\n<li><a href=\"https://google.github.io/android-gradle-dsl/3.1/\" target=\"_blank\">Android Plugin DSL 学习</a></li>\n<li><a href=\"https://avatarqing.github.io/Gradle-Plugin-User-Guide-Chinese-Verision/basic_project/android_tasks.html\" target=\"_blank\">Gradle task 学习</a></li>\n<li><a href=\"https://blog.csdn.net/innost/article/details/48228651\" target=\"_blank\">深入理解Android之Gradle</a></li>\n<li><a href=\"https://juejin.im/post/5af4f117f265da0b9f405221#heading-3\">https://juejin.im/post/5af4f117f265da0b9f405221#heading-3</a></li>\n</ul>\n","prev":{"title":"Android开发之SQLite使用详解","link":"posts/1551971490"},"next":{"title":"Android开发之Touch事件的分发和消费机制","link":"posts/1543414682"},"plink":"https://blog.ixin.run/posts/1543499481/","toc":[{"id":"android项目中gradle位置","title":"Android项目中Gradle位置","index":"1"},{"id":"项目根目录的settings.gradle","title":"项目根目录的settings.gradle","index":"2"},{"id":"项目根目录的build.gradle","title":"项目根目录的build.gradle","index":"3"},{"id":"模块下的build.gradle","title":"模块下的build.gradle","index":"4","children":[{"id":"defaultconfig","title":"defaultConfig","index":"4.1"},{"id":"buildtypes","title":"buildTypes","index":"4.2"},{"id":"productflavors","title":"productFlavors","index":"4.3"},{"id":"dependencies","title":"dependencies","index":"4.4"}]},{"id":"参考","title":"参考","index":"5"}],"reward":true,"copyright":{"author":"i猩人","link":"<a href=\"https://blog.ixin.run/posts/1543499481/\" title=\"Android开发Gradle配置总结\">https://blog.ixin.run/posts/1543499481/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}