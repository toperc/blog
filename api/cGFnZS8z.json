{"per_page":10,"total":9,"current":3,"data":[{"title":"LRU算法基本思路","date":"2019-10-21T12:54:17.000Z","date_formatted":{"ll":"2019年10月21日","L":"2019/10/21","MM-DD":"10-21"},"excerpt":"<p>LRU（Least Recently Used），即最近最少使用淘汰法，它是按照一个非常注明的计算机操作系统基础理论得来的：<strong>最近使用的页面数据会在未来一段时期内仍然被使用,已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用</strong>。</p>\n<p>本文就带着大家徒手撸一个最基本的LRU算法。</p>","link":"posts/1571663304","tags":["算法"],"categories":["数据结构和算法"]},{"title":"Android媒体库你了解多少","date":"2019-10-19T14:15:26.000Z","date_formatted":{"ll":"2019年10月19日","L":"2019/10/19","MM-DD":"10-19"},"excerpt":"<p>Android系统中有一个媒体库，这个大家应该有所了解，平时在开发过程中如果不涉及媒体文件（图片、音频、视频）这块则很少接触到。有些时候我们在本地添加一张图片，但是在相册中却无法搜索到，这里主要原因就是没有通知系统媒体库刷新导致的。本篇我们就探讨下Android上媒体库的这些事。</p>\n<p>为什么通知媒体库后，媒体库里就能找到了呢？兴许你还会遇到一种情况，就是明明相册里可以发现这张图片，可是到图片的具体路径下却找不到这张图片。到此应该会猜测到是不是媒体库和本地相册都持有一份媒体文件信息呢？基本上猜到了八九不离十了，其实媒体库就是一个数据库，专门管理媒体文件的相关信息，例如图片信息，缩略图等。</p>","link":"posts/1571496871","tags":["媒体库"],"categories":["Android"]},{"title":"Java垃圾回收（三）GC算法","date":"2019-09-22T09:07:50.000Z","date_formatted":{"ll":"2019年9月22日","L":"2019/09/22","MM-DD":"09-22"},"excerpt":"<p>在前面的一篇已经讲过GC的过程了，本篇我们就讲一讲在GC过程中所伴随的一些回收算法，Java中标记垃圾的算法主要有两种，引用计数法和可达性分析算法，其中引用计数法由于某些缺陷而不被java所采用的，现阶段所用的各种回收算法都是在可达性分析算法基础上延伸出来的。</p>","link":"posts/1569143270","tags":["JVM","垃圾回收"],"categories":["Java"]},{"title":"Java垃圾回收（二）GC过程","date":"2019-09-22T08:07:50.000Z","date_formatted":{"ll":"2019年9月22日","L":"2019/09/22","MM-DD":"09-22"},"excerpt":"<p>什么样的对象才是垃圾？对于Java对象来讲，如果说这个对象没有被其他对象所引用该对象就是无用的，此对象就被称为垃圾，其占用的内存也就要被销毁。本篇我们就讲一讲GC（Garbage Collection）的具体过程。</p>","link":"posts/1569139670","tags":["JVM","垃圾回收"],"categories":["Java"]},{"title":"Java垃圾回收（一）四种对象引用类型","date":"2019-09-22T07:07:50.000Z","date_formatted":{"ll":"2019年9月22日","L":"2019/09/22","MM-DD":"09-22"},"excerpt":"<p>垃圾收集GC（Garbage Collection）是Java语言的核心技术之一， 在Java中，程序员不需要去关心内存动态分配和垃圾回收的问题，这一切都交给了JVM来处理。本篇我们先弄清楚在开发过程中如何使用对象引用来实现合适时机的垃圾回收，下篇再由浅入深谈谈jvm底层是如何垃圾回收的。</p>\n<p>在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用(Strong Reference)，软引用(Soft Reference)，弱引用(Weak Reference)，虚引用(Phantom Reference)四种，这四种引用强度依赖逐渐减弱。理解这四种对象引用方式也是对java垃圾回收机制的基本认识。</p>","link":"posts/1569136070","tags":["JVM","垃圾回收"],"categories":["Java"]},{"title":"JVM（一）内存分配","date":"2019-09-20T11:42:46.000Z","date_formatted":{"ll":"2019年9月20日","L":"2019/09/20","MM-DD":"09-20"},"excerpt":"<p>Java内存分配无论是处于正常开发计算过程还是绞尽脑汁思考内存回收都需要深入理解的，本文所属范畴是JVM，不应该先来个类加载和运行机制吗，为什么先研究内存分配呢？老实说因为这块很接近我们的开发，越接近后边的深入越容易理解。在了解JVM内存分配之前我们先简单熟悉一下Java HotSpot VM，因为我们经常挂在嘴边的JVM目前就是这家伙。</p>","link":"posts/1568979766","tags":["JVM","内存分配"],"categories":["Java"]},{"title":"位运算的那些事（三）位掩码","date":"2019-08-28T14:34:40.000Z","date_formatted":{"ll":"2019年8月28日","L":"2019/08/28","MM-DD":"08-28"},"excerpt":"<p>前两篇我重点针对位运算基础以及运算过程详细的进行了讲解说明，相信看过的小伙伴也都很明了了。那么基础有了，也知道运算过程了，那我们常见的战场在哪里呢？这就像排兵布阵一样，只阅读兵法，而没有实践和模拟，只能算纸上谈兵了。本篇就拉开帷幕直面开发中这个最常见的战场——位掩码（BitMask）。</p>","link":"posts/1567003105","tags":["二进制","位运算"],"categories":["计算机基础"]},{"title":"位运算的那些事（二）如何位运算","date":"2019-08-25T14:18:59.000Z","date_formatted":{"ll":"2019年8月25日","L":"2019/08/25","MM-DD":"08-25"},"excerpt":"<p>上一篇为了讲位运算不得已将二进制机器码与真值之间的关系系统的解释了一通，本篇我们就根据这些基础将二进制位运算几个常用的运算符运算规则理一理，相信本文之后你就明白了这一个过程。</p>\n<p>上篇我也提到位运算符主要针对二进制，它主要包括：“与（&amp;）”、“或（|）”、“非（~）”、“异或（^）”，当然还有移位运算（左移、右移，无符号左移），这在开发过程中也是很常见的，下边我就以这两部分来说。</p>","link":"posts/1566743147","tags":["二进制","位运算"],"categories":["计算机基础"]},{"title":"位运算的那些事（一）搞懂机器码","date":"2019-08-25T14:16:59.000Z","date_formatted":{"ll":"2019年8月25日","L":"2019/08/25","MM-DD":"08-25"},"excerpt":"<p>最近在开发过程中查看Android源码，多处看到一些类似<code>result = specSize | MEASURED_STATE_TOO_SMALL;</code>的写法，乍一看很熟悉，实际阅读起来很痛苦，这是我们大学里学过的位运算，单看代码似乎我们不可能一瞬间知道结果是多少，所以千万要和我们常见的<code>result = a || b</code>区分开来。以此为引子我们就了解一下有关位运算的那些事。</p>\n<p>位运算主要针对二进制，它包括了：“与（&amp;）”、“或(|)”、“非（~）”、“异或(^)”。从表面上看似乎有点像逻辑运算符，但逻辑运算符是针对两个关系运算符来进行逻辑运算，而位运算符主要<strong>针对两个二进制数的位</strong>进行逻辑运算。</p>\n<p>理解位运算，必须先了解二进制在计算机中转换过程，这也是本篇所讲的重点内容。这些明白了，针对一些复杂的简单的运算法则也就很清晰了。</p>","link":"posts/1566742995","tags":["二进制","位运算"],"categories":["计算机基础"]},{"title":"Android数据库GreenDao的使用完全解析","date":"2019-07-23T12:20:19.000Z","date_formatted":{"ll":"2019年7月23日","L":"2019/07/23","MM-DD":"07-23"},"excerpt":"<p>最近一直在处理公司项目本地数据库，原来的订单数据都是采用SP加密保存的，但SP仅仅适合数据量小的数据存储，随着功能的扩展发现数据越来越多越来越杂，所以这部分数据全部迁移到本地数据库还是有必要的，之前项目已经采用了Greendao，这块本来也想做个总结，但是greendao知识点比较丰富，后来上网发现别人总结的一篇很全面——<a href=\"https://www.jianshu.com/p/53083f782ea2\" target=\"_blank\">《一篇技术好文之Android数据库 GreenDao的使用完全解析》</a>，这里就做一个转载记录，方便工作过程中查阅调优。<strong>另外特别说明一下Greendao官方已经不再维护了</strong>，替代方案也有很多，例如<code>ObjectBox</code>（与Greendao同一公司）、<code>Realm</code>、<code>Room</code>（Google官方）等。本篇也有额外说明，如果想更好的使用Greendao，请结合另外一篇<a href=\"https://blog.csdn.net/sinat_15877283/article/details/51098477\" target=\"_blank\">《DataBase 数据库整理（greenDao示例）》</a>查看，会起到事半功倍的效果。</p>\n<blockquote>\n<p>本文主要从如下几个方面进行讲解：</p>\n<ol>\n<li>存储的数据库结构</li>\n<li>GreenDao的优缺点</li>\n<li>GreenDao的使用配置</li>\n<li>使用GreenDao实现数据的增删改查</li>\n<li>GreenDao的注解使用</li>\n<li>GreenDao的关系处理</li>\n<li>GreenDao的升级</li>\n<li>GreenDao数据库加密</li>\n<li>项目地址</li>\n<li>总结</li>\n<li>参考博客</li>\n</ol>\n</blockquote>","link":"posts/1563884419","tags":["SQLite","数据持久化"],"categories":["Android"]}]}