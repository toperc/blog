{"per_page":10,"total":9,"current":3,"data":[{"title":"记一次BuildConfig.DEBUG不准确导致的Bug","date":"2019-12-11T15:21:16.000Z","date_formatted":{"ll":"2019年12月11日","L":"2019/12/11","MM-DD":"12-11"},"excerpt":"<p>Android开发过程中通常我们区分debug和release的相关配置都会采用<code>BuildConfig.DEBUG</code>来进行判断，殊不知这个东西弄不好却是一个坑，刚好在最近的开发过程中遇到。</p>","link":"posts/1576077775","categories":["Android"]},{"title":"Android开发混淆的那些事","date":"2019-12-11T14:57:42.000Z","date_formatted":{"ll":"2019年12月11日","L":"2019/12/11","MM-DD":"12-11"},"excerpt":"<p>混淆想必大家都不陌生，android上用的这一套混淆规则和java混淆几乎是一样的。为何需要混淆呢？简单的说，就是将原本正常的项目文件，对其类，方法，字段，重新命名,a,b,c,d,e,f…之类的字母，达到混淆代码的目的，这样反编译出来，结构乱糟糟的，给反编译者制造一些代码阅读的麻烦。</p>","link":"posts/1576076353","tags":["混淆"],"categories":["Android"]},{"title":"Git分支管理最佳实践","date":"2019-11-19T15:31:00.000Z","date_formatted":{"ll":"2019年11月19日","L":"2019/11/19","MM-DD":"11-19"},"excerpt":"<p>Git是什么，这里就不再多说了，本篇就目前主流公司普遍流行的git分支管理方式做一个简单的总结，另外在开发过程中代码规范提交也是很重要的，本文也会做一个说明。</p>","link":"posts/1574177460","tags":["DevOps","Git"],"categories":["DevOps"]},{"title":"LRU算法基本思路","date":"2019-10-21T12:54:17.000Z","date_formatted":{"ll":"2019年10月21日","L":"2019/10/21","MM-DD":"10-21"},"excerpt":"<p>LRU（Least Recently Used），即最近最少使用淘汰法，它是按照一个非常注明的计算机操作系统基础理论得来的：<strong>最近使用的页面数据会在未来一段时期内仍然被使用,已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用</strong>。</p>\n<p>本文就带着大家徒手撸一个最基本的LRU算法。</p>","link":"posts/1571663304","tags":["算法"],"categories":["数据结构和算法"]},{"title":"Android媒体库你了解多少","date":"2019-10-19T14:15:26.000Z","date_formatted":{"ll":"2019年10月19日","L":"2019/10/19","MM-DD":"10-19"},"excerpt":"<p>Android系统中有一个媒体库，这个大家应该有所了解，平时在开发过程中如果不涉及媒体文件（图片、音频、视频）这块则很少接触到。有些时候我们在本地添加一张图片，但是在相册中却无法搜索到，这里主要原因就是没有通知系统媒体库刷新导致的。本篇我们就探讨下Android上媒体库的这些事。</p>\n<p>为什么通知媒体库后，媒体库里就能找到了呢？兴许你还会遇到一种情况，就是明明相册里可以发现这张图片，可是到图片的具体路径下却找不到这张图片。到此应该会猜测到是不是媒体库和本地相册都持有一份媒体文件信息呢？基本上猜到了八九不离十了，其实媒体库就是一个数据库，专门管理媒体文件的相关信息，例如图片信息，缩略图等。</p>","link":"posts/1571496871","tags":["媒体库"],"categories":["Android"]},{"title":"Java垃圾回收（三）GC算法","date":"2019-09-22T09:07:50.000Z","date_formatted":{"ll":"2019年9月22日","L":"2019/09/22","MM-DD":"09-22"},"excerpt":"<p>在前面的一篇已经讲过GC的过程了，本篇我们就讲一讲在GC过程中所伴随的一些回收算法，Java中标记垃圾的算法主要有两种，引用计数法和可达性分析算法，其中引用计数法由于某些缺陷而不被java所采用的，现阶段所用的各种回收算法都是在可达性分析算法基础上延伸出来的。</p>","link":"posts/1569143270","tags":["JVM","垃圾回收"],"categories":["Java"]},{"title":"Java垃圾回收（二）GC过程","date":"2019-09-22T08:07:50.000Z","date_formatted":{"ll":"2019年9月22日","L":"2019/09/22","MM-DD":"09-22"},"excerpt":"<p>什么样的对象才是垃圾？对于Java对象来讲，如果说这个对象没有被其他对象所引用该对象就是无用的，此对象就被称为垃圾，其占用的内存也就要被销毁。本篇我们就讲一讲GC（Garbage Collection）的具体过程。</p>","link":"posts/1569139670","tags":["JVM","垃圾回收"],"categories":["Java"]},{"title":"Java垃圾回收（一）四种对象引用类型","date":"2019-09-22T07:07:50.000Z","date_formatted":{"ll":"2019年9月22日","L":"2019/09/22","MM-DD":"09-22"},"excerpt":"<p>垃圾收集GC（Garbage Collection）是Java语言的核心技术之一， 在Java中，程序员不需要去关心内存动态分配和垃圾回收的问题，这一切都交给了JVM来处理。本篇我们先弄清楚在开发过程中如何使用对象引用来实现合适时机的垃圾回收，下篇再由浅入深谈谈jvm底层是如何垃圾回收的。</p>\n<p>在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用(Strong Reference)，软引用(Soft Reference)，弱引用(Weak Reference)，虚引用(Phantom Reference)四种，这四种引用强度依赖逐渐减弱。理解这四种对象引用方式也是对java垃圾回收机制的基本认识。</p>","link":"posts/1569136070","tags":["JVM","垃圾回收"],"categories":["Java"]},{"title":"JVM（一）内存分配","date":"2019-09-20T11:42:46.000Z","date_formatted":{"ll":"2019年9月20日","L":"2019/09/20","MM-DD":"09-20"},"excerpt":"<p>Java内存分配无论是处于正常开发计算过程还是绞尽脑汁思考内存回收都需要深入理解的，本文所属范畴是JVM，不应该先来个类加载和运行机制吗，为什么先研究内存分配呢？老实说因为这块很接近我们的开发，越接近后边的深入越容易理解。在了解JVM内存分配之前我们先简单熟悉一下Java HotSpot VM，因为我们经常挂在嘴边的JVM目前就是这家伙。</p>","link":"posts/1568979766","tags":["JVM","内存分配"],"categories":["Java"]},{"title":"位运算的那些事（三）位掩码","date":"2019-08-28T14:34:40.000Z","date_formatted":{"ll":"2019年8月28日","L":"2019/08/28","MM-DD":"08-28"},"excerpt":"<p>前两篇我重点针对位运算基础以及运算过程详细的进行了讲解说明，相信看过的小伙伴也都很明了了。那么基础有了，也知道运算过程了，那我们常见的战场在哪里呢？这就像排兵布阵一样，只阅读兵法，而没有实践和模拟，只能算纸上谈兵了。本篇就拉开帷幕直面开发中这个最常见的战场——位掩码（BitMask）。</p>","link":"posts/1567003105","tags":["二进制","位运算"],"categories":["计算机基础"]}]}