{"title":"Activity的生命周期和启动模式","date":"2018-02-26T14:27:49.000Z","date_formatted":{"ll":"2018年2月26日","L":"2018/02/26","MM-DD":"02-26"},"link":"post/1519655269","comments":true,"tags":["基础组件"],"categories":["Android"],"updated":"2021-01-14T08:08:54.887Z","content":"<p>Activity的生命周期和启动模式属于面试必考内容，有些时候可能随着工作经历的增长面试官不会去问这些，但是在面试的过程中或多或少都会牵涉一点，因为这是基础，虽然简单，还是总结一下，以后看着也舒服。</p>\n<a id=\"more\"></a>\n<h2 id=\"activity的生命周期图\">Activity的生命周期图<a title=\"#activity的生命周期图\" href=\"#activity的生命周期图\"></a></h2>\n<p>Activity的生命周期主要方法分为7个，这里就看图吧，一目了然。<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/AA9CB7E8247B45C683D622DFBEB5C62F?method=download&amp;shareKey=cfc56eb2314245653941a181d79a80e7\" alt=\"Activity的生命周期图\"></p>\n<h2 id=\"activity的生命周期走向\">Activity的生命周期走向<a title=\"#activity的生命周期走向\" href=\"#activity的生命周期走向\"></a></h2>\n<p>这里假设有两个界面，第一页为A，第二页为B，虽然onSaveInstanceState不被看作Activity生命周期的主要方法，这里也着重提出他的执行地方，因为关系着有些时候Activity重绘时数据恢复的功能。整个执行过程按照下边的步骤执行观察生命周期走向：</p>\n<ol>\n<li>刚进第一页<br>\nonCreat -&gt; onStart -&gt; onResume</li>\n<li>按Home键退到后台<br>\nonPause -&gt; onSaveInstanceState -&gt; onStop</li>\n<li>重新回到第一页<br>\nonRestart -&gt; onStart -&gt; onResume</li>\n<li>按电源键关闭屏幕<br>\n和2一样</li>\n<li>按电源键点亮屏幕<br>\n和3一样</li>\n<li>跳转到第二页<br>\nonPause(A) -&gt; onCreat(B) -&gt; onStart(B) -&gt;onResume(B) -&gt; onSaveInstanceState(A) -&gt; onStop(A)</li>\n<li>返回到第一页<br>\nonPause(B) -&gt; onRestart(A) -&gt; onStart(A) -&gt; onResume(A) -&gt; onStop(B) -&gt; onDestroy(B)</li>\n<li>第一页退出<br>\nonPause(A) -&gt; onStop(A) -&gt; onDestory(A)</li>\n</ol>\n<h2 id=\"activity的可见过程\">Activity的可见过程<a title=\"#activity的可见过程\" href=\"#activity的可见过程\"></a></h2>\n<p>Activity的初始过程包括onCreat、onStart、onResume三部分，各个部分有他们自己的使用场景：</p>\n<ul>\n<li>onCreat:主要用于view的实例过程，包括布局填充和绘制。</li>\n<li>onStart:界面已经布置完毕，甚至可以说处于“可见”状态，但是此时的Activity是没有灵魂的，没有焦点的，不可操作的。</li>\n<li>onResume:见名知意，就是在onStart僵死的过程后赋予界面焦点，让界面可以进行交互，从此之后Activity便处于活跃状态，这里有一个“从此之后”。</li>\n</ul>\n<p>因此，因此界面真正可见是在onWindowFocusChanged()方法执行的时候，面试的时候这个过程容易和面试官产生分歧，静下心慢慢和面试官讲清楚，此关即可通过。</p>\n<h2 id=\"activity的启动模式\">Activity的启动模式<a title=\"#activity的启动模式\" href=\"#activity的启动模式\"></a></h2>\n<p>Activity的启动方式主要分为四种：</p>\n<ul>\n<li>standard</li>\n<li>singleTop</li>\n<li>singleTask</li>\n<li>singleInstance</li>\n</ul>\n<p><strong>standerd</strong><br>\n既是所谓的标准模式，类似叠罗汉，采用先进后出的实现形式。所有实例都在一个栈中，实例与实例之间都是有先后顺序。例如A&gt;B,若是B销毁必然呈现A.</p>\n<p><strong>singleTop</strong><br>\n可以理解为栈顶单一模式，既是多个相同的实例在栈顶只能存在一个，不在栈顶的时候无所谓。假如B的启动模式是singTop,例如A&gt;B&gt;B实际是A&gt;B。A&gt;B&gt;C&gt;B&gt;B实际是A&gt;B&gt;C&gt;B。这种形式栈顶的B不再走onCreat重新启动,因为实例之前已经有了，没必要整个重绘界面，但是总归要有一个接口来告诉我有一个同胞同卵兄弟（穿的衣服可能不一样）来顶替我，那这时候我只需要把他的衣服拿过来换上就可以了。挑明:不走onCreat,走onNewIntent。</p>\n<p><strong>singleTask</strong><br>\n可以理解为栈内单一模式，既是多个相同的实例在栈内只能存在一个，假如B的启动模式是singleTask,例如A&gt;B&gt;C&gt;B实际是A&gt;B,特殊说明这种形式第二个B上边的所有实例都会被销毁，并且也是不再走onCreat,而走onNewIntent。</p>\n<p><strong>singleInstance</strong><br>\n可以理解为栈内唯一模式，既是一个栈中有且只能有一个实例。比较特殊。假如B的启动模式为singleInstance,例如A&gt;B,那么将开启一个新栈专门存B,A和B不会在同一个栈里.</p>\n<p>启动模式在AndroidManifest文件中注册Activity的时候设置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;activity android:name=<span class=\"string\">&quot;.ui.MainActivity&quot;</span> android:launchMode=<span class=\"string\">&quot;singleTask&quot;</span> android:screenOrientation=<span class=\"string\">&quot;portrait&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n<p>这种方式针对全局都有效。但是有些时候又有一定的局限性，假如我们想某个页面在特定的时候或者特定的按钮下启动才会有特定的启动模式，怎么办？这个时候就需要传输跳转时结合intent的各种flag了。</p>\n<h2 id=\"intent中的各种flag\">Intent中的各种FLAG<a title=\"#intent中的各种flag\" href=\"#intent中的各种flag\"></a></h2>\n<ul>\n<li>\n<p>FLAG_ACTIVITY_BROUGHT_TO_FRONT<br>\n如果通过该Flag启动的Activity已经存在，下次再次启动，将只是把该Activity带到前台。假如A启动B时设置该标签，B又启动C,C又启动B（正常启动）,最终栈内的实例是A,C,B.</p>\n</li>\n<li>\n<p>FLAG_ACTIVITY_CLEAR_TOP<br>\n相当于启动模式的singleTask。假设启动B时设置此标记，例如栈中现在是A,B,C,D那么再次启动B后的结果是A,B.</p>\n</li>\n<li>\n<p>FLAG_ACTIVITY_NEW_TASK<br>\n启动一个新的栈来存储启动这个activity。</p>\n</li>\n<li>\n<p>FLAG_ACTIVITY_NO_ANIMATION<br>\n启动Activity时不使用过渡动画</p>\n</li>\n<li>\n<p>FLAG_ACTIVITY_NO_HISTORY<br>\n被启动的Activity将不会记录在栈的历史中，假设启动D设置了此标记，例如之前栈中有A,B,C，现在C启动D，然后在由D启动E，那么此时栈中存在的实例有A,B,C,E.</p>\n</li>\n<li>\n<p>FLAG_ACTIVITY_REORDER_TO_FRONT<br>\n假如当前栈中已经存在所启动的Activity, 例如当前栈内有A,B,C.此时由 C通过该标记启动B,那么最终栈内的顺序是A,C,B.</p>\n</li>\n<li>\n<p>FLAG_ACTIVITY_SINGLE_TOP<br>\n相当于启动模式的singleTop。假设启动B时设置此标记，例如栈中现在是A,B，那么再次启动B后的结果还是A,B.，假如栈中现在是A,B,C,启动B,则是A,B,C,B.</p>\n</li>\n</ul>\n<p>至于其他FLAG并不常用，真正用到时查看intent的Flag的Api，可参考：<a href=\"http://blog.csdn.net/javensun/article/details/8700265\">http://blog.csdn.net/javensun/article/details/8700265</a></p>\n<p>启动之前存在的页面：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"keyword\">this</span>,OrderDetialActivity.class);</span><br><span class=\"line\">intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP|Intent.FLAG_ACTIVITY_CLEAR_TOP);</span><br><span class=\"line\">intent.putExtra(Constants.INTENT_SETRESULT,<span class=\"keyword\">true</span>);</span><br><span class=\"line\">startActivity(intent);</span><br></pre></td></tr></table></figure>\n<p>退出当前账户重新登录：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent(context, LoginActivity.class);</span><br><span class=\"line\">intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class=\"line\">startActivity(intent);</span><br></pre></td></tr></table></figure>","prev":{"title":"Service的生命周期和启动方式等相关总结","link":"post/1519660975"},"next":{"title":"View创建的那些事儿","link":"post/1517199857"},"plink":"https://blog.ixin.run/post/1519655269/","toc":[{"id":"activity的生命周期图","title":"Activity的生命周期图","index":"1"},{"id":"activity的生命周期走向","title":"Activity的生命周期走向","index":"2"},{"id":"activity的可见过程","title":"Activity的可见过程","index":"3"},{"id":"activity的启动模式","title":"Activity的启动模式","index":"4"},{"id":"intent中的各种flag","title":"Intent中的各种FLAG","index":"5"}],"reward":true,"copyright":{"custom":"转载请注明出处，谢谢支持。"}}