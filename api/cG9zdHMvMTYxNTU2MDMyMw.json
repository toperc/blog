{"title":"HTTPS协议原理必知必会","date":"2021-03-12T14:45:07.000Z","date_formatted":{"ll":"2021年3月12日","L":"2021/03/12","MM-DD":"03-12"},"link":"posts/1615560323","comments":true,"tags":["HTTP","HTTPS"],"categories":["计算机网络"],"updated":"2021-03-15T04:16:08.121Z","content":"<p>前边的一篇文章<a href=\"./posts/1615211970\">《HTTP协议原理知多少》</a>我把有关Http的知识总结了一下，Http是一个无状态，透明的网络协议，然而在当下大网络环境下，安全这块是很重要的，所以Http也被无情的拍着沙滩上了，当然前人栽树后人乘凉，前人打地基后人盖大楼，一切都离不开基础，本篇文章我就总结一下在Http基础上添加了安全模块的Https的相关知识点，细看必有收获。</p>\n<a id=\"more\"></a>\n<h2 id=\"http的缺点\">HTTP的缺点<a title=\"#http的缺点\" href=\"#http的缺点\"></a></h2>\n<p>HTTP主要有以下不足：</p>\n<ul>\n<li>通信使用明文（不加密），内容可能会被窃听</li>\n<li>不验证通信方的身份，因此有可能遭遇伪装</li>\n<li>无法证明报文的完整性，所以有可能已遭篡改</li>\n</ul>\n<h2 id=\"什么是https\">什么是HTTPS<a title=\"#什么是https\" href=\"#什么是https\"></a></h2>\n<p><strong>HTTP加上加密处理和认证以及完整性保护后即是HTTPS</strong>。</p>\n<p>HTTPS 要比 HTTPS 多了 secure 安全性这个概念，实际上， HTTPS 并不是一个新的应用层协议，它其实就是 HTTP + TLS/SSL 协议组合而成，而安全性的保证正是 SSL/TLS 所做的工作。</p>\n<p>通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，<strong>所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP</strong>。</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/WEB9d2aefb04bd7a5f7e4453e54021f03d7?method=download&amp;shareKey=e50e258183770dce72ac4eae1f59bc9d\" alt=\"HTTPS是身披SSL外壳的HTTP\" class=\"φbs\"></p>\n<h2 id=\"tls/ssl协议\">TLS/SSL协议<a title=\"#tls/ssl协议\" href=\"#tls/ssl协议\"></a></h2>\n<p>1994年网景公司为了解决HTTP的安全问题创建了SSL协议，SSL协议有三个版本，分别是SSL v1、SSL v2、SSLv3。1996年，IETF（Internet Engineering Task Force）组织在SSL v3的基础上进一步标准化了该协议，微软为这个新协议取名TLS v1.0。</p>\n<p>【SSL】: 安全套接层（Secure Sockets Layer）</p>\n<p>【TLS】: 传输层安全（Transport Layer Security）</p>\n<p>在理解的时候可以认为两者是一样的，TLS协议是SSL协议的升级版。</p>\n<blockquote>\n<p>TLS/SSL 的功能实现主要依赖于三类基本算法：<code>非对称加密</code>、<code>对称加密</code>和<code>散列函数</code>，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。</p>\n</blockquote>\n<h2 id=\"加密\">加密<a title=\"#加密\" href=\"#加密\"></a></h2>\n<h3 id=\"密码学的四个目标\">密码学的四个目标<a title=\"#密码学的四个目标\" href=\"#密码学的四个目标\"></a></h3>\n<p><strong>1）机密性（隐私性）</strong></p>\n<p>在网络中传递的数据如果具备机密性，那么传输的数据就是一串无意义的数字，只有拥有密钥的才能解释这些数据，密钥是加密算法的关键。在密码学中，<code>对称加密算法</code>和<code>公开密钥算法</code>都能够保证机密性。</p>\n<p><strong>2）完整性</strong></p>\n<p>完整性表示接收方能够确保接收到的数据就是发送方发送的原始数据，假设数据被中间人篡改，接收方如果有策略知晓数据被篡改了，那么传递的数据就具备完整性。在密码学中，主要使用<code>消息验证码（MAC）算法</code>保证完整性。</p>\n<p><strong>3）身份验证</strong></p>\n<p>互联网应用一般都有发送方和接收方，对于接收方来说，必须确认发送方的身份，才能确保收到的数据就是真实发送方发送的。反之对于发送方来说也是一样的，通信双方必须确保对端就是要通信的对象。在密码学中，一般使用<code>数字签名技术</code>确认身份。</p>\n<p><strong>4）不可抵赖性</strong></p>\n<p>举个例子，A向B借钱了，并写了张借条，当B希望A还钱的时候，A抵赖说这张借条不是他写的，理由就是有人冒充他写了这张借条，A的行为可以抵赖。在密码学中，<code>数字签名技术</code>能够避免抵赖。</p>\n<h3 id=\"公开密钥算法\">公开密钥算法<a title=\"#公开密钥算法\" href=\"#公开密钥算法\"></a></h3>\n<p>公开密钥算法即非对称加密，服务端会同时产生一对密钥：公钥和私钥，公钥裸奔，私钥隐藏。</p>\n<p>用作加密：公钥加密私钥解密；<br>\n用作签名：私钥加密公钥解密；</p>\n<h3 id=\"https的加密核心\">HTTPS的加密核心<a title=\"#https的加密核心\" href=\"#https的加密核心\"></a></h3>\n<p>常规加解密我们最容易想到的是对称加密，即客户端和服务端都采用相同的密码进行加解密，但这样有一个问题，万一密码被盗了，那整个数据传输通道就裸奔了。此时如果采用非对称加密，即客户端采用公钥加密服务端采用私钥解密，那这个问题就迎刃而解了。</p>\n<p>但是<strong>HTTPS采用的却是对称加密和非对称加密的组合形式</strong>。有同学可能会问，既然非对称加密很完美那么只采用这一种不可以吗？这里的答案是不可以。</p>\n<p>原因是非对称加密虽然很安全，但是非对称加密与对称加密相比，其处理速度要慢。假如传输数据流很大的话，岂不是要等个天荒地老咯。</p>\n<p>所以HTTPS采用一个很讨巧的方式，采用<strong>对称加密方法加密需要传输的数据流</strong>，而<strong>非对称加密方法加密前一步对称加密中产生的密钥</strong>，然后进行传输。服务器通过私钥解密就可以得到准确的数据流密钥，进而解密数据流。</p>\n<h2 id=\"认证\">认证<a title=\"#认证\" href=\"#认证\"></a></h2>\n<p>非对称加密公开密钥的方式虽然看起来很安全，但是也有一些遗憾，那就是无法证明公开密钥本身就是货真价实的公开密钥。</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/WEBa07203c5f61981fd058f1c17e90f4b1c?method=download&amp;shareKey=8b9ee55e74a62cb9d81efca1779f367a\" alt=\"公钥被中间人拿到篡改\" class=\"φbs\"></p>\n<p>如果公钥被中间人拿到纂改怎么办呢？</p>\n<p>在HTTPS中，通过 数字证书（「证书」 + 「数字签名」）来解决这个问题。</p>\n<h3 id=\"数字签名\">数字签名<a title=\"#数字签名\" href=\"#数字签名\"></a></h3>\n<p>数字签名功能主要是用于校验数据来源和一致性（完整性），非对称加密中的通过<strong>私钥加密公钥解密</strong>的手段实现。</p>\n<p>假设现在A向B发送一封邮件，具体签名校验流程如下：</p>\n<ol>\n<li>A先对这封Email执行哈希运算得到hash值简称“摘要”，取名h1。</li>\n<li>然后用自己私钥对摘要加密，生成的东西叫“数字签名”。</li>\n<li>把数字签名加在Email正文后面，一起发送给B。</li>\n<li>B收到邮件后用A的公钥对数字签名解密，成功则代表Email确实来自A，失败说明有人冒充。</li>\n</ol>\n<p>以上四步是对方身份的确认，接下来两步判断数据是否被篡改：</p>\n<ol start=\"5\">\n<li>B对邮件正文执行哈希运算得到hash值，取名h2。</li>\n<li>B会对比第4步数字签名的hash值h1和自己运算得到的h2，一致则说明邮件未被篡改。</li>\n</ol>\n<p>有同学可能又问了为什么签名要先经过hash运算呢？答案应该也很容易想到。</p>\n<p>直接对源数据加解密是个耗时工程，如果源数据比较大，那整个过程是时间和性能的巨大开销。我们这里要明白上边提到的签名的主要作用是什么。</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/WEBba99f42302d6d2d7a1093daa38a6e699?method=download&amp;shareKey=ddd715bdec116779a57c3af36f2d7af1\" alt=\"数字签名校验过程\" class=\"φbs\"></p>\n<h3 id=\"数字证书\">数字证书<a title=\"#数字证书\" href=\"#数字证书\"></a></h3>\n<p>上边说到公钥有可能被中间人拿到替换或者篡改，为了让客户端校验身份，服务器必须配置服务器证书，证书由CA（Certificate Authority）机构签发。数字证书认证机构（CA,Certificate Authority）处于客户端与服务器双方都可信赖的第三方机构的立场上。</p>\n<p>数字证书包含两部分：证书和数字签名：</p>\n<ul>\n<li>证书是为了保证公钥来源的正确性（公钥的确来自我们自己的服务器）</li>\n<li>数字签名保证公钥没有被篡改。</li>\n</ul>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/WEB9a207920a978cd4f9bee44b6ce93a1fb?method=download&amp;shareKey=2f0b997ca06076c6cd3ee1c335b103c4\" alt=\"三方认证生成数字证书\" class=\"φbs\"></p>\n<p>如果没有数字签名的话，这样子可以就会有下面情况：</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/WEB82d8a17efd9f4fd9a18fdd404fb669ca?method=download&amp;shareKey=f6de78eafd3a78891fd41b621e024055\" alt=\"没有数字签名的证书存在安全隐患\" class=\"φbs\"></p>\n<p>所以<code>「证书」 + 「数字签名」</code>方式可以完好的保证公钥的准确性。我们假设中间人截取到服务器的公钥后，去替换成自己的公钥，因为有数字签名的存在，这样子客户端验证发现数字签名不匹配，这样子就防止中间人替换公钥的问题。</p>\n<p>使用通信方式时，如何安全转交认证机关的公开密钥是一件很困难的事，因此，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/WEBc031b52121d083e9b436401458185c23?method=download&amp;shareKey=22632b77a446dff35da5de68980f3a08\" alt=\"浏览器内部植入常用的认证机关的公开密钥\" class=\"φbs\"></p>\n<p>客户端是如何去对比两者数字签名的呢？</p>\n<ol>\n<li>浏览器会去安装一些比较权威的第三方认证机构的公钥，比如VeriSign、Symantec以及GlobalSign等等。</li>\n<li>验证数字签名的时候，会直接从本地拿到相应的第三方的公钥，对私钥加密后的数字签名进行解密得到真正的签名。</li>\n<li>然后客户端利用签名生成规则进行签名生成，看两个签名是否匹配，如果匹配认证通过，不匹配则获取证书失败。</li>\n</ol>\n<h2 id=\"完整性保护\">完整性保护<a title=\"#完整性保护\" href=\"#完整性保护\"></a></h2>\n<p>在HTTPS的通信流程中，应用层发送数据时，会附加一种叫做MAC（Message Authentication Code，消息认证码）的报文摘要，MAC能够查知报文是否遭到篡改，从而保护报文的完整性。</p>\n<p>消息认证码MAC是一种与密钥相关的<code>单向散列函数</code>，无需解密只需校验。消息认证码MAC通常采用HMAC （推荐HMAC-SHA256） 或 认证加密算法（AEAD，比如AES-GCM-256 ，AES属于对称加密算法的一种）通信双方拥有相同的共享密钥。</p>\n<p>前提条件：</p>\n<ul>\n<li>在消息认证码生成的一方和校验的一方, 必须有一个秘钥</li>\n<li>双方约定好使用同样的哈希函数对数据进行运算</li>\n</ul>\n<p>工作过程如下：</p>\n<p>).A把消息发送给B前，先把共享密钥发送给B。</p>\n<p>2).A把要发送的消息使用共享密钥计算出MAC值，然后将消息和MAC发送给B。</p>\n<p>3).B接收到消息和MAC值后，使用共享密钥计算出MAC值，与接收到的MAC值对比。</p>\n<p>4).如果MAC值相同，说明接收到的消息是完整的。因为提前已经知道共享密钥除了B那就只有A拥有，所以也可以确定消息是A发的。</p>\n<p>工作原理举例图示：</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/WEBec3be39557de01226dccd955e0304da7?method=download&amp;shareKey=1f67f918bc46d2a962c0a27c713b96b6\" alt=\"消息认证码工作原理图示\" class=\"φbs\"></p>\n<h3 id=\"消息认证码无法解决的问题\">消息认证码无法解决的问题<a title=\"#消息认证码无法解决的问题\" href=\"#消息认证码无法解决的问题\"></a></h3>\n<p>消息认证码虽然可以证明双方发送的消息是一致的，没有篡改，也不存在中间人伪装。但是它无法 “对第三方证明” 和 “防止抵赖”。</p>\n<p>无法 “对第三方证明” 原因是因为消息认证码中用到的密钥是共享密钥，通信双方都有这个密钥，所以对第三方无法证明消息到底出自双方中的哪一方。解决 “第三方证明” 的问题需要用到数字签名。</p>\n<p>无法 “防止抵赖” 原因是也是因为消息认证码的共享密钥双方都有，无法判断消息是发自于哪一方。所以消息认证码无法防止否认(nonrepudiation)。解决 “防止抵赖” 的问题需要用到数字签名。</p>\n<h3 id=\"单向散列函数、消息认证码和数字签名区别\">单向散列函数、消息认证码和数字签名区别<a title=\"#单向散列函数、消息认证码和数字签名区别\" href=\"#单向散列函数、消息认证码和数字签名区别\"></a></h3>\n<ul>\n<li>单向散列函数保证消息的一致性，完整性，没有被篡改。</li>\n<li>消息认证码保证消息的一致性，完整性，没有被篡改，并且不存在中间人伪装。</li>\n<li>数字签名保证消息的一致性，完整性，没有被篡改，并且不存在中间人伪装，并且能防止抵赖。</li>\n</ul>\n<h2 id=\"https通信过程\">HTTPS通信过程<a title=\"#https通信过程\" href=\"#https通信过程\"></a></h2>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/WEB278f7eba86468f1df7f96df55a2f0695?method=download&amp;shareKey=b1c1e151edbfba222a46fc93a42a972f\" alt=\"HTTPS的通信步骤图示\" class=\"φbs\"></p>\n<p><strong>步骤1</strong>： 客户端通过发送Client Hello报文开始SSL通信。报文中包含客户端支持的SSL的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</p>\n<p><strong>步骤2</strong>： 服务器可进行SSL通信时，会以Server Hello报文作为应答。和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</p>\n<p><strong>步骤3</strong>： 之后服务器发送Certificate报文。报文中包含公开密钥证书。</p>\n<p><strong>步骤4</strong>： 最后服务器发送Server Hello Done报文通知客户端，最初阶段的SSL握手协商部分结束。</p>\n<p><strong>步骤5</strong>: SSL第一次握手结束之后，客户端以Client Key Exchange报文作为回应。报文中包含通信加密中使用的一种被称为Pre-master secret的随机密码串。该报文已用步骤3中的公开密钥进行加密。</p>\n<p><strong>步骤6</strong>： 接着客户端继续发送Change Cipher Spec报文。该报文会提示服务器，在此报文之后的通信会采用Pre-master secret密钥加密。</p>\n<p><strong>步骤7</strong>： 客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。</p>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<ul>\n<li>《图解HTTP》</li>\n<li>《深入浅出HTTPS》</li>\n<li><a href=\"https://juejin.cn/post/6857287743966281736#heading-59\">https://juejin.cn/post/6857287743966281736#heading-59</a></li>\n<li><a href=\"https://liaodanqi.me/2020/04/11/net-sec-integrity-and-digital-signature/\">https://liaodanqi.me/2020/04/11/net-sec-integrity-and-digital-signature/</a></li>\n<li><a href=\"https://juejin.cn/post/6844904158319869960\">https://juejin.cn/post/6844904158319869960</a></li>\n</ul>\n","prev":{"title":"Android多渠道打包","link":"posts/1615692625"},"next":{"title":"Http协议原理知多少","link":"posts/1615211970"},"plink":"https://blog.ixin.run/posts/1615560323/","toc":[{"id":"http的缺点","title":"HTTP的缺点","index":"1"},{"id":"什么是https","title":"什么是HTTPS","index":"2"},{"id":"tls/ssl协议","title":"TLS&#x2F;SSL协议","index":"3"},{"id":"加密","title":"加密","index":"4","children":[{"id":"密码学的四个目标","title":"密码学的四个目标","index":"4.1"},{"id":"公开密钥算法","title":"公开密钥算法","index":"4.2"},{"id":"https的加密核心","title":"HTTPS的加密核心","index":"4.3"}]},{"id":"认证","title":"认证","index":"5","children":[{"id":"数字签名","title":"数字签名","index":"5.1"},{"id":"数字证书","title":"数字证书","index":"5.2"}]},{"id":"完整性保护","title":"完整性保护","index":"6","children":[{"id":"消息认证码无法解决的问题","title":"消息认证码无法解决的问题","index":"6.1"},{"id":"单向散列函数、消息认证码和数字签名区别","title":"单向散列函数、消息认证码和数字签名区别","index":"6.2"}]},{"id":"https通信过程","title":"HTTPS通信过程","index":"7"},{"id":"参考","title":"参考","index":"8"}],"reward":true,"copyright":{"author":"i猩人","link":"<a href=\"https://blog.ixin.run/posts/1615560323/\" title=\"HTTPS协议原理必知必会\">https://blog.ixin.run/posts/1615560323/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}