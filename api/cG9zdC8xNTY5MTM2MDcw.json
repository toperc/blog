{"title":"Java垃圾回收（一）四种对象引用类型","date":"2019-09-22T07:07:50.000Z","date_formatted":{"ll":"2019年9月22日","L":"2019/09/22","MM-DD":"09-22"},"link":"post/1569136070","comments":true,"tags":["JVM","垃圾回收"],"categories":["Java"],"updated":"2021-01-14T08:08:54.907Z","content":"<p>垃圾收集GC（Garbage Collection）是Java语言的核心技术之一， 在Java中，程序员不需要去关心内存动态分配和垃圾回收的问题，这一切都交给了JVM来处理。本篇我们先弄清楚在开发过程中如何使用对象引用来实现合适时机的垃圾回收，下篇再由浅入深谈谈jvm底层是如何垃圾回收的。</p>\n<p>在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用(Strong Reference)，软引用(Soft Reference)，弱引用(Weak Reference)，虚引用(Phantom Reference)四种，这四种引用强度依赖逐渐减弱。理解这四种对象引用方式也是对java垃圾回收机制的基本认识。</p>\n<a id=\"more\"></a>\n<h2 id=\"强引用(strongreference)\">强引用(StrongReference)<a title=\"#强引用(strongreference)\" href=\"#强引用(strongreference)\"></a></h2>\n<p>强引用就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类引用，只要强引用存在，垃圾收集器永远不会回收掉被引用的对象。</p>\n<h2 id=\"软引用(softreference)\">软引用(SoftReference)<a title=\"#软引用(softreference)\" href=\"#软引用(softreference)\"></a></h2>\n<p>软引用用来描述一些还有用，但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出之前，将会把这些对象列进回收范围之中，并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出错误。在JDK1.2之后，提供了SoftReference来实现软引用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//创建软引用数组</span></span><br><span class=\"line\">  SoftReference&lt;Person&gt; [] p = <span class=\"keyword\">new</span> SoftReference[<span class=\"number\">100</span>]; </span><br><span class=\"line\">  <span class=\"comment\">//赋值  </span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt; p.length ;i++)&#123;</span><br><span class=\"line\">   p[i] = <span class=\"keyword\">new</span> SoftReference&lt;Person&gt;(<span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;name&quot;</span>+i ,i));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//测试</span></span><br><span class=\"line\">  System.out.println(p[<span class=\"number\">1</span>].get());</span><br><span class=\"line\">  System.out.println(p[<span class=\"number\">4</span>].get());</span><br><span class=\"line\">  <span class=\"comment\">//通知系统进行回收</span></span><br><span class=\"line\">  System.gc();</span><br><span class=\"line\">  System.runFinalization();</span><br><span class=\"line\">  </span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;---------------&quot;</span>);</span><br><span class=\"line\">  System.out.println(p[<span class=\"number\">1</span>].get());</span><br><span class=\"line\">  System.out.println(p[<span class=\"number\">4</span>].get());</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>软引用的对象当系统内存充足时和强引用没有太多区别，但内存不足时会回收软引用的对象。</p>\n<h2 id=\"弱引用(weakreference)\">弱引用(WeakReference)<a title=\"#弱引用(weakreference)\" href=\"#弱引用(weakreference)\"></a></h2>\n<p>弱引用也是用来描述非必须对象的，但是它的强度比软引用更弱一点，被弱引用关联的对象只能生存到下一次垃圾回收之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉被弱引用关联的对象。在JDK1.2之后，提供了WeakReference来实现弱引用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">   String str = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;JAVA讲义&quot;</span>);</span><br><span class=\"line\">   <span class=\"comment\">//创建一个弱引用对象 指向 str对象</span></span><br><span class=\"line\">   WeakReference&lt;String&gt; wr = <span class=\"keyword\">new</span> WeakReference&lt;String&gt; (str);</span><br><span class=\"line\">   <span class=\"comment\">//切断强引用</span></span><br><span class=\"line\">   str =<span class=\"keyword\">null</span>;</span><br><span class=\"line\">   <span class=\"comment\">//输出</span></span><br><span class=\"line\">   System.out.println(wr.get());<span class=\"comment\">//JAVA讲义</span></span><br><span class=\"line\">   <span class=\"comment\">//强制垃圾回收</span></span><br><span class=\"line\">   System.gc();</span><br><span class=\"line\">   System.out.println(wr.get()); <span class=\"comment\">//null</span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>弱引用具有很强的不确定性。因为垃圾回收每次都会回收弱引用的对象。</p>\n<p><strong>软引用只有在内存不足时进行回收，而弱引用只要发生gc就进行回收，这是二者区别</strong></p>\n<h2 id=\"虚引用(phantomreference)\">虚引用(PhantomReference)<a title=\"#虚引用(phantomreference)\" href=\"#虚引用(phantomreference)\"></a></h2>\n<p>虚引用它是最弱的一种引用关系。一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象的实例。为一个对象设置虚引用关联的唯一目的是希望能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference来实现虚引用。</p>\n<p>软引用和弱引用可以单独使用，虚引用不能单独使用，虚引用的作用是就跟踪对象被垃圾回收的状态，程序可以通过检测与虚引用关联的虚引用队列是否已经包含了指定的虚引用，从而了解虚引用的对象是否即将被回收。如果一个对象只有一个虚引用存在，那么他就类似没有引用存在。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//创建一个对象</span></span><br><span class=\"line\">  String str = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;JAVA讲义&quot;</span>);</span><br><span class=\"line\">  <span class=\"comment\">//创建一个引用队列</span></span><br><span class=\"line\">  ReferenceQueue&lt;String&gt; rq = <span class=\"keyword\">new</span> ReferenceQueue&lt;String&gt;();</span><br><span class=\"line\">  <span class=\"comment\">//创建一个虚引用，指定引用对象.不能单独使用必须关联引用队列</span></span><br><span class=\"line\">  PhantomReference pr = <span class=\"keyword\">new</span> PhantomReference(str,rq);</span><br><span class=\"line\">  <span class=\"comment\">//切断强引用</span></span><br><span class=\"line\">  str =<span class=\"keyword\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">//试图取得虚引用对象</span></span><br><span class=\"line\">  System.out.println(pr.get()); <span class=\"comment\">//null</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//垃圾回收</span></span><br><span class=\"line\">  System.gc();</span><br><span class=\"line\">  System.runFinalization();</span><br><span class=\"line\">  <span class=\"comment\">//取出引队列中的最先进入队列的引用与pr进行比较</span></span><br><span class=\"line\">  System.out.println(rq.poll()==pr); <span class=\"comment\">//true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"引用队列(reference-queue)\">引用队列(Reference Queue)<a title=\"#引用队列(reference-queue)\" href=\"#引用队列(reference-queue)\"></a></h2>\n<p>引用队列可以很容易地实现跟踪不需要的引用。当你在构造WeakReference时传入一个ReferenceQueue对象（PhantomReference必须和引用队列结合使用），当该引用指向的对象被标记为垃圾的时候，这个引用对象会自动地加入到引用队列里面。接下来，你就可以在固定的周期处理传入的引用队列，比如做一些清理工作来处理这些没有用的引用对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">User user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">WeakReference&lt;User&gt; weakReference = <span class=\"keyword\">new</span> WeakReference&lt;User&gt;(user);</span><br><span class=\"line\">weakReference.get();</span><br><span class=\"line\"></span><br><span class=\"line\">ReferenceQueue&lt;User&gt; referenceQueue = <span class=\"keyword\">new</span> ReferenceQueue&lt;User&gt;();</span><br><span class=\"line\">WeakReference&lt;User&gt; weakReference2 = <span class=\"keyword\">new</span> WeakReference&lt;User&gt;(user, referenceQueue);</span><br><span class=\"line\"><span class=\"comment\">//当引用对象被标识为可回收时返回true</span></span><br><span class=\"line\">weakReference.isEnqueued();</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\">总结<a title=\"#总结\" href=\"#总结\"></a></h2>\n<p>以上讲解了java四种对象引用方式，这也是面对java垃圾回收机制在开发过程中很重要的一环。有两点总结：</p>\n<ol>\n<li>如果希望尽可能减小程序在起声明周期中所占用的内存大小，可以灵活使用这些引用。</li>\n<li>如果使用了这些引用就不能保留这些对象的强引用（强引用应该置null），否则就浪费了这些类提供的任何好处。</li>\n</ol>\n","prev":{"title":"Java垃圾回收（二）GC过程","link":"post/1569139670"},"next":{"title":"JVM（一）内存分配","link":"post/1568979766"},"plink":"https://blog.ixin.run/post/1569136070/","toc":[{"id":"强引用(strongreference)","title":"强引用(StrongReference)","index":"1"},{"id":"软引用(softreference)","title":"软引用(SoftReference)","index":"2"},{"id":"弱引用(weakreference)","title":"弱引用(WeakReference)","index":"3"},{"id":"虚引用(phantomreference)","title":"虚引用(PhantomReference)","index":"4"},{"id":"引用队列(reference-queue)","title":"引用队列(Reference Queue)","index":"5"},{"id":"总结","title":"总结","index":"6"}],"reward":true,"copyright":{"custom":"转载请注明出处，谢谢支持。"}}