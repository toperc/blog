{"title":"Java泛型的认识和理解","date":"2018-03-14T16:08:11.000Z","date_formatted":{"ll":"2018年3月15日","L":"2018/03/15","MM-DD":"03-15"},"link":"post/1521043691","comments":true,"categories":["Java"],"updated":"2021-01-14T08:08:54.917Z","content":"<p>针对泛型大家并不陌生，主要是针对某些对象以及方法参数的限定，避免在代码编写的过程中由于类型的不匹配从而造成运行期发生异常，泛型只在编译阶段有用，运行期间则会进行泛型擦除。</p>\n<a id=\"more\"></a>\n<h2 id=\"什么是泛型\">什么是泛型<a title=\"#什么是泛型\" href=\"#什么是泛型\"></a></h2>\n<p>泛型即“参数化类型”，目的就是将参数类型像参数一样引入到类、方法、接口中来，进而来统一内部使用时的参数类型，JDK1.5引入的。<br>\n举个栗子</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class=\"line\">\tString name = (String) list.get(i); <span class=\"comment\">// 取出Integer时，运行时出现异常</span></span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;name:&quot;</span> + name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上异常的原因正是因为类型不匹配造成的，因此我们在定义的时候规定一种类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>\n<p>这样在编译的时候就不允许使用添加integer类型了，取的时候也就大胆放心的去取了，这就是泛型的目的。</p>\n<p>泛型给我们带来了不一样的编程体验，平时在使用泛型的时候不知道具体的泛型参数是什么，那么我们可以这样定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cache</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    T value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用的时候我们只需将确定的泛型参数传进去即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache&lt;String&gt; cache1 = <span class=\"keyword\">new</span> Cache&lt;String&gt;();</span><br><span class=\"line\">cache1.setValue(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\">String value2 = cache1.getValue();</span><br><span class=\"line\"></span><br><span class=\"line\">Cache&lt;Integer&gt; cache2 = <span class=\"keyword\">new</span> Cache&lt;Integer&gt;();</span><br><span class=\"line\">cache2.setValue(<span class=\"number\">456</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> value3 = cache2.getValue();</span><br></pre></td></tr></table></figure>\n<p>尖括号 <T> 中的T被称作是类型参数，用于指代任何类型。出于规范的目的，Java建议我们用单个大写字母来代表类型参数。常见的如：</p>\n<ol>\n<li>T 代表一般的任何类。</li>\n<li>E 代表 Element 的意思，或者 Exception 异常的意思。</li>\n<li>K 代表 Key 的意思。</li>\n<li>V 代表 Value 的意思，通常与 K 一起配合使用。</li>\n<li>S 代表 Subtype 的意思，文章后面部分会讲解示意。</li>\n</ol>\n<p>总结了一下泛型的优点：<br>\n（1）软件编程扩展<br>\n与普通的 Object 代替一切类型这样简单粗暴而言，泛型使得数据的类别可以像参数一样由外部传递进来。它提供了一种扩展能力。它更符合面向抽象开发的软件编程宗旨。<br>\n（2）类型安全<br>\n通过知道使用泛型定义的变量的类型限制，编译器可以更有效地提高Java程序的类型安全。<br>\n（3）消除强制类型转换<br>\n消除源代码中的许多强制类型转换，这使得代码更加可读，并且减少了出错机会。所有的强制转换都是自动和隐式的。<br>\n（4）提高性能<br>\n泛型使得在参数调用的时候事先判断了参数是否符合标准，避免了在运行时数据调用不规范所进行的一系列处理，保证程序稳定快速运行。</p>\n<h2 id=\"泛型的使用\">泛型的使用<a title=\"#泛型的使用\" href=\"#泛型的使用\"></a></h2>\n<p>在开发过程中泛型按照使用的情况大致分为三种：</p>\n<ol>\n<li>泛型接口</li>\n<li>泛型类</li>\n<li>泛型方法</li>\n</ol>\n<h3 id=\"泛型接口\">泛型接口<a title=\"#泛型接口\" href=\"#泛型接口\"></a></h3>\n<p>1.知道泛型参数的情况下。<br>\n具体泛型参数类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Call</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Call</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;this is call&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GenericInterface</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">T <span class=\"title\">next</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接口实现类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GenericClass</span> <span class=\"keyword\">implements</span> <span class=\"title\">GenericInterface</span>&lt;<span class=\"title\">Call</span>&gt; </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Call <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tCall c = <span class=\"keyword\">new</span> Call();</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> c;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>主函数功能实现:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] arg)</span></span>&#123;</span><br><span class=\"line\">\tGenericClass genericClass = <span class=\"keyword\">new</span> GenericClass();</span><br><span class=\"line\">\tgenericClass.next();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br>\nthis is call</p>\n<p>2.大部分情况下是事先并不只泛型参数具体类型，此时需要泛型类来确定泛型接口中具体传入的参数类型。<br>\n定义接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GenericInterface</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">T <span class=\"title\">next</span><span class=\"params\">(T t)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接口实现类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GenericClass</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">GenericInterface</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">next</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> t;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>主函数功能实现:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] arg)</span></span>&#123;</span><br><span class=\"line\">\tGenericClass&lt;Call&gt; genericClass = <span class=\"keyword\">new</span> GenericClass&lt;Call&gt;();</span><br><span class=\"line\">\tgenericClass.next(<span class=\"keyword\">new</span> Call());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br>\nthis is call</p>\n<h3 id=\"泛型类\">泛型类<a title=\"#泛型类\" href=\"#泛型类\"></a></h3>\n<p>和泛型接口定义一样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    T value;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getValue</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用的时候将泛型参数传进去：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Test&lt;String&gt; test = <span class=\"keyword\">new</span> Test&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<p>当然泛型参数也可以不止一个：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MultiType</span> &lt;<span class=\"title\">E</span>,<span class=\"title\">T</span>&gt;</span>&#123;</span><br><span class=\"line\">    E value1;</span><br><span class=\"line\">    T value2;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">getValue1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getValue2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"泛型方法\">泛型方法<a title=\"#泛型方法\" href=\"#泛型方法\"></a></h3>\n<p>这里的泛型方法特指由方法本身来确定将来传入的参数类型而非像上边引用泛型接口或泛型类的泛型参数。泛型方法可单独对方法定义方法的形参类型和方法的返回类型。<br>\n定义方法的形参类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testMethod</span><span class=\"params\">(T t)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义方法的返回类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T  <span class=\"title\">testMethod</span><span class=\"params\">(T t)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"泛型方法与泛型类共存\">泛型方法与泛型类共存<a title=\"#泛型方法与泛型类共存\" href=\"#泛型方法与泛型类共存\"></a></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;<span class=\"title\">T</span>&gt;</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title\">testMethod1</span><span class=\"params\">(T t)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(t.getClass().getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>  &lt;E&gt; <span class=\"function\">E <span class=\"title\">testMethod2</span><span class=\"params\">(E e)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里testMethod1和testMethod2两个方法所接收的参数类型是不一样的。testMethod1属于普通方法，其参数来自于类传入的参数类型决定，testMethod2由将来自身方法的传入的参数来决定参数类型，这里为了代码的方便阅读和避免混淆所以采用T和E来进行区分。</p>\n<p>从上边的一路走来可以看出无论是泛型接口还是泛型类或是泛型方法其将来的传入参数均来源于<T>所在的位置，这里的<T>是对T的声明定义。</p>\n<h2 id=\"通配符-？\">通配符 ？<a title=\"#通配符-？\" href=\"#通配符-？\"></a></h2>\n<p><strong>？</strong> 是通配符，目的希望泛型能够处理某一范围内的数据类型，也就是说让泛型所表示的参数类型更广一些从而满足泛型限定的对象之间能够正常匹配。</p>\n<p><strong>&lt; ? &gt;</strong> 表示类型的无界通配符，意思是目前并不知道参数类型是什么，是对类型的无界限定，使得参数范围更广阔。<br>\n例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;?&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>\n<p>注意List&lt; ? &gt;和List是有区别的，就拿上句代码来说表示的意思是“生成一个集合对象只能放String类型，至于这个集合类型却是未知的”，这也是<strong>使用无界通配符不能往里面存任何类型数据</strong> 的原因，只能存null。而<code>List list = new ArrayList&lt;String&gt;();</code>表示的意思是“生成一个集合对象只能存放String类型，这个集合本身所限定的范围却是任意都可以”，看出来两者的区别了吧</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Child&gt; lsc = <span class=\"keyword\">new</span> ArrayList&lt;Child&gt;();</span><br><span class=\"line\">List&lt;Parent&gt; lsp = <span class=\"keyword\">new</span> ArrayList&lt;Parent&gt;();</span><br><span class=\"line\">lsp = lsc;  <span class=\"comment\">//编译器报错不通过</span></span><br><span class=\"line\"></span><br><span class=\"line\">List lsc = <span class=\"keyword\">new</span> ArrayList&lt;Child&gt;();</span><br><span class=\"line\">List&lt;Parent&gt; lsp = <span class=\"keyword\">new</span> ArrayList&lt;Parent&gt;();</span><br><span class=\"line\">lsp = lsc;  <span class=\"comment\">//编译器可以运行</span></span><br></pre></td></tr></table></figure>\n<p>另外，通配符不能作为“参数类型”使用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//error</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&lt;?&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ? item1;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ? item2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>通配符的边界</strong><br>\n通配符常用的就是对边界的限定，有界通配符分为两种：</p>\n<ul>\n<li>&lt; ? extends T &gt;：是指 “上界通配符（Upper Bounds Wildcards）”，限定的是所有的子类及其本身类型。</li>\n<li>&lt; ? super T &gt;：是指 “下界通配符（Lower Bounds Wildcards）”，限定的是所有的父类及其本身类型。</li>\n</ul>\n<p>通配符的边界限定能更好更准确的控制参数类型，便于数据顺利的传入和取出。<br>\n举个栗子：<br>\n这里有一个Fruit类和他的派生类Apple类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fruit</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Apple</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fruit</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>接着我们设定一个容器，并设定他有存取功能</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Plate</span>&lt;<span class=\"title\">T</span>&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T item;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Plate</span><span class=\"params\">(T t)</span></span>&#123;item=t;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T t)</span></span>&#123;item=t;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> item;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们现在有一个想法就是生成一个用来装“苹果”的“水果盘子”，想像是美好的，现实却是不允许的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Plate&lt;Fruit&gt; p=<span class=\"keyword\">new</span> Plate&lt;Apple&gt;(<span class=\"keyword\">new</span> Apple());    <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n<p>编译器的想法是：苹果属于水果。但是装苹果的盘子却不属于装水果的盘子，其实想想也在理，这之间有一个关系存在，前者属于继承关系，后者仅仅是参数上存在着联系，对于Plate在没有一个参数限定的条件下是不能随意进行等价的。这就是通配符要有一个上下边界的范围限定的原因。</p>\n<h3 id=\"&lt;-?-extends-t-&gt;\">&lt; ? extends T &gt;<a title=\"#&lt;-?-extends-t-&gt;\" href=\"#&lt;-?-extends-t-&gt;\"></a></h3>\n<p>上界通配符，指的是所有的子类及其本身类型。还是上边的例子变换成Plate&lt; ? extends Fruit &gt;意思就可以是装所有水果的盘子，不一定是哪种水果，有可能是Fruit本身也有可能就是Apple.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Plate&lt;？extends Fruit&gt; p=<span class=\"keyword\">new</span> Plate&lt;Apple&gt;(<span class=\"keyword\">new</span> Apple());</span><br></pre></td></tr></table></figure>\n<p>这样就说的过去了，总有一个是属于我（苹果）的。接下来就可以调用盘子里的方法了。但是并不是所有的方法都能调用，设定上届通配符可以取数据但是不允许存入数据的，除了null。编译器看到Plate&lt; ? extends Fruit&gt;只知道盘子里将来放的是Fruit或者他的孩子，而具体是什么并不知道，所以编译器在这里仅仅给以一个占位符：CAP#1，来表示捕获一个Fruit或Fruit的子类，具体是什么类不知道，然后无论是想往里插入Apple或者Fruit编译器都不知道能不能和这个CAP#1匹配，所以就都不允许。另外，读取数据时也只能存放在Fruit或者Fruit基类中，因为不能确定到底是哪种类型，否则不得不进行类型判断或者强转了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Plate&lt;? extends Fruit&gt; p=<span class=\"keyword\">new</span> Plate&lt;Apple&gt;(<span class=\"keyword\">new</span> Apple());</span><br><span class=\"line\"><span class=\"comment\">//不能存入任何元素</span></span><br><span class=\"line\">p.set(<span class=\"keyword\">new</span> Fruit());    <span class=\"comment\">//Error</span></span><br><span class=\"line\">p.set(<span class=\"keyword\">new</span> Apple());    <span class=\"comment\">//Error</span></span><br><span class=\"line\">p.set(<span class=\"keyword\">null</span>); \t</span><br><span class=\"line\"><span class=\"comment\">//读取出来的东西只能存放在Fruit或它的基类里。</span></span><br><span class=\"line\">Fruit newFruit1=p.get();</span><br><span class=\"line\">Object newFruit2=p.get();</span><br><span class=\"line\">Apple newFruit3=p.get();    <span class=\"comment\">//Error</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"&lt;-?-super-t-&gt;\">&lt; ? super T &gt;<a title=\"#&lt;-?-super-t-&gt;\" href=\"#&lt;-?-super-t-&gt;\"></a></h3>\n<p>下届通配符，指的是Fruit本身以及所有Fruit的基类，有可能是Foot或者Object。但是要明白一点Plate&lt; ? super Fruit &gt;的基类不是Plate&lt; Apple &gt;的基类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Plate&lt;? <span class=\"keyword\">super</span> Fruit&gt; p=<span class=\"keyword\">new</span> Plate&lt;Apple&gt;(<span class=\"keyword\">new</span> Apple());  <span class=\"comment\">//Error</span></span><br></pre></td></tr></table></figure>\n<p>使用下界&lt; ? super Fruit &gt;会使从盘子里取东西的get( )方法部分失效，只能存放到Object对象里，还是因为不能确定到底是哪种类型，只能基类来接收。set( )方法正常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Plate&lt;? <span class=\"keyword\">super</span> Fruit&gt; p=<span class=\"keyword\">new</span> Plate&lt;Fruit&gt;(<span class=\"keyword\">new</span> Fruit());</span><br><span class=\"line\"><span class=\"comment\">//存入元素正常</span></span><br><span class=\"line\">p.set(<span class=\"keyword\">new</span> Fruit());</span><br><span class=\"line\">p.set(<span class=\"keyword\">new</span> Apple());</span><br><span class=\"line\"><span class=\"comment\">//读取出来的东西只能存放在Object类里。</span></span><br><span class=\"line\">Apple newFruit3=p.get();    <span class=\"comment\">//Error</span></span><br><span class=\"line\">Fruit newFruit1=p.get();    <span class=\"comment\">//Error</span></span><br><span class=\"line\">Object newFruit2=p.get();</span><br></pre></td></tr></table></figure>\n<h4 id=\"extends、super选取\">extends、super选取<a title=\"#extends、super选取\" href=\"#extends、super选取\"></a></h4>\n<p>1.频繁往外读取内容的，适合用上界extends。<br>\n2.经常往里插入的，适合用下界super。</p>\n<h2 id=\"类型擦除\">类型擦除<a title=\"#类型擦除\" href=\"#类型擦除\"></a></h2>\n<p>泛型只在编译阶段有用，在进入JVM之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。</p>\n<p>java1.5版本之前是没有泛型的，1.5版本引入泛型概念，为了和之前的版本能够很好兼容，这里采用了类型擦数的方式。</p>\n<p>看下面的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; a = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();  </span><br><span class=\"line\">List b = <span class=\"keyword\">new</span> ArrayList();  </span><br><span class=\"line\">Class c1 = a.getClass();  </span><br><span class=\"line\">Class c2 = b.getClass();  </span><br><span class=\"line\">System.out.println(c1 == c2); <span class=\"comment\">//true  </span></span><br></pre></td></tr></table></figure>\n<p>上面程序的输出结果为true。所有反射的操作都是在运行时的，既然为true，就证明了编译之后，程序会采取去泛型化的措施，也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦除，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。</p>\n<p>上述结论可通过下面反射的例子来印证：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;String&gt; a = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();  </span><br><span class=\"line\">a.add(<span class=\"string\">&quot;CSDN&quot;</span>);  </span><br><span class=\"line\">Class c = a.getClass();  </span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;  </span><br><span class=\"line\">    Method method = c.getMethod(<span class=\"string\">&quot;add&quot;</span>,Object.class);  </span><br><span class=\"line\">    method.invoke(a,<span class=\"number\">100</span>);  </span><br><span class=\"line\">    System.out.println(a);  </span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(Exception e)&#123;  </span><br><span class=\"line\">    e.printStackTrace();  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>因为绕过了编译阶段也就绕过了泛型，输出结果为：<br>\n[CSDN, 100]</p>\n<h3 id=\"泛型擦除规则\">泛型擦除规则<a title=\"#泛型擦除规则\" href=\"#泛型擦除规则\"></a></h3>\n<p>并不是所有的泛型参数类型擦除后都是Object类型，类型擦除是有规则的：</p>\n<blockquote>\n<p>泛型擦除就是类型变量用第一个限定来替换,如果没有给定限定就用Object替换,例如类Pair<T>中的类型变量没有限定所以用Object替换。</p>\n</blockquote>\n<p>看个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Interval</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span> &amp; <span class=\"title\">Serializable</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T lower;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T upper;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Interval</span><span class=\"params\">(T first, T second)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.compareTo(second) &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            lower = second;</span><br><span class=\"line\">            upper = first;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            lower = first;</span><br><span class=\"line\">            upper = second;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>擦除后的原始类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Interval</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Comparable lower;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Comparable upper;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Interval</span><span class=\"params\">(Comparable first, Comparable second)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时把限定改为Interval&lt;T extends Serializable &amp; Comparable&gt;则原始类型就用Serializable替换T,而编译器会在需要的时候插入强制类型转换为Comparable,为了提高效率,我们应该把没有方法的接口放在后面。</p>\n<h3 id=\"翻译泛型方法\">翻译泛型方法<a title=\"#翻译泛型方法\" href=\"#翻译泛型方法\"></a></h3>\n<p>你可能会有疑问，泛型擦除后非限定的类型转换成Object，编译前进行引用时并没有进行类型转换，还能够正常运行，这是怎么回事呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pair&lt;Manager&gt; pair = ...;</span><br><span class=\"line\">Manager manager = pair.getFirst();</span><br></pre></td></tr></table></figure>\n<p>这里引入&quot;翻译泛型表达式&quot;概念：在程序调用泛型方法的时候，如果返回值被擦除，编译器会插入强制的类型转换。<br>\n擦除后getFirst返回值为Object,编译器会自动插入Manager强制类型转换,所以getFirst()方法会执行如下两个指令：</p>\n<ul>\n<li>对原始方法调用getFirst()</li>\n<li>把返回值Object强转成Manager</li>\n</ul>\n<h2 id=\"类型擦除带来的问题\">类型擦除带来的问题<a title=\"#类型擦除带来的问题\" href=\"#类型擦除带来的问题\"></a></h2>\n<p>因为种种原因，Java不能实现真正的泛型，只能使用类型擦除来实现伪泛型，这样虽然不会有类型膨胀的问题，但是也引起了许多新的问题。所以，Sun对这些问题作出了许多限制，避免我们犯各种错误。</p>\n<p><strong>1.类型擦除与多态冲突</strong><br>\n假设有一个超类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span>&lt;<span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">(T value)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;This is Parent Class, value is &quot;</span> + value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以及一个子类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Parent</span>&lt;<span class=\"title\">String</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">(String value)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;This is Child class, value is &quot;</span> + value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后有以下测试代码，企图实现多态：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainApp</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Child child = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\">        Parent&lt;String&gt; parent = child;</span><br><span class=\"line\"></span><br><span class=\"line\">        parent.sayHello(<span class=\"string\">&quot;This is a string&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>按照泛型类型擦除原则，父类中是sayHello(Object value)，子类中还是sayHello(String value)，这两个根本不是重写关系，而是重载，这不是多态的形式，所以你会感觉冲突了吧，但是结果是可以正常运行，这是怎么回事？</p>\n<p>原因是编译器在Child类中自动生成了一个<strong>桥方法</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">(Object value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    sayHello((String) value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出，这个桥方法实际上就是对超类中sayHello(Obejct)的重写。这样做的原因是，当程序员在子类中写下以下这段代码的时候，本意是对超类中的同名方法进行重写，但因为超类发生了类型擦除，所以实际上并没有重写成功，因此加入了桥方法的机制来避免类型擦除与多态发生冲突。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Parent</span>&lt;<span class=\"title\">String</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">(String value)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;This is Child class, value is &quot;</span> + value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>桥方法并不需要自己手动生成，一切都是编译器自动完成的。</p>\n<p><strong>2.泛型类型变量不能是基本数据类型</strong><br>\n不能用类型参数替换基本类型。就比如，没有ArrayList<double>，只有ArrayList<Double>。因为当类型擦除后，ArrayList的原始类型变为Object，但是Object类型不能存储double值，只能引用Double的值。</p>\n<p><strong>3.使用泛型不能在运行时进行类型匹配查询</strong><br>\n例如：若定义<code>ArrayList&lt;String&gt; arrayList=new ArrayList&lt;String&gt;();</code>则不能使用<code>if( arrayList instanceof ArrayList&lt;String&gt;)</code>，此时运行时会报错。因为类型擦除之后，ArrayList<String>只剩下原始类型，泛型信息String不存在了。</p>\n<p><strong>4.不能抛出也不能捕获泛型类的对象</strong><br>\n例如下面的定义将不会通过编译：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Problem</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Exception</span></span>&#123;......&#125; </span><br></pre></td></tr></table></figure>\n<p>假如上述代码成立，则：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;  </span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(Problem&lt;Integer&gt; e1)&#123;  </span><br><span class=\"line\">。。  </span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(Problem&lt;Number&gt; e2)&#123;  </span><br><span class=\"line\">...  </span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure>\n<p>根据类型擦除性质，泛型类型擦除后两个catch都变为原始类型Object类型，也就是说两个catch一模一样，这不符合常规，当然不能通过。</p>\n<p>不能在catch条件中使用泛型变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T extends Throwable&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doWork</span><span class=\"params\">(Class&lt;T&gt; t)</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;  </span><br><span class=\"line\">        ...  </span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(T e)&#123; <span class=\"comment\">//编译错误  </span></span><br><span class=\"line\">        ...  </span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(IndexOutOfBounds e)&#123;  </span><br><span class=\"line\">    &#125;                           </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>根据异常捕获的原则，一定是子类在前面，父类在后面，那么上面就违背了这个原则。所以java为了避免这样的情况，禁止在catch子句中使用泛型变量。</p>\n<p><strong>5.泛型类型不能直接实例化</strong><br>\n不能实例化泛型类型:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T first = <span class=\"keyword\">new</span> T(); <span class=\"comment\">//ERROR</span></span><br></pre></td></tr></table></figure>\n<p>类型擦除会使这个操作做成new Object()。</p>\n<p>不能实例化数组</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>&lt;T&gt; T[] minMax(T[] a)&#123;  </span><br><span class=\"line\">    T[] mm = <span class=\"keyword\">new</span> T[<span class=\"number\">2</span>]; <span class=\"comment\">//ERROR  </span></span><br><span class=\"line\">    ...  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>擦除会使这个方法总是构靠一个Object[2]数组</p>\n<p><strong>6.条件不能与擦除后的原型类产生冲突</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt;   </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(T value)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>考虑一个Pair<String>。从概念上，它有两个equals方法：<br>\nbooleanequals(String); //在Pair<T>中定义<br>\nboolean equals(Object); //从object中继承<br>\n擦除后方法变成了：<br>\nboolean equals(Object)<br>\n这与Object.equals方法发生了冲突，补救的办法就是重新命名引发错误的方法。</p>\n<p><strong>7.泛型在静态方法和静态类中的问题</strong><br>\n泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数。<br>\n例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test2</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> T one;   <span class=\"comment\">//编译错误    </span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>  T <span class=\"title\">show</span><span class=\"params\">(T one)</span></span>&#123; <span class=\"comment\">//编译错误    </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;    </span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure>\n<p>因为泛型类中的泛型参数的实例化是在定义对象的时候指定的，而静态变量和静态方法不需要使用对象来调用。对象都没有创建，如何确定这个泛型参数是何种类型，所以当然是错误的。</p>\n<p>静态泛型方法是可以使用泛型参数的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test2</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T &gt;<span class=\"function\">T <span class=\"title\">show</span><span class=\"params\">(T one)</span></span>&#123;<span class=\"comment\">//这是正确的    </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;    </span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure>\n<p>因为这是一个泛型方法，在泛型方法中使用的T是自己在方法中定义的T，而不是泛型类中的T。</p>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<ul>\n<li>《Java编程思想》</li>\n<li><a href=\"https://blog.csdn.net/lonelyroamer/article/details/7868820\">https://blog.csdn.net/lonelyroamer/article/details/7868820</a></li>\n</ul>\n","prev":{"title":"Android多CPU适配总结","link":"post/1521647039"},"next":{"title":"Service的生命周期和启动方式等相关总结","link":"post/1519660975"},"plink":"https://blog.ixin.run/post/1521043691/","toc":[{"id":"什么是泛型","title":"什么是泛型","index":"1"},{"id":"泛型的使用","title":"泛型的使用","index":"2","children":[{"id":"泛型接口","title":"泛型接口","index":"2.1"},{"id":"泛型类","title":"泛型类","index":"2.2"},{"id":"泛型方法","title":"泛型方法","index":"2.3"},{"id":"泛型方法与泛型类共存","title":"泛型方法与泛型类共存","index":"2.4"}]},{"id":"通配符-？","title":"通配符 ？","index":"3","children":[{"id":"&lt;-?-extends-t-&gt;","title":"&lt; ? extends T &gt;","index":"3.1"},{"id":"&lt;-?-super-t-&gt;","title":"&lt; ? super T &gt;","index":"3.2"}]},{"id":"类型擦除","title":"类型擦除","index":"4","children":[{"id":"泛型擦除规则","title":"泛型擦除规则","index":"4.1"},{"id":"翻译泛型方法","title":"翻译泛型方法","index":"4.2"}]},{"id":"类型擦除带来的问题","title":"类型擦除带来的问题","index":"5"},{"id":"参考","title":"参考","index":"6"}],"reward":true,"copyright":{"custom":"转载请注明出处，谢谢支持。"}}