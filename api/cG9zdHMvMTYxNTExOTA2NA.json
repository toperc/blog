{"title":"你了解android的进程间通信吗","date":"2021-03-07T12:10:40.000Z","date_formatted":{"ll":"2021年3月7日","L":"2021/03/07","MM-DD":"03-07"},"link":"posts/1615119064","comments":true,"tags":["Android","进程间通信"],"categories":["Android"],"updated":"2021-03-10T01:15:14.497Z","content":"<p>你了解android的进程间通信吗？提到进程间通信，这是android开发中很重要的一环，也是面试高频知识点，本文总结一下进程间通信的几种方式，把这块知识系统起来。</p>\n<a id=\"more\"></a>\n<h2 id=\"什么是进程间通信\">什么是进程间通信<a title=\"#什么是进程间通信\" href=\"#什么是进程间通信\"></a></h2>\n<p>进程间通信（IPC，Interprocess communication）是一组编程接口，让程序员能够协调不同的进程，使之能在一个操作系统里同时运行，并相互传递、交换信息。</p>\n<h2 id=\"如何开启多进程\">如何开启多进程<a title=\"#如何开启多进程\" href=\"#如何开启多进程\"></a></h2>\n<p>正常情况下，在Android中多进程是指一个应用中存在多个进程的情况，因此这里不讨论两个应用之间的多进程情况。<strong>在Android中上层应用开发使用多进程唯一一种方法，那就是给四大组件（Activity、Service、Receiver、ContentProvider）在AndroidMenifest中指定android:process属性</strong>。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">&lt;activity</span><br><span class=\"line\">    android:name=&quot;com.ryg.chapter_2.SecondActivity&quot;</span><br><span class=\"line\">    android:configChanges=&quot;screenLayout&quot;</span><br><span class=\"line\">    android:label=&quot;@string/app_name&quot;</span><br><span class=\"line\">    android:process=&quot;:remote&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;activity</span><br><span class=\"line\">    android:name=&quot;com.ryg.chapter_2.ThirdActivity&quot;</span><br><span class=\"line\">    android:configChanges=&quot;screenLayout&quot;</span><br><span class=\"line\">    android:label=&quot;@string/app_name&quot;</span><br><span class=\"line\">    android:process=&quot;com.ryg.chapter_2.remote&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<p>上面的示例分别为SecondActivity和ThirdActivity指定了process属性，并且它们的属性值不同，这意味着当前应用又增加了两个新进程。</p>\n<p>其中SecondActivity和ThirdActivity的android:process属性分别为“:remote”和“com.ryg.chapter_2.remote”，这两种方式是有区别的：</p>\n<ul>\n<li>首先，“:”的含义是指要在当前的进程名前面附加上当前的包名，这是一种简写的方法，对于SecondActivity来说，它完整的进程名为com.ryg.chapter_2:remote，而对于ThirdActivity中的声明方式，它是一种完整的命名方式，不会附加包名信息；</li>\n<li>其次，<strong>进程名以“:”开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一个进程中，而进程名不以“:”开头的进程属于全局进程，其他应用通过ShareUID方式可以和它跑在同一个进程中。</strong></li>\n</ul>\n<p>Android系统会为每个应用分配一个唯一的UID。通常，不同的APK会具有不同的userId，因此运行时属于不同的进程中，而不同进程中的资源是不共享的，然后有些时候，我们自己公司开发了多个APK并且需要他们之间互相共享资源，那么就可以通过设置<strong>相同的shareUserId和相同的签名</strong>来实现这一目的。</p>\n<h2 id=\"多进程影响\">多进程影响<a title=\"#多进程影响\" href=\"#多进程影响\"></a></h2>\n<p>我们知道<strong>Android为每一个应用分配了一个独立的虚拟机，或者说为每个进程都分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，这就导致在不同的虚拟机中访问同一个类的对象会产生多份副本</strong>。</p>\n<p>所以，所有运行在不同进程中的四大组件，只要它们之间需要通过内存来共享数据，都会共享失败，这也是多进程所带来的主要影响。一般来说，使用多进程会造成如下几方面的问题：</p>\n<ul>\n<li>（1）静态成员和单例模式完全失效。\n<ul>\n<li>静态成员属于类，不属于对象</li>\n<li>因为单例模式想要保证全局只有一个对象，多进程会有多个副本了，那也就不能保证全局只有一个对象了，也就失去了作用了</li>\n</ul>\n</li>\n<li>（2）线程同步机制完全失效。</li>\n<li>（3）SharedPreferences的可靠性下降。</li>\n<li>（4）Application会多次创建。</li>\n</ul>\n<h2 id=\"ipc有哪些方式\">IPC有哪些方式<a title=\"#ipc有哪些方式\" href=\"#ipc有哪些方式\"></a></h2>\n<p>有问题就要有解决，为了解决这些问题，系统提供了很多跨进程通信方法，虽然说不能直接地共享内存，但是通过跨进程通信我们还是可以实现数据交互。</p>\n<p>关于Android中的进程间通信，大概可以通过以下方式进行：</p>\n<ul>\n<li>Bundle：四大组件间通信</li>\n<li>File：文件共享</li>\n<li>AIDL：Binder机制</li>\n<li>Messager：基于AIDL、Handler实现</li>\n<li>ContentProvider：应用间数据共享</li>\n<li>Socket：建立C/S通信模型</li>\n</ul>\n<h3 id=\"使用bundle\">使用Bundle<a title=\"#使用bundle\" href=\"#使用bundle\"></a></h3>\n<p>四大组件中的三大组件（Activity、Service、Receiver）都是支持在Intent中传递Bundle数据的，由于Bundle实现了Parcelable接口，所以它可以方便地在不同的进程间传输，这里说明一点ContentProvider的call方法可以使用Bundle，而在其他方法中不能使用。</p>\n<p>另外，Bundle不支持的类型我们无法通过它在进程间传递数据，这不用说了。</p>\n<h3 id=\"使用file（文件共享）\">使用File（文件共享）<a title=\"#使用file（文件共享）\" href=\"#使用file（文件共享）\"></a></h3>\n<p>共享文件也是一种不错的进程间通信方式，两个进程通过读/写同一个文件来交换数据，比如A进程把数据写入文件，B进程通过读取这个文件来获取数据。</p>\n<p>由于Android系统基于Linux，使得其并发读/写文件可以没有限制地进行，甚至两个线程同时对同一个文件进行写操作都是允许的，那么我们读出的内容就有可能不是最新的，如果是并发写的话那就更严重了。</p>\n<p>普通文件并发执行，如果妥善处理并发的速度和频率或许可以保证数据的准确性。然而SharedPreferences是个特例，<strong>从本质上来说，SharedPreferences也属于文件的一种，但是由于系统对它的读/写有一定的缓存策略，即在内存中会有一份SharedPreferences文件的缓存，因此在多进程模式下，系统对它的读/写就变得不可靠，当面对高并发的读/写访问，Sharedpreferences有很大几率会丢失数据，因此，不建议在进程间通信中使用SharedPreferences</strong>。</p>\n<h3 id=\"使用messenger\">使用Messenger<a title=\"#使用messenger\" href=\"#使用messenger\"></a></h3>\n<p>Messenger可以翻译为信使，顾名思义，通过它可以在不同进程中传递Message（信息）对象，在Messenger（信使）中进行数据传递必须将数据放入Message（信息）中，而Messenger和Message都实现了Parcelable接口，因此可以跨进程传输。</p>\n<p>Messenger是一种轻量级的IPC方案，它的底层实现是AIDL：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Messenger</span><span class=\"params\">(Handler target)</span> </span>&#123;</span><br><span class=\"line\">     mTarget = target.getIMessenger();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Messenger</span><span class=\"params\">(IBinder target)</span> </span>&#123;</span><br><span class=\"line\">     mTarget = IMessenger.Stub.asInterface(target);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Messenger的使用方法很简单，它对AIDL做了封装，使得我们可以更简便地进行进程间通信。同时，由于它一次处理一个请求，因此在服务端我们不用考虑线程同步的问题，这是因为服务端中不存在并发执行的情形。</p>\n<p><strong>Messager一般用在同一个应用多个不同进程服务的通信处理</strong>，下边通过代码描述一下服务端和客户端两个过程Messager通信实现过程：</p>\n<p><strong>服务端进程</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessengerService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">&quot;MessengerService&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//继承Handler，MessengerHandler用来处理客户端发送的消息，并从消息中取出客户端发来的文本信息。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessengerHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MyConstants.MSG_FROM_CLIENT:</span><br><span class=\"line\">                Log.i(TAG, <span class=\"string\">&quot;receive msg from Client:&quot;</span> + msg.getData().getString(<span class=\"string\">&quot;msg&quot;</span>));</span><br><span class=\"line\">                <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">                 * 因为我们的Messenger是通过客户端来获取的，而在客户端那边这个Messenger是以Handler为参数创建的，</span></span><br><span class=\"line\"><span class=\"comment\">                 * 所以在服务端通过客户端的Messenger发送消息后，在客户端的Handler就会处理这条消息，</span></span><br><span class=\"line\"><span class=\"comment\">                 * 嘻嘻，就达到了消息传送的目的。</span></span><br><span class=\"line\"><span class=\"comment\">                 */</span></span><br><span class=\"line\">                Messenger client = msg.replyTo;</span><br><span class=\"line\">                Message relpyMessage = Message.obtain(<span class=\"keyword\">null</span>, MyConstants.MSG_FROM_SERVICE);</span><br><span class=\"line\">                Bundle bundle = <span class=\"keyword\">new</span> Bundle();</span><br><span class=\"line\">                bundle.putString(<span class=\"string\">&quot;reply&quot;</span>, <span class=\"string\">&quot;嗯，你的消息我已经收到，稍后会回复你。&quot;</span>);</span><br><span class=\"line\">                relpyMessage.setData(bundle);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    client.send(relpyMessage);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">super</span>.handleMessage(msg);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这是我们服务端自己的Messenger，它是以上面的Handler对象为参数创建的，</span></span><br><span class=\"line\">    <span class=\"comment\">//这个Messenger是要通过绑定该服务器的时候onBind方法传递给客户端，然后客户端获取了该Messenger，</span></span><br><span class=\"line\">    <span class=\"comment\">//再以该Messenger来发送消息，这样服务端就可以接收到该消息并处理。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Messenger mMessenger = <span class=\"keyword\">new</span> Messenger(<span class=\"keyword\">new</span> MessengerHandler());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这个方法是在绑定服务的过程中调用的并将结果返回给客户端的，所以通过onBind方法客户端就可以获取我们Messenger的Binder对象了，</span></span><br><span class=\"line\">    <span class=\"comment\">//然后客户端可以根据该Binder对象来创建一个Messenger，这样客户端中用的Messenger和这里的Messenger就是向对应的了。</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mMessenger.getBinder();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">onStartCommand</span><span class=\"params\">(Intent intent, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> startId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onStartCommand(intent, flags, startId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，注册service，让其运行在单独的进程中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;service</span><br><span class=\"line\">      android:name=<span class=\"string\">&quot;com.ryg.chapter_2.messenger.MessengerService&quot;</span></span><br><span class=\"line\">      android:process=<span class=\"string\">&quot;:remote&quot;</span> &gt;</span><br></pre></td></tr></table></figure>\n<p><strong>客户端进程</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessengerActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">&quot;MessengerActivity&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Messenger mService;</span><br><span class=\"line\">    <span class=\"comment\">//准备一个接收消息的Messenger和Handler</span></span><br><span class=\"line\">    <span class=\"comment\">//这是客户端自己的Messenger，传递给服务端，让服务端返回消息用的。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Messenger mGetReplyMessenger = <span class=\"keyword\">new</span> Messenger (<span class=\"keyword\">new</span> MessengerHandler ());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessengerHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> MyConstants.MSG_FROM_SERVICE:</span><br><span class=\"line\">                    Log.i (TAG, <span class=\"string\">&quot;receive msg from Service:&quot;</span> + msg.getData ().getString (<span class=\"string\">&quot;reply&quot;</span>));</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">super</span>.handleMessage (msg);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 这个是客户端用来绑定服务端用的，在绑定过程中会调用onServiceConnected，它的第二个参数IBinder service，</span></span><br><span class=\"line\"><span class=\"comment\">     * 就是在服务端中onBind方法返回的结果，这个结果是服务端的Messenger对象的Binder对象，</span></span><br><span class=\"line\"><span class=\"comment\">     * 然后客户端通过这个Binder对象就可以创建一个Messenger，</span></span><br><span class=\"line\"><span class=\"comment\">     * 所以就是在绑定服务的过程中将服务端的Messenger传递给了客户端，建立起了两者之间的桥梁</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ServiceConnection mConnection = <span class=\"keyword\">new</span> ServiceConnection () &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceConnected</span><span class=\"params\">(ComponentName className, IBinder service)</span> </span>&#123;</span><br><span class=\"line\">            mService = <span class=\"keyword\">new</span> Messenger (service);</span><br><span class=\"line\">            Log.d (TAG, <span class=\"string\">&quot;bind service&quot;</span>);</span><br><span class=\"line\">            Message msg = Message.obtain (<span class=\"keyword\">null</span>, MyConstants.MSG_FROM_CLIENT);</span><br><span class=\"line\">            Bundle data = <span class=\"keyword\">new</span> Bundle ();</span><br><span class=\"line\">            data.putString (<span class=\"string\">&quot;msg&quot;</span>, <span class=\"string\">&quot;hello, this is client.&quot;</span>);</span><br><span class=\"line\">            msg.setData (data);</span><br><span class=\"line\">            <span class=\"comment\">//把接收服务端回复的Messenger通过Message的replyTo参数传递给服务端</span></span><br><span class=\"line\">            msg.replyTo = mGetReplyMessenger;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                mService.send (msg);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">                e.printStackTrace ();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceDisconnected</span><span class=\"params\">(ComponentName className)</span> </span>&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate (savedInstanceState);</span><br><span class=\"line\">        setContentView (R.layout.activity_messenger);</span><br><span class=\"line\">        Intent intent = <span class=\"keyword\">new</span> Intent (<span class=\"string\">&quot;com.ryg.MessengerService.launch&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//在bindService的时候，服务端会通过onBind方法返回一个包含了服务端业务调用的Binder对象，</span></span><br><span class=\"line\">        <span class=\"comment\">//通过这个对象，客户端就可以获取服务端提供的服务或者数据，</span></span><br><span class=\"line\">        bindService (intent, mConnection, Context.BIND_AUTO_CREATE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        unbindService (mConnection);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDestroy ();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>客户端的实现也比较简单，首先需要绑定远程进程的MessengerService，绑定成功后，根据服务端返回的binder对象创建Messenger对象并使用此对象向服务端发送消息。</p>\n<p>Messenger的工作原理图：</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/99E3FC29F03D45239EACDDA98CC7284A?method=download&amp;shareKey=cc0657542f6fae5a93ad4381da6362a6\" alt=\"Messenger的工作原理图\" class=\"φbs\"></p>\n<p>Messenger是以串行的方式处理客户端发来的消息，如果大量的消息同时发送到服务端，服务端仍然只能一个个处理，如果有大量的并发请求，那么用Messenger就不太合适了。同时，Messenger的作用主要是为了传递消息，很多时候我们可能需要跨进程调用服务端的方法，这种情形用Messenger就无法做到了。但是我们可以使用AIDL来实现跨进程的方法调用。</p>\n<h3 id=\"使用aidl\">使用AIDL<a title=\"#使用aidl\" href=\"#使用aidl\"></a></h3>\n<p>AIDL，一种接口定义语言，用于约束两个进程之间的通讯规则，供编译器生成代码实现Android设备的IPC。AIDL也是Messenger的底层实现，因此Messenger本质上也是AIDL，只不过系统为我们做了封装从而方便上层的调用而已。</p>\n<p>AIDL方式主要用于两个应用间数据传输和方法调用实现。这里简单描述一下服务端和客户端AIDL各自的工作：</p>\n<ol>\n<li><strong>服务端</strong>：服务端首先要创建一个Service用来监听客户端的连接请求，然后创建一个AIDL文件，将暴露给客户端的接口在这个AIDL文件中声明，最后在Service中实现这个AIDL接口即可</li>\n<li><strong>客户端</strong>：客户端所要做事情就稍微简单一些，首先需要绑定服务端的Service，绑定成功后，将服务端返回的Binder对象转成AIDL接口所属的类型，接着就可以调用AIDL中的方法了。</li>\n</ol>\n<p>AIDL具体使用可参看我早前写的一篇文章<a href=\"https://blog.ixin.run/posts/1469856029\" target=\"_blank\">《Android开发之进程间通信AIDL的探究和学习》</a></p>\n<p>AIDL方法是在服务端的Binder线程池中执行的，因此当多个客户端同时连接的时候，会存在多个线程同时访问的情形，所以我们要在AIDL方法中处理线程同步，如果是用List存储对象，那么可更换为CopyonWriteArayList来进行自动的线程同步，下边实现一个aidl接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义aidl接口</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IBookManager</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">List&lt;Book&gt; <span class=\"title\">getBookList</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addBook</span><span class=\"params\">(in Book book)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实现aidl接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BookManagerService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">&quot;BookManagerService&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> CopyOnWriteArrayList&lt;Book&gt; mBookList = <span class=\"keyword\">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Binder mBinder = <span class=\"keyword\">new</span> IBookManager.Stub() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Book&gt; <span class=\"title\">getBookList</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mBookList;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addBook</span><span class=\"params\">(Book book)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">            mBookList.add(book);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\"></span><br><span class=\"line\">        mBookList.add(<span class=\"keyword\">new</span> Book(<span class=\"number\">1</span>,<span class=\"string\">&quot;Android&quot;</span>));</span><br><span class=\"line\">        mBookList.add(<span class=\"keyword\">new</span> Book(<span class=\"number\">1</span>,<span class=\"string\">&quot;IOS&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mBinder;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AIDL工作原理图：</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/BEC0091BAA504AF28B98A436B31FB5EE?method=download&amp;shareKey=fff00c3f93105cdfb27fb64bd1e13fd1\" alt=\"AIDL工作原理图\" class=\"φbs\"></p>\n<h3 id=\"使用contentprovider\">使用ContentProvider<a title=\"#使用contentprovider\" href=\"#使用contentprovider\"></a></h3>\n<p>ContentProvider是Android中提供的专门用于不同应用间进行数据共享的方式，从这一点来看，它天生就适合进程间通信。和Messenger一样，ContentProvider的底层实现同样也是Binder，但是它的使用过程要比AIDL简单许多，这是因为系统已经为我们做了封装，使得我们无须关心底层细节即可轻松实现IPC。</p>\n<p>系统预置了许多ContentProvider，比如通讯录信息、日程表信息等，要跨进程访问这些信息，只需要通过ContentResolver的query、update、insert和delete方法即可。</p>\n<p>ContentProvider的使用可参看我之前的一篇文章<a href=\"https://blog.ixin.run/posts/1552144290\" target=\"_blank\">《Android开发ContentProvider学习总结》</a></p>\n<h3 id=\"使用socket\">使用Socket<a title=\"#使用socket\" href=\"#使用socket\"></a></h3>\n<p>Socket也称为“套接字”，是网络通信中的概念，它分为流式套接字和用户数据报套接字两种，分别对应于网络的传输控制层中的TCP和UDP协议。</p>\n<ul>\n<li>TCP协议是面向连接的协议，提供稳定的双向通信功能，TCP连接的建立需要经过“三次握手”才能完成，为了提供稳定的数据传输功能，其本身提供了超时重传机制，因此具有很高的稳定性；</li>\n<li>而UDP是无连接的，提供不稳定的单向通信功能，当然UDP也可以实现双向通信功能。</li>\n<li>在性能上，UDP具有更好的效率，其缺点是不保证数据一定能够正确传输，尤其是在网络拥塞的情况下。</li>\n</ul>\n<p>两个进程可以通过Socket来实现信息的传输，Socket本身可以支持传输任意字节流，很显然，这是一种IPC方式。</p>\n<p>Socket的使用可参看我之前的一篇文章<a href=\"https://blog.ixin.run/posts/1472485045\" target=\"_blank\">《Java开发揭开socket编程的面纱》</a></p>\n<h2 id=\"选择合适的ipc\">选择合适的IPC<a title=\"#选择合适的ipc\" href=\"#选择合适的ipc\"></a></h2>\n<p>不同IPC方式有不同适用场景，在实际的开发中，只要我们选择合适的IPC方式就可以轻松完成多进程的开发场景。</p>\n<p>IPC方式的优缺点和适用场景表：</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/0C970C0EDEBC48698791BD20746EF290?method=download&amp;shareKey=a086369266bf1f831b2793faeb30121e\" alt=\"IPC方式的优缺点和适用场景\" class=\"φbs\"></p>\n<p>RPC(Remote Procedure Call)：远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的思想。特指一种隐藏了过程调用时实际通信细节的IPC方法。而IPC概念泛指进程之间任何形式的通信行为。</p>\n<p>这里再对比上表总结一下：</p>\n<ul>\n<li>只有允许不同应用的客户端用 IPC 方式调用远程方法，并且想要在服务中处理多线程时，才有必要使用 <code>AIDL</code></li>\n<li>如果需要调用远程方法，但不需要处理并发 IPC，就应该通过实现一个 <code>Binder</code> 创建接口</li>\n<li>如果您想执行 IPC，但只是传递数据，不涉及方法调用，也不需要高并发，就使用 <code>Messenger</code> 来实现接口</li>\n<li>如果需要处理一对多的进程间数据共享（主要是数据的 CRUD），就使用 <code>ContentProvider</code></li>\n<li>如果要实现一对多的并发实时通信，就使用 <code>Socket</code></li>\n</ul>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<ul>\n<li>《Android开发艺术探索》</li>\n<li><a href=\"https://developer.android.com/reference/android/os/Binder\">https://developer.android.com/reference/android/os/Binder</a></li>\n</ul>\n","prev":{"title":"Http协议原理知多少","link":"posts/1615211970"},"next":{"title":"Android开发数据持久化有哪些形式","link":"posts/1615050026"},"plink":"https://blog.ixin.run/posts/1615119064/","toc":[{"id":"什么是进程间通信","title":"什么是进程间通信","index":"1"},{"id":"如何开启多进程","title":"如何开启多进程","index":"2"},{"id":"多进程影响","title":"多进程影响","index":"3"},{"id":"ipc有哪些方式","title":"IPC有哪些方式","index":"4","children":[{"id":"使用bundle","title":"使用Bundle","index":"4.1"},{"id":"使用file（文件共享）","title":"使用File（文件共享）","index":"4.2"},{"id":"使用messenger","title":"使用Messenger","index":"4.3"},{"id":"使用aidl","title":"使用AIDL","index":"4.4"},{"id":"使用contentprovider","title":"使用ContentProvider","index":"4.5"},{"id":"使用socket","title":"使用Socket","index":"4.6"}]},{"id":"选择合适的ipc","title":"选择合适的IPC","index":"5"},{"id":"参考","title":"参考","index":"6"}],"reward":true,"copyright":{"author":"i猩人","link":"<a href=\"https://blog.ixin.run/posts/1615119064/\" title=\"你了解android的进程间通信吗\">https://blog.ixin.run/posts/1615119064/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}