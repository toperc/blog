{"title":"Java中对==、equals()、hashcode()三者的理解","date":"2016-12-08T08:57:06.000Z","date_formatted":{"ll":"2016年12月8日","L":"2016/12/08","MM-DD":"12-08"},"link":"post/1481187426","comments":true,"categories":["Java"],"updated":"2021-01-14T08:08:54.907Z","content":"<p>以前看了有关==、equals()、hashcode()这三者的区别和使用，当时感觉就这一点知识能够记住，最近用到这块内容脑海中只有一丝印象却不知具体如何，好记性不如赖笔头，遂再重新总结一下，以便日后信手拈来。</p>\n<a id=\"more\"></a>\n<h2 id=\"==\">==<a title=\"#==\" href=\"#==\"></a></h2>\n<p>对于引用对象而言，比较两个对象引用的是否是同一个对象。比较是的两个引用对象的存储地址是否一样。<br>\n对于基本数据类型而言，比较的就是两个数据的值是否相等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String a &#x3D; &quot;aaa&quot;;</span><br><span class=\"line\">String b &#x3D; &quot;aaa&quot;;</span><br><span class=\"line\">String c &#x3D; new String(&quot;aaa&quot;);</span><br><span class=\"line\">System.out.println(a&#x3D;&#x3D;b);    &#x2F;&#x2F;比较1</span><br><span class=\"line\">System.out.println(a&#x3D;&#x3D;c);     &#x2F;&#x2F;比较2</span><br></pre></td></tr></table></figure>\n<p>结果是：<br>\ntrue<br>\nfalse</p>\n<p>解释：</p>\n<ol>\n<li>String a = &quot;aaa&quot;这种方式的时候java首先在内存中寻找&quot;aaa&quot;字符串，如果有，就把aaa的地址给它，如果没有则创建。因此比较1结果返回true;</li>\n<li>String c = new String(“aaa”)这种方式不论内存中是否存在“aaa”都会开辟一个新的空间来存储c对象，比较2两个引用的地址是不一样的，因此返回false;</li>\n</ol>\n<h2 id=\"equals()\">equals()<a title=\"#equals()\" href=\"#equals()\"></a></h2>\n<p>针对对象而言，equals()和==效果是一样的。但是有一个这样的需求：发新书的时候，两个同学都发了一本语文书，这时候根据书的外观和内容我们可以说这两本语文书是一样的。这里的equals()比较的是两个对象的某些属性值是否相等从而判断两个对象(内容)是否相等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String c &#x3D; new string(&quot;aaa&quot;);</span><br><span class=\"line\">String d &#x3D; new String(&quot;aaa&quot;);</span><br><span class=\"line\">System.out.println(c.equals(d));</span><br></pre></td></tr></table></figure>\n<p>结果是：<br>\ntrue<br>\n深入源码能够发现String类中equals()方法已经进行重写过了。另外JDK中基本数据类型的包装类中equals()方法也已经重写过了，比较的时候都是比较的两个对象的值。</p>\n<h3 id=\"为什么重写equals()\">为什么重写equals()<a title=\"#为什么重写equals()\" href=\"#为什么重写equals()\"></a></h3>\n<p>就像上边的需求，有些时候仅仅是两个对象的某些属性相同就认为两个对象一样，这个时候我们一般要重写对象的equals()方法，重写的目的就是根据某些特定的属性来判断两个对象的是否相等。</p>\n<p>在重写equals方法时，要注意满足离散数学上的特性：</p>\n<ul>\n<li>自反性 ：对任意引用值X，x.equals(x)的返回值一定为true；</li>\n<li>对称性： 对于任何引用值x,y,当且仅当y.equals(x)返回值为true时，x.equals(y)的返回值一定为true;</li>\n<li>传递性：如果x.equals(y)=true, y.equals(z)=true,则x.equals(z)=true；</li>\n<li>一致性：如果参与比较的对象没任何改变，则对象比较的结果也不应该有任何改变；</li>\n<li>非空性：任何非空的引用值X，x.equals(null)的返回值一定为false；</li>\n</ul>\n<h2 id=\"hashcode()\">hashCode()<a title=\"#hashcode()\" href=\"#hashcode()\"></a></h2>\n<p>hashCode()返回的是一个hashCode（hash码），hash码主要用于散列对象作为KEY来标示这个对象的存储位置，功能类似索引一样能够快速查找提取对象。由此可知每个对象的hash码是唯一的（在对象的内存地址基础上经过特定算法返回一个hash码）。</p>\n<h3 id=\"为什么重写hashcode()\">为什么重写hashcode()<a title=\"#为什么重写hashcode()\" href=\"#为什么重写hashcode()\"></a></h3>\n<p>一般情况下我们是不需要重写hashcode()的，Object.hashCode生成规则也有通用约定：</p>\n<ol>\n<li>在一个应用程序执行期间，如果一个对象的equals方法做比较所用到的信息没有被修改的话，那么，对该对象调用hashCode方法多次，它必须始终如一地返回 同一个整数。在同一个应用程序的多次执行过程中，这个整数可以不同，即这个应用程序这次执行返回的整数与下一次执行返回的整数可以不一致。</li>\n<li>如果两个对象根据equals(Object)方法是相等的，那么调用这两个对象中任一个对象的hashCode方法必须产生同样的整数结果。</li>\n<li>如果两个对象根据equals(Object)方法是不相等的，那么调用这两个对象中任一个对象的hashCode方法，不要求必须产生不同的整数结果。然而，程序员应该意识到这样的事实，对于不相等的对象产生截然不同的整数结果，有可能提高散列表（hash table）的性能。</li>\n</ol>\n<p>上边可用一句话说明：我们认为两个对象相同，则两个对象的hashcode必定一样。我们重写equals()方法仅仅是判定若干个属性是否相等（这两个对象默认不重写情况下有可能是不一样的，hashcode默认也是不一样），所以要重写hashcode令其在若干属性相等下也一样。</p>\n<p>一般我们在集合（例如list）中存对象时hashcode所扮演的角色并不重要，但是当对象需要放在HashTable、HashMap、HashSet等hash结构的集合时候，我们如果重写equals()方法必须就重写hashcode()方法，因为在hash结构的集合中存储对象就是通过hash算法来散列对象的。假如这里有一些箱子(bucket，一个bucket可存放多个元对象，参考HashMap原理)，hash码可以看成每一个箱子指定的编码，每一个元对象就是根据箱子的编码存入每一个箱子的，所有的箱子加起来就是一个HashSet，HashMap，或 Hashtable对象。当我们想找某一个元对象的时候，我们必须先指定他所在那个箱子的hash码，才能找到那个箱子，然后根据对象的值从那个箱子中拿到这个对象。所以得出的结论是：</p>\n<p>在java集合中判断两个对象是否相同，先判断两个对象的hashcode是否相等，再采用equals()判断两个对象的值是否相等。即：</p>\n<ul>\n<li>如果x.equals(y)返回“true”，那么x和y的hashCode()必须相等。</li>\n<li>如果x.equals(y)返回“false”，那么x和y的hashCode()有可能相等，也有可能不等。</li>\n</ul>\n<h2 id=\"equals()和hashcode()重写\">equals()和hashcode()重写<a title=\"#equals()和hashcode()重写\" href=\"#equals()和hashcode()重写\"></a></h2>\n<p>由上可知我们equals()和hashcode()的方法重写是成对的，重写equals()方法必须重写hashcode()方法。</p>\n<h3 id=\"equals()方法的重写规则：\">equals()方法的重写规则：<a title=\"#equals()方法的重写规则：\" href=\"#equals()方法的重写规则：\"></a></h3>\n<ol>\n<li>使用instanceof操作符检查“实参是否为正确的类型”。</li>\n<li>对于类中的每一个“关键域”，检查实参中的域与当前对象中对应的域值。<br>\n[2.1]对于非float和double类型的原语类型域，使用==比较；<br>\n[2.2]对于对象引用域，递归调用equals方法；<br>\n[2.3]对于float域，使用Float.floatToIntBits(afloat)转换为int，再使用==比较；<br>\n[2.4]对于double域，使用Double.doubleToLongBits(adouble) 转换为int，再使用==比较；<br>\n[2.5]对于数组域，调用Arrays.equals方法。</li>\n</ol>\n<h3 id=\"hashcode()方法的重写规则：\">hashcode()方法的重写规则：<a title=\"#hashcode()方法的重写规则：\" href=\"#hashcode()方法的重写规则：\"></a></h3>\n<ol>\n<li>把某个非零常数值，例如17，保存在int变量result中；</li>\n<li>对于对象中每一个关键域f（指equals方法中考虑的每一个域）：<br>\n[2.1]boolean型，计算(f ? 0 : 1);<br>\n[2.2]byte,char,short型，计算(int);<br>\n[2.3]long型，计算(int) (f ^ (f&gt;&gt;&gt;32));<br>\n[2.4]float型，计算Float.floatToIntBits(afloat);<br>\n[2.5]double型，计算Double.doubleToLongBits(adouble)得到一个long，再执行[2.3];<br>\n[2.6]对象引用，递归调用它的hashCode方法;<br>\n[2.7]数组域，对其中每个元素调用它的hashCode方法。</li>\n<li>将上面计算得到的散列码保存到int变量c，然后执行 result=37*result+c;</li>\n<li>返回result。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBean</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mInt;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">short</span> mShort;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">char</span> mChar;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">byte</span> mByte;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mBoolean;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> mLong;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mFloat;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> mDouble;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object mObject;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestBean[] mArray;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == o) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span> || !(o <span class=\"keyword\">instanceof</span> TestBean)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        TestBean tb = (TestBean) o;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tb.mInt == mInt</span><br><span class=\"line\">                &amp;&amp;tb.mShort == mShort</span><br><span class=\"line\">                &amp;&amp; tb.mChar == mChar</span><br><span class=\"line\">                &amp;&amp; tb.mByte == mByte</span><br><span class=\"line\">                &amp;&amp; tb.mBoolean == mBoolean</span><br><span class=\"line\">                &amp;&amp; tb.mLong == mLong</span><br><span class=\"line\">                &amp;&amp; Float.floatToIntBits(tb.mFloat) == Float.floatToIntBits(mFloat)</span><br><span class=\"line\">                &amp;&amp; Double.doubleToLongBits(tb.mDouble) == Double.doubleToLongBits(mDouble)</span><br><span class=\"line\">                &amp;&amp; ((tb.mObject != <span class=\"keyword\">null</span> &amp;&amp; tb.mObject.equals(mObject)) || (tb.mObject == <span class=\"keyword\">null</span> &amp;&amp; mObject == <span class=\"keyword\">null</span>))</span><br><span class=\"line\">                &amp;&amp; Arrays.equals(mArray, tb.mArray);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = <span class=\"number\">17</span>;</span><br><span class=\"line\">        result = <span class=\"number\">31</span> * result + mInt;</span><br><span class=\"line\">        result = <span class=\"number\">31</span> * result + (<span class=\"keyword\">int</span>) mShort;</span><br><span class=\"line\">        result = <span class=\"number\">31</span> * result + (<span class=\"keyword\">int</span>) mChar;</span><br><span class=\"line\">        result = <span class=\"number\">31</span> * result + (<span class=\"keyword\">int</span>) mByte;</span><br><span class=\"line\">        result = <span class=\"number\">31</span> * result + (mBoolean ? <span class=\"number\">0</span> : <span class=\"number\">1</span>);</span><br><span class=\"line\">        result = <span class=\"number\">31</span> * result + (<span class=\"keyword\">int</span>) (mLong ^ (mLong &gt;&gt;&gt; <span class=\"number\">32</span>));</span><br><span class=\"line\">        result = <span class=\"number\">31</span> * result + Float.floatToIntBits(mFloat);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> doubleToLong = Double.doubleToLongBits(mDouble);</span><br><span class=\"line\">        result = <span class=\"number\">31</span> * result + (<span class=\"keyword\">int</span>) (doubleToLong ^ (doubleToLong &gt;&gt;&gt; <span class=\"number\">32</span>));</span><br><span class=\"line\">        result = <span class=\"number\">31</span> * result + mObject.hashCode();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mArray.length; i++) &#123;</span><br><span class=\"line\">            result = <span class=\"number\">31</span> * result + mArray[i].hashCode();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的31和17仅仅作为一个因子，其实取什么值都可以的，hashcode是一个对象存储位置的标示，因子取值的标准就是最终的得到的结果要尽可能的分散。至于为什么都是取的31，这里大概有这几个原因：</p>\n<ul>\n<li>31是一个奇素数，奇素数作用就是如果我用一个数字来乘以这个素数，那么最终的出来的结果只能被素数本身和被乘数还有1来整除！。(减少冲突)</li>\n<li>31可以由i*31== (i&lt;&lt;5)-1来表示,现在很多虚拟机里面都有做相关优化.（提高算法效率）</li>\n<li>选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突）</li>\n<li>并且31只占用5bits,相乘造成数据溢出的概率较小。</li>\n</ul>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<ul>\n<li>《Effective Java第二版》</li>\n<li><a href=\"https://juejin.im/entry/5968876df265da6c232898c2\">https://juejin.im/entry/5968876df265da6c232898c2</a></li>\n</ul>\n","prev":{"title":"Java注解小记","link":"post/1481852082"},"next":{"title":"Android开发序列化Serializable和Parcelable对比和抉择","link":"post/1480596660"},"plink":"https://blog.ixin.run/post/1481187426/","toc":[{"id":"==","title":"&#x3D;&#x3D;","index":"1"},{"id":"equals()","title":"equals()","index":"2","children":[{"id":"为什么重写equals()","title":"为什么重写equals()","index":"2.1"}]},{"id":"hashcode()","title":"hashCode()","index":"3","children":[{"id":"为什么重写hashcode()","title":"为什么重写hashcode()","index":"3.1"}]},{"id":"equals()和hashcode()重写","title":"equals()和hashcode()重写","index":"4","children":[{"id":"equals()方法的重写规则：","title":"equals()方法的重写规则：","index":"4.1"},{"id":"hashcode()方法的重写规则：","title":"hashcode()方法的重写规则：","index":"4.2"}]},{"id":"参考","title":"参考","index":"5"}],"reward":true,"copyright":{"custom":"转载请注明出处，谢谢支持。"}}