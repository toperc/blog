{"title":"Android开发之Fragment知识总结","date":"2019-04-18T15:55:14.000Z","date_formatted":{"ll":"2019年4月18日","L":"2019/04/18","MM-DD":"04-18"},"thumbnail":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1555613909401&di=6752f902ac9ad9912b724457339747e7&imgtype=0&src=http%3A%2F%2Fnowre.com%2Fwp-content%2Fuploads%2F2019%2F02%2F000.jpg","link":"posts/1555602958","comments":true,"categories":["Android"],"updated":"2021-01-29T12:51:44.631Z","content":"<p>最近华为的新出的折叠手机（mate X）甚是火爆，甚至欧美国外发烧网友都为之疯狂，折起来是一步双面屏手机，展开有瞬间编程一个平板，最重要的特色就是分屏，可以左边看电视右边聊天。手机从塞班时代百花争艳到乔布斯的方块范畴，再到现在的不到不小的16:9，然后就是华为、三星的折叠系列，不出意料未来的手机又会到一个个性化高峰。这些对于我们开发者又是一个里程碑的挑战，以前我们只需要维护好一个页面，现在为了实行多样化需求，我们要尽可能在单个页面上做更多的碎片处理。</p>\n<a id=\"more\"></a>\n<h2 id=\"fragment的生命周期（对比activity）\">Fragment的生命周期（对比Activity）<a title=\"#fragment的生命周期（对比activity）\" href=\"#fragment的生命周期（对比activity）\"></a></h2>\n<p>Fragment的实例过程是跟随在Activity生命周期后边的。<br>\n<img src=\"https://img-blog.csdnimg.cn/20200421233251427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpMDk3OA==,size_16,color_FFFFFF,t_70\" alt=\"Fragment的生命周期\"></p>\n<p>Fragment有两种创建方式：静态和动态。静态创建方式是直接在Activity的xml中布局Fragment，动态方式一般是在Activity的onCreat()方法下动态引入Fragment，因此两种情况生命周期在初始化过程略有不同，以下是Fragment的周期：</p>\n<p><strong>静态方式初始化过程：</strong><br>\n<img src=\"https://img-blog.csdnimg.cn/20200421233345145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpMDk3OA==,size_16,color_FFFFFF,t_70\" alt=\"静态方式初始化过程\"></p>\n<p><strong>动态方式初始化过程：</strong><br>\n<img src=\"https://img-blog.csdnimg.cn/20200421233422894.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpMDk3OA==,size_16,color_FFFFFF,t_70\" alt=\"动态方式初始化过程\"></p>\n<p><strong>退到后台过程：</strong><br>\n<img src=\"https://img-blog.csdnimg.cn/20200421233442741.png\" alt=\"界面退到后台\"></p>\n<p><strong>恢复到前台过程：</strong><br>\n<img src=\"https://img-blog.csdnimg.cn/20200421233501204.png\" alt=\"界面恢复到前台\"></p>\n<p><strong>静态方式屏幕旋转过程：</strong><br>\n<img src=\"https://img-blog.csdnimg.cn/20200421233541844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpMDk3OA==,size_16,color_FFFFFF,t_70\" alt=\"静态方式屏幕旋转过程\"></p>\n<p><strong>动态方式屏幕旋转过程：</strong><br>\n<img src=\"https://img-blog.csdnimg.cn/20200421233634124.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpMDk3OA==,size_16,color_FFFFFF,t_70\" alt=\"动态方式屏幕旋转过程\"></p>\n<p><strong>销毁过程：</strong><br>\n<img src=\"https://img-blog.csdnimg.cn/20200421233841247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpMDk3OA==,size_16,color_FFFFFF,t_70\" alt=\"界面销毁\"></p>\n<p><strong>onSaveInstanceState</strong><br>\nFragment的onSaveInstanceState和Activity的onSaveInstanceState执行时间一样，也是处于onPause和onStop之间。</p>\n<p><strong>我的声明周期为什么和你的不一致？</strong><br>\n有些同学问为什么我Demo里Fragment声明周期却比Activity的早，比如Fragment的onStart方法比Activity的onStart()执行早呢？其实Activity的onStart方法执行的时候会执行父类的onStart方法（super.onStart()），此时由Activity的super.onStart()影响Fragment的onStart方法的启动，然而你的日志却在Activity的super.onStart方法之后，然后就有这种疑问了，Activity生命周期的super方法均会影响Fragment的生命周期，所以我们真正去生命周期时候要顺藤摸瓜，否则结果恰恰相反。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Activity</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Log.e(TAG, <span class=\"string\">&quot;++++++++++++++-onStart()&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onStart();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Fragment</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Log.e(TAG,<span class=\"string\">&quot;-----------+onStart()&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onStart();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>为什么动态方式创建我执行屏幕旋转时初始化过程Fragment的初始化执行了两编，并且伴随着还有一编销毁过程？</strong><br>\n大家知道屏幕旋转会使Activity的生命周期重建，并且onSaveInstanceState也会执行相应状态保存，然后在重建的时候进行释放。动态创建是在super.onCreate(savedInstanceState);这句之后，因此父类的onCreate()方法会根据savedInstanceState状态做判断，这里会将之前存储的Fragment作相应的销毁，然后在进行实例加载。所以我们动态加载的时候一般会从savedInstanceState中根据Fragment的Tag取出相应的Fragment，然后用事务在进行加载。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Activity源码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mFragments.attachHost((Fragment)<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">    FragmentActivity.NonConfigurationInstances nc = (FragmentActivity.NonConfigurationInstances)<span class=\"keyword\">this</span>.getLastNonConfigurationInstance();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nc != <span class=\"keyword\">null</span> &amp;&amp; nc.viewModelStore != <span class=\"keyword\">null</span> &amp;&amp; <span class=\"keyword\">this</span>.mViewModelStore == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mViewModelStore = nc.viewModelStore;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (savedInstanceState != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        Parcelable p = savedInstanceState.getParcelable(<span class=\"string\">&quot;android:support:fragments&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mFragments.restoreAllState(p, nc != <span class=\"keyword\">null</span> ? nc.fragments : <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (savedInstanceState.containsKey(<span class=\"string\">&quot;android:support:next_request_index&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.mNextCandidateRequestIndex = savedInstanceState.getInt(<span class=\"string\">&quot;android:support:next_request_index&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">int</span>[] requestCodes = savedInstanceState.getIntArray(<span class=\"string\">&quot;android:support:request_indicies&quot;</span>);</span><br><span class=\"line\">            String[] fragmentWhos = savedInstanceState.getStringArray(<span class=\"string\">&quot;android:support:request_fragment_who&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (requestCodes != <span class=\"keyword\">null</span> &amp;&amp; fragmentWhos != <span class=\"keyword\">null</span> &amp;&amp; requestCodes.length == fragmentWhos.length) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.mPendingFragmentActivityResults = <span class=\"keyword\">new</span> SparseArrayCompat(requestCodes.length);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; requestCodes.length; ++i) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.mPendingFragmentActivityResults.put(requestCodes[i], fragmentWhos[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                Log.w(<span class=\"string\">&quot;FragmentActivity&quot;</span>, <span class=\"string\">&quot;Invalid requestCode mapping in savedInstanceState.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.mPendingFragmentActivityResults == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mPendingFragmentActivityResults = <span class=\"keyword\">new</span> SparseArrayCompat();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mNextCandidateRequestIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mFragments.dispatchCreate();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"fragmentactivity和activity的区别\">FragmentActivity和Activity的区别<a title=\"#fragmentactivity和activity的区别\" href=\"#fragmentactivity和activity的区别\"></a></h2>\n<p>fragment是3.0以后的东西，为了在低版本中使用fragment就要用到android-support-v4.jar兼容包,而fragmentActivity就是这个兼容包里面的，它提供了操作fragment的一些方法，其功能跟3.0及以后的版本的Activity的功能一样。下面是API中的原话：</p>\n<blockquote>\n<p>FragmentActivity is a special activity provided in the Support Library to handle fragments on system versions older than API level 11. If the lowest system version you support is API level 11 or higher, then you can use a regular Activity.</p>\n</blockquote>\n<ol>\n<li>fragmentactivity 继承自activity，用来解决android3.0 之前没有fragment的api，所以在使用的时候需要导入support包，同时继承fragmentActivity，这样在activity中就能嵌入fragment来实现你想要的布局效果。</li>\n<li>当然3.0之后你就可以直接继承自Activity，并且在其中嵌入使用fragment了。</li>\n<li>获得Manager的方式也不同<br>\n3.0以下：getSupportFragmentManager()<br>\n3.0以上：getFragmentManager()</li>\n</ol>\n<h2 id=\"fragment常用形式\">Fragment常用形式<a title=\"#fragment常用形式\" href=\"#fragment常用形式\"></a></h2>\n<p>终于讲到Fragment的加载形式了，上边提到Fragment的加载形式有两种：静态加载和动态加载。</p>\n<h3 id=\"静态创建\">静态创建<a title=\"#静态创建\" href=\"#静态创建\"></a></h3>\n<p>静态创建方式是直接在Activity的xml中布局Fragment，这个很简单，但是一定要注意两点：</p>\n<ol>\n<li>xml中的fragment一定要有一个id或者tag。</li>\n<li>所对应的fragment一定要返回一个视图。</li>\n</ol>\n<p>xml布局：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;fragment</span><br><span class=\"line\">    android:id=&quot;@+id/myfragment_1&quot;</span><br><span class=\"line\">    android:name=&quot;com.example.admin.TestFragment&quot;</span><br><span class=\"line\">    android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">    android:layout_height=&quot;wrap_content&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<p>fragment类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestFragment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fragment</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">onCreateView</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> LayoutInflater inflater, <span class=\"meta\">@Nullable</span> ViewGroup container, <span class=\"meta\">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> inflater.inflate(R.layout.fragment, container, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"动态创建\">动态创建<a title=\"#动态创建\" href=\"#动态创建\"></a></h3>\n<p>动态创建方式是需要在Activity的onCreat()方法下动态引入Fragment，由于上边提到在屏幕旋转或者Activity被无意回收销毁前系统会执行onSaveInstanceState()方法保存相应的状态，然后在Activity的onCreat方法执行时savedInstanceState会释放相应资源，此时如果直接在onCreat方法中创建有可能会走两遍生命周期，因此我们要利用这个特点直接从相应状态中去取，去不到时再创建也不迟。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在Activity中onCreat中实现</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">    setContentView(R.layout.activity_main);</span><br><span class=\"line\">    </span><br><span class=\"line\">    FragmentManager fm = getSupportFragmentManager();</span><br><span class=\"line\">    FragmentTransaction transaction = fm.beginTransaction();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(savedInstanceState != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        tf = (TestFragment) fm.findFragmentByTag(<span class=\"string\">&quot;TestFragment&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tf == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        tf = <span class=\"keyword\">new</span> TestFragment();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    transaction.replace(R.id.id_content, tf, <span class=\"string\">&quot;TestFragment&quot;</span>);</span><br><span class=\"line\">    transaction.commit();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>动态创建涉及到两个类：FragmentManager和FragmentTransaction。</p>\n<h3 id=\"fragmentmanager\">FragmentManager<a title=\"#fragmentmanager\" href=\"#fragmentmanager\"></a></h3>\n<p>FragmentManager是一个抽象类，定义了一些和 Fragment 相关的操作和内部类/接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//开启一系列对 Fragments 的操作 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> FragmentTransaction <span class=\"title\">beginTransaction</span><span class=\"params\">()</span></span>; </span><br><span class=\"line\"><span class=\"comment\">//FragmentTransaction.commit() 是异步执行的，如果你想立即执行，可以调用这个方法 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">boolean</span> <span class=\"title\">executePendingTransactions</span><span class=\"params\">()</span></span>; </span><br><span class=\"line\"><span class=\"comment\">//根据 ID 找到从 XML 解析出来的或者事务中添加的 Fragment </span></span><br><span class=\"line\"><span class=\"comment\">//首先会找添加到 FragmentManager 中的，找不到就去回退栈里找 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Fragment <span class=\"title\">findFragmentById</span><span class=\"params\">(<span class=\"meta\">@IdRes</span> <span class=\"keyword\">int</span> id)</span></span>; </span><br><span class=\"line\"><span class=\"comment\">//跟上面的类似，不同的是使用 tag 进行查找 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Fragment <span class=\"title\">findFragmentByTag</span><span class=\"params\">(String tag)</span></span>; </span><br><span class=\"line\"><span class=\"comment\">//弹出回退栈中栈顶的 Fragment，异步执行的 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">popBackStack</span><span class=\"params\">()</span></span>; </span><br><span class=\"line\"><span class=\"comment\">//立即弹出回退栈中栈顶的，直接执行哦 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">boolean</span> <span class=\"title\">popBackStackImmediate</span><span class=\"params\">()</span></span>; </span><br><span class=\"line\"><span class=\"comment\">//返回栈顶符合名称的，如果传入的 name 不为空，在栈中间找到了 Fragment，那将弹出这个 Fragment 上面的所有 Fragment </span></span><br><span class=\"line\"><span class=\"comment\">//有点类似启动模式的 singleTask 的感觉 </span></span><br><span class=\"line\"><span class=\"comment\">//如果传入的 name 为 null，那就和 popBackStack() 一样了 </span></span><br><span class=\"line\"><span class=\"comment\">//异步执行 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">popBackStack</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> flags)</span></span>; </span><br><span class=\"line\"><span class=\"comment\">//同步版的上面 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">boolean</span> <span class=\"title\">popBackStackImmediate</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> flags)</span></span>; </span><br><span class=\"line\"><span class=\"comment\">//和使用 name 查找、弹出一样 </span></span><br><span class=\"line\"><span class=\"comment\">//不同的是这里的 id 是 FragmentTransaction.commit() 返回的 id </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">popBackStack</span><span class=\"params\">(<span class=\"keyword\">int</span> id, <span class=\"keyword\">int</span> flags)</span></span>; </span><br><span class=\"line\"><span class=\"comment\">//你懂得 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">boolean</span> <span class=\"title\">popBackStackImmediate</span><span class=\"params\">(<span class=\"keyword\">int</span> id, <span class=\"keyword\">int</span> flags)</span></span>; </span><br><span class=\"line\"><span class=\"comment\">//获取回退栈中的元素个数 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">getBackStackEntryCount</span><span class=\"params\">()</span></span>; </span><br><span class=\"line\"><span class=\"comment\">//根据索引获取回退栈中的某个元素 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> BackStackEntry <span class=\"title\">getBackStackEntryAt</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span></span>; </span><br><span class=\"line\"><span class=\"comment\">//添加或者移除一个监听器 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">addOnBackStackChangedListener</span><span class=\"params\">(OnBackStackChangedListener listener)</span></span>; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">removeOnBackStackChangedListener</span><span class=\"params\">(OnBackStackChangedListener listener)</span></span>; </span><br><span class=\"line\"><span class=\"comment\">//还定义了将一个 Fragment 实例作为参数传递 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">putFragment</span><span class=\"params\">(Bundle bundle, String key, Fragment fragment)</span></span>; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Fragment <span class=\"title\">getFragment</span><span class=\"params\">(Bundle bundle, String key)</span></span>; </span><br><span class=\"line\"><span class=\"comment\">//获取 manager 中所有添加进来的 Fragment </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> List&lt;Fragment&gt; <span class=\"title\">getFragments</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n<p>我们获取FragmentManager有两种包引入：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//针对4.0之前的方式，能兼容更低的版本，引入的包是v4包，所对应的fragment也要时v4包下的。（推荐）</span></span><br><span class=\"line\">FragmentManager fm = getSupportFragmentManager();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//针对4.0之后的方式，引入的包是v7包，所对应的fragment也要是v7包下的。</span></span><br><span class=\"line\">FragmentManager fm = getFragmentManager();</span><br></pre></td></tr></table></figure>\n<h3 id=\"fragmenttransaction\">FragmentTransaction<a title=\"#fragmenttransaction\" href=\"#fragmenttransaction\"></a></h3>\n<p>做过数据库的童鞋都有事务的印象，主要针对数据的增删改查。FragmentTransaction就是对Fragment的“增删改查”。FragmentTransaction的相关操作大概有以下相关方法。</p>\n<ol>\n<li>add(id, fragment) —— 增加framgent到队列中，并显示该fragment到指定布局中。<br>\n生命周期调用：<br>\n当fragment与activity连接并被建立时（onAttach()、onCreate()被调用过）<br>\nonCreateView()、onActivityCreated()、onStart()、onResume()。<br>\n当fragment与activity未连接并未被建立时（onAttach()、onCreate()未被调用过）<br>\nonAttach()、onCreate()、onCreateView()、onActivityCreated()、onStart()、onResume()。<br>\n注意：同一个Fragmen不能增加到队列两次或多次。</li>\n<li>show(fragment) —— 显示队列中的指定framgent。<br>\n生命周期的调用：<br>\n当队列中不存在该fragment时，回调onAttach()、onCreate()。<br>\n当队列中存在该fragment时并被调用过hide(fragment)时，回调onHiddenChange(boolean)。<br>\n其他情况没有回调函数。</li>\n<li>replace(id, fragment) —— 先检查队列中是否已经存在，存在就会崩溃，不存在就会进入队列并把其他fragment清出队列，最后显示该fragment到指定布局中。<br>\n生命周期的调用：同add(id, fragment)。</li>\n<li>remove(fragment) —— 销毁队列中指定的fragment。<br>\n生命周期调用：<br>\n当队列中不存在该fragment时，不会有任何反应。<br>\n当队列中存在该fragment时，fragment的生命周期执行情况主要依赖是否当前fragment进入到返回栈。</li>\n<li>hide(fragment) —— 隐藏队列中指定的fragment，相当于调用视图的.setVisibility(View.GONE)<br>\n生命周期的调用：<br>\n当队列中存在该fragment时，回调onHiddenChange(boolen)<br>\n当队列中不存在该fragment时，回调onAttach()、onCreate()、onHiddenChange(boolen)。</li>\n<li>detach(fragment) —— 销毁指定frament的视图，并且该fragment的onCreateView(……)不能再被调用（除非调用attach(fragment)重新连接）<br>\n生命周期的调用：<br>\n当队列中存在该fragment时，回调onDestroyView()<br>\n当队列中不存在该fragment时，回调onAttach()、onCreate()。</li>\n<li>attach(fragment) —— 创建指定fragment的视图。标识该fragment的onCreateView(……)能被调用。<br>\n生命周期的调用：<br>\n当队列中存在该fragment时且被调用detach(fragment)时，回调createView()、onActivityCreated()、onResume()。<br>\n当队列中不存在该fragment时，回调onAttach()、onCreate()。<br>\n其他情况没有用。</li>\n<li>addToBackStack(string) —— 使本次事务增加的fragment进入当前activity的返回栈中。当前参数是对返回栈的描述，没什么实际用途。传入null即可。</li>\n<li>commit() —— 提交本次事务，可在非主线程中被调用。主要用于多线程处理情况。</li>\n<li>commitNow() —— 提交本次事务，只在主线程中被调用。 这时候addToBackStack(string)不可用。</li>\n</ol>\n<p>针对事务，我们最常用的有两种：</p>\n<ol>\n<li>replace() --父容器中只能存在一个fragment，好处就是生命周期好管理。</li>\n<li>add(), show(), hide() --父容器中根据还需要add一次，后边根据情况show或者hide，好处就是省内存空间。</li>\n</ol>\n<h2 id=\"fragment进出栈管理\">Fragment进出栈管理<a title=\"#fragment进出栈管理\" href=\"#fragment进出栈管理\"></a></h2>\n<p>我们知道在多个activity的情况下按下返回键会返回到上一页，但是一个activity中有多个fragment时按下返回键却直接退出了当前Activity。我们知道Activity有任务栈，用户通过startActivity将Activity加入栈，点击返回按钮将Activity出栈。Fragment也有类似的栈，称为回退栈（Back Stack），回退栈是由FragmentManager管理的（上边谈到FragmentManager使用的相关方法都已经提到）。</p>\n<h3 id=\"加入回退栈\">加入回退栈<a title=\"#加入回退栈\" href=\"#加入回退栈\"></a></h3>\n<p>默认情况下，Fragment事务是不会加入回退栈的，如果想将Fragment加入回退栈并实现事物回滚，首先需要在commit()方法之前调用事务的以下方法将其添加到回退栈中：<code>addToBackStack(String tag) //标记本次的回滚操作</code></p>\n<h3 id=\"弹出回退栈\">弹出回退栈<a title=\"#弹出回退栈\" href=\"#弹出回退栈\"></a></h3>\n<p>Fragment的回退非常简单，默认每次只能回退到上一步操作，并不能一次性回退到我们想要的位置，这在开发的时候是不灵活的。所以需要我们来多了解事物回滚的相关原理来解决这样的问题，其实在Fragment回退时，默认调用FragmentManager的popBackStack()方法将最上层的操作弹出回退栈。当栈中有多层时，我们可以根据id或TAG标识来指定弹出到的操作所在层：</p>\n<ul>\n<li>popBackStack(int id, int flags)：其中id表示提交变更时commit()的返回值。</li>\n<li>popBackStack(String name, int flags)：其中name是addToBackStack(String tag)中的tag值。</li>\n</ul>\n<p>在上面2个方法里面，都用到了flags，其实flags有两个取值：0或FragmentManager.POP_BACK_STACK_INCLUSIVE。当取值0时，表示除了参数指定这一层之上的所有层都退出栈，指定的这一层为栈顶层；当取值POP_BACK_STACK_INCLUSIVE时，表示连着参数指定的这一层一起退出栈。<br>\n如果想要了解回退栈中Fragment的情况，可以通过以下2个方法来实现：</p>\n<ul>\n<li>getBackStackEntryCount()：获取回退栈中Fragment的个数。</li>\n<li>getBackStackEntryAt(int index)：获取回退栈中该索引值下的Fragment。</li>\n</ul>\n<p>使用popBackStack()来弹出栈内容的话，调用该方法后会将事物操作插入到FragmentManager的操作队列，只有当轮询到该事物时才能执行。如果想立即执行事物的话，可以使用下面这几个方法：</p>\n<ul>\n<li>popBackStackImmediate()</li>\n<li>popBackStackImmediate(String tag)</li>\n<li>popBackStackImmediate(String tag, int flag)</li>\n<li>popBackStackImmediate(int id, int flag)</li>\n</ul>\n<h2 id=\"fragment懒加载\">Fragment懒加载<a title=\"#fragment懒加载\" href=\"#fragment懒加载\"></a></h2>\n<p>什么是懒加载，单例模式有一个懒汉模式，和这种有异曲同工，即所见即所得，例如页面可见时才加载数据，既节省内存，又能提示用户当前数据正在处理，不必感到迷茫。Fragment的懒加载主要用到setUserVisibleHint()这个方法。</p>\n<p>setUserVisibleHint()使用范围必须在一组有序的Fragment时（FragmentPageAdapter）才会起作用，单个Fragment是不起作用的，并且该方法调用不一定在Fragment正常的生命周期之内。见源码注释：<br>\n<img src=\"https://img-blog.csdnimg.cn/20200421234040959.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpMDk3OA==,size_16,color_FFFFFF,t_70\" alt=\"setUserVisibleHint源码\"></p>\n<p>在FragmentPageAdapter中，假如有四张fragment：</p>\n<p><strong>初始时：</strong><br>\n先执行setUserVisibleHint，将一次性加载在内存中的每个fragement（默认一次性加载两个Fragment）的该方法执行一遍，先默认都初始为false，最后将可见的那个fragment（第一个）初始为true。然后执行Fragment的生命周期：<br>\nsetUserVisibleHint -------&gt; onAttach、 onCreat…<br>\n<img src=\"https://img-blog.csdnimg.cn/2020042123410283.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpMDk3OA==,size_16,color_FFFFFF,t_70\" alt=\"懒加载初始时声明周期\"></p>\n<p><strong>滑动到第二页时：</strong><br>\n此时该fragment的部分生命周期已经走过（例如：onCreatView），但是该fragment的可见情况发生了变化，所以在第二页的时候只执行了setUserVisibleHint，不再执行onCreatView等生命周期方法。不过滑到第二页的时候顺便把第三页的相关方法初始一下：<br>\n<img src=\"https://img-blog.csdnimg.cn/20200421234139842.PNG\" alt=\"懒加载滑动到第二页时生命周期\"></p>\n<p><strong>滑到最后一页时：</strong><br>\n假如这里一组只有四个Fragment，因为接下来没有第5个Fragment，所以不用进行预加载了，只需要做两步操作：</p>\n<ol>\n<li>把前一页的可见性置为false,把本页的可见性置为true。</li>\n<li>把上上一页的生命周期关闭（内存中只允许放两页，所以要把老的fragment出栈）。</li>\n</ol>\n<p>懒加载滑到最后一页时时生命周期<br>\n<img src=\"https://img-blog.csdnimg.cn/20200421234201608.PNG\" alt=\"懒加载滑到最后一页时\"></p>\n<p><strong>间接跳转：</strong><br>\n假如从第四页直接跳到第一页（这里不是滑动，是导航跳转），可见性上先根据第一页的预加载方式进行逐个初始关闭，把第四页关闭，在把第一页打开。生命周期上先预处理第一页第二页的生命开启，接着将第三页第四页的生命关闭。举一反三其他间接跳转也类似。<br>\n<img src=\"https://img-blog.csdnimg.cn/20200421234222141.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpMDk3OA==,size_16,color_FFFFFF,t_70\" alt=\"懒加载间接跳转生命周期\"></p>\n<p>综上：其实这里只需要考虑两件事：</p>\n<ol>\n<li>设置可见性（初始可见性为false，关闭老页面可见性为false, 开启当前页可见性为true）。</li>\n<li>设置生命周期（预加载新的生命周期，关闭老的生命周期）。</li>\n</ol>\n<p>因为这两件事是交替变换，可见性为true但生命周期不一定初始化，此时是不能做一些有关界面的数据填充；生命周期准备好了但是可见性为false，加载的数据用户看不到，资源显的浪费。所以在数据加载时要同时考虑这两种情况，这里设置两个全局变量（mIsPrepare：标识生命周期； mIsVisible ：标识可见状态）来标识这两个情况：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">loadData</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">  mIsPrepare = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  onLazyLoad();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUserVisibleHint</span><span class=\"params\">(<span class=\"keyword\">boolean</span> isVisibleToUser)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">super</span>.setUserVisibleHint(isVisibleToUser);</span><br><span class=\"line\">  mIsVisible = isVisibleToUser;</span><br><span class=\"line\">  onLazyLoad();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">onLazyLoad</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mIsPrepare) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始相关数据，以便于在滑动过程中能看到下一页有预处理数据</span></span><br><span class=\"line\">    initData();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mIsVisible) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 加载最终数据</span></span><br><span class=\"line\">      queryData(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"fragment常见问题及解决方式\">Fragment常见问题及解决方式<a title=\"#fragment常见问题及解决方式\" href=\"#fragment常见问题及解决方式\"></a></h2>\n<p>以下两个坑是对我印象最深，早在还未毕业在实习的时候与fragment第一次亲密接触就遇到了。</p>\n<h3 id=\"fragment的getactivity为null\">Fragment的getActivity为null<a title=\"#fragment的getactivity为null\" href=\"#fragment的getactivity为null\"></a></h3>\n<p>这种情况主要是主Activity被回收，然后在恢复的时候重新实例了一个新的Activity，导致原来的Fragment找不到原来的Activity，既然知道原因了，我们可以从以下三种情况入手：</p>\n<ol>\n<li>\n<p>Activity销毁不缓存任何状态，这样在Activity重置时Fragment也会跟着重置。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onSaveInstanceState</span><span class=\"params\">(Bundle outState)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//super.onSaveInstanceState(outState);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里说明一下：Activity的onSaveInstanceState是保存Activity被回收时的状态，同理Fragment的也是，因此这里只需把Activity的super.onSaveInstanceState(outState)注释即可，Fragment自行根据情况选择是否注释。</p>\n</li>\n<li>\n<p>Fragment内部onAttach时把当前Activity的上下文保存起来。(推荐)<br>\n当出现这个问题时，只要在Fragment 中声明一个上下文类型的成员变量，并在onAttach()方法中将getActivity()的值赋给变量，在Fragment中使用到getActivity()时，都是用context即可。也就是说在将Fragment挂载到Activity时，就获得到了这个activity，并将这个activity保存起来了，这样就可以直接使用而不需要每次使用时都调用一遍getActivity()了。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Context context;</span><br><span class=\"line\"><span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAttach</span><span class=\"params\">(Activity activity)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onAttach(activity);  </span><br><span class=\"line\">        context = activity;  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>使用全局Application的上下文。</p>\n</li>\n</ol>\n<h3 id=\"同一容器中多个fragment重叠\">同一容器中多个Fragment重叠<a title=\"#同一容器中多个fragment重叠\" href=\"#同一容器中多个fragment重叠\"></a></h3>\n<p>这种情况也是当所属Activity被回收重置时，由于一个容器中多个fragment找不到归属，本来有些是需要隐藏的，结果却都显示出来了。<br>\n解决方法也有两种方法：</p>\n<ol>\n<li>不保存Activity的状态，让Fragment重新创建实例化。和上边getActivity()为null的第一种处理方式一样。</li>\n<li>在Activity的onCreate(Bundle savedInstanceState)方法里判断savedInstanceState是否为空，不为空则根据fragment的tag，将fragment的实例找出来，然后根据情况显示还是隐藏。 <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(savedInstanceState != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    tf = (TestFragment) fm.findFragmentByTag(<span class=\"string\">&quot;TestFragment&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (tf == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    tf = <span class=\"keyword\">new</span> TestFragment();</span><br><span class=\"line\">    transaction.add(R.id.id_content, tf, <span class=\"string\">&quot;TestFragment&quot;</span>);</span><br><span class=\"line\">    transaction.commit();</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    transaction.show(tf);</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"fragment与fragment、activity通信\">Fragment与Fragment、Activity通信<a title=\"#fragment与fragment、activity通信\" href=\"#fragment与fragment、activity通信\"></a></h2>\n<p>首先说明一下官方不建议Fragment与Fragment直接进行通信的，这会造成碎片耦合，不易后期维护和扩展，一般都是有Activity作为中间桥梁进行转接。以下是Fragment与Fragment、Fragment与Activity之间通信的方法归总。</p>\n<h3 id=\"handler消息推送方式\">Handler消息推送方式<a title=\"#handler消息推送方式\" href=\"#handler消息推送方式\"></a></h3>\n<p>例如Activity向Fragment中传递消息，思想是在Fragment中注册handler，然后将此Handler实例通过Activity的公有方法传递给Activity，最后Activity再合适的情况下触发handler的sendMessage()。具体过程如下：</p>\n<p>1.Fragment注册Handler，用于将来的消息接收。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Handler mHandler = <span class=\"keyword\">new</span> Handler()&#123; </span><br><span class=\"line\">    <span class=\"meta\">@Override</span> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">super</span>.handleMessage(msg); </span><br><span class=\"line\">        Bundle bundle = msg.getData(); </span><br><span class=\"line\">        strHandler = bundle.getString(<span class=\"string\">&quot;hehe&quot;</span>); </span><br><span class=\"line\">        textView.setText(strHandler+TwoFragment.class.getName()); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>2.Activity中暴露公有setHandler方法，用于Fragment将注册的handler传给Activity.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setHandler</span><span class=\"params\">(Handler handler)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handler = handler;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3.Fragment将Handler实例传递给Activity</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAttach</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onAttach(context); </span><br><span class=\"line\">    MainActivity activity = (MainActivity) getActivity(); </span><br><span class=\"line\">    activity.setHandler(mHandler); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4.Activity事件响应，发送Handler消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tvMain.setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123; </span><br><span class=\"line\">    <span class=\"meta\">@Override</span> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"comment\">//如果是activity相应事件，发送msg </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(handler == <span class=\"keyword\">null</span>)&#123; </span><br><span class=\"line\">            <span class=\"keyword\">return</span>; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        Message message = <span class=\"keyword\">new</span> Message(); </span><br><span class=\"line\">        Bundle bundle = <span class=\"keyword\">new</span> Bundle(); </span><br><span class=\"line\">        bundle.putString(<span class=\"string\">&quot;hehe&quot;</span>,<span class=\"string\">&quot;我是activity发送的msg&quot;</span>); </span><br><span class=\"line\">        message.setData(bundle); </span><br><span class=\"line\">        handler.sendMessage(message); </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>其实不建议用handler处理，因为你会发现他耦合性挺重的，既要在Fragment中注册又要在Activity中handler发射，并且用不好还会出现内存泄露的情况。</p>\n<h3 id=\"广播发送方式\">广播发送方式<a title=\"#广播发送方式\" href=\"#广播发送方式\"></a></h3>\n<p>这个应该都明白，假如现在Fragment向Activity通信，我们只需在Activity中注册广播，然后由Fragment发送广播，Activity即可接收到。</p>\n<p>如果项目中fragment不是很多话，可以用广播传递，当然要注意广播的注销，方法也比较简单。</p>\n<h3 id=\"事件总线发送方式\">事件总线发送方式<a title=\"#事件总线发送方式\" href=\"#事件总线发送方式\"></a></h3>\n<p>我们常用的事件总线如EventBus，EventBus是一款针对Android优化的发布/订阅事件总线。简化了应用程序内各组件间、组件与后台线程间的通信。可以利用EventBus代替广播进行发送，其过程和上边广播发送方式类似，这里就不多说了。</p>\n<p>EventBus虽然更加简单，但是采用反射机制，造成性能上问题，并且EventBus不设好标示，将来甚至都不知道消息是从哪里传来的。</p>\n<h3 id=\"使用自定义接口方式\">使用自定义接口方式<a title=\"#使用自定义接口方式\" href=\"#使用自定义接口方式\"></a></h3>\n<p>Fragment中创建接口，Activity中实现接口，然后Fragment在需要的地方通过接口实例调用接口方法，从而Activity中即可接收到。</p>\n<p>1.Fragment中创建接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IListener</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">changerSomething</span><span class=\"params\">(String msg)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.Fragment中创建接收接口实例方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setListener</span><span class=\"params\">(IListener listener)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mListener = listener;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3.Activity中Fragment实例实现自身接口实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mFragment.setListener(<span class=\"keyword\">new</span> Ilistener&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">changerSomething</span><span class=\"params\">(String msg)</span></span>&#123;</span><br><span class=\"line\">        tvMain.setText(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>4.Fragment中调用接口实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123; </span><br><span class=\"line\">    <span class=\"meta\">@Override</span> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mListener != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            mListener.changerSomething(<span class=\"string\">&quot;我是通过接口传递到MainActivity中&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>以上几种方式都有缺点，看起来这一种还不错，简单，解耦，并且完全可定制化，但是你会发现每个Fragment都要写这么多代码是很耐受的。所以接下来我们需要对这种方式进行一个完美封装，让其想EventBus一样，一行代码即可搞定。</p>\n<h3 id=\"万能接口方式\">万能接口方式<a title=\"#万能接口方式\" href=\"#万能接口方式\"></a></h3>\n<p>这里就不贴代码了，封装嘛，考验一下大家的奇思妙想。</p>\n<h2 id=\"最后\">最后<a title=\"#最后\" href=\"#最后\"></a></h2>\n<p>整个Fragment的相关知识点这里做了一个完全总结，文章有点长，需耐心看了，当然Fragment也不仅仅这一点，例如FragmentDialog代替Dialog，更多的需要我们在开发的过程中去挖掘学习。</p>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<ul>\n<li><a href=\"https://blog.csdn.net/cqkxzsxy/article/details/78593823\">https://blog.csdn.net/cqkxzsxy/article/details/78593823</a></li>\n<li><a href=\"https://blog.csdn.net/HUandroid/article/details/79481363\">https://blog.csdn.net/HUandroid/article/details/79481363</a></li>\n</ul>\n","prev":{"title":"Android开发之OKHttp知识归总","link":"posts/1555949544"},"next":{"title":"网络优化之HttpDNS实践","link":"posts/1554649638"},"plink":"https://blog.ixin.run/posts/1555602958/","toc":[{"id":"fragment的生命周期（对比activity）","title":"Fragment的生命周期（对比Activity）","index":"1"},{"id":"fragmentactivity和activity的区别","title":"FragmentActivity和Activity的区别","index":"2"},{"id":"fragment常用形式","title":"Fragment常用形式","index":"3","children":[{"id":"静态创建","title":"静态创建","index":"3.1"},{"id":"动态创建","title":"动态创建","index":"3.2"},{"id":"fragmentmanager","title":"FragmentManager","index":"3.3"},{"id":"fragmenttransaction","title":"FragmentTransaction","index":"3.4"}]},{"id":"fragment进出栈管理","title":"Fragment进出栈管理","index":"4","children":[{"id":"加入回退栈","title":"加入回退栈","index":"4.1"},{"id":"弹出回退栈","title":"弹出回退栈","index":"4.2"}]},{"id":"fragment懒加载","title":"Fragment懒加载","index":"5"},{"id":"fragment常见问题及解决方式","title":"Fragment常见问题及解决方式","index":"6","children":[{"id":"fragment的getactivity为null","title":"Fragment的getActivity为null","index":"6.1"},{"id":"同一容器中多个fragment重叠","title":"同一容器中多个Fragment重叠","index":"6.2"}]},{"id":"fragment与fragment、activity通信","title":"Fragment与Fragment、Activity通信","index":"7","children":[{"id":"handler消息推送方式","title":"Handler消息推送方式","index":"7.1"},{"id":"广播发送方式","title":"广播发送方式","index":"7.2"},{"id":"事件总线发送方式","title":"事件总线发送方式","index":"7.3"},{"id":"使用自定义接口方式","title":"使用自定义接口方式","index":"7.4"},{"id":"万能接口方式","title":"万能接口方式","index":"7.5"}]},{"id":"最后","title":"最后","index":"8"},{"id":"参考","title":"参考","index":"9"}],"reward":true,"copyright":{"author":"i猩人","link":"<a href=\"https://blog.ixin.run/posts/1555602958/\" title=\"Android开发之Fragment知识总结\">https://blog.ixin.run/posts/1555602958/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}