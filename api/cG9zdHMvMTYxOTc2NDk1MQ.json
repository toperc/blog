{"title":"Android注解处理器APT技术探究","date":"2021-04-30T06:42:31.000Z","date_formatted":{"ll":"2021年4月30日","L":"2021/04/30","MM-DD":"04-30"},"link":"posts/1619764951","comments":true,"tags":["APT"],"categories":["Android"],"updated":"2021-05-17T08:50:03.678Z","content":"<p>说起注解处理器，Android程序员都比较兴奋，因为在开发过程中我们常用的一些明星框架，例如<code>ButterKnife</code>、<code>EventBus</code>、<code>Dagger</code>以及阿里的<code>ARouter</code>都采用是注解处理器技术。简单注解，简单的api，超高的性能等诸多优点，本文就带你从整体出发探讨以下APT技术是怎么玩的。</p>\n<a id=\"more\"></a>\n<h2 id=\"什么是apt\">什么是APT<a title=\"#什么是apt\" href=\"#什么是apt\"></a></h2>\n<p>APT全称“Annotation Processing Tool”，即注解处理器，是javac的一种处理注释的工具，它对源代码文件进行检测找出其中的Annotation，并根据注解自动生成代码，帮助开发者减少了很多重复代码的编写。</p>\n<p>现在很多流行的框架都是用的这个思想，比如Butterknife、Dragger、Room、组件化框架都是用的编译时注解原理，自动生成了代码，简化了使用。</p>\n<p>通俗理解：<strong>根据规则，帮助我们生成代码、生成类文件</strong></p>\n<h2 id=\"什么是element\">什么是Element<a title=\"#什么是element\" href=\"#什么是element\"></a></h2>\n<p>Element指得是节点或者元素，我们常常把html语言成为结构体语言，因为html语言中有很多规范的标签限定，每一种标签都是一个element:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;utf-8&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>i猩人<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>对于java源文件来说，同样也是一种结构体语言，源代码的每一个部分都是一个特定类型的Element，也就是说Element代表源文件中的元素，例如包、类、字段、方法等。java的Element是一个接口，由Element衍生出来的扩展类共有5种：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example;       <span class=\"comment\">// PackageElement 包元素/节点</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;     <span class=\"comment\">// TypeElement 类元素/节点; 其中&lt;T&gt;属于TypeParameterElement 泛型元素/节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> x;         <span class=\"comment\">// VariableElement 变量、枚举、方法参数元素/节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Main</span><span class=\"params\">()</span> </span>&#123;        <span class=\"comment\">// ExecuteableElement 构造函数、方法元素/节点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>PackageElement 表示一个包程序元素。提供对有关包及其成员的信息的访问。</li>\n<li>TypeElement  表示一个类或者接口程序元素。提供对有关类型及其成员信息的访问。</li>\n<li>TypeParameterElement 表示一个泛型元素</li>\n<li>VariableElement 表示一个字段、enum常量、方法或者构造方法的参数、局部变量或异常参数</li>\n<li>ExecuteableElement 表示某个类或者接口的方法、构造方法或初始化程序（静态或者实例）</li>\n</ul>\n<p>Element是一个接口，常用的api如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Element</span> <span class=\"keyword\">extends</span> <span class=\"title\">AnnotatedConstruct</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取元素的类型，实际的对象类型</span></span><br><span class=\"line\">    <span class=\"function\">TypeMirror <span class=\"title\">asType</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取Element的类型，判断是哪种Element</span></span><br><span class=\"line\">    <span class=\"function\">ElementKind <span class=\"title\">getKind</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取修饰符，如public static final等关键字</span></span><br><span class=\"line\">    <span class=\"function\">Set&lt;Modifier&gt; <span class=\"title\">getModifiers</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取名字，不带包名</span></span><br><span class=\"line\">    <span class=\"function\">Name <span class=\"title\">getSimpleName</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 返回包含该节点的父节点，与getEnclosedElements()方法相反</span></span><br><span class=\"line\">    <span class=\"function\">Element <span class=\"title\">getEnclosingElement</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 返回该节点下直接包含的子节点，例如包节点下包含的类节点</span></span><br><span class=\"line\">    List&lt;? extends Element&gt; getEnclosedElements();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object var1)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    List&lt;? extends AnnotationMirror&gt; getAnnotationMirrors();</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;A extends Annotation&gt; <span class=\"function\">A <span class=\"title\">getAnnotation</span><span class=\"params\">(Class&lt;A&gt; var1)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;R, P&gt; <span class=\"function\">R <span class=\"title\">accept</span><span class=\"params\">(ElementVisitor&lt;R, P&gt; var1, P var2)</span></span>;`</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>既然源文件是一种结构化的数据，那么针对某个Element我们可以获取它的父元素或者子元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TypeElement person= ... ;  </span><br><span class=\"line\"><span class=\"comment\">// 遍历它的孩子</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (Element e : person.getEnclosedElements())&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 拿到孩子元素的最近的父元素</span></span><br><span class=\"line\">    Element parent = e.getEnclosingElement();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们发现Element有时会代表多种元素，例如TypeElement代表类或接口，此时我们可以通过element.getKind()来区分：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(Who.class);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Element element : elements) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (element.getKind() == ElementKind.CLASS) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果元素是类</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (element.getKind() == ElementKind.INTERFACE) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前元素是接口</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ElementKind枚举声明有这些:</p>\n<div class=\"φbt\"><div class=\"φbv\"><table><thead>\n<tr>\n<th>枚举类型</th>\n<th>种类</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>PACKAGE</td>\n<td>包</td>\n</tr>\n<tr>\n<td>ENUM</td>\n<td>枚举</td>\n</tr>\n<tr>\n<td>CLASS</td>\n<td>类</td>\n</tr>\n<tr>\n<td>ANNOTATION_TYPE</td>\n<td>注解</td>\n</tr>\n<tr>\n<td>INTERFACE</td>\n<td>接口</td>\n</tr>\n<tr>\n<td>ENUM_CONSTANT</td>\n<td>枚举常量</td>\n</tr>\n<tr>\n<td>FIELD</td>\n<td>字段</td>\n</tr>\n<tr>\n<td>PARAMETER</td>\n<td>参数</td>\n</tr>\n<tr>\n<td>LOCAL_VARIABLE</td>\n<td>本地变量</td>\n</tr>\n<tr>\n<td>EXCEPTION_PARAMETER</td>\n<td>异常参数</td>\n</tr>\n<tr>\n<td>METHOD</td>\n<td>方法</td>\n</tr>\n<tr>\n<td>CONSTRUCTOR</td>\n<td>构造函数</td>\n</tr>\n<tr>\n<td>OTHER</td>\n<td>其他</td>\n</tr>\n</tbody>\n</table></div></div><p>其他Element如VariableElement特殊的api：</p>\n<ul>\n<li>getConstantValue() ：获取初始化变量的值。</li>\n</ul>\n<p>其他的都相对简单一些。</p>\n<h2 id=\"注解处理器实现过程\">注解处理器实现过程<a title=\"#注解处理器实现过程\" href=\"#注解处理器实现过程\"></a></h2>\n<p>一般的apt框架都是习惯建立三个module，两个java module，一个Android lib module:<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/94290775DE4640FBA18EEE6223DE1237?method=download&amp;shareKey=5fa563c6e4cd1f0e9726aec77977ea8b\" alt=\"apt框架文件结构\"></p>\n<ul>\n<li>apt-annotation 存放注解</li>\n<li>apt-processor 存放自定义注解处理器，java代码编译生成规则在这里声明</li>\n<li>apt-api 暴露给用户的api，我们生成的java代码怎么调用，需要提供api支持</li>\n</ul>\n<p>其中apt-processor需要依赖apt-annotation，因为要用到apt-annotation中的相关注解，通过注解获取更多的类信息</p>\n<p>接下来我们理一下注解处理器的实现过程，总的来说需要以下几步：</p>\n<ol>\n<li>注解处理器声明</li>\n<li>注解处理器注册</li>\n<li>注解处理器文件生成</li>\n<li>注解处理器调用</li>\n</ol>\n<h3 id=\"注解处理器声明\">注解处理器声明<a title=\"#注解处理器声明\" href=\"#注解处理器声明\"></a></h3>\n<p>每一个注解处理器都要继承于<code>AbstractProcessor</code>，然后实现以下五个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyProcessor</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractProcessor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 注解处理器初始化方法，相当于Activity的onCreate方法。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> processingEnvironment 该入参可以提供若干工具类，供将来编写代码生成规则时所使用</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.init(processingEnvironment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 声明注解处理器生成java代码规则，在这里写你的扫描、评估和处理注解的代码，以及生成Java文件。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> set              支持处理的注解集合。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> roundEnvironment 表示当前或是之前的运行环境,可以通过该对象查找指定注解下的节点信息。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 如果返回 true，则这些注解已处理，后续 Processor 无需再处理它们；如果返回 false，则这些注解未处理并且可能要求后续 Processor 处理它们。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">process</span><span class=\"params\">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回一个当前注解处理器所有支持的注解的集合。当前注解处理器需要处理哪种注解就加入那种注解。如果类型符合，就会调用process（）方法。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Set&lt;String&gt; <span class=\"title\">getSupportedAnnotationTypes</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.getSupportedAnnotationTypes();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 需要通过那个版本的jdk来进行编译</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SourceVersion <span class=\"title\">getSupportedSourceVersion</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.getSupportedSourceVersion();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 接收外来传入的参数，最常用的形式就是在Gradle里`javaCompileOptions`</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Set&lt;String&gt; <span class=\"title\">getSupportedOptions</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.getSupportedOptions();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中<code>getSupportedAnnotationTypes()</code>、<code>getSupportedSourceVersion()</code>和<code>getSupportedOptions()</code>还可以采用注解进行声明，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SupportedAnnotationTypes(&#123;&quot;com.simple.annotation.MyAnnotation&quot;&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@SupportedSourceVersion(SourceVersion.RELEASE_7)</span></span><br><span class=\"line\"><span class=\"meta\">@SupportedOptions(&quot;MODULE_NAME&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyProcessor</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractProcessor</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.init(processingEnvironment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">process</span><span class=\"params\">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中<code>MyAnnotation</code>就是我们注解处理器所支持的注解，是个列表，开发中我们所使用的注解只要在这个列表内就行就能被注解处理器接收到，进而通过这些注解获取更多的节点信息；<code>MODULE_NAME</code>是我们在gradle中注册的外部变量，便于编译的时候注解处理器能够引用到，例如大名鼎鼎的ARouter在build.gradle的defaultConfig闭包中注册的<code>AROUTER_MODULE_NAME</code>变量，用于将来生成路由表分组所需：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javaCompileOptions &#123;</span><br><span class=\"line\">    annotationProcessorOptions &#123;</span><br><span class=\"line\">        arguments = [AROUTER_MODULE_NAME: project.getName()]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"注解处理器注册\">注解处理器注册<a title=\"#注解处理器注册\" href=\"#注解处理器注册\"></a></h3>\n<p>怎样将注解处理器注册到Java编译器中呢？这里有两种方式：手动注册和自动注册。</p>\n<p><strong>手动注册</strong>属于古老基本的注册方式，就是把所有的自定义注解处理器打包成一个jar包，然后通过<strong>引用此jar包来生成相应的java代码</strong>。在此之前你需要声明一个特定的文件javax.annotation.processing.Processor到META-INF/services路径下，一同打包到jar包中。</p>\n<blockquote>\n<p>META-INF/services 相当于一个信息包，目录中的文件和目录获得Java平台的认可与解释用来配置应用程序、扩展程序、类加载器和服务文件，在jar打包时自动生成</p>\n</blockquote>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/6FE224B85B174F71A08164131954FC78?method=download&amp;shareKey=6a43243eb6f7f3e4df94bca1f46fd7f1\" alt=\"注解处理器老注册方式\" class=\"φbs\"></p>\n<p>其中javax.annotation.processing.Processor文件中的内容为每个注解处理器的合法的全名列表，每一个元素换行分割</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.simple.processor.MyProcessor</span><br><span class=\"line\">com.simple.processor.MyProcessor1</span><br><span class=\"line\">com.simple.processor.MyProcessor2</span><br></pre></td></tr></table></figure>\n<p><strong>自动注册</strong>比较简单，只需要在apt-processor模块的build-gradle中声明一条依赖：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">&#x27;com.google.auto.service:auto-service:1.0-rc4&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>然后在相应的注解处理器的类名上添加一条注解<code>@AutoService(Processor.class)</code>，即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AutoService(Processor.class)</span></span><br><span class=\"line\"><span class=\"meta\">@SupportedAnnotationTypes(&#123;&quot;com.simple.annotation.MyAnnotation&quot;&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@SupportedSourceVersion(SourceVersion.RELEASE_7)</span></span><br><span class=\"line\"><span class=\"meta\">@SupportedOptions(&quot;MODULE_NAME&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyProcessor</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractProcessor</span> </span>&#123;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h3 id=\"注解处理器文件生成\">注解处理器文件生成<a title=\"#注解处理器文件生成\" href=\"#注解处理器文件生成\"></a></h3>\n<p>这一步是APT技术的精华所在，编写我们想要的java代码对应的生成规则。开篇我们已经提到了Element节点的概念，编译的过程同样是根据源文件节点信息来过滤和解析，当然生成java代码也同样需要过滤节点信息，然后根据规则拼接。</p>\n<p>还记得我们声明自定义注解器的<code>init</code>方法吗？在这里我们一般会实例化几个工具：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 节点工具类（类、函数、属性都是节点）</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Elements mElementUtils;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 类信息工具类</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Types mTypeUtils;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 文件生成器</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Filer mFiler;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 日志信息打印器</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Messager mMessager;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> String mModuleName;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.init(processingEnvironment);</span><br><span class=\"line\">    mElementUtils = processingEnv.getElementUtils();</span><br><span class=\"line\">    mTypeUtils = processingEnv.getTypeUtils();</span><br><span class=\"line\">    mFiler = processingEnv.getFiler();</span><br><span class=\"line\">    mMessager = processingEnv.getMessager();</span><br><span class=\"line\"></span><br><span class=\"line\">    mModuleName = processingEnv.getOptions().get(<span class=\"string\">&quot;MODULE_NAME&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中：</p>\n<ul>\n<li>mElementUtils 节点工具类，获取指定的节点信息，通过节点信息可以进一步获取该节点的类型、名称等。</li>\n<li>mTypeUtils 类信息工具类，常用于类型判断</li>\n<li>mFiler 文件生成器，生成指定的文件</li>\n<li>mMessager 日志工具类，用于打印日志信息</li>\n</ul>\n<p>接下来便可以用这几个工具在<code>process</code>方法里大展身手了。注解处理器文件生成规则主要在<code>process</code>方法中实现，文件生成规则实现方式也有两种：</p>\n<ol>\n<li>常规的写文件方式。</li>\n<li>利用<a href=\"https://github.com/square/javapoet\" target=\"_blank\">javapoet</a>框架来编写。</li>\n</ol>\n<p>例如想生成以下这个文件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.helloworld;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Hello, APT!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>常规的写文件方式，采用Writer.write实现，相应比较死板，需要把每一个字母都写上，有时候甚至连导包的<code>import</code>代码也要一字不差的垒上，这种方式写起来痛苦，容易出错，当然优点就是比较清晰一目了然：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder()</span><br><span class=\"line\">                .append(<span class=\"string\">&quot;package com.example.helloworld;\\n\\n&quot;</span>)</span><br><span class=\"line\">                .append(<span class=\"string\">&quot;public final class HelloWorld&#123;\\n&quot;</span>)</span><br><span class=\"line\">                .append(<span class=\"string\">&quot;\\tpublic static void main(String[] args) &#123;\\n&quot;</span>)</span><br><span class=\"line\">                .append(<span class=\"string\">&quot;\\t\\tSystem.out.println(\\&quot;Hello, APT!\\&quot;);\\n&quot;</span>)</span><br><span class=\"line\">                .append(<span class=\"string\">&quot;\\t&#125;\\n&quot;</span>)</span><br><span class=\"line\">                .append(<span class=\"string\">&quot;&#125;&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Writer writer = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            JavaFileObject source = mFiler.createSourceFile(<span class=\"string\">&quot;com.example.helloworld&quot;</span>);</span><br><span class=\"line\">            writer = source.openWriter();</span><br><span class=\"line\">            writer.write(builder.toString());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;APT process error&quot;</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (writer != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    writer.close();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//Silent</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>大名鼎鼎的<a href=\"https://github.com/greenrobot/EventBus\" target=\"_blank\">EventBus</a>就是这种处理的，甚至最新的3.0版本方式也没有改变。</p>\n<p>利用square团队的<code>javapoet</code>框架写文件方式更像编辑器写代码一样，更符合程序员的感觉，推荐！JavaPoet常用类如下：</p>\n<ul>\n<li>TypeSpec————用于生成类、接口、枚举对象的类</li>\n<li>MethodSpec————用于生成方法对象的类</li>\n<li>ParameterSpec————用于生成参数对象的类</li>\n<li>AnnotationSpec————用于生成注解对象的类</li>\n<li>FieldSpec————用于配置生成成员变量的类</li>\n<li>ClassName————通过包名和类名生成的对象，在JavaPoet中相当于为其指定Class</li>\n<li>ParameterizedTypeName————通过MainClass和IncludeClass生成包含泛型的Class</li>\n<li>JavaFile————控制生成的Java文件的输出的类</li>\n</ul>\n<p>JavaPoet的生成规则如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构建主函数</span></span><br><span class=\"line\">MethodSpec main = MethodSpec.methodBuilder(<span class=\"string\">&quot;main&quot;</span>)</span><br><span class=\"line\">    .addModifiers(Modifier.PUBLIC, Modifier.STATIC) <span class=\"comment\">// 指定方法修饰符</span></span><br><span class=\"line\">    .returns(<span class=\"keyword\">void</span>.class) <span class=\"comment\">// 指定返回类型</span></span><br><span class=\"line\">    .addParameter(String[].class, <span class=\"string\">&quot;args&quot;</span>) <span class=\"comment\">// 添加参数</span></span><br><span class=\"line\">    .addStatement(<span class=\"string\">&quot;$T.out.println($S)&quot;</span>, System.class, <span class=\"string\">&quot;Hello, APT!&quot;</span>) <span class=\"comment\">// 构建方法体</span></span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 构建类</span></span><br><span class=\"line\">TypeSpec helloWorld = TypeSpec.classBuilder(<span class=\"string\">&quot;HelloWorld&quot;</span>)</span><br><span class=\"line\">    .addModifiers(Modifier.PUBLIC, Modifier.FINAL) <span class=\"comment\">// 指定类修饰符</span></span><br><span class=\"line\">    .addMethod(main) <span class=\"comment\">// 添加方法</span></span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定包路径，构建文件体</span></span><br><span class=\"line\">JavaFile javaFile = JavaFile.builder(<span class=\"string\">&quot;com.example.helloworld&quot;</span>, helloWorld)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建文件</span></span><br><span class=\"line\">javaFile.writeTo(System.out);</span><br></pre></td></tr></table></figure>\n<p>JavaPoet详细的使用文档内容比较多，这里不做过多的描述，可以查看官方文档：<a href=\"https://github.com/square/javapoet%EF%BC%8C%E5%BD%93%E7%84%B6%E4%B9%9F%E6%9C%89%E7%BD%91%E5%8F%8B%E4%B8%93%E9%97%A8%E6%95%B4%E7%90%86%E4%BA%86%E4%B8%80%E4%BA%9B%E4%B8%AD%E6%96%87%E6%95%99%E7%A8%8B%EF%BC%9Ahttps://blog.csdn.net/l540675759/article/details/82931785\">https://github.com/square/javapoet，当然也有网友专门整理了一些中文教程：https://blog.csdn.net/l540675759/article/details/82931785</a></p>\n<p><strong>无论用哪种方式编写我们的java代码生成规则，我建议都先写一个指定java代码模板，然后根据此模板进行编写。</strong></p>\n<p>另外，写java代码生成规则之前我们也要做一件事，就是对注解处理器所支持的注解进行获取并解析，获取必要的节点信息，然后将这些信息组合到我们的生成规则中，这样我们的注解才会有意义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">process</span><span class=\"params\">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (set == <span class=\"keyword\">null</span> || set.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Set&lt;? extends Element&gt; rootElements = roundEnvironment.getElementsAnnotatedWith(MyAnnotation.class);</span><br><span class=\"line\">    StringBuilder annotations = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rootElements != <span class=\"keyword\">null</span> &amp;&amp; !rootElements.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Element element : rootElements) &#123;</span><br><span class=\"line\">            annotations.append(element.getSimpleName() + <span class=\"string\">&quot;,&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    String s = annotations.toString();</span><br><span class=\"line\">    mMessager.printMessage(Diagnostic.Kind.NOTE, <span class=\"string\">&quot;所有注解的类信息：&quot;</span> + s);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构建主函数</span></span><br><span class=\"line\">    MethodSpec main = MethodSpec.methodBuilder(<span class=\"string\">&quot;main&quot;</span>)</span><br><span class=\"line\">            .addModifiers(Modifier.PUBLIC, Modifier.STATIC) <span class=\"comment\">// 指定方法修饰符</span></span><br><span class=\"line\">            .returns(<span class=\"keyword\">void</span>.class) <span class=\"comment\">// 指定返回类型</span></span><br><span class=\"line\">            .addParameter(String[].class, <span class=\"string\">&quot;args&quot;</span>) <span class=\"comment\">// 添加参数</span></span><br><span class=\"line\">            .addStatement(<span class=\"string\">&quot;$T.out.println($S)&quot;</span>, System.class, s) <span class=\"comment\">// 构建方法体</span></span><br><span class=\"line\">            .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构建类</span></span><br><span class=\"line\">    TypeSpec helloWorld = TypeSpec.classBuilder(<span class=\"string\">&quot;HelloWorld&quot;</span>)</span><br><span class=\"line\">            .addModifiers(Modifier.PUBLIC, Modifier.FINAL) <span class=\"comment\">// 指定类修饰符</span></span><br><span class=\"line\">            .addMethod(main) <span class=\"comment\">// 添加方法</span></span><br><span class=\"line\">            .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 指定包路径，构建文件体</span></span><br><span class=\"line\">    JavaFile javaFile = JavaFile.builder(<span class=\"string\">&quot;com.example.helloworld&quot;</span>, helloWorld).build();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建文件</span></span><br><span class=\"line\">        javaFile.writeTo(mFiler);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"注解处理器调用\">注解处理器调用<a title=\"#注解处理器调用\" href=\"#注解处理器调用\"></a></h3>\n<p>关于调用，上边也说过，我们专门新建一个名为apt-api的android module，为什么要写api呢？首先我们写代码的时候这些文件还没有编译生成，我们无法直接用。第二，APT是一个动态框架，也就是说开发不需要关心到底生成什么鬼东西，只要告诉我怎么用就行，生成千千万个文件都是内部的细节，开发不需要操心。</p>\n<p>例如我们想实例化上边的HelloWorld，我们可以这样编写相应的api：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAptApi</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Class&lt;?&gt; c = Class.forName(<span class=\"string\">&quot;com.example.helloworld.HelloWorld&quot;</span>);</span><br><span class=\"line\">            c.newInstance();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InstantiationException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一般情况下我们想要使用我们生成的java类文件，更多的是将类文件实现某个现成的接口，通过接口代理来使用。</p>\n<h2 id=\"最后\">最后<a title=\"#最后\" href=\"#最后\"></a></h2>\n<p>注解处理器APT技术使用很广泛，但是总归有个套路和框架，本篇文章仅仅从apt的整体结构上阐释其基本使用过程，师傅领进门修行靠个人，更深层次的还望各位童鞋进一步挖掘，最好是也可以透过一些框架原理去深层次学习，例如ButterKnife和EventBus。</p>\n","prev":{"title":"DO AS ONE WISHES","link":"posts/0"},"next":{"title":"Android组件化可行性方案探讨和思考","link":"posts/1618992460"},"plink":"https://blog.ixin.run/posts/1619764951/","toc":[{"id":"什么是apt","title":"什么是APT","index":"1"},{"id":"什么是element","title":"什么是Element","index":"2"},{"id":"注解处理器实现过程","title":"注解处理器实现过程","index":"3","children":[{"id":"注解处理器声明","title":"注解处理器声明","index":"3.1"},{"id":"注解处理器注册","title":"注解处理器注册","index":"3.2"},{"id":"注解处理器文件生成","title":"注解处理器文件生成","index":"3.3"},{"id":"注解处理器调用","title":"注解处理器调用","index":"3.4"}]},{"id":"最后","title":"最后","index":"4"}],"reward":true,"copyright":{"author":"i猩人","link":"<a href=\"https://blog.ixin.run/posts/1619764951/\" title=\"Android注解处理器APT技术探究\">https://blog.ixin.run/posts/1619764951/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}