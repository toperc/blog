{"title":"Http协议原理知多少","date":"2021-03-08T13:59:05.000Z","date_formatted":{"ll":"2021年3月8日","L":"2021/03/08","MM-DD":"03-08"},"link":"posts/1615211970","comments":true,"tags":["HTTP"],"categories":["计算机网络"],"updated":"2021-03-15T04:16:08.121Z","content":"<p>推荐一本书《图解HTTP》，我看了有好几遍，尤其是书中的图片很形象。无论是前端、移动端抑或是大后端都离不开Http协议，所以弄清楚Http相关知识和原理着实重要，本文就挑重点式总结一下Http知识。</p>\n<a id=\"more\"></a>\n<h2 id=\"tcp/ip协议族\">TCP/IP协议族<a title=\"#tcp/ip协议族\" href=\"#tcp/ip协议族\"></a></h2>\n<p>为了理解HTTP，我们有必要事先了解一下TCP/IP协议族。</p>\n<blockquote>\n<p>什么是协议？<br>\n计算机与网络设备进行通信，双方就必须基于相同的方法。比如，如何找到通信目标，采用哪种语言通信，如何结束通信等。这些都需要规则约束，我们把这种规则称之为协议（protocol）。</p>\n</blockquote>\n<p>通常使用的网络（包括互联网）是在TCP/IP协议族的基础上运作的，而HTTP、TCP、IP等协议都属于它内部的子集。切莫把TCP/IP解读为仅仅是TCP和IP协议。</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/32807F1D6ED44FF1BB4F6FF81578DECF?method=download&amp;shareKey=ee96a266c9abef8e7576ef61039e1955\" alt=\"TCPIP是互联网相关的各类协议族的总称\" class=\"φbs\"></p>\n<h3 id=\"tcp/ip分层\">TCP/IP分层<a title=\"#tcp/ip分层\" href=\"#tcp/ip分层\"></a></h3>\n<p>TCP/IP采用四层分层模型，自上而下分别为应用层、传输层、网络层、数据链路层。</p>\n<p><strong>应用层</strong>：</p>\n<p>应用层决定了向用户提供应用服务时通信的活动。应用层相关的协议有：</p>\n<ul>\n<li>HTTP（Hyper Text Transfer Protocol，超文本传输协议）</li>\n<li>FTP（File TransferProtocol，文件传输协议）</li>\n<li>DNS（Domain Name System，域名解析系统）</li>\n</ul>\n<p><strong>传输层</strong>：</p>\n<p>传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。传输层相关的协议有：</p>\n<ul>\n<li>TCP（Transmission Control Protocol，传输控制协议）</li>\n<li>UDP（User Data Protocol，用户数据报协议）</li>\n</ul>\n<p><strong>网络层</strong>：</p>\n<p>处理在网络上流动的数据包，为数据包选择路由。网络层相关的协议有：</p>\n<ul>\n<li>IP（Internet Protocol，IP协议）</li>\n</ul>\n<p><strong>数据链路层</strong>：</p>\n<p>用来处理连接网络的硬件部分，硬件上的范畴均在链路层的作用范围之内。</p>\n<h3 id=\"http协议\">HTTP协议<a title=\"#http协议\" href=\"#http协议\"></a></h3>\n<p>HTTP（Hyper Text Transfer Protocol，超文本传输协议），位于TCP/IP四层模型当中的应用层。 作用：在浏览器与服务器间传送文档，也是从Web服务器传输超文本到客户端的传输协议，无状态的传输协议；不仅能够保证正确、快速、高效的传输超文本文档，而且可以确定资源加载顺序等。 在Web开发中，页面缓存控制、数据传递、文档语言参数设定等等，都离不开HTTP协议。</p>\n<p>HTTP协议的几个重要概念：</p>\n<ol>\n<li>连接(Connection)：一个传输层的实际环流，它是建立在两个相互通讯的应用程序之间。</li>\n<li>消息(Message)：HTTP通讯的基本单位，包括一个结构化的八元组序列并通过连接传输。</li>\n<li>请求(Request)：一个从客户端到服务器的请求信息包括应用于资源的方法、资源的标识符和协议的版本号</li>\n<li>响应(Response)：一个从服务器返回的信息包括HTTP协议的版本号、请求的状态(例如“成功”或“没找到”)和文档的MIME类型。</li>\n<li>资源(Resource)：由URI标识的网络数据对象或服务。</li>\n<li>实体(Entity)：数据资源或来自服务资源的回映的一种特殊表示方法，它可能被包围在一个请求或响应信息中。一个实体包括实体头信息和实体的本身内容。</li>\n<li>客户机(Client)：一个为发送请求目的而建立连接的应用程序。</li>\n<li>用户代理(Useragent)：初始化一个请求的客户机。它们是浏览器、编辑器或其它用户工具。</li>\n<li>服务器(Server)：一个接受连接并对请求返回信息的应用程序。</li>\n<li>源服务器(Originserver)：是一个给定资源可以在其上驻留或被创建的服务器。</li>\n<li>代理(Proxy)：一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。<br>\n代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处理没有被用户代理完成的请求。</li>\n<li>网关(Gateway)：一个作为其它服务器中间媒介的服务器。与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。<br>\n网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。</li>\n<li>通道(Tunnel)：是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。</li>\n<li>缓存(Cache)：反应信息的局域存储。</li>\n</ol>\n<h3 id=\"dns协议\">DNS协议<a title=\"#dns协议\" href=\"#dns协议\"></a></h3>\n<p>DNS（Domain Name System，域名解析服务）的缩写，主要负责将域名解析为对应的IP地址。它与HTTP协议一样位于应用层。</p>\n<p>对于用户来说使用一串有意义的字符去访问某台计算机是更容易接受的。例如，用www.baidu.com访问百度。将用户容易理解的域名解析为网络传输需要的IP，这就是DNS存在的意义。</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/0361DA392A8C4AD19E7DAA178B8BD2C7?method=download&amp;shareKey=46dd1d840c79618649c88751bbcc74e9\" alt=\"DNS域名解析示意图\" class=\"φbs\"></p>\n<h3 id=\"tcp协议\">TCP协议<a title=\"#tcp协议\" href=\"#tcp协议\"></a></h3>\n<p>TCP（Transmission Control Protocol，传输控制协议），TCP位于传输层，提供可靠的字节流服务。</p>\n<p>TCP协议为了更容易传送大数据需要将大块数据分割成以报文段（segment）为单位的数据包。而且TCP协议能够确认数据最终是否送达到对方和安全断开连接，采用的方式是<code>三次握手和四次挥手形式</code>。</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/A60EB05247764F729CB8B0B1AF925428?method=download&amp;shareKey=cb2a188eeeead1dfc68283e7a931d42f\" alt=\"三次握手示意图\" class=\"φbs\"></p>\n<h3 id=\"ip协议\">IP协议<a title=\"#ip协议\" href=\"#ip协议\"></a></h3>\n<p>IP（Internet Protocol）网际协议位于网络层，IP协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是IP地址和MAC地址（Media AccessControl Address）。</p>\n<p>IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会更改。</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/2BE620B72FE9472CBED6EA1B316024DD?method=download&amp;shareKey=af61140458074b9dbac7684c59e86fe0\" alt=\"IP定位原理示意图\" class=\"φbs\"></p>\n<h3 id=\"网络通信传输流\">网络通信传输流<a title=\"#网络通信传输流\" href=\"#网络通信传输流\"></a></h3>\n<p>下图是根据TCP/IP分层原理，端到端数据流的走向。</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/C1551CBFDBA84F28A0B2E16D862A1D11?method=download&amp;shareKey=1b6be26f3f16ec629ea60de85a387284\" alt=\"网络通信传输流\" class=\"φbs\"></p>\n<p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。</p>\n<p>单说发送端这部分，数据流中各个协议扮演的角色如下：</p>\n<ol>\n<li>应用层的HTTP协议将请求地址和数据按照一定的格式包装成请求体，然后向下传输。</li>\n<li>传输层的TCP协议负责连接、发送数据、断开连接。<strong>TCP协议保证了HTTP数据包到达接受端的可靠性</strong>。为了传输方便，<strong>在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割</strong>，并在各个报文上打上标记序号及端口号后转发给网络层。</li>\n<li>网络层IP协议，将传输层传过来的数据作为自己的数据，并在自己数据前端加上IP首部然后转发给数据链路层。值得一提的是，在IP首部指定了接受端的MAC地址。</li>\n<li>数据链路层负责数据信号通过硬件向接收端进行传输。</li>\n</ol>\n<h3 id=\"各种协议与http协议的关系\">各种协议与HTTP协议的关系<a title=\"#各种协议与http协议的关系\" href=\"#各种协议与http协议的关系\"></a></h3>\n<p>通过一张图我们回顾一下整个HTTP过程：</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/836B03C2C2F444A5BD6F1A8D1F43F8F3?method=download&amp;shareKey=b3c6eba58f991f385eed8e81621fc7a4\" alt=\"各种协议与HTTP协议的关系\" class=\"φbs\"></p>\n<h2 id=\"http报文\">HTTP报文<a title=\"#http报文\" href=\"#http报文\"></a></h2>\n<p>用于HTTP协议交互的信息被称为HTTP报文，HTTP报文本身是由多行（用CR+LF作换行符）数据构成的字符串文本。</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/05F39EB8EEF740B08A4F8B534A7E6BA3?method=download&amp;shareKey=911e271d7f5a2317415060d3265d7165\" alt=\"HTTP报文的结构\" class=\"φbs\"></p>\n<p>HTTP报文有两种：<strong>请求报文</strong> 和 <strong>响应报文</strong>。请求报文指从客户端向服务端发送的报文，响应报文指从服务端响应客户端的报文。</p>\n<p>这两种报文都是由 <strong>首行</strong>、<strong>报文首部</strong>、<strong>报文主体</strong>三部分组成的。</p>\n<p><strong>请求报文</strong>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST &#x2F;i HTTP&#x2F;1.1</span><br><span class=\"line\">Host: count.typora.io</span><br><span class=\"line\">Accept: *&#x2F;*</span><br><span class=\"line\">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">Cookie: __cfduid&#x3D;d345ac732c82bada5e1f1b3ec7f42498e1550563241</span><br><span class=\"line\">Accept-Language: zh-cn</span><br><span class=\"line\">Content-Length: 206</span><br><span class=\"line\">Accept-Encoding: br, gzip, deflate</span><br><span class=\"line\">User-Agent: Typora&#x2F;1355 CFNetwork&#x2F;975.0.3 Darwin&#x2F;18.2.0 (x86_64)</span><br><span class=\"line\"></span><br><span class=\"line\">app_key&#x3D;3162bc659f38963b8f15099e19551</span><br></pre></td></tr></table></figure>\n<p><strong>响应报文</strong>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP&#x2F;1.1 200 OK</span><br><span class=\"line\">Server: nginx</span><br><span class=\"line\">Date: Mon, 11 Mar 2019 03:28:05 GMT</span><br><span class=\"line\">Content-Type: application&#x2F;json; charset&#x3D;utf-8</span><br><span class=\"line\">Vary: Accept-Encoding</span><br><span class=\"line\">Access-Control-Allow-Origin: *</span><br><span class=\"line\">X-Frame-Options: deny</span><br><span class=\"line\">X-XSS-Protection: 1; mode&#x3D;block</span><br><span class=\"line\">Content-Encoding: gzip</span><br><span class=\"line\">Transfer-Encoding: chunked</span><br><span class=\"line\">Connection: Keep-alive</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&quot;result&quot;:&quot;Success&quot;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"请求报文首行\">请求报文首行<a title=\"#请求报文首行\" href=\"#请求报文首行\"></a></h3>\n<p><code>POST /i HTTP/1.1</code>是请求报文的首行。其中 <code>POST</code> 代表请求方法。 <code>/i</code> 表示请求的资源URI。<code>HTTP/1.1</code> 表示HTTP版本号。</p>\n<h4 id=\"请求方法\">请求方法<a title=\"#请求方法\" href=\"#请求方法\"></a></h4>\n<p>告知服务器请求意图，期望服务器产生某种行为。</p>\n<p>目前常见的方法有：</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/70410101D48F42D88624B31FB6ED6BE5?method=download&amp;shareKey=60d7060ee9513bd17ec7474ac86b4628\" alt=\"http请求方法\" class=\"φbs\"></p>\n<p>通常我们只会用到GET、POST方法。GET用来请求访问已被URI识别的资源，指定的资源经服务器解析后返回响应结果。POST用来传输实体的主体。虽然GET也可以用来传输实体的主体，但是一般我们不用，而是用POST。</p>\n<p>PUT用来传输文件，但是由于HTTP/1.1的PUT方法不带验证机制，存在安全隐患，因此很少用到。</p>\n<p>DETETE和PUT存在一样的问题，因此也很少用到。但是如果服务器采用了REST风格的设计，PUT和DELETE将会被应用到。</p>\n<p>HEAD和GET方法一样，只是不返回响应报文的主体部分。用来确认URI的有效性和资源更新的日期时间等。例如，客户端需要一个很大的文件（几百兆），如果每次都从网络上加载文件会造成很大的开销。为了解决这个问题，客户端可以在首次GET文件后进行缓存，以后只需要HEAD请求验证文件是否更新，只有当文件更新后才需要重新GET。</p>\n<h3 id=\"响应报文首行\">响应报文首行<a title=\"#响应报文首行\" href=\"#响应报文首行\"></a></h3>\n<p><code>HTTP/1.1 200 OK</code> 是响应报文的首行。其中<code>HTTP/1.1</code>已经介绍过了，与请求报文首行中的HTTP版本号相同。<code>200</code>表示返回结果的状态码。<code>OK</code>表示原因短语。</p>\n<h4 id=\"状态码\">状态码<a title=\"#状态码\" href=\"#状态码\"></a></h4>\n<p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/B4DB98B74BE144E09ECB4AC53031F931?method=download&amp;shareKey=effd7f46770a282093b6f498a2f8f07b\" alt=\"响应的状态码可描述请求的处理结果\" class=\"φbs\"></p>\n<p>状态码如<code>200 OK</code>，以3位数字和原因短语组成。数字中的第一位指定了响应类别，后两位无分类。响应类别有以下5种：</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/1FCF55BB77ED4F00BA91EEAF5638052B?method=download&amp;shareKey=c0f757eba0118eaeaa22ac01176cfac5\" alt=\"状态码的类别\" class=\"φbs\"></p>\n<h3 id=\"报文首部\">报文首部<a title=\"#报文首部\" href=\"#报文首部\"></a></h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host: count.typora.io</span><br><span class=\"line\">Accept: *&#x2F;*</span><br><span class=\"line\">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">Cookie: __cfduid&#x3D;d345ac732c82bada5e1f1b3ec7f42498e1550563241</span><br><span class=\"line\">Accept-Language: zh-cn</span><br><span class=\"line\">Content-Length: 206</span><br><span class=\"line\">Accept-Encoding: br, gzip, deflate</span><br><span class=\"line\">User-Agent: Typora&#x2F;1355 CFNetwork&#x2F;975.0.3 Darwin&#x2F;18.2.0 (x86_64)</span><br></pre></td></tr></table></figure>\n<p>报文的首部字段表示请求的各种条件和属性，它能起到传递额外重要信息的作用。根据其用途的不同可以分为以下四种：<code>通用首部字段</code>、<code>请求首部字段</code>、<code>响应首部字段</code>、<code>实体首部字段</code>。</p>\n<p>HTTP/1.1规范定义了如下47种首部字段。</p>\n<h4 id=\"通用首部字段\">通用首部字段<a title=\"#通用首部字段\" href=\"#通用首部字段\"></a></h4>\n<p>请求报文和响应报文都会用到的首部。</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/9339F678053A4B52BC0E5198DF0B79B4?method=download&amp;shareKey=57b6ed9e44332b397b50388801168d59\" alt=\"通用首部字段\" class=\"φbs\"></p>\n<h4 id=\"请求首部字段\">请求首部字段<a title=\"#请求首部字段\" href=\"#请求首部字段\"></a></h4>\n<p>请求报文用到的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/B443BE4A554A4ACFB7E87BD2DE5C7662?method=download&amp;shareKey=045073e3bfb35d529c74200b3ee1d0f2\" alt=\"请求首部字段\" class=\"φbs\"></p>\n<h4 id=\"响应首部字段\">响应首部字段<a title=\"#响应首部字段\" href=\"#响应首部字段\"></a></h4>\n<p>响应报文用到的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/EDED608258A346D7A98463F7D6044008?method=download&amp;shareKey=ac57c5f7db1b37f052c0502f86776905\" alt=\"响应首部字段\" class=\"φbs\"></p>\n<h4 id=\"实体首部字段\">实体首部字段<a title=\"#实体首部字段\" href=\"#实体首部字段\"></a></h4>\n<p>针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/B47E8C7E04864641AE82F69194F4168A?method=download&amp;shareKey=2d4018cc9550d8c469e2f4786d5246f1\" alt=\"实体首部字段\" class=\"φbs\"></p>\n<h4 id=\"常用的报文首部\">常用的报文首部<a title=\"#常用的报文首部\" href=\"#常用的报文首部\"></a></h4>\n<p>HTTP/1.1定义了47种首部字段，另外还有一些扩展的。比较常用的几种：</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/D2E91B85A5D340239203C59E8A65CF61?method=download&amp;shareKey=653f5a6a58e935e5921eb4816e5d930d\" alt=\"常用的首部字段\" class=\"φbs\"></p>\n<h2 id=\"http工作原理\">HTTP工作原理<a title=\"#http工作原理\" href=\"#http工作原理\"></a></h2>\n<p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>\n<p>以下是 HTTP 请求/响应的步骤：</p>\n<p><strong>1、客户端连接到Web服务器</strong><br>\n一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。</p>\n<p><strong>2、发送HTTP请求</strong><br>\n通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p>\n<p><strong>3、服务器接受请求并返回HTTP响应</strong><br>\nWeb服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p>\n<p><strong>4、释放连接TCP连接</strong><br>\n若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p>\n<p><strong>5、客户端浏览器解析HTML内容</strong><br>\n客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p>\n<p>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p>\n<ol>\n<li>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址；</li>\n<li>解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接；</li>\n<li>浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器；</li>\n<li>服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器；</li>\n<li>释放 TCP连接；</li>\n<li>浏览器将该 html 文本并显示内容；</li>\n</ol>\n<h2 id=\"http特性\">HTTP特性<a title=\"#http特性\" href=\"#http特性\"></a></h2>\n<h3 id=\"1.-无状态\">1. 无状态<a title=\"#1.-无状态\" href=\"#1.-无状态\"></a></h3>\n<p>HTTP 是一种无状态协议，即HTTP不会管理之前客户端与服务器的通信状态。由于不用保存通信状态，那么服务器的CPU以及内存的压力会大大降价。这是HTTP无状态的优点，但它也会给我们带来一些的问题。</p>\n<p>例如，我们去某购物网站购物，提交订单之前要对我们的身份进行验证（需要我们登录账号）。但是由于HTTP的无状态特性（没有记录登录状态），每次下单都会要求我们重新登录。为了即不破坏HTTP的无状态特性又可以解决类似的问题，HTTP引入了Cookie技术。Cookie技术通过在请求报文和响应报文中加入cookie信息来实现状态的保持。在响应报文中，服务器可以通过set-cookie首部告诉客户端Cookie信息。客户端再次请求时会通过Cookie首部携带上Cookie信息。</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/98AF08E6B382451AADC09970B60FC719?method=download&amp;shareKey=7f9c5c69c2bdc1caff2655449a776ff4\" alt=\"cookie使用\" class=\"φbs\"></p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/3328311BC5F447A0801926BBC8FFAF70?method=download&amp;shareKey=12ddaaa3c7f963829cda02bf0ce9a6b1\" alt=\"cookie工作原理\" class=\"φbs\"></p>\n<h3 id=\"2.-持久连接\">2. 持久连接<a title=\"#2.-持久连接\" href=\"#2.-持久连接\"></a></h3>\n<p>HTTP依赖于TCP进行数据传输，TCP是一种稳定的长连接，即如果没有一方明确的提出过断开连接，那么连接将一直持续。</p>\n<p>在早些年的HTTP协议中，每进行一次HTTP通信，都会有一次TCP的连接与断开。这与TCP的长连接特性相违背。因此，在HTTP/1.1和部分HTTP/1.0中增加了<strong>持久连接（HTTP persistent connection，也称作HTTP keep-alive或HTTP connection reuse）</strong>，使用同一个TCP连接来发送和接受多个HTTP通信，而不是为每一次通信都打开新的连接。HTTP就是通过Connection首部来管理持久连接的。</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/CA56718E56D74D5C82BBD110F44AD8BE?method=download&amp;shareKey=bef7a3ef4138f8c474613ec3d3e9f572\" alt=\"Connection首部使用\" class=\"φbs\"></p>\n<h3 id=\"3.-缓存机制\">3. 缓存机制<a title=\"#3.-缓存机制\" href=\"#3.-缓存机制\"></a></h3>\n<p>HTTP允许客户端在一次URL请求完成后将响应结果存储到本地。下次向该URL请求资源时，客户端会直接从本地存储中获取到该URL的资源。引入了缓存机制后，HTTP请求会变的稍微复杂一点：</p>\n<ol>\n<li>\n<p>当我们初次访问一个URL时，服务器返回请求资源并同时告诉客户端对资源进行缓存、以及缓存过期时间。</p>\n</li>\n<li>\n<p>再次访问该URL时，客户端会根据URI找到对应的缓存，并检查缓存是否有效（当前时间小于缓存的过期时间）。</p>\n</li>\n<li>\n<p>若缓存有效，客户端不会去访问服务器，而是直接从缓存中获取资源，这个过程我们称为<strong>缓存命中</strong>。</p>\n</li>\n<li>\n<p>若缓存无效（当前时间大于缓存的过期时间），客户端会去向服务器验证缓存是否有效。</p>\n<ul>\n<li>有效，服务器仅返回代表缓存有效的首部信息，客户端更新缓存过期时间，同时从缓存中取得资源。</li>\n<li>无效，服务器返回新的资源，客户端更新资源。</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/AF15E54831A54A099DBB2204ED4F1518?method=download&amp;shareKey=46b44b90f94298c76dbce5f4c5528f2e\" alt=\"缓存机制使用的首部字段\" class=\"φbs\"></p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/07945B001A7E49C5BCC4AD97DF8B4D47?method=download&amp;shareKey=f03707d312d559469c6d3602ff6889c2\" alt=\"HTTP引入缓存机制后的请求\" class=\"φbs\"></p>\n<h2 id=\"扩展知识\">扩展知识<a title=\"#扩展知识\" href=\"#扩展知识\"></a></h2>\n<h3 id=\"get和post的区别\">GET和POST的区别<a title=\"#get和post的区别\" href=\"#get和post的区别\"></a></h3>\n<p>其实这个问题这么多年来争论一直<a href=\"https://www.zhihu.com/question/28586791\" target=\"_blank\">喋喋不休</a>。GET和POST这两种方式从<code>&quot;明面&quot;</code>上说可能有以下区别：</p>\n<ul>\n<li>GET能被缓存，POST不能缓存 。</li>\n<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>\n<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>\n<li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li>\n<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>\n<li>GET只允许 ASCII 字符。POST没有限制。也允许二进制数据。</li>\n</ul>\n<p>然而上边的这些区别仅仅是<code>&quot;明面&quot;</code>上的。实际上GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。这里有一个很形象的说明：</p>\n<blockquote>\n<p>在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。</p>\n</blockquote>\n<p>针对<code>“安全性”</code>，我们常听到GET不如POST安全，因为POST用body传输数据，而GET用url传输，更加容易看到。但是从攻击的角度，无论是GET还是POST都不够安全，因为HTTP本身是明文协议。每个HTTP请求和返回的每个byte都会在网络上明文传播，不管是url，header还是body。</p>\n<p>针对<code>&quot;长度限制&quot;</code>，这里也有一个形象的说明：</p>\n<blockquote>\n<p>在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器（发起http请求）和服务器（接受http请求）就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物（url中无限加参数）。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。</p>\n</blockquote>\n<h3 id=\"tcp和udp的区别\">TCP和UDP的区别<a title=\"#tcp和udp的区别\" href=\"#tcp和udp的区别\"></a></h3>\n<p><strong>什么是UDP?</strong></p>\n<p>UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p>\n<p>它有以下几个特点：</p>\n<p><strong>1.面向无连接</strong></p>\n<p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。具体来说就是：</p>\n<ul>\n<li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li>\n<li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li>\n</ul>\n<p><strong>2.有单播，多播，广播的功能</strong></p>\n<p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p>\n<p><strong>3.UDP是面向报文的</strong></p>\n<p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p>\n<p><strong>4.不可靠性</strong></p>\n<p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p>\n<p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p>\n<p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p>\n<p>TCP和UDP的比较:</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/1CCDEA3D12084F048AF86940EF8F7296?method=download&amp;shareKey=3f548ea6f30bfe307486990c792c976c\" alt=\"TCP和UDP的比较\" class=\"φbs\"></p>\n<h3 id=\"osi七层模型\">OSI七层模型<a title=\"#osi七层模型\" href=\"#osi七层模型\"></a></h3>\n<p>OSI（open system interconnection，开放式系统互联参考模型）是一种概念模型，由国际标准化组织提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。</p>\n<p>该模型将通信系统中的数据流划分为七个层，从跨通信介质传输位的物理实现到分布式应用程序数据的最高层表示。每个中间层为其上一层提供功能，其自身功能则由其下一层提供。</p>\n<p>自上而下七层分别是：</p>\n<p><strong>第7层 应用层</strong></p>\n<p>应用层（Application Layer）提供为应用软件而设计的接口，以设置与另一应用软件之间的通信。例如：HTTP、HTTPS、FTP、Telnet、SSH、SMTP、POP3等。</p>\n<p><strong>第6层 表示层</strong></p>\n<p>表示层（Presentation Layer）把数据转换为能与接收者的系统格式兼容并适合传输的格式。</p>\n<p><strong>第5层 会话层</strong></p>\n<p>会话层（Session Layer）负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接。</p>\n<p><strong>第4层 传输层</strong></p>\n<p>传输层（Transport Layer）把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议（TCP）等。</p>\n<p><strong>第3层 网络层</strong></p>\n<p>网络层（Network Layer）决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络资料。例如:互联网协议（IP）等。</p>\n<p><strong>第2层 数据链路层</strong></p>\n<p>数据链路层（Data Link Layer）负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成信息框（Data Frame）。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。例如以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）等。</p>\n<p>分为两个子层：逻辑链路控制（logical link control，LLC）子层和介质访问控制（Media access control，MAC）子层。</p>\n<p><strong>第1层 物理层</strong></p>\n<p>物理层（Physical Layer）在局部局域网上发送数据帧（Data Frame），它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等。</p>\n<p>OSI和TCP/IP对应关系：</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/09A2256813194A09A259EC6AC905A336?method=download&amp;shareKey=f2075ebfb001c155906f0229edd354f1\" alt=\"OSI和TCP/IP对应关系\" class=\"φbs\"></p>\n<h2 id=\"王炸\">王炸<a title=\"#王炸\" href=\"#王炸\"></a></h2>\n<p>一张图理清全域TCP/IP：</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/4D837300B9F940C2875DD22A1667EF15?method=download&amp;shareKey=069a3e589a8ff4329651ea7f07d2c4f5\" alt=\"全域TCP/IP\" class=\"φbs\"></p>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<ul>\n<li>《图解HTTP》</li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE\" target=\"_blank\">超文本传输协议–维基百科</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B\" target=\"_blank\">OSI模型–维基百科</a></li>\n<li><a href=\"https://juejin.cn/post/6844903815531986957\">https://juejin.cn/post/6844903815531986957</a></li>\n<li><a href=\"https://juejin.cn/post/6857287743966281736\">https://juejin.cn/post/6857287743966281736</a></li>\n</ul>\n","prev":{"title":"HTTPS协议原理必知必会","link":"posts/1615560323"},"next":{"title":"你了解android的进程间通信吗","link":"posts/1615119064"},"plink":"https://blog.ixin.run/posts/1615211970/","toc":[{"id":"tcp/ip协议族","title":"TCP&#x2F;IP协议族","index":"1","children":[{"id":"tcp/ip分层","title":"TCP&#x2F;IP分层","index":"1.1"},{"id":"http协议","title":"HTTP协议","index":"1.2"},{"id":"dns协议","title":"DNS协议","index":"1.3"},{"id":"tcp协议","title":"TCP协议","index":"1.4"},{"id":"ip协议","title":"IP协议","index":"1.5"},{"id":"网络通信传输流","title":"网络通信传输流","index":"1.6"},{"id":"各种协议与http协议的关系","title":"各种协议与HTTP协议的关系","index":"1.7"}]},{"id":"http报文","title":"HTTP报文","index":"2","children":[{"id":"请求报文首行","title":"请求报文首行","index":"2.1"},{"id":"响应报文首行","title":"响应报文首行","index":"2.2"},{"id":"报文首部","title":"报文首部","index":"2.3"}]},{"id":"http工作原理","title":"HTTP工作原理","index":"3"},{"id":"http特性","title":"HTTP特性","index":"4","children":[{"id":"1.-无状态","title":"1. 无状态","index":"4.1"},{"id":"2.-持久连接","title":"2. 持久连接","index":"4.2"},{"id":"3.-缓存机制","title":"3. 缓存机制","index":"4.3"}]},{"id":"扩展知识","title":"扩展知识","index":"5","children":[{"id":"get和post的区别","title":"GET和POST的区别","index":"5.1"},{"id":"tcp和udp的区别","title":"TCP和UDP的区别","index":"5.2"},{"id":"osi七层模型","title":"OSI七层模型","index":"5.3"}]},{"id":"王炸","title":"王炸","index":"6"},{"id":"参考","title":"参考","index":"7"}],"reward":true,"copyright":{"author":"i猩人","link":"<a href=\"https://blog.ixin.run/posts/1615211970/\" title=\"Http协议原理知多少\">https://blog.ixin.run/posts/1615211970/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}