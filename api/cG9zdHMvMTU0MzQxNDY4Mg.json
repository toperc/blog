{"title":"Android开发之Touch事件的分发和消费机制","date":"2018-11-28T14:18:02.000Z","date_formatted":{"ll":"2018年11月28日","L":"2018/11/28","MM-DD":"11-28"},"link":"posts/1543414682","comments":true,"tags":["View视图"],"categories":["Android"],"updated":"2021-01-29T12:51:44.633Z","content":"<p>凡是和视图打交道的避免不了事件的分发和消费，无论是桌面还是移动设备，Android上的Touch事件分发机制尤为重要。</p>\n<a id=\"more\"></a>\n<h2 id=\"触摸事件场景分配\">触摸事件场景分配<a title=\"#触摸事件场景分配\" href=\"#触摸事件场景分配\"></a></h2>\n<p>Android 中与 Touch事件相关的方法包括：</p>\n<ul>\n<li>dispatchTouchEvent(MotionEvent ev)</li>\n<li>onInterceptTouchEvent(MotionEvent ev)</li>\n<li>onTouchEvent(MotionEvent ev)</li>\n</ul>\n<p>能够响应这些方法的控件包括：</p>\n<ul>\n<li>ViewGroup 及其子类</li>\n<li>Activity</li>\n</ul>\n<p>其中Activity和最小单位的view（例如TextView,不能向其中添加子view ）是不存在onInterceptTouchEvent方法的。以下所说的上层下层是按照由外到内来说。<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/AD2304BA531440FDAE18456182617D11?method=download&amp;shareKey=f32e743438fd32e6a75f69e0ff52531e\" alt=\"触摸事件场景\"></p>\n<h2 id=\"触摸事件分发流程\">触摸事件分发流程<a title=\"#触摸事件分发流程\" href=\"#触摸事件分发流程\"></a></h2>\n<p>1.事件分发：public boolean dispatchTouchEvent(MotionEvent ev)</p>\n<p>从开始触摸的时候，事件的执行顺序一定是要从最外层的Activity开始，然后按照Activity-&gt;window-&gt;viewgroup-&gt;view依次往下传递，最终将事件传递到具体的view。这种方式也叫隧道方式。我们可以根据它的返回值来控制其走向和终止：</p>\n<ul>\n<li>return super.dispatchTouchEvent(ev):判断本层是否可执行onInterceptTouchEvent方法，能就派发给onInterceptTouchEvent方法执行，不能就接着向下层的dispatchTouchEvent方法去派发。</li>\n<li>return false:判断时候有上层view，有就接着让上层的onTouchEvent方法消费，没有（说明已经是最外层）本方法消费后消失。</li>\n<li>return true:仅本view消费后消失，并不往下分发。</li>\n</ul>\n<p>2.事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev)</p>\n<p>每当viewgroup中的dispatchTouchEvent正常分发紧接着要执行viewgroup中的onInterceptTpuchEvent方法对此事件进行拦截。和上边一样我们也可以控制其返回值进而控制其是进行拦截事件然后响应还是接着向下一层分发：</p>\n<ul>\n<li>return super.onInterceptTouchEvent(ev):判断是否有下层，有就接着向下层的dispatchTouchEvent派发，没有就执行本层view的onTouchEvent.</li>\n<li>return false:和super.onInterceptTouchEvent返回值功能一样。</li>\n<li>return true:进行拦截，不在向下层进行派发，直接交由本层的onTouchEvent方法进行消费。</li>\n</ul>\n<p>3.事件响应：public boolean onTouchEvent(MotionEvent ev)</p>\n<p>一旦事件拦截成功或者执行到最后，事件要进行消费（响应），这里也是有三个返回值，可以控制消费完毕后是就此消失还是接着让其他view也跟着响应一下：</p>\n<ul>\n<li>return super.onTouchEvent(ev):接着向上层传递，通知上层的onTouchEvent方法消费。若上层的返回值也是super.onTouchEvent或者false,接着向上传递，直至事件终止。</li>\n<li>return false:和super.onTouchEvent返回值的功能一样。</li>\n<li>return true:消费后终止（消失）。</li>\n</ul>\n<p>图解具体分发和消费：<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/C343FAC247244C629270AF79E0D7BA55?method=download&amp;shareKey=b136ad73daae06377fc87bf50de8ac73\" alt=\"Touch事件的分发和消费机制\"></p>\n","prev":{"title":"Android开发Gradle配置总结","link":"posts/1543499481"},"next":{"title":"Gradle之Groovy语言","link":"posts/1543411658"},"plink":"https://blog.ixin.run/posts/1543414682/","toc":[{"id":"触摸事件场景分配","title":"触摸事件场景分配","index":"1"},{"id":"触摸事件分发流程","title":"触摸事件分发流程","index":"2"}],"reward":true,"copyright":{"author":"i猩人","link":"<a href=\"https://blog.ixin.run/posts/1543414682/\" title=\"Android开发之Touch事件的分发和消费机制\">https://blog.ixin.run/posts/1543414682/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}