{"title":"Java类加载机制","date":"2021-03-19T10:18:14.000Z","date_formatted":{"ll":"2021年3月19日","L":"2021/03/19","MM-DD":"03-19"},"link":"posts/1616149094","comments":true,"tags":["类加载机制"],"categories":["Java"],"updated":"2021-03-31T02:41:27.968Z","content":"<p>我们知道Class文件中描述的各种信息最终都需要加载到虚拟机中之后才能运行和使用。而虚拟机如何加载这些Class文件？Class文件中的信息进入到虚拟机后会发生什么变化？本文就带你认识一下Java的类加载机制，相信你看过本文之后一切都清楚明了了。</p>\n<a id=\"more\"></a>\n<h2 id=\"开胃汤\">开胃汤<a title=\"#开胃汤\" href=\"#开胃汤\"></a></h2>\n<p>在认识Java类加载机制之前先看两张图，后边的知识点配合这两张图深入的更快一些。</p>\n<p>java程序的执行流程图：</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/07F0E850D11941FFAAF7AE7DFC109055?method=download&amp;shareKey=26e9e2b014ebc9def001408e7161ad04\" alt=\"java程序的执行流程图\" class=\"φbs\"></p>\n<p>jvm的大致物理结构图：</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/C528E5DFE8D84557BB54C04BF08D5CCC?method=download&amp;shareKey=045a451f0ab7abcfc17b78d95dacc307\" alt=\"jvm的大致物理结构图\" class=\"φbs\"></p>\n<h2 id=\"什么是类加载机制\">什么是类加载机制<a title=\"#什么是类加载机制\" href=\"#什么是类加载机制\"></a></h2>\n<p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p>\n<h2 id=\"类的生命周期\">类的生命周期<a title=\"#类的生命周期\" href=\"#类的生命周期\"></a></h2>\n<p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括7个阶段：</p>\n<ul>\n<li>加载（Loading）</li>\n<li>验证（Verification）</li>\n<li>准备（Preparation）</li>\n<li>解析（Resolution）</li>\n<li>初始化（Initialization）</li>\n<li>使用（Using）</li>\n<li>卸载（Unloading）</li>\n</ul>\n<p>其中验证、准备、解析3个部分统称为连接（Linking）。整个过程也可以说成：加载、连接、初始化、使用、卸载，这样更好记一些。</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/AB0DF22393234867B08E72B3202F84BA?method=download&amp;shareKey=3787511fdf933f81e7d237774621ccec\" alt=\"类的生命周期\" class=\"φbs\"></p>\n<p>上图的<code>解析阶段</code>不一定在初始化之前完成：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。</p>\n<h2 id=\"类的加载过程\">类的加载过程<a title=\"#类的加载过程\" href=\"#类的加载过程\"></a></h2>\n<p>类的加载过程，也就是加载、验证、准备、解析和初始化这5个阶段所执行的具体动作。</p>\n<h3 id=\"加载\">加载<a title=\"#加载\" href=\"#加载\"></a></h3>\n<blockquote>\n<p>加载阶段是类加载过程的第一个阶段。在这个阶段，JVM 的主要目的是将字节码从各个位置（网络、磁盘等）转化为二进制字节流加载到内存中，接着会为这个类在 JVM 的方法区创建一个对应的 Class 对象，这个 Class 对象就是这个类各种数据的访问入口。</p>\n</blockquote>\n<p>总结一句话就是：把代码数据加载到内存中。</p>\n<h3 id=\"验证\">验证<a title=\"#验证\" href=\"#验证\"></a></h3>\n<p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>\n<blockquote>\n<p>Class文件并不一定要求用Java源码编译而来，可以使用任何途径产生，甚至包括用十六进制编辑器直接编写来产生Class文件。虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。</p>\n</blockquote>\n<p>当 JVM 加载完 Class 字节码文件并在方法区创建对应的 Class 对象之后，JVM 便会启动对该字节码流的校验，只有符合 JVM 字节码规范的文件才能被 JVM 正确执行。这个校验过程大致可以分为下面两个方面：</p>\n<ul>\n<li><strong>JVM规范校验</strong><br>\nJVM 会对字节流进行文件格式校验，判断其是否符合 JVM 规范，是否能被当前版本的虚拟机处理。例如：文件是否是否以<code>魔数0xCAFEBABE</code>开头，主次版本号是否在当前虚拟机处理范围之内等。</li>\n<li><strong>代码逻辑校验</strong><br>\nJVM 会对代码组成的数据流和控制流进行校验，确保 JVM 运行该字节码文件后不会出现致命错误。例如一个方法要求传入 int 类型的参数，但是使用它的时候却传入了一个 String 类型的参数。一个方法要求返回 String 类型的结果，但是最后却没有返回结果。代码中引用了一个名为 Apple 的类，但是你实际上却没有定义 Apple 类。</li>\n</ul>\n<h3 id=\"准备（关注点）\">准备（关注点）<a title=\"#准备（关注点）\" href=\"#准备（关注点）\"></a></h3>\n<p>当完成字节码文件的校验之后，JVM 便会开始为<strong>类变量</strong>分配内存并初始化。这里需要注意以下两点：</p>\n<ul>\n<li><strong>分配内存的对象</strong><br>\nJava 中的变量有「类变量」和「类成员变量」两种类型，「类变量」指的是被 static 修饰的变量，而其他所有类型的变量都属于「类成员变量」。<br>\n在准备阶段，JVM 只会为「类变量」分配内存，而不会为「类成员变量」分配内存。「类成员变量」的内存分配需要等到初始化阶段才开始。  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//准备阶段为factor分配空间</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> factor = <span class=\"number\">3</span>;  </span><br><span class=\"line\"><span class=\"comment\">//准备阶段不分配，初始化的时候才分配</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String website = <span class=\"string\">&quot;www.cnblogs.com/chanshuyi&quot;</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><strong>对象初始化的值</strong><br>\n在准备阶段，JVM 会为类变量分配内存，并为其初始化，但仅赋予属于该类型的“<strong>零值</strong>”。  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//准备阶段sector的值是0，而不是3</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> sector = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">//final类型代表不可变，因此在准备阶段就可以把该对象的值定死。此时number是3，而不是0</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> number = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"解析\">解析<a title=\"#解析\" href=\"#解析\"></a></h3>\n<p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>\n<ul>\n<li><strong>符号引用（Symbolic Reference）</strong><br>\n符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经在内存中。</li>\n<li><strong>直接引用（Direct Reference）</strong><br>\n直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般都不相同，如果有了直接引用，那引用的目标必定已经在内存中存在。</li>\n</ul>\n<p>解析阶段，JVM 针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类引用进行解析。</p>\n<h3 id=\"初始化（关注点）\">初始化（关注点）<a title=\"#初始化（关注点）\" href=\"#初始化（关注点）\"></a></h3>\n<p>到了初始化阶段，用户定义的 Java 程序代码才真正开始执行。在这个阶段，JVM 会根据语句执行顺序对类对象进行初始化，一般来说当 JVM 遇到下面 5 种情况的时候会触发初始化：</p>\n<ul>\n<li>\n<p>遇到 new、getstatic、putstatic、invokestatic <code>这四条字节码指令</code>时，先触发其初始化。生成这4条指令的最常见的Java代码场景是：</p>\n<ul>\n<li>使用new关键字实例化对象的时候</li>\n<li>读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候</li>\n<li>调用一个类的静态方法的时候</li>\n</ul>\n</li>\n<li>\n<p>使用 java.lang.reflect 包的方法对类进行反射调用的时候，先触发其初始化。</p>\n</li>\n<li>\n<p>如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p>\n</li>\n<li>\n<p>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</p>\n</li>\n<li>\n<p>当使用 JDK1.7 动态语言支持时，如果一个 java.lang.invoke.MethodHandle实例最后的解析结果 REF_getstatic,REF_putstatic,REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。(不常见，先记录)</p>\n</li>\n</ul>\n<h2 id=\"类加载器\">类加载器<a title=\"#类加载器\" href=\"#类加载器\"></a></h2>\n<p>从Java虚拟机的角度来讲，只存在两种不同的类加载器：</p>\n<ul>\n<li>一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；</li>\n<li>另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。</li>\n</ul>\n<p>但是在开发者角度来看，类加载器还可以划分得更细致一些，绝大部分Java程序都会使用到以下3种系统提供的类加载器：</p>\n<ul>\n<li>启动类加载器（Bootstrap ClassLoader）</li>\n<li>扩展类加载器（Extension ClassLoader）</li>\n<li>应用程序类加载器（Application ClassLoader）</li>\n</ul>\n<p>我们的应用程序都是由这3种类加载器互相配合进行加载的，当然还可以加入自己定义的类加载器。他们之间的层次关系称为类加载器的双亲委派模型（Parent Delegation Model）</p>\n<h3 id=\"双亲委派模型\">双亲委派模型<a title=\"#双亲委派模型\" href=\"#双亲委派模型\"></a></h3>\n<p>双亲委派模型示意图：</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/D317BAC222CA4AD8918BE7E2BF51F963?method=download&amp;shareKey=50b668fd32bb8e72af3f758b66dadd8b\" alt=\"双亲委派模型\" class=\"φbs\"></p>\n<p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。</p>\n<p>双亲委派模型的工作过程是：<strong>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</strong></p>\n<h3 id=\"为什么要使用双亲委派模型呢\">为什么要使用双亲委派模型呢<a title=\"#为什么要使用双亲委派模型呢\" href=\"#为什么要使用双亲委派模型呢\"></a></h3>\n<p>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有<strong>优先级</strong>的层次关系。</p>\n<p>例如类java.lang.Object，这是所有类的超类，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。</p>\n<p>如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java. lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。</p>\n<h3 id=\"类加载过程源码\">类加载过程源码<a title=\"#类加载过程源码\" href=\"#类加载过程源码\"></a></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">synchronized</span> Class <span class=\"title\">loadClass</span><span class=\"params\">(String name, <span class=\"keyword\">boolean</span> resolve)</span>  </span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> ClassNotFoundException </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">// 首先检查该name指定的class是否有被加载  </span></span><br><span class=\"line\">    Class c = findLoadedClass(name);  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">                <span class=\"comment\">// 如果parent不为null，则调用parent的loadClass进行加载  </span></span><br><span class=\"line\">                c = parent.loadClass(name, <span class=\"keyword\">false</span>);  </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">                <span class=\"comment\">// parent为null，则调用BootstrapClassLoader进行加载  </span></span><br><span class=\"line\">                c = findBootstrapClass0(name);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;  </span><br><span class=\"line\">            <span class=\"comment\">// 如果仍然无法加载成功，则调用自身的findClass进行加载  </span></span><br><span class=\"line\">            c = findClass(name);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resolve) &#123;  </span><br><span class=\"line\">        resolveClass(c);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> c;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>通过上面代码可以看出，双亲委派模型是通过loadClass()方法来实现的，根据代码以及代码中的注释可以很清楚地了解整个过程其实非常简单：先检查是否已经被加载过，如果没有则调用父加载器的loadClass()方法，如果父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载器加载失败，则先抛出ClassNotFoundException，然后再调用自己的findClass()方法进行加载。</p>\n<h3 id=\"自定义类加载器\">自定义类加载器<a title=\"#自定义类加载器\" href=\"#自定义类加载器\"></a></h3>\n<p>若要实现自定义类加载器，只需要继承java.lang.ClassLoader 类，并且重写其findClass()方法即可。java.lang.ClassLoader 类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个 Java 类，即 java.lang.Class 类的一个实例。</p>\n<p>ClassLoader 中与加载类相关的方法如下：</p>\n<ul>\n<li>getParent() 返回该类加载器的父类加载器。</li>\n<li>loadClass(String name) 加载名称为 二进制名称为name 的类，返回的结果是 java.lang.Class 类的实例。</li>\n<li>findClass(String name) 查找名称为 name 的类，返回的结果是 java.lang.Class 类的实例。</li>\n<li>findLoadedClass(String name) 查找名称为 name 的已经被加载过的类，返回的结果是 java.lang.Class 类的实例。</li>\n<li>resolveClass(Class&lt;?&gt; c) 链接指定的 Java 类。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">* 一、ClassLoader加载类的顺序 </span></span><br><span class=\"line\"><span class=\"comment\">*  1.调用 findLoadedClass(String) 来检查是否已经加载类。 </span></span><br><span class=\"line\"><span class=\"comment\">*  2.在父类加载器上调用 loadClass 方法。如果父类加载器为 null，则使用虚拟机的内置类加载器。 </span></span><br><span class=\"line\"><span class=\"comment\">*  3.调用 findClass(String) 方法查找类。 </span></span><br><span class=\"line\"><span class=\"comment\">* 二、实现自己的类加载器 </span></span><br><span class=\"line\"><span class=\"comment\">*  1.获取类的class文件的字节数组 </span></span><br><span class=\"line\"><span class=\"comment\">*  2.将字节数组转换为Class类的实例 </span></span><br><span class=\"line\"><span class=\"comment\">*/</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassLoaderTest</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException </span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">//新建一个类加载器  </span></span><br><span class=\"line\">        MyClassLoader cl = <span class=\"keyword\">new</span> MyClassLoader(<span class=\"string\">&quot;myClassLoader&quot;</span>);  </span><br><span class=\"line\">        <span class=\"comment\">//加载类，得到Class对象  </span></span><br><span class=\"line\">        Class&lt;?&gt; clazz = cl.loadClass(<span class=\"string\">&quot;classloader.Animal&quot;</span>);  </span><br><span class=\"line\">        <span class=\"comment\">//得到类的实例  </span></span><br><span class=\"line\">        Animal animal=(Animal) clazz.newInstance();  </span><br><span class=\"line\">        animal.say();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;hello world!&quot;</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClassLoader</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassLoader</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//类加载器的名称  </span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;  </span><br><span class=\"line\">    <span class=\"comment\">//类存放的路径  </span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String path = <span class=\"string\">&quot;E:\\\\workspace\\\\Algorithm\\\\src&quot;</span>;  </span><br><span class=\"line\">    MyClassLoader(String name) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    MyClassLoader(ClassLoader parent, String name) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">super</span>(parent);  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">        * 重写findClass方法 </span></span><br><span class=\"line\"><span class=\"comment\">        */</span>  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Class&lt;?&gt; findClass(String name) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] data = loadClassData(name);  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.defineClass(name, data, <span class=\"number\">0</span>, data.length);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">byte</span>[] loadClassData(String name) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">            name = name.replace(<span class=\"string\">&quot;.&quot;</span>, <span class=\"string\">&quot;//&quot;</span>);  </span><br><span class=\"line\">            FileInputStream is = <span class=\"keyword\">new</span> FileInputStream(<span class=\"keyword\">new</span> File(path + name + <span class=\"string\">&quot;.class&quot;</span>));  </span><br><span class=\"line\">            ByteArrayOutputStream baos = <span class=\"keyword\">new</span> ByteArrayOutputStream();  </span><br><span class=\"line\">            <span class=\"keyword\">int</span> b = <span class=\"number\">0</span>;  </span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((b = is.read()) != -<span class=\"number\">1</span>) &#123;  </span><br><span class=\"line\">                baos.write(b);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> baos.toByteArray();  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;  </span><br><span class=\"line\">            e.printStackTrace();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h3 id=\"如何判断一个类的唯一性\">如何判断一个类的唯一性<a title=\"#如何判断一个类的唯一性\" href=\"#如何判断一个类的唯一性\"></a></h3>\n<p>对于任何一个类，都需要由加载它的类加载器和这个类来确立其在JVM中的唯一性。也就是说，两个类来源于同一个Class文件，并且被同一个类加载器加载，这两个类才相等。</p>\n<h2 id=\"一个类的执行过程\">一个类的执行过程<a title=\"#一个类的执行过程\" href=\"#一个类的执行过程\"></a></h2>\n<p>看完上边的类加载机制是不是对一个类在虚拟机中的加载过程有一定的清晰认识了，那么理论总归要面向实处，下边就拿一些小栗子来直面类的执行过程（初始化）。</p>\n<p><strong>栗子1</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Book</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 3</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello i猩人&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Book() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;书的构造方法&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;price=&quot;</span> + price + <span class=\"string\">&quot;,amount=&quot;</span> + amount);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;书的普通代码块&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> price = <span class=\"number\">110</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;书的静态代码块&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> amount = <span class=\"number\">112</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">书的静态代码块</span><br><span class=\"line\">Hello i猩人</span><br></pre></td></tr></table></figure>\n<p>看到这个结果是不是很懵呢？为什么是先执行静态代码块而不是构造方法呢？这已经脱离了我们常规对类执行的认识了，实际上Java代码编译成字节码之后，是没有构造方法的概念的，只有<code>类初始化方法</code> 和 <code>对象初始化方法</code> 。</p>\n<ul>\n<li>类初始化方法。编译器会按照其出现顺序，收集<strong>类变量</strong>的赋值语句、静态代码块，最终组成类初始化方法。类初始化方法一般在类初始化的时候执行。</li>\n<li>对象初始化方法。编译器会按照其出现顺序，收集<strong>成员变量</strong>的赋值语句、普通代码块，最后收集构造函数的代码，最终组成对象初始化方法。对象初始化方法一般在实例化类对象的时候执行。</li>\n</ul>\n<p>也就是说先搜集类初始化方法，即类中从上到下的所有静态变量和静态方法，这些属于类不属于对象，先执行，而后才是从上到下执行对象的流程。是不是豁然开朗，明白了上边的执行过程了，猜猜这里构造方法里的语句为什么没有打印出来呢，可以留言讨论。</p>\n<p><strong>栗子2</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Grandpa</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;爷爷在静态代码块&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> <span class=\"keyword\">extends</span> <span class=\"title\">Grandpa</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;爸爸在静态代码块&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 3</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> factor = <span class=\"number\">25</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Father</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我是爸爸~&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;儿子在静态代码块&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Son</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我是儿子~&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InitializationDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 4</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;爸爸的岁数:&quot;</span> + Son.factor);    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">爷爷在静态代码块</span><br><span class=\"line\">爸爸在静态代码块</span><br><span class=\"line\">爸爸的岁数:<span class=\"number\">25</span></span><br></pre></td></tr></table></figure>\n<p>猜中了开头却没有猜中结尾，这里为什么不输出“儿子在静态代码块”这句呢？记着，<strong>静态代码块和静态成员只属于类，只有被引用所属的类才能初始化</strong>，这里的<code>Son.factor</code>实际是<code>Father.factor</code>。</p>\n<p><strong>栗子3</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Grandpa</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;爷爷在静态代码块&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 4</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Grandpa</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我是爷爷~&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> <span class=\"keyword\">extends</span> <span class=\"title\">Grandpa</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;爸爸在静态代码块&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 5</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Father</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我是爸爸~&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 3</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;儿子在静态代码块&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 6</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Son</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我是儿子~&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InitializationDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 入口（是入口也是最后，上边所有过程执行完毕，这条语句才算执行完成）</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">爷爷在静态代码块</span><br><span class=\"line\">爸爸在静态代码块</span><br><span class=\"line\">儿子在静态代码块</span><br><span class=\"line\">我是爷爷~</span><br><span class=\"line\">我是爸爸~</span><br><span class=\"line\">我是儿子~</span><br></pre></td></tr></table></figure>\n<p><strong>栗子4</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Book</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        staticFunction();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1 （先执行此条语句，但此条语句先生成了一个对象，所以接下来只能先走对象初始化方法了）</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> Book book = <span class=\"keyword\">new</span> Book();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 4</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;书的静态代码块&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;书的普通代码块&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3</span></span><br><span class=\"line\">    Book() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;书的构造方法&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;price=&quot;</span> + price + <span class=\"string\">&quot;,amount=&quot;</span> + amount);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 5</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">staticFunction</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;书的静态方法&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> price = <span class=\"number\">110</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> amount = <span class=\"number\">112</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">书的普通代码块</span><br><span class=\"line\">书的构造方法</span><br><span class=\"line\">price=<span class=\"number\">110</span>,amount=<span class=\"number\">0</span></span><br><span class=\"line\">书的静态代码块</span><br><span class=\"line\">书的静态方法</span><br></pre></td></tr></table></figure>\n<p>看完前三个栗子本来对这个栗子信心满满，结果“又错了”。哈哈，本文讲的目的就是从上到下，先理论再实战嘛！</p>\n<p>第一步，准备，首先Jvm准备阶段是先为类变量分配内存，所以，最初我们的 book 实例变量值为 null，amount 变量值为 0。</p>\n<p>第二步，初始化，先为类变量或者静态方法初始化（类构造器），应该先执行以下几条语句：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> Book book = <span class=\"keyword\">new</span> Book();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;书的静态代码块&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">staticFunction</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;书的静态方法&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> amount = <span class=\"number\">112</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>然而在第一句的时候却要先实例化出一个对象了，所以只能先走生成对象的策略（对象构造器）。接下来走的是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;书的普通代码块&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Book() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;书的构造方法&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// price已经定义的有值，而amount仅仅是分配了内存空间，却还没有实例化（还没有执行到），因此值是0。</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;price=&quot;</span> + price + <span class=\"string\">&quot;,amount=&quot;</span> + amount);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里应该整个过程都理解透彻了吧。</p>\n<h3 id=\"类执行过程小结\">类执行过程小结<a title=\"#类执行过程小结\" href=\"#类执行过程小结\"></a></h3>\n<p>从上面几个例子可以看出，分析一个类的执行顺序大概可以按照如下步骤：</p>\n<ol>\n<li><strong>确定类变量的初始值</strong>。在类加载的准备阶段，JVM 会为类变量初始化零值，这时候类变量会有一个初始的零值。如果是被 final 修饰的类变量，则直接会被初始成用户想要的值。</li>\n<li><strong>初始化入口方法</strong>。当进入类加载的初始化阶段后，JVM 会寻找整个 main 方法入口，从而初始化 main 方法所在的整个类。当需要对一个类进行初始化时，会首先初始化类构造器（），之后初始化对象构造器（）。</li>\n<li><strong>初始化类构造器</strong>。JVM 会按顺序收集类变量的赋值语句、静态代码块，最终组成类构造器由 JVM 执行。</li>\n<li><strong>初始化对象构造器</strong>。JVM 会按照收集成员变量的赋值语句、普通代码块，最后收集构造方法，将它们组成对象构造器，最终由 JVM 执行。</li>\n</ol>\n<p>如果在初始化 main 方法所在类的时候遇到了其他类的初始化，那么就先加载对应的类，加载完成之后返回。如此反复循环，最终返回 main 方法所在类。</p>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<ul>\n<li>《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》</li>\n<li><a href=\"https://juejin.cn/post/6844903564804882445#heading-1\">https://juejin.cn/post/6844903564804882445#heading-1</a></li>\n<li><a href=\"https://www.cnblogs.com/chanshuyi/p/the_java_class_load_mechamism.html\">https://www.cnblogs.com/chanshuyi/p/the_java_class_load_mechamism.html</a></li>\n</ul>\n","prev":{"title":"浅入深出了解Android传感器","link":"posts/1617159391"},"next":{"title":"浅谈Android编译打包流程","link":"posts/1615946471"},"plink":"https://blog.ixin.run/posts/1616149094/","toc":[{"id":"开胃汤","title":"开胃汤","index":"1"},{"id":"什么是类加载机制","title":"什么是类加载机制","index":"2"},{"id":"类的生命周期","title":"类的生命周期","index":"3"},{"id":"类的加载过程","title":"类的加载过程","index":"4","children":[{"id":"加载","title":"加载","index":"4.1"},{"id":"验证","title":"验证","index":"4.2"},{"id":"准备（关注点）","title":"准备（关注点）","index":"4.3"},{"id":"解析","title":"解析","index":"4.4"},{"id":"初始化（关注点）","title":"初始化（关注点）","index":"4.5"}]},{"id":"类加载器","title":"类加载器","index":"5","children":[{"id":"双亲委派模型","title":"双亲委派模型","index":"5.1"},{"id":"为什么要使用双亲委派模型呢","title":"为什么要使用双亲委派模型呢","index":"5.2"},{"id":"类加载过程源码","title":"类加载过程源码","index":"5.3"},{"id":"自定义类加载器","title":"自定义类加载器","index":"5.4"},{"id":"如何判断一个类的唯一性","title":"如何判断一个类的唯一性","index":"5.5"}]},{"id":"一个类的执行过程","title":"一个类的执行过程","index":"6","children":[{"id":"类执行过程小结","title":"类执行过程小结","index":"6.1"}]},{"id":"参考","title":"参考","index":"7"}],"reward":true,"copyright":{"author":"i猩人","link":"<a href=\"https://blog.ixin.run/posts/1616149094/\" title=\"Java类加载机制\">https://blog.ixin.run/posts/1616149094/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}