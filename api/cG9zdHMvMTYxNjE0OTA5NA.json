{"title":"Java类加载机制","date":"2021-03-19T10:18:14.000Z","date_formatted":{"ll":"2021年3月19日","L":"2021/03/19","MM-DD":"03-19"},"link":"posts/1616149094","comments":true,"tags":["类加载机制"],"categories":["Java"],"updated":"2021-03-19T12:38:14.412Z","content":"<p>我们知道Class文件中描述的各种信息最终都需要加载到虚拟机中之后才能运行和使用。而虚拟机如何加载这些Class文件？Class文件中的信息进入到虚拟机后会发生什么变化？本文就带你认识一下Java的类加载机制，相信你看过本文之后一切都清楚明了了。</p>\n<h2 id=\"开胃汤\">开胃汤<a title=\"#开胃汤\" href=\"#开胃汤\"></a></h2>\n<p>在认识Java类加载机制之前先看两张图，后边的知识点配合这两张图深入的更快一些。</p>\n<p>java程序的执行流程图：</p>\n<p><img src=\"\" alt=\"java程序的执行流程图\" class=\"φbs\"></p>\n<p>jvm的大致物理结构图：</p>\n<p><img src=\"\" alt=\"jvm的大致物理结构图\" class=\"φbs\"></p>\n<h2 id=\"什么是类加载机制\">什么是类加载机制<a title=\"#什么是类加载机制\" href=\"#什么是类加载机制\"></a></h2>\n<p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p>\n<h2 id=\"类的生命周期\">类的生命周期<a title=\"#类的生命周期\" href=\"#类的生命周期\"></a></h2>\n<p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括7个阶段：</p>\n<ul>\n<li>加载（Loading）</li>\n<li>验证（Verification）</li>\n<li>准备（Preparation）</li>\n<li>解析（Resolution）</li>\n<li>初始化（Initialization）</li>\n<li>使用（Using）</li>\n<li>卸载（Unloading）</li>\n</ul>\n<p>其中验证、准备、解析3个部分统称为连接（Linking）。整个过程也可以说成：加载、连接、初始化、使用、卸载，这样更好记一些。</p>\n<p><img src=\"\" alt=\"类的生命周期\" class=\"φbs\"></p>\n<p>上图的<code>解析阶段</code>不一定在初始化之前完成：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。</p>\n<h2 id=\"类的加载过程\">类的加载过程<a title=\"#类的加载过程\" href=\"#类的加载过程\"></a></h2>\n<p>类的加载过程，也就是加载、验证、准备、解析和初始化这5个阶段所执行的具体动作。</p>\n<h3 id=\"加载\">加载<a title=\"#加载\" href=\"#加载\"></a></h3>\n<blockquote>\n<p>加载阶段是类加载过程的第一个阶段。在这个阶段，JVM 的主要目的是将字节码从各个位置（网络、磁盘等）转化为二进制字节流加载到内存中，接着会为这个类在 JVM 的方法区创建一个对应的 Class 对象，这个 Class 对象就是这个类各种数据的访问入口。</p>\n</blockquote>\n<p>总结一句话就是：把代码数据加载到内存中。</p>\n<h3 id=\"验证\">验证<a title=\"#验证\" href=\"#验证\"></a></h3>\n<p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>\n<blockquote>\n<p>Class文件并不一定要求用Java源码编译而来，可以使用任何途径产生，甚至包括用十六进制编辑器直接编写来产生Class文件。虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。</p>\n</blockquote>\n<p>当 JVM 加载完 Class 字节码文件并在方法区创建对应的 Class 对象之后，JVM 便会启动对该字节码流的校验，只有符合 JVM 字节码规范的文件才能被 JVM 正确执行。这个校验过程大致可以分为下面两个个方面：</p>\n<ul>\n<li><strong>JVM规范校验</strong><br>\nJVM 会对字节流进行文件格式校验，判断其是否符合 JVM 规范，是否能被当前版本的虚拟机处理。例如：文件是否是否以<code>魔数0xCAFEBABE</code>开头，主次版本号是否在当前虚拟机处理范围之内等。</li>\n<li><strong>代码逻辑校验</strong><br>\nJVM 会对代码组成的数据流和控制流进行校验，确保 JVM 运行该字节码文件后不会出现致命错误。例如一个方法要求传入 int 类型的参数，但是使用它的时候却传入了一个 String 类型的参数。一个方法要求返回 String 类型的结果，但是最后却没有返回结果。代码中引用了一个名为 Apple 的类，但是你实际上却没有定义 Apple 类。</li>\n</ul>\n<h3 id=\"准备\">准备<a title=\"#准备\" href=\"#准备\"></a></h3>\n<h3 id=\"解析\">解析<a title=\"#解析\" href=\"#解析\"></a></h3>\n<h3 id=\"初始化\">初始化<a title=\"#初始化\" href=\"#初始化\"></a></h3>\n<h2 id=\"类加载器\">类加载器<a title=\"#类加载器\" href=\"#类加载器\"></a></h2>\n<p>从Java虚拟机的角度来讲，只存在两种不同的类加载器：</p>\n<ul>\n<li>一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；</li>\n<li>另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。</li>\n</ul>\n<p>但是在开发者角度来看，类加载器还可以划分得更细致一些，绝大部分Java程序都会使用到以下3种系统提供的类加载器：</p>\n<ul>\n<li>启动类加载器（Bootstrap ClassLoader）</li>\n<li>扩展类加载器（Extension ClassLoader）</li>\n<li>应用程序类加载器（Application ClassLoader）</li>\n</ul>\n<p>我们的应用程序都是由这3种类加载器互相配合进行加载的，当然还可以加入自己定义的类加载器。他们之间的层次关系称为类加载器的双亲委派模型（Parent Delegation Model）</p>\n<h3 id=\"双亲委派模型\">双亲委派模型<a title=\"#双亲委派模型\" href=\"#双亲委派模型\"></a></h3>\n<p>双亲委派模型示意图：</p>\n<p><img src=\"\" alt=\"双亲委派模型\" class=\"φbs\"></p>\n<p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。</p>\n<p>双亲委派模型的工作过程是：<strong>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</strong></p>\n<h3 id=\"为什么要使用双亲委派模型呢\">为什么要使用双亲委派模型呢<a title=\"#为什么要使用双亲委派模型呢\" href=\"#为什么要使用双亲委派模型呢\"></a></h3>\n<p>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有<strong>优先级</strong>的层次关系。</p>\n<p>例如类java.lang.Object，这是所有类的超类，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。</p>\n<p>如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java. lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。</p>\n<h2 id=\"类加载源码\">类加载源码<a title=\"#类加载源码\" href=\"#类加载源码\"></a></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">synchronized</span> Class <span class=\"title\">loadClass</span><span class=\"params\">(String name, <span class=\"keyword\">boolean</span> resolve)</span>  </span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> ClassNotFoundException </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">// 首先检查该name指定的class是否有被加载  </span></span><br><span class=\"line\">    Class c = findLoadedClass(name);  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (parent != <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">                <span class=\"comment\">// 如果parent不为null，则调用parent的loadClass进行加载  </span></span><br><span class=\"line\">                c = parent.loadClass(name, <span class=\"keyword\">false</span>);  </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">                <span class=\"comment\">// parent为null，则调用BootstrapClassLoader进行加载  </span></span><br><span class=\"line\">                c = findBootstrapClass0(name);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;  </span><br><span class=\"line\">            <span class=\"comment\">// 如果仍然无法加载成功，则调用自身的findClass进行加载  </span></span><br><span class=\"line\">            c = findClass(name);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resolve) &#123;  </span><br><span class=\"line\">        resolveClass(c);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> c;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>通过上面代码可以看出，双亲委派模型是通过loadClass()方法来实现的，根据代码以及代码中的注释可以很清楚地了解整个过程其实非常简单：先检查是否已经被加载过，如果没有则调用父加载器的loadClass()方法，如果父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载器加载失败，则先抛出ClassNotFoundException，然后再调用自己的findClass()方法进行加载。</p>\n<h2 id=\"自定义类加载器\">自定义类加载器<a title=\"#自定义类加载器\" href=\"#自定义类加载器\"></a></h2>\n<p>若要实现自定义类加载器，只需要继承java.lang.ClassLoader 类，并且重写其findClass()方法即可。</p>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<ul>\n<li>《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》</li>\n<li><a href=\"https://juejin.cn/post/6844903564804882445#heading-1\">https://juejin.cn/post/6844903564804882445#heading-1</a></li>\n<li><a href=\"https://www.cnblogs.com/chanshuyi/p/the_java_class_load_mechamism.html\">https://www.cnblogs.com/chanshuyi/p/the_java_class_load_mechamism.html</a></li>\n</ul>\n","prev":{"title":"DO AS ONE WISHES","link":"posts/0"},"next":{"title":"浅谈Android编译打包流程","link":"posts/1615946471"},"plink":"https://blog.ixin.run/posts/1616149094/","toc":[{"id":"开胃汤","title":"开胃汤","index":"1"},{"id":"什么是类加载机制","title":"什么是类加载机制","index":"2"},{"id":"类的生命周期","title":"类的生命周期","index":"3"},{"id":"类的加载过程","title":"类的加载过程","index":"4","children":[{"id":"加载","title":"加载","index":"4.1"},{"id":"验证","title":"验证","index":"4.2"},{"id":"准备","title":"准备","index":"4.3"},{"id":"解析","title":"解析","index":"4.4"},{"id":"初始化","title":"初始化","index":"4.5"}]},{"id":"类加载器","title":"类加载器","index":"5","children":[{"id":"双亲委派模型","title":"双亲委派模型","index":"5.1"},{"id":"为什么要使用双亲委派模型呢","title":"为什么要使用双亲委派模型呢","index":"5.2"}]},{"id":"类加载源码","title":"类加载源码","index":"6"},{"id":"自定义类加载器","title":"自定义类加载器","index":"7"},{"id":"参考","title":"参考","index":"8"}],"reward":true,"copyright":{"author":"i猩人","link":"<a href=\"https://blog.ixin.run/posts/1616149094/\" title=\"Java类加载机制\">https://blog.ixin.run/posts/1616149094/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}