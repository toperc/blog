{"per_page":10,"total":12,"current":12,"data":[{"title":"什么是进程，什么是线程","date":"2016-07-28T05:03:39.000Z","date_formatted":{"ll":"2016年7月28日","L":"2016/07/28","MM-DD":"07-28"},"excerpt":"<p>提到进程和线程，大家都有所了解，但是据其概念又比较抽象不容易掌握。计算机科学是人类进步的结晶，但是也是为人类服务，所以千万不要被我们自己创造的东西绕进去而最终不知道这玩意到底是啥，所以提炼升华转成大白话最重要。</p>","link":"posts/1469682219","categories":["计算机基础"]},{"title":"Android开发Handler消息机制探究","date":"2016-07-27T07:41:45.000Z","date_formatted":{"ll":"2016年7月27日","L":"2016/07/27","MM-DD":"07-27"},"excerpt":"<p>我们知道一个应用启动时系统会为其创建一个进程，而每一个Activity启动的时候又会形成一个线程，这个线程叫主线程，又叫UI线程。Android的主线程是不安全的，因为从主线程中可以创建多个子线程来分配任务，一个activity的所有view都是唯一的，都有唯一的标识，如果在每个子线程中更新view，我们不能预知线程执行结果的先后顺序，也就无法预知什么时候才能更新view，所以造成结果就是view更新时的冲突问题。这也就是为什么从安卓2.0之后官方规定只能在主线程中更新界面了，子线程执行结果后通知主线程更新界面的桥梁便需要handler来帮忙，本篇深入探究一下handle的工作机制。</p>","link":"posts/1469605305","tags":["线程间通信"],"categories":["Android"]},{"title":"JAVA设计模式之代理模式","date":"2016-06-15T08:12:56.000Z","date_formatted":{"ll":"2016年6月15日","L":"2016/06/15","MM-DD":"06-15"},"excerpt":"<p>说起Java代理模式，不明其理可能一头雾水，明白了也就很简单了。举一个生活中最典型的例子：律师代替原告打官司，来看一下过程：</p>\n<ol>\n<li>原告准备做哪些事：原告可以提供很多材料给律师，目的是打官司赢地皮。</li>\n<li>律师二次包装：律师利用自身丰厚的经验根据这些材料帮着打。</li>\n<li>原告有信息不愿透漏：律师只能根据原告提供的信息进行辩论，原告也许有暗黑的一面，不愿意让律师说出来。</li>\n</ol>\n<p>最终结果：律师能否打赢，注重看律师的水平，当然离不开原告所提供资料的充分和真实。</p>","link":"posts/1465978376","tags":["设计模式"],"categories":["Java"]},{"title":"Android开发之单元测试初探","date":"2016-06-12T06:36:07.000Z","date_formatted":{"ll":"2016年6月12日","L":"2016/06/12","MM-DD":"06-12"},"excerpt":"<p>从androidstudio1.5开始新建安卓项目中有两个测试包,androidTest和test。其中前者是针对设备进行的测试，即官方支持的UI测试，后者是直接在本机上进行测试即最常见的本地单元测试。在androidStudio1.5之前只有前者，单元测试要自己重建，如图：<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/5E99E10A73F041BD8421DCC2593DA919?method=download&amp;shareKey=ef016b2d142019ce2373b6507a54f0db\" alt=\"android项目中的单元测试\"></p>","link":"posts/1465713367","tags":["单元测试"],"categories":["Android"]},{"title":"Android开发权限处理和自定义权限","date":"2016-04-01T02:40:11.000Z","date_formatted":{"ll":"2016年4月1日","L":"2016/04/01","MM-DD":"04-01"},"excerpt":"<p>早在Android6.0之前，权限这一块是不需要处理的，只需要用到哪些权限在Manifest里注册一下，然后在安装的时候简单声明一下。但是从6.0开始为了用户的隐私和安全，Google引入了动态权限申请机制，将所有权限分成了正常权限和危险权限，应用的相关功能每次在使用危险权限时需要动态的申请并得到用户的授权才能使用。</p>","link":"posts/1459478411","tags":["运行时权限"],"categories":["Android"]},{"title":"Android核心架构探究学习","date":"2015-08-28T09:28:50.000Z","date_formatted":{"ll":"2015年8月28日","L":"2015/08/28","MM-DD":"08-28"},"excerpt":"<p>谈起Android架构，很多人都知道Android是java开发的，以为Android就是java的一个儿子，这也只是站在表层去看问题。Android是一个系统，作为一个现在都快发展到6.0的系统，内部必有一个庞大的核心体系，就像一个舞台，要有支柱，要有台面，才能撑起各种演员和设备在其上面配合着表演。</p>\n<p>Android系统的底层是建立在Linux系统之上的，系统架构总共分为4层5块。从上往下4层分别是：应用程序层、应用程序框架层、函数库层、Linux内核层。5块分别指APPLICATIONS、APPLICATIONS FRAMWORK、LIBRARIES、ANDROID RUNTIME、LINUX KERNEL，这都和前边一一对应，其中ANDROID RUNTIME是在函数库层额外开出的android运行时虚拟机。</p>\n<p>这4层采用一种软件叠层（Software Stack）的方式进行构建，层与层之间相互分离又分工明确，确保层与层之间的低耦合，保证系统的稳定性。</p>","link":"posts/1440754130","tags":["系统"],"categories":["Android"]}]}