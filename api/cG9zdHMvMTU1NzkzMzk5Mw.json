{"title":"Android开发之Context认识和运用","date":"2019-05-15T15:26:33.000Z","date_formatted":{"ll":"2019年5月15日","L":"2019/05/15","MM-DD":"05-15"},"link":"posts/1557933993","comments":true,"categories":["Android"],"updated":"2021-01-29T12:51:44.630Z","content":"<p>谈到Context，做Android的可以说是无人不知无人不晓，例如“XXXXActivity.this”、“getApplicationContext()”、“getContext()”等多种形式。虽然大家都知道，可是真正的去用好它也是一门艺术，深入不全免不了也要入坑。</p>\n<p>之前我们项目上新增了一个悬浮球功能，获取的是全局Application的WINDOW_SERVICE，然而那个悬浮球的实例却采用的Activity的context，存在的问题就是内存回收时将此context回收掉，导致windowManager不能控制这个view了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.IllegalArgumentException: View not attached to window manager</span><br></pre></td></tr></table></figure>\n<p>本篇就针对的Context深入学习做一个总结吧。</p>\n<a id=\"more\"></a>\n<h2 id=\"context是什么\">Context是什么<a title=\"#context是什么\" href=\"#context是什么\"></a></h2>\n<p>Context，中文直译为“上下文”，它描述的是一个应用程序环境的信息，SDK中对其说明如下：</p>\n<blockquote>\n<p>Interface to global information about an application environment. This is an abstract class whose implementation is provided by the Android system. It allows access to application-specific resources and classes, as well as up-calls  for application-level operations such as launching activities, broadcasting and receiving intents, etc</p>\n</blockquote>\n<p>从Android系统的角度来理解：Context是一个场景，代表与操作系统的交互的一种过程。Context在加载资源、启动Activity、获取系统服务、创建View等操作都要参与。</p>\n<p>从程序的角度上来理解：Context是个抽象类，而Activity、Service、Application等都是该类的一个实现。</p>\n<h2 id=\"context的行为\">Context的行为<a title=\"#context的行为\" href=\"#context的行为\"></a></h2>\n<p>Context体现到代码上来说，是个抽象类，其主要表达的行为列表如下：</p>\n<div class=\"φbt\"><div class=\"φbv\"><table><thead>\n<tr>\n<th style=\"text-align:left\">Context行为分类</th>\n<th style=\"text-align:left\">常用函数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">使用系统提供的服务</td>\n<td style=\"text-align:left\">getPackageManager()、getSystemService()…</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">基本功能</td>\n<td style=\"text-align:left\">startActivity()、sendBroadcast()、registerReceiver()、startService()、bindService()、getContentResolver()…【内部基本上是和AMS打交道】</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">访问资源</td>\n<td style=\"text-align:left\">getAssets()、getResources()、getString()、getColor()、getClassLoader()…</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">和当前所寄身的进程之间的联系</td>\n<td style=\"text-align:left\">getMainLooper()、getApplicationContext()…</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">和信息存储相关</td>\n<td style=\"text-align:left\">getSharedPreferences()、openFileInput()、openFileOutput()、deleteFile()、openOrCreateDatabase()、deleteDatabase()…</td>\n</tr>\n</tbody>\n</table></div></div><h2 id=\"context的关系谱\">Context的关系谱<a title=\"#context的关系谱\" href=\"#context的关系谱\"></a></h2>\n<p>Context的系谱中主要包含Context、ContextImpl、ContextWrapper、ContextThemeWrapper以及最终的成员Application、Activity、Service。</p>\n<p>这些成员的关系如下图所示：<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/51D6385112C144B29372AD679822B903?method=download&amp;shareKey=23bdb3a3d1169dad244903a5875e43b2\" alt=\"Context的关系谱\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Context</span><br><span class=\"line\">├── ContextImpl</span><br><span class=\"line\">└── ContextWrapper</span><br><span class=\"line\">    ├── Application</span><br><span class=\"line\">    ├── ContextThemeWrapper</span><br><span class=\"line\">    │   └── Activity</span><br><span class=\"line\">    └── Service</span><br></pre></td></tr></table></figure>\n<p>从继承关系图中可以看出，Application类、Service类和Activity类都继承了Context类。应用程序被启动后，会为应用程序创建一个全局的Application对应的Context对象。ContextImpl类是Context的真正实现。ContextWrapper类是Context的包装类，可以在不改变ContextImpl的情况下，为其增加一些自定义操作。ContextWrapper中的mBase实际上是一个ContextImpl对象。而ContextImpl类中的mOuterContext是一个Context对象，指向相对应的Activity或Service或Application。</p>\n<p>是不是有点绕？没关系，下边就简要分析一下这几个成员的具体细节。</p>\n<h3 id=\"相关类介绍\">相关类介绍<a title=\"#相关类介绍\" href=\"#相关类介绍\"></a></h3>\n<h4 id=\"context\">Context<a title=\"#context\" href=\"#context\"></a></h4>\n<p>路径： /frameworks/base/core/java/android/content/Context.java<br>\n说明：抽象类，提供了一组通用的API。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Context</span> </span>&#123;</span><br><span class=\"line\">\t ...</span><br><span class=\"line\"> \t <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Object <span class=\"title\">getSystemService</span><span class=\"params\">(String name)</span></span>;  <span class=\"comment\">//获得系统级服务</span></span><br><span class=\"line\">\t <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">(Intent intent)</span></span>;     <span class=\"comment\">//通过一个Intent启动Activity</span></span><br><span class=\"line\">\t <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> ComponentName <span class=\"title\">startService</span><span class=\"params\">(Intent service)</span></span>;  <span class=\"comment\">//启动Service</span></span><br><span class=\"line\">\t <span class=\"comment\">//根据文件名得到SharedPreferences对象</span></span><br><span class=\"line\">\t <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> SharedPreferences <span class=\"title\">getSharedPreferences</span><span class=\"params\">(String name,<span class=\"keyword\">int</span> mode)</span></span>;</span><br><span class=\"line\">\t ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"contextiml\">ContextIml<a title=\"#contextiml\" href=\"#contextiml\"></a></h4>\n<p>路径：/frameworks/base/core/java/android/app/ContextImpl.java<br>\n说明：该Context类的实现类为ContextIml，该类实现了Context类的功能。请注意，该函数的大部分功能都是直接调用，其属性mPackageInfo去完成，这点我们后面会讲到。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Common implementation of Context API, which provides the base</span></span><br><span class=\"line\"><span class=\"comment\"> * context object for Activity and other application components.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ContextImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">Context</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//所有Application程序公用一个mPackageInfo对象</span></span><br><span class=\"line\">    ActivityThread.PackageInfo mPackageInfo;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getSystemService</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">    \t...</span><br><span class=\"line\">    \t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ACTIVITY_SERVICE.equals(name)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> getActivityManager();</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    \t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (INPUT_METHOD_SERVICE.equals(name)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> InputMethodManager.getInstance(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\">    \t...</span><br><span class=\"line\">    \t<span class=\"comment\">//开始启动一个Activity</span></span><br><span class=\"line\">        mMainThread.getInstrumentation().execStartActivity(</span><br><span class=\"line\">            getOuterContext(), mMainThread.getApplicationThread(), <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, intent, -<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"contextwrapper\">ContextWrapper<a title=\"#contextwrapper\" href=\"#contextwrapper\"></a></h4>\n<p>路径：\\frameworks\\base\\core\\java\\android\\content\\ContextWrapper.java<br>\n说明：正如其名称一样，该类只是对Context类的一种包装，该类的构造函数包含了一个真正的Context引用，即ContextImpl对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ContextWrapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">Context</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//该属性指向一个ContextIml实例，一般在创建Application、Service、Activity时赋值</span></span><br><span class=\"line\">    Context mBase;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建Application、Service、Activity，会调用该方法给mBase属性赋值</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">attachBaseContext</span><span class=\"params\">(Context base)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mBase != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Base context already set&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mBase = base;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//调用mBase实例方法</span></span><br><span class=\"line\">        mBase.startActivity(intent);  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"contextthemewrapper\">ContextThemeWrapper<a title=\"#contextthemewrapper\" href=\"#contextthemewrapper\"></a></h4>\n<p>路径：/frameworks/base/core/java/android/view/ContextThemeWrapper.java<br>\n说明：该类内部包含了主题(Theme)相关的接口，即android:theme属性指定的。只有Activity需要主题，Service不需要主题，所以Service直接继承于ContextWrapper类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ContextThemeWrapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">ContextWrapper</span> </span>&#123;</span><br><span class=\"line\">\t <span class=\"comment\">//该属性指向一个ContextIml实例，一般在创建Application、Service、Activity时赋值</span></span><br><span class=\"line\">\t <span class=\"keyword\">private</span> Context mBase;</span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"comment\">//mBase赋值方式同样有一下两种</span></span><br><span class=\"line\">\t <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ContextThemeWrapper</span><span class=\"params\">(Context base, <span class=\"keyword\">int</span> themeres)</span> </span>&#123;</span><br><span class=\"line\">\t        <span class=\"keyword\">super</span>(base);</span><br><span class=\"line\">\t        mBase = base;</span><br><span class=\"line\">\t        mThemeResource = themeres;</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t <span class=\"meta\">@Override</span></span><br><span class=\"line\">\t <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">attachBaseContext</span><span class=\"params\">(Context newBase)</span> </span>&#123;</span><br><span class=\"line\">\t        <span class=\"keyword\">super</span>.attachBaseContext(newBase);</span><br><span class=\"line\">\t        mBase = newBase;</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"context的创建时机\">Context的创建时机<a title=\"#context的创建时机\" href=\"#context的创建时机\"></a></h2>\n<p>熟悉了Context的继承关系后，我们接下来分析应用程序在什么情况需要创建Context对象的。</p>\n<h3 id=\"context的数量\">Context的数量<a title=\"#context的数量\" href=\"#context的数量\"></a></h3>\n<p>应用程序创建Context实例的情况有如下几种情况：</p>\n<ul>\n<li>创建Application 对象时， 而且整个App共一个Application对象</li>\n<li>创建Activity对象时</li>\n<li>创建Service对象时</li>\n</ul>\n<p>因此应用程序App共有的Context数目公式为：<br>\n<strong>总Context实例个数 =1（Application对应的Context实例）+ Activity个数 + Service个数</strong></p>\n<h3 id=\"具体的创建时机\">具体的创建时机<a title=\"#具体的创建时机\" href=\"#具体的创建时机\"></a></h3>\n<h4 id=\"创建application对象的时机\">创建Application对象的时机<a title=\"#创建application对象的时机\" href=\"#创建application对象的时机\"></a></h4>\n<p>每个应用程序在第一次启动时，都会首先创建Application对象。如果对应用程序启动一个Activity(startActivity)流程比较清楚的话，创建Application的时机在创建handleBindApplication()方法中，该函数位于ActivityThread.java类中 ，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建Application时同时创建的ContextIml实例</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">handleBindApplication</span><span class=\"params\">(AppBindData data)</span></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"comment\">///创建Application对象</span></span><br><span class=\"line\">    Application app = data.info.makeApplication(data.restrictedBackupMode, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Application <span class=\"title\">makeApplication</span><span class=\"params\">(<span class=\"keyword\">boolean</span> forceDefaultAppClass, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        java.lang.ClassLoader cl = getClassLoader();</span><br><span class=\"line\">        ContextImpl appContext = <span class=\"keyword\">new</span> ContextImpl();    <span class=\"comment\">//创建一个ContextImpl对象实例</span></span><br><span class=\"line\">        appContext.init(<span class=\"keyword\">this</span>, <span class=\"keyword\">null</span>, mActivityThread);  <span class=\"comment\">//初始化该ContextIml实例的相关属性</span></span><br><span class=\"line\">        <span class=\"comment\">///新建一个Application对象 </span></span><br><span class=\"line\">        app = mActivityThread.mInstrumentation.newApplication(</span><br><span class=\"line\">                cl, appClass, appContext);</span><br><span class=\"line\">       appContext.setOuterContext(app);  <span class=\"comment\">//将该Application实例传递给该ContextImpl实例         </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建activity对象的时机\">创建Activity对象的时机<a title=\"#创建activity对象的时机\" href=\"#创建activity对象的时机\"></a></h4>\n<p>通过startActivity()或startActivityForResult()请求启动一个Activity时，如果系统检测需要新建一个Activity对象时，就会回调handleLaunchActivity()方法，该方法继而调用performLaunchActivity()方法，去创建一个Activity实例，并且回调onCreate()、onStart()方法等，函数都位于ActivityThread.java类，如下：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建一个Activity实例时同时创建ContextIml实例</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">handleLaunchActivity</span><span class=\"params\">(ActivityRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tActivity a = performLaunchActivity(r, customIntent);  <span class=\"comment\">//启动一个Activity</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Activity <span class=\"title\">performLaunchActivity</span><span class=\"params\">(ActivityRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tActivity activity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">//创建一个Activity对象实例</span></span><br><span class=\"line\">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class=\"line\">        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (activity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ContextImpl appContext = <span class=\"keyword\">new</span> ContextImpl();      <span class=\"comment\">//创建一个ContextImpl对象实例</span></span><br><span class=\"line\">        appContext.init(r.packageInfo, r.token, <span class=\"keyword\">this</span>);   <span class=\"comment\">//初始化该ContextIml实例的相关属性</span></span><br><span class=\"line\">        appContext.setOuterContext(activity);            <span class=\"comment\">//将该Activity信息传递给该ContextImpl实例</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建service对象的时机\">创建Service对象的时机<a title=\"#创建service对象的时机\" href=\"#创建service对象的时机\"></a></h4>\n<p>通过startService或者bindService时，如果系统检测到需要新创建一个Service实例，就会回调handleCreateService()方法，<br>\n完成相关数据操作。handleCreateService()函数位于ActivityThread.java类，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建一个Service实例时同时创建ContextIml实例</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">handleCreateService</span><span class=\"params\">(CreateServiceData data)</span></span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tService service = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建一个Service实例</span></span><br><span class=\"line\">        java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class=\"line\">        service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tContextImpl context = <span class=\"keyword\">new</span> ContextImpl(); <span class=\"comment\">//创建一个ContextImpl对象实例</span></span><br><span class=\"line\">    context.init(packageInfo, <span class=\"keyword\">null</span>, <span class=\"keyword\">this</span>);   <span class=\"comment\">//初始化该ContextIml实例的相关属性</span></span><br><span class=\"line\">    <span class=\"comment\">//获得我们之前创建的Application对象信息</span></span><br><span class=\"line\">    Application app = packageInfo.makeApplication(<span class=\"keyword\">false</span>, mInstrumentation);</span><br><span class=\"line\">    <span class=\"comment\">//将该Service信息传递给该ContextImpl实例</span></span><br><span class=\"line\">    context.setOuterContext(service);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"重量级packageinfo\">重量级PackageInfo<a title=\"#重量级packageinfo\" href=\"#重量级packageinfo\"></a></h3>\n<p>需要强调一点的是，通过对ContextImp的分析可知，其方法的大多数操作都是直接调用其属性mPackageInfo(该属性类<br>\n型为PackageInfo)的相关方法而来。这说明ContextImp是一种轻量级类，而PackageInfo才是真正重量级的类。而一个App里的所有ContextIml实例，都对应同一个packageInfo对象。</p>\n<h3 id=\"context的getsharedpreferences()方法\">Context的getSharedPreferences()方法<a title=\"#context的getsharedpreferences()方法\" href=\"#context的getsharedpreferences()方法\"></a></h3>\n<p>这里给大家分析利用Context获取SharedPreferences类的使用方法，SharedPreferences类想必大家都使用过，其一般获取方<br>\n法就是通过调用getSharedPreferences()方法去根据相关信息获取SharedPreferences对象。具体流程如下：</p>\n<p>1.调用getSharedPreferences()获取对应的的文件，该函数实现功能如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Context类静态数据集合，以键值对保存了所有读取该xml文件后所形成的数据集合</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HashMap&lt;File, SharedPreferencesImpl&gt; sSharedPrefs = </span><br><span class=\"line\">\t   <span class=\"keyword\">new</span> HashMap&lt;File, SharedPreferencesImpl&gt;(); </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SharedPreferences <span class=\"title\">getSharedPreferences</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> mode)</span></span>&#123;</span><br><span class=\"line\">\t <span class=\"comment\">//其所对应的SharedPreferencesImpl对象 ，该对象已一个HashMap集合保存了我们对该文件序列化结果</span></span><br><span class=\"line\">\t SharedPreferencesImpl sp;  </span><br><span class=\"line\">     File f = getSharedPrefsFile(name);  <span class=\"comment\">//该包下是否存在对应的文件，不存在就新建一个</span></span><br><span class=\"line\">     <span class=\"keyword\">synchronized</span> (sSharedPrefs) &#123;       <span class=\"comment\">//是否已经读取过该文件，是就直接返回该SharedPreferences对象</span></span><br><span class=\"line\">         sp = sSharedPrefs.get(f);</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (sp != <span class=\"keyword\">null</span> &amp;&amp; !sp.hasFileChanged()) &#123;</span><br><span class=\"line\">             <span class=\"comment\">//Log.i(TAG, &quot;Returning existing prefs &quot; + name + &quot;: &quot; + sp);</span></span><br><span class=\"line\">             <span class=\"keyword\">return</span> sp;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"comment\">//以下为序列化该xml文件，同时将数据写到map集合中     </span></span><br><span class=\"line\">     Map map = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (f.exists() &amp;&amp; f.canRead()) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">             str = <span class=\"keyword\">new</span> FileInputStream(f);</span><br><span class=\"line\">             map = XmlUtils.readMapXml(str);</span><br><span class=\"line\">             str.close();</span><br><span class=\"line\">         &#125; </span><br><span class=\"line\">         ...</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"keyword\">synchronized</span> (sSharedPrefs) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (sp != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">             <span class=\"comment\">//Log.i(TAG, &quot;Updating existing prefs &quot; + name + &quot; &quot; + sp + &quot;: &quot; + map);</span></span><br><span class=\"line\">             sp.replace(map);   <span class=\"comment\">//更新数据集合</span></span><br><span class=\"line\">         &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">             sp = sSharedPrefs.get(f);</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (sp == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">            \t <span class=\"comment\">//新建一个SharedPreferencesImpl对象，并且设置其相关属性</span></span><br><span class=\"line\">                 sp = <span class=\"keyword\">new</span> SharedPreferencesImpl(f, mode, map);  </span><br><span class=\"line\">                 sSharedPrefs.put(f, sp);</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> sp;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.SharedPreferences不过是个接口，它定义了一些操作xml文件的方法，其真正实现类为SharedPreferencesImpl，该类是ContextIml的内部类，该类如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//SharedPreferences只是一种接口，其真正实现类是SharedPreferencesImpl类</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SharedPreferencesImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">SharedPreferences</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//保存了该文件序列化结果后的操作，键值对形式</span></span><br><span class=\"line\">\t <span class=\"keyword\">private</span> Map mMap;  </span><br><span class=\"line\">\t </span><br><span class=\"line\">\t <span class=\"comment\">//通过key值获取对应的value值</span></span><br><span class=\"line\">\t <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getString</span><span class=\"params\">(String key, String defValue)</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">             String v = (String)mMap.get(key);</span><br><span class=\"line\">             <span class=\"keyword\">return</span> v != <span class=\"keyword\">null</span> ? v : defValue;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">\t ...</span><br><span class=\"line\">\t <span class=\"comment\">//获得该SharedPreferencesImpl对象对应的Edito类，对数据进行操作</span></span><br><span class=\"line\">\t <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EditorImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">Editor</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"comment\">//保存了对键值变化的集合</span></span><br><span class=\"line\">\t\t <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Object&gt; mModified = Maps.newHashMap(); </span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"context的使用\">Context的使用<a title=\"#context的使用\" href=\"#context的使用\"></a></h2>\n<h3 id=\"如何获取context\">如何获取Context<a title=\"#如何获取context\" href=\"#如何获取context\"></a></h3>\n<ol>\n<li><strong>View.getContext()</strong>，返回当前Activity所在的应用进程的Context对象，通常是当前正在展示的Activity对象。</li>\n<li><strong>Activity.getApplicationContext()</strong>，获取当前Activity所在的（应用）进程的Context对象，通常我们使用Context对象时，要优先考虑这个全局的进程Context。</li>\n<li><strong>Activity.this</strong>，返回当前的Activity实例，如果是UI控件需要使用Activity作为Context对象，但是默认的Toast因为是系统层级的Windows，直接使用ApplicationContext则可。</li>\n<li><strong>getApplication()</strong>，和getApplicationContext获取的对象一致的，但是getApplication方法只有在Activity和Service中才能调到。例如BroadcasrReceiver中需要获取Application，则需要借助getApplicationContext（）方法。</li>\n</ol>\n<h3 id=\"context的使用场景\">Context的使用场景<a title=\"#context的使用场景\" href=\"#context的使用场景\"></a></h3>\n<p>先来看一张Context使用场景图：<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/2A4E0C992D1F4B8BA4DE0AD7CA2456BB?method=download&amp;shareKey=033528fc05a2380b8f8a063fe3cbf373\" alt=\"context的使用场景\"></p>\n<p>大家注意看到有一些NO上添加了一些数字，其实这些从能力上来说是YES，但是为什么说是NO呢？下面一个一个解释：</p>\n<ul>\n<li>数字1：启动Activity在这些类中是可以的，但是需要创建一个新的task。一般情况不推荐。</li>\n<li>数字2：在这些类中去layout inflate是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用。</li>\n<li>数字3：在receiver为null时允许，在4.2或以上的版本中，用于获取黏性广播的当前值。（可以无视）</li>\n</ul>\n<p>注：ContentProvider、BroadcastReceiver之所以在上述表格中，是因为在其内部方法中都有一个context用于使用。</p>\n<p>这里我们看下表格，重点看Activity和Application，可以看到，和UI相关的方法基本都不建议或者不可使用Application。并且，前三个操作基本不可能在Application中出现。实际上，只要把握住一点，凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以，当然了，注意Context引用的持有，防止内存泄漏。</p>\n<p>假如我是面试官，问你Service能否启动Activity呢，想必你也应该知道怎么回答了吧</p>\n<h3 id=\"context引起的内存泄漏\">Context引起的内存泄漏<a title=\"#context引起的内存泄漏\" href=\"#context引起的内存泄漏\"></a></h3>\n<p>Context引起的内存泄漏也是很恐怖的，下边就举例两个场景：</p>\n<p>1.错误的单例模式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Context mContext;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mContext = context;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> Singleton(context);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种情况下即使Activity被销毁掉，但因为它的引用还存在于一个Singleton中，就不可能被GC掉。</p>\n<p>2.View持有Activity引用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Drawable mDrawable;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle saveInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(saveInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        ImageView iv = <span class=\"keyword\">new</span> ImageView(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        mDrawable = getResources().getDrawable(R.drawable.ic_launcher);</span><br><span class=\"line\">        iv.setImageDrawable(mDrawable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有一个静态的Drawable对象当ImageView设置这个Drawable时，ImageView保存了mDrawable的引用，而ImageView传入的this是MainActivity的mContext，因为被static修饰的mDrawable是常驻内存的，MainActivity是它的间接引用，MainActivity被销毁时，也不能被GC掉，所以造成内存泄漏。</p>\n<p>所以我们平时使用的时候尽量保证以下几点：</p>\n<ol>\n<li>如果不涉及Activity的主题样式，尽量使用Application的Context。</li>\n<li>不要让生命周期长于Activity的对象持有其的引用。</li>\n<li>尽量不要在Activity中使用非静态内部类，因为非静态内部类会隐式持有外部类示例的引用，如果使用静态内部类，将外部实例引用作为弱引用持有。</li>\n</ol>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<ul>\n<li><a href=\"https://blog.csdn.net/lmj623565791/article/details/40481055\">https://blog.csdn.net/lmj623565791/article/details/40481055</a></li>\n<li><a href=\"https://blog.csdn.net/qinjuning/article/details/7310620\">https://blog.csdn.net/qinjuning/article/details/7310620</a></li>\n<li><a href=\"https://developer.android.com/reference/android/content/Context\">https://developer.android.com/reference/android/content/Context</a></li>\n</ul>\n","prev":{"title":"对象拷贝性能对比分析","link":"posts/1563597009"},"next":{"title":"Android开发之UI线程和非UI线程","link":"posts/1557641723"},"plink":"https://blog.ixin.run/posts/1557933993/","toc":[{"id":"context是什么","title":"Context是什么","index":"1"},{"id":"context的行为","title":"Context的行为","index":"2"},{"id":"context的关系谱","title":"Context的关系谱","index":"3","children":[{"id":"相关类介绍","title":"相关类介绍","index":"3.1"}]},{"id":"context的创建时机","title":"Context的创建时机","index":"4","children":[{"id":"context的数量","title":"Context的数量","index":"4.1"},{"id":"具体的创建时机","title":"具体的创建时机","index":"4.2"},{"id":"重量级packageinfo","title":"重量级PackageInfo","index":"4.3"},{"id":"context的getsharedpreferences()方法","title":"Context的getSharedPreferences()方法","index":"4.4"}]},{"id":"context的使用","title":"Context的使用","index":"5","children":[{"id":"如何获取context","title":"如何获取Context","index":"5.1"},{"id":"context的使用场景","title":"Context的使用场景","index":"5.2"},{"id":"context引起的内存泄漏","title":"Context引起的内存泄漏","index":"5.3"}]},{"id":"参考","title":"参考","index":"6"}],"reward":true,"copyright":{"author":"i猩人","link":"<a href=\"https://blog.ixin.run/posts/1557933993/\" title=\"Android开发之Context认识和运用\">https://blog.ixin.run/posts/1557933993/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}