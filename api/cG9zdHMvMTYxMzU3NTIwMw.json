{"title":"Stream流式编程知识总结","date":"2021-02-17T15:19:29.000Z","date_formatted":{"ll":"2021年2月17日","L":"2021/02/17","MM-DD":"02-17"},"link":"posts/1613575203","comments":true,"tags":["Java","Stream","流式编程"],"categories":["Java"],"updated":"2021-02-24T13:38:31.281Z","content":"<p>本篇继上一篇《<a href=\"https://blog.ixin.run/posts/1613545058\" target=\"_blank\">Lambda表达式你会吗</a>》又一篇Java8新特性——流式编程，上篇文章中并没有采用Stream例子来装饰Lambda表达式，害怕有同学看不懂，所以在文章末尾留个彩蛋，本篇文章重点讲一下对Java8中流式编程的运用学习。</p>\n<a id=\"more\"></a>\n<p>Java8新特性系列：</p>\n<ul>\n<li><a href=\"https://blog.ixin.run/posts/1613545058\" target=\"_blank\">《Lambda表达式你会吗》</a></li>\n<li><a href=\"https://blog.ixin.run/posts/1613575203\" target=\"_blank\">《Stream流式编程知识总结》</a></li>\n<li><a href=\"https://blog.ixin.run/posts/1613581746\" target=\"_blank\">《Stream流式编程实现原理》</a></li>\n</ul>\n<h2 id=\"什么是stream\">什么是Stream<a title=\"#什么是stream\" href=\"#什么是stream\"></a></h2>\n<p>Stream它并不是一个容器，它只是对容器的功能进行了增强，添加了很多便利的操作,例如查找、过滤、分组、排序等一系列的操作。并且有<code>串行</code>、<code>并行</code>两种执行模式，<strong>并行模式充分的利用了多核处理器的优势，使用fork/join框架进行了任务拆分</strong>，同时提高了执行速度。简而言之，Stream就是提供了一种高效且易于使用的处理数据的方式。</p>\n<p>特点：</p>\n<ul>\n<li>Stream自己不会存储元素。</li>\n<li>Stream操作不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li>\n<li>Stream操作是延迟执行的。它会等到需要结果的时候才执行。也就是执行终端操作的时候。</li>\n</ul>\n<p>图解：</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/5F8E6FFD15CC4DB6B1581F988B549E54?method=download&amp;shareKey=71bdcabd6cbf47997ecb3c02cef719a5\" alt=\"Stream操作流\" class=\"φbs\"></p>\n<p>一个Stream的操作就如上图，在一个管道内，分为三个步骤：</p>\n<ul>\n<li>第一步是创建Stream，从集合、数组中获取一个流；</li>\n<li>第二步是中间操作链，对数据进行处理；</li>\n<li>第三步是终端操作，用来执行中间操作链，返回结果；</li>\n</ul>\n<h2 id=\"为什么需要流式操作\">为什么需要流式操作<a title=\"#为什么需要流式操作\" href=\"#为什么需要流式操作\"></a></h2>\n<p>集合API是Java API中最重要的部分。基本上每一个java程序都离不开集合。尽管很重要，但是现有的集合处理在很多方面都无法满足需要。</p>\n<p>一个原因是，许多其他的语言或者类库以声明的方式来处理特定的数据模型，比如SQL语言，你可以从表中查询，按条件过滤数据，并且以某种形式将数据分组，而不必需要了解查询是如何实现的——数据库帮你做所有的脏活。这样做的好处是你的代码很简洁。很遗憾，Java没有这种好东西，你需要用控制流程自己实现所有数据查询的底层的细节。</p>\n<p>其次是你如何有效地处理包含大量数据的集合。理想情况下，为了加快处理过程，你会利用多核架构。但是并发程序不太好写，而且很容易出错。</p>\n<p>Stream API很好的解决了这两个问题。它抽象出一种叫做流的东西让你以声明的方式处理数据，更重要的是，它还实现了多线程：帮你处理底层诸如线程、锁、条件变量、易变变量等等。</p>\n<h2 id=\"怎么创建stream\">怎么创建Stream<a title=\"#怎么创建stream\" href=\"#怎么创建stream\"></a></h2>\n<p>常用的Stream有三种创建方式：</p>\n<ul>\n<li>集合 Collection.stream()</li>\n<li>数组 Arrays.stream</li>\n<li>静态方法 Stream.of</li>\n</ul>\n<h3 id=\"由集合创建\">由集合创建<a title=\"#由集合创建\" href=\"#由集合创建\"></a></h3>\n<p>Java8 中的 Collection 接口被扩展，提供了两个获取流的方法,这两个方法是default方法，也就是说所有实现Collection接口的接口都不需要实现就可以直接使用：</p>\n<ol>\n<li>default Stream<E> stream() : 返回一个串行流。</li>\n<li>default Stream<E> parallelStream() : 返回一个并行流。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; integerList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">integerList.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">integerList.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">Stream&lt;Integer&gt; stream = integerList.stream();</span><br><span class=\"line\">Stream&lt;Integer&gt; stream1 = integerList.parallelStream();</span><br></pre></td></tr></table></figure>\n<h3 id=\"由数组创建\">由数组创建<a title=\"#由数组创建\" href=\"#由数组创建\"></a></h3>\n<p>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] array = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">Stream&lt;Integer&gt; stream = Arrays.stream(array);</span><br></pre></td></tr></table></figure>\n<h3 id=\"由静态方法stream.of创建\">由静态方法Stream.of创建<a title=\"#由静态方法stream.of创建\" href=\"#由静态方法stream.of创建\"></a></h3>\n<p>可以使用静态方法 Stream.of(), 通过显示值 创建一个流。它可以接收任意数量的参数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;Integer&gt; integerStream = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"准备数据\">准备数据<a title=\"#准备数据\" href=\"#准备数据\"></a></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//计算机俱乐部</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;Student&gt; computerClub = Arrays.asList(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;2015134001&quot;</span>, <span class=\"string\">&quot;小明&quot;</span>, <span class=\"number\">15</span>, <span class=\"string\">&quot;1501&quot;</span>),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;2015134003&quot;</span>, <span class=\"string\">&quot;小王&quot;</span>, <span class=\"number\">14</span>, <span class=\"string\">&quot;1503&quot;</span>),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;2015134006&quot;</span>, <span class=\"string\">&quot;小张&quot;</span>, <span class=\"number\">15</span>, <span class=\"string\">&quot;1501&quot;</span>),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;2015134008&quot;</span>, <span class=\"string\">&quot;小梁&quot;</span>, <span class=\"number\">17</span>, <span class=\"string\">&quot;1505&quot;</span>)</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">//篮球俱乐部</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;Student&gt; basketballClub = Arrays.asList(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;2015134012&quot;</span>, <span class=\"string\">&quot;小c&quot;</span>, <span class=\"number\">13</span>, <span class=\"string\">&quot;1503&quot;</span>),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;2015134013&quot;</span>, <span class=\"string\">&quot;小s&quot;</span>, <span class=\"number\">14</span>, <span class=\"string\">&quot;1503&quot;</span>),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;2015134015&quot;</span>, <span class=\"string\">&quot;小d&quot;</span>, <span class=\"number\">15</span>, <span class=\"string\">&quot;1504&quot;</span>),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;2015134018&quot;</span>, <span class=\"string\">&quot;小y&quot;</span>, <span class=\"number\">16</span>, <span class=\"string\">&quot;1505&quot;</span>)</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">//乒乓球俱乐部</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;Student&gt; pingpongClub = Arrays.asList(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;2015134022&quot;</span>, <span class=\"string\">&quot;小u&quot;</span>, <span class=\"number\">16</span>, <span class=\"string\">&quot;1502&quot;</span>),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;2015134021&quot;</span>, <span class=\"string\">&quot;小i&quot;</span>, <span class=\"number\">14</span>, <span class=\"string\">&quot;1502&quot;</span>),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;2015134026&quot;</span>, <span class=\"string\">&quot;小m&quot;</span>, <span class=\"number\">17</span>, <span class=\"string\">&quot;1504&quot;</span>),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;2015134027&quot;</span>, <span class=\"string\">&quot;小n&quot;</span>, <span class=\"number\">16</span>, <span class=\"string\">&quot;1504&quot;</span>)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;List&lt;Student&gt;&gt; allClubStu = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">allClubStu.add(computerClub);</span><br><span class=\"line\">allClubStu.add(basketballClub);</span><br><span class=\"line\">allClubStu.add(pingpongClub);</span><br></pre></td></tr></table></figure>\n<p>以上数据用于下边的Stream的中间操作和终止操作实例说明。</p>\n<h2 id=\"stream中间操作\">Stream中间操作<a title=\"#stream中间操作\" href=\"#stream中间操作\"></a></h2>\n<p>如果Stream只有中间操作是不会执行的，当执行终端操作的时候才会执行中间操作，这种方式称为延迟加载或惰性求值。多个中间操作组成一个中间操作链，只有当执行终端操作的时候才会执行一遍中间操作链，下面看下Stream有哪些中间操作。</p>\n<h3 id=\"distinct\">distinct<a title=\"#distinct\" href=\"#distinct\"></a></h3>\n<p>distinct: 对于Stream中包含的元素进行去重操作（去重逻辑依赖元素的equals方法），新生成的Stream中没有重复的元素；</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/261480920B09496B879298FE3316E928?method=download&amp;shareKey=51d2fbc84b967398b09b320c06a2e6e5\" alt=\"distinct方法示意图\" class=\"φbs\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = Arrays.asList(<span class=\"string\">&quot;b&quot;</span>,<span class=\"string\">&quot;b&quot;</span>,<span class=\"string\">&quot;c&quot;</span>,<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">list.forEach(System.out::print); <span class=\"comment\">//bbca</span></span><br><span class=\"line\">list.stream().distinct().forEach(System.out::print);<span class=\"comment\">//bca</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"filter\">filter<a title=\"#filter\" href=\"#filter\"></a></h3>\n<p>filter: 对于Stream中包含的元素使用给定的过滤函数进行过滤操作，新生成的Stream只包含符合条件的元素；</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/539AC71D896E465091D6487A4E638EA4?method=download&amp;shareKey=827e2ca8843b61eea9eb2701e1d2cf12\" alt=\"filter方法示意图\" class=\"φbs\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//筛选1501班的学生</span></span><br><span class=\"line\">computerClub.stream().filter(e -&gt; e.getClassNum().equals(<span class=\"string\">&quot;1501&quot;</span>)).forEach(System.out::println);</span><br><span class=\"line\"><span class=\"comment\">//筛选年龄大于15的学生</span></span><br><span class=\"line\">List&lt;Student&gt; collect = computerClub.stream().filter(e -&gt; e.getAge() &gt; <span class=\"number\">15</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n<h3 id=\"map\">map<a title=\"#map\" href=\"#map\"></a></h3>\n<p>map: 对于Stream中包含的元素使用给定的转换函数进行转换操作，新生成的Stream只包含转换生成的元素。</p>\n<p>这个方法有三个对于原始类型的变种方法，分别是：mapToInt，mapToLong和mapToDouble。这三个方法也比较好理解，比如mapToInt就是把原始Stream转换成一个新的Stream，这个新生成的Stream中的元素都是int类型。之所以会有这样三个变种方法，可以免除自动装箱/拆箱的额外消耗；</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/2226A8D01A8C453BBDAF29654BB9CB60?method=download&amp;shareKey=4024c7be6b6fb4df9b0ff6cc872a6cf7\" alt=\"map方法示意图\" class=\"φbs\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//篮球俱乐部所有成员名 + 暂时住上商标^_^,并且获取所有队员名</span></span><br><span class=\"line\">List&lt;String&gt; collect1 = basketballClub.stream()</span><br><span class=\"line\">        .map(e -&gt; e.getName() + <span class=\"string\">&quot;^_^&quot;</span>)</span><br><span class=\"line\">        .collect(Collectors.toList());</span><br><span class=\"line\">collect1.forEach(System.out::println);</span><br><span class=\"line\"><span class=\"comment\">//小c^_^^_^</span></span><br><span class=\"line\"><span class=\"comment\">//小s^_^^_^</span></span><br><span class=\"line\"><span class=\"comment\">//小d^_^^_^</span></span><br><span class=\"line\"><span class=\"comment\">//小y^_^^_^</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"flatmap\">flatMap<a title=\"#flatmap\" href=\"#flatmap\"></a></h3>\n<p>flatMap：和map类似，不同的是其每个元素转换得到的是Stream对象，会把子Stream中的元素压缩到父集合中；</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/41657628B5924189953B1D36B1B926E3?method=download&amp;shareKey=f661f2bafe82c18eadcb9768699422f0\" alt=\"flatMap方法示意图\" class=\"φbs\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取年龄大于15的所有俱乐部成员</span></span><br><span class=\"line\">List&lt;Student&gt; collect2 = Stream.of(basketballClub, computerClub, pingpongClub)</span><br><span class=\"line\">        .flatMap(e -&gt; e.stream().filter(s -&gt; s.getAge() &gt; <span class=\"number\">15</span>))</span><br><span class=\"line\">        .collect(Collectors.toList());</span><br><span class=\"line\">collect2.forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用双层list获取所有年龄大于15的俱乐部成员</span></span><br><span class=\"line\">List&lt;Student&gt; collect3 = allClubStu.stream()</span><br><span class=\"line\">        .flatMap(e -&gt; e.stream().filter(s -&gt; s.getAge() &gt; <span class=\"number\">15</span>))</span><br><span class=\"line\">        .collect(Collectors.toList());</span><br><span class=\"line\">collect3.forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n<h3 id=\"peek\">peek<a title=\"#peek\" href=\"#peek\"></a></h3>\n<p>peek: 生成一个包含原Stream的所有元素的新Stream，同时会提供一个消费函数（Consumer实例），新Stream每个元素被消费的时候都会执行给定的消费函数；</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/0099197CB64842D899AD63225245068A?method=download&amp;shareKey=736caede137803fc873c54372bf1b795\" alt=\"peek方法示意图\" class=\"φbs\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//篮球俱乐部所有成员名 + 赞助商商标^_^,并且获取所有队员详细内容</span></span><br><span class=\"line\">List&lt;Student&gt; collect = basketballClub.stream()</span><br><span class=\"line\">        .peek(e -&gt; e.setName(e.getName() + <span class=\"string\">&quot;^_^&quot;</span>))</span><br><span class=\"line\">        .collect(Collectors.toList());</span><br><span class=\"line\">collect.forEach(System.out::println);</span><br><span class=\"line\"><span class=\"comment\">//Student&#123;idNum=&#x27;2015134012&#x27;, name=&#x27;小c^_^&#x27;, age=13, classNum=&#x27;1503&#x27;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//Student&#123;idNum=&#x27;2015134013&#x27;, name=&#x27;小s^_^&#x27;, age=14, classNum=&#x27;1503&#x27;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//Student&#123;idNum=&#x27;2015134015&#x27;, name=&#x27;小d^_^&#x27;, age=15, classNum=&#x27;1504&#x27;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//Student&#123;idNum=&#x27;2015134018&#x27;, name=&#x27;小y^_^&#x27;, age=16, classNum=&#x27;1505&#x27;&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"limit\">limit<a title=\"#limit\" href=\"#limit\"></a></h3>\n<p>limit: 对一个Stream进行截断操作，获取其前N个元素，如果原Stream中包含的元素个数小于N，那就获取其所有的元素；</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/A033AD2A6EA747038A8003E5E3DC73DC?method=download&amp;shareKey=1180bb49da1ad4fb5472a65825d619b8\" alt=\"limit方法示意图\" class=\"φbs\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = Arrays.asList(<span class=\"string\">&quot;a&quot;</span>,<span class=\"string\">&quot;b&quot;</span>,<span class=\"string\">&quot;c&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//获取list中top2即截断取前两个</span></span><br><span class=\"line\">List&lt;String&gt; collect1 = list.stream().limit(<span class=\"number\">2</span>).collect(Collectors.toList());</span><br><span class=\"line\">collect1.forEach(System.out::print);<span class=\"comment\">//ab</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"skip\">skip<a title=\"#skip\" href=\"#skip\"></a></h3>\n<p>skip: 返回一个丢弃原Stream的前N个元素后剩下元素组成的新Stream，如果原Stream中包含的元素个数小于N，那么返回空Stream；</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/E8152D9B1B9448CEB73E14120AF2E649?method=download&amp;shareKey=e234a439cc90b7b4f8ae8b2397c8aa55\" alt=\"skip方法示意图\" class=\"φbs\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = Arrays.asList(<span class=\"string\">&quot;a&quot;</span>,<span class=\"string\">&quot;b&quot;</span>,<span class=\"string\">&quot;c&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//获取list中top2即截断取前两个</span></span><br><span class=\"line\">List&lt;String&gt; collect1 = list.stream().skip(<span class=\"number\">2</span>).collect(Collectors.toList());</span><br><span class=\"line\">collect1.forEach(System.out::print);<span class=\"comment\">//c</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"sorted\">sorted<a title=\"#sorted\" href=\"#sorted\"></a></h3>\n<p>sorted有两种形式存在：</p>\n<ol>\n<li>sorted(Comparator): 指定比较规则进行排序。</li>\n<li>sorted(): 产生一个新流，按照自然顺序排序。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = Arrays.asList(<span class=\"string\">&quot;b&quot;</span>,<span class=\"string\">&quot;c&quot;</span>,<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//获取list中top2即截断取前两个</span></span><br><span class=\"line\">List&lt;String&gt; collect1 = list.stream().sorted().collect(Collectors.toList());</span><br><span class=\"line\">collect1.forEach(System.out::print);<span class=\"comment\">//abc</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"stream的终端操作\">Stream的终端操作<a title=\"#stream的终端操作\" href=\"#stream的终端操作\"></a></h2>\n<p>如果说Stream中间操作返回的是Stream，那么终端操作返回的就是最终转换需要返回的结果。</p>\n<h2 id=\"汇聚操作：\">汇聚操作：<a title=\"#汇聚操作：\" href=\"#汇聚操作：\"></a></h2>\n<ul>\n<li>foreach(Consumer c) 遍历操作</li>\n<li>collect(Collector) 将流转化为其他形式</li>\n</ul>\n<p>其中Collectors具体方法有：</p>\n<ul>\n<li>toList List 把流中元素收集到List</li>\n<li>toSet Set 把流中元素收集到Set</li>\n<li>toCollection Coolection 把流中元素收集到Collection中</li>\n<li>groupingBy Map&lt;K,List&gt; 根据K属性对流进行分组</li>\n<li>partitioningBy Map&lt;boolean, List&gt; 根据boolean值进行分组</li>\n</ul>\n<p>栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//此处只是演示 此类需求直接用List构造器即可</span></span><br><span class=\"line\">List&lt;Student&gt; collect = computerClub.stream().collect(Collectors.toList());</span><br><span class=\"line\">Set&lt;Student&gt; collect1 = pingpongClub.stream().collect(Collectors.toSet());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注意key必须是唯一的 如果不是唯一的会报错而不是像普通map那样覆盖</span></span><br><span class=\"line\">Map&lt;String, String&gt; collect2 = pingpongClub.stream()</span><br><span class=\"line\">        .collect(Collectors.toMap(Student::getIdNum, Student::getName));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//分组 类似于数据库中的group by</span></span><br><span class=\"line\">Map&lt;String, List&lt;Student&gt;&gt; collect3 = pingpongClub.stream()</span><br><span class=\"line\">        .collect(Collectors.groupingBy(Student::getClassNum));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//字符串拼接 第一个参数是分隔符 第二个参数是前缀 第三个参数是后缀</span></span><br><span class=\"line\">String collect4 = pingpongClub.stream().map(Student::getName).collect(Collectors.joining(<span class=\"string\">&quot;,&quot;</span>, <span class=\"string\">&quot;【&quot;</span>, <span class=\"string\">&quot;】&quot;</span>)); <span class=\"comment\">//【小u,小i,小m,小n】</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//三个俱乐部符合年龄要求的按照班级分组</span></span><br><span class=\"line\">Map&lt;String, List&lt;Student&gt;&gt; collect5 = Stream.of(basketballClub, pingpongClub, computerClub)</span><br><span class=\"line\">        .flatMap(e -&gt; e.stream().filter(s -&gt; s.getAge() &lt; <span class=\"number\">17</span>))</span><br><span class=\"line\">        .collect(Collectors.groupingBy(Student::getClassNum));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//按照是否年龄&gt;16进行分组 key为true和false</span></span><br><span class=\"line\">ConcurrentMap&lt;Boolean, List&lt;Student&gt;&gt; collect6 = Stream.of(basketballClub, pingpongClub, computerClub)</span><br><span class=\"line\">        .flatMap(Collection::stream)</span><br><span class=\"line\">        .collect(Collectors.groupingByConcurrent(s -&gt; s.getAge() &gt; <span class=\"number\">16</span>));</span><br></pre></td></tr></table></figure>\n<h3 id=\"匹配操作\">匹配操作<a title=\"#匹配操作\" href=\"#匹配操作\"></a></h3>\n<ul>\n<li>booelan allMatch(Predicate) 都符合</li>\n<li>boolean anyMatch(Predicate) 任一元素符合</li>\n<li>boolean noneMatch(Predicate) 都不符合</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">boolean</span> b = basketballClub.stream().allMatch(e -&gt; e.getAge() &lt; <span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> b1 = basketballClub.stream().anyMatch(e -&gt; e.getAge() &lt; <span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> b2 = basketballClub.stream().noneMatch(e -&gt; e.getAge() &lt; <span class=\"number\">20</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"寻找操作\">寻找操作<a title=\"#寻找操作\" href=\"#寻找操作\"></a></h3>\n<ul>\n<li>findFirst——返回第一个元素</li>\n<li>findAny——返回当前流中的任意元素</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Optional&lt;Student&gt; first = basketballClub.stream().findFirst();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (first.isPresent()) &#123;</span><br><span class=\"line\">    Student student = first.get();</span><br><span class=\"line\">    System.out.println(student);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Optional&lt;Student&gt; any = basketballClub.stream().findAny();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (any.isPresent()) &#123;</span><br><span class=\"line\">    Student student2 = any.get();</span><br><span class=\"line\">    System.out.println(student2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Optional&lt;Student&gt; any1 = basketballClub.stream().parallel().findAny();</span><br><span class=\"line\">System.out.println(any1);</span><br></pre></td></tr></table></figure>\n<h3 id=\"计数和极值\">计数和极值<a title=\"#计数和极值\" href=\"#计数和极值\"></a></h3>\n<ul>\n<li>count 返回流中元素的总个数</li>\n<li>max(Comparator) 返回流中最大值</li>\n<li>min(Comparator) 返回流中最小值</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">long</span> count = basketballClub.stream().count();</span><br><span class=\"line\">Optional&lt;Student&gt; max = basketballClub.stream().max(Comparator.comparing(Student::getAge));</span><br><span class=\"line\"><span class=\"keyword\">if</span> (max.isPresent()) &#123;</span><br><span class=\"line\">    Student student = max.get();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Optional&lt;Student&gt; min = basketballClub.stream().min(Comparator.comparingInt(Student::getAge));</span><br><span class=\"line\"><span class=\"keyword\">if</span> (min.isPresent()) &#123;</span><br><span class=\"line\">    Student student = min.get();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"fork/join框架\">Fork/Join框架<a title=\"#fork/join框架\" href=\"#fork/join框架\"></a></h2>\n<p>上面我们提到过，说Stream的并行模式使用了Fork/Join框架，这里简单说下Fork/Join框架是什么？<code>Fork/Join</code>框架是java7中加入的一个并行任务框架，可以将任务拆分为多个小任务，每个小任务执行完的结果再合并成为一个结果。在任务的执行过程中使用工作窃取（work-stealing）算法，减少线程之间的竞争。</p>\n<p>Fork/Join图解：</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/1F6D446E74504528B96EE39CA948269A?method=download&amp;shareKey=125238f35bf56e24faa804eb65d07d8c\" alt=\"Fork/Join图解\" class=\"φbs\"></p>\n<p>工作窃取图解:</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/ACBE731451DE4A8FAF279D8AD7EE6E6D?method=download&amp;shareKey=c5ab237553dc22d26b77f120ee35a597\" alt=\"工作窃取图解\" class=\"φbs\"></p>\n<p>什么是工作窃取算法？说白了就是多线程同步执行，<strong>当一个线程把自己队列任务完成后去“窃取”其他线程队列任务继续干</strong>。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p>\n<h2 id=\"最后\">最后<a title=\"#最后\" href=\"#最后\"></a></h2>\n<p>本篇文章大量的图片示例采用了RxJava图示说明，其实RxJava编程思想虽然是响应式编程，但是其操作符转换和流式编程如出一辙，本篇文章主要讲述Stream流式编程的认识和运用，有兴趣的小伙伴可以继续深入了解一下Stream的工作原理。</p>\n","prev":{"title":"Stream流式编程实现原理","link":"posts/1613581746"},"next":{"title":"Lambda表达式你会吗","link":"posts/1613545058"},"plink":"https://blog.ixin.run/posts/1613575203/","toc":[{"id":"什么是stream","title":"什么是Stream","index":"1"},{"id":"为什么需要流式操作","title":"为什么需要流式操作","index":"2"},{"id":"怎么创建stream","title":"怎么创建Stream","index":"3","children":[{"id":"由集合创建","title":"由集合创建","index":"3.1"},{"id":"由数组创建","title":"由数组创建","index":"3.2"},{"id":"由静态方法stream.of创建","title":"由静态方法Stream.of创建","index":"3.3"}]},{"id":"准备数据","title":"准备数据","index":"4"},{"id":"stream中间操作","title":"Stream中间操作","index":"5","children":[{"id":"distinct","title":"distinct","index":"5.1"},{"id":"filter","title":"filter","index":"5.2"},{"id":"map","title":"map","index":"5.3"},{"id":"flatmap","title":"flatMap","index":"5.4"},{"id":"peek","title":"peek","index":"5.5"},{"id":"limit","title":"limit","index":"5.6"},{"id":"skip","title":"skip","index":"5.7"},{"id":"sorted","title":"sorted","index":"5.8"}]},{"id":"stream的终端操作","title":"Stream的终端操作","index":"6"},{"id":"汇聚操作：","title":"汇聚操作：","index":"7","children":[{"id":"匹配操作","title":"匹配操作","index":"7.1"},{"id":"寻找操作","title":"寻找操作","index":"7.2"},{"id":"计数和极值","title":"计数和极值","index":"7.3"}]},{"id":"fork/join框架","title":"Fork&#x2F;Join框架","index":"8"},{"id":"最后","title":"最后","index":"9"}],"reward":true,"copyright":{"author":"i猩人","link":"<a href=\"https://blog.ixin.run/posts/1613575203/\" title=\"Stream流式编程知识总结\">https://blog.ixin.run/posts/1613575203/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}