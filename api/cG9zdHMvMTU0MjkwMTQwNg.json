{"title":"那些年Android保活的奇技淫巧","date":"2018-11-22T15:43:26.000Z","date_formatted":{"ll":"2018年11月22日","L":"2018/11/22","MM-DD":"11-22"},"link":"posts/1542901406","comments":true,"categories":["Android"],"updated":"2021-01-29T12:51:44.652Z","content":"<p>进程保活是android开发者很重要的一堂课。在对外的应用中我们希望自己的应用能够在用户的手机上保留的时间长一点，用来做一些“背后应该做”的事。在对内的应用中更希望应用能够长时间保活，用来进行数据的采集和数据接收发送，保证业务的稳定性。</p>\n<a id=\"more\"></a>\n<h2 id=\"为什么是那些年\">为什么是那些年<a title=\"#为什么是那些年\" href=\"#为什么是那些年\"></a></h2>\n<p>为什么说是那些年呢？早在4.4之前简直就是一场噩梦般存在，手机上各家应用被各种手段进行金钟罩般保护着，甚至有大神给出的方案称进程永生不死，擂台就那么大一点，最终导致应用装的越多手机越卡。后来google也重视了这个问题，后边的版本慢慢将这些所谓的保活的漏洞补住了一部分，当然目前的各种手段其实最多只是让应用生命力稍微强一点，至于永生不死，也不现实，除非系统帮你。</p>\n<p>如实说，作为一名开发者，虽然也会一些招式，但是我真心不希望这些所谓的保活黑科技出现，因为安卓生态平衡一旦打破，带来的结果将是用户流失，走向消亡。这里本着深明大义的原则做一个保活手段的相关总结，前边也说了目前的保活手段最多帮应用提升一点生命力，永生不现实，这里也是系统分析一下相关思想。</p>\n<h2 id=\"保活手段\">保活手段<a title=\"#保活手段\" href=\"#保活手段\"></a></h2>\n<p>目前的保活手段可谓是层出不穷，以下是常用的几种手段。</p>\n<ol>\n<li>申请电源锁，保持CPU 运转，从而提高应用的生命力。</li>\n<li>提高后台服务service的优先级，尽可能的提高其生命力。</li>\n<li>采用服务前台展示的形式，从而提高其生命力。</li>\n<li>在service的onstartCommand方法里返回STATR_STICK。</li>\n<li>在service的onDestroy方法里自启service。</li>\n<li>root后成为系统级应用，在Manifest文件添加属性值android:persistent=“true”。</li>\n<li>开机，网络切换、拍照、拍视频时候，利用系统产生的广播唤醒app。</li>\n<li>通过接入各大手机厂商自家的推送服务。</li>\n<li>AlarmManager唤醒。</li>\n<li>JobScheduler定时唤醒。</li>\n<li>双进程，甚至多进程守护。</li>\n<li>长连接心跳唤醒保活。</li>\n<li>1像素点悬浮层。</li>\n<li>无声音乐保活。</li>\n<li>系统白名单。</li>\n</ol>\n<h2 id=\"保活分类\">保活分类<a title=\"#保活分类\" href=\"#保活分类\"></a></h2>\n<ol>\n<li>\n<p>按照大众说法可以分为三种类：</p>\n<ul>\n<li><strong>黑色保活</strong>：利用进程规则或广播拉起，强制应用不容易杀死，导致应用强占内存不放，用户比较反感。</li>\n<li><strong>白色保活</strong>：google允许的保活方式，其实也是用户同意的。</li>\n<li><strong>灰色保活</strong>：隐式保活，仅仅是提高其生命力，进程杀掉其生命也就结束了。</li>\n</ul>\n</li>\n<li>\n<p>按照我自己的说法可以分为两类：</p>\n<ul>\n<li><strong>不死</strong>：尽可能保证其不被杀死。</li>\n<li><strong>回生</strong>：死了通过各种拉活手段将其救活。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"保活手段细说\">保活手段细说<a title=\"#保活手段细说\" href=\"#保活手段细说\"></a></h2>\n<p>例如申请电源锁、利用service生命周期以及startForeground前台保活，这些常见的提升生命力的保活方式我就不提了，以下简单阐述一些其他保活骚操作。</p>\n<h3 id=\"利用系统静态广播唤醒\">利用系统静态广播唤醒<a title=\"#利用系统静态广播唤醒\" href=\"#利用系统静态广播唤醒\"></a></h3>\n<p>在某种应激下系统会发出一些广播通知，例如开机广播，开屏灭屏广播，锁屏解锁等，可以利用系统级广播来进行拉活app。google已经注意到这种情况，在Android N系统中已去掉了 ACTION_NEW_PICTURE（拍照），ACTION_NEW_VIDEO（拍视频），CONNECTIVITY_ACTION（网络切换）三种广播。另外在4.0以上，一旦被系统强制杀死后也不能接收广播来进行启动了。</p>\n<p>常见的系统静态广播有：<br>\n<img src=\"https://note.youdao.com/yws/api/personal/file/D79B0A5A32A446C988CD92705F4E0263?method=download&amp;shareKey=3a65aa1a230b59e78855f25a585d0f56\" alt=\"系统静态广播\"></p>\n<h3 id=\"通过接入各大手机厂商自家的推送服务\">通过接入各大手机厂商自家的推送服务<a title=\"#通过接入各大手机厂商自家的推送服务\" href=\"#通过接入各大手机厂商自家的推送服务\"></a></h3>\n<p>一般手机厂商自家的推送进程系统是不会杀的。例如你若想支持小米用户，就接入小米的推送，你若想支持华为的用户，你就接入华为的推送。然后根据推送广播来保护自己的应用。</p>\n<h3 id=\"alarmmanager唤醒\">AlarmManager唤醒<a title=\"#alarmmanager唤醒\" href=\"#alarmmanager唤醒\"></a></h3>\n<blockquote>\n<p>Note: Beginning with API 19 (KITKAT) alarm delivery is inexact: the OS will shift alarms in order to minimize wakeups and battery use. There are new APIs to support applications which need strict delivery guarantees; see setWindow(int, long, long, PendingIntent) and setExact(int, long, PendingIntent). Applications whose targetSdkVersion is earlier than API 19 will continue to see the previous behavior in which all alarms are delivered exactly when requested.<br>\nYou do not instantiate this class directly; instead, retrieve it through Context.getSystemService(Context.ALARM_SERVICE).</p>\n</blockquote>\n<p>google官方文档这段话大致意思是AlarmManager在4.4之后开始变得不准确，系统为了降低电量消耗和最小化唤醒。在目前的操作系统中一旦应用强制停止后定时唤醒也将不在起作用。</p>\n<p><strong>相关常量：</strong><br>\nAlarmManager主要是使用到了5个关于时间类型的常量：<br>\n<strong>ELAPSED_REALTIME</strong>：表示闹钟在手机睡眠状态下不可用，该状态下闹钟使用相对时间（相对于系统启动开始），状态值为3,使用SystemClock.elapsedRealtime()可获得时间。<br>\n<strong>ELAPSED_REALTIME_WAKEUP</strong>：表示闹钟在睡眠状态下会唤醒系统并执行提示功能，该状态下闹钟也使用相对时间，状态值为2，SystemClock.elapsedRealtime()；<br>\n<strong>RTC</strong>：表示闹钟在睡眠状态下不可用，该状态下闹钟使用绝对时间（ SystemClock.currentThreadTimeMillis()），即当前系统时间，状态值为1；<br>\n<strong>RTC_WAKEUP</strong>：表示闹钟在睡眠状态下会唤醒系统并执行提示功能，该状态下闹钟使用绝对时间（SystemClock.currentThreadTimeMillis()），状态值为0；<br>\n<strong>AlarmManager.POWER_OFF_WAKEUP</strong>：表示闹钟在手机关机状态下也能正常进行提示功能，所以是5个状态中用的最多的状态之一，该状态下闹钟也是用绝对时间，状态值为4；不过本状态好像受SDK版本影响，某些版本并不支持；</p>\n<p><strong>常用方法</strong><br>\n①<strong>set(int type, long triggerAtMillis, PendingIntent operation)</strong><br>\n该方法用于设置一次性闹钟，第一个参数表示闹钟类型，第二个参数表示闹钟执行时间，第三个参数表示闹钟响应动作。<br>\n②<strong>setExact(int type, long triggerAtMillis, PendingIntent operation)</strong><br>\n设置一个闹钟在规定的时间内准确地发出。（当然准确是不可能准确的）<br>\n③<strong>setWindow(int type, long windowStartMillis, long windowLengthMillis, PendingIntent operation)</strong><br>\n大致的参数同前面几个，第三个参数指的是当警报发出时最大延迟时间是多少。<br>\n④<strong>setExactAndAllowWhileIdle(int type, long triggerAtMillis, PendingIntent operation)</strong><br>\n同setExact，即使在系统低功耗的情况下也能发出警报。<br>\n⑤<strong>setAndAllowWhileIdle(int type, long triggerAtMillis, PendingIntent operation)</strong><br>\n同set。<br>\n⑥<strong>setAlarmClock(AlarmManager.AlarmClockInfo info, PendingIntent operation)</strong><br>\n第一个参数表示闹钟的信息当然使用的是绝对时间，第二参数想要执行的意图。</p>\n<p>AlarmManager拉活逻辑</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 每5分钟唤醒一次service</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> context</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">setKeepAliveAlarm</span><span class=\"params\">(Context context, <span class=\"keyword\">boolean</span> interVal)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 防止4.4以下的重复执行setRepeating</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.KITKAT &amp;&amp; interVal) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 循环时间</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> TIME_INTERVAL = <span class=\"number\">5</span> * <span class=\"number\">60</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\">    AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);</span><br><span class=\"line\">    <span class=\"comment\">// Intent local = new Intent(context, KeepAliveReceiver.class);</span></span><br><span class=\"line\">    Intent local = <span class=\"keyword\">new</span> Intent(context, <span class=\"string\">&quot;ALERT_KEEP_ACTION&quot;</span>);</span><br><span class=\"line\">    local.addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES);<span class=\"comment\">// 表示包含未启动的App</span></span><br><span class=\"line\">    PendingIntent pendingIntent = PendingIntent.getBroadcast(context, <span class=\"number\">999</span>, local, PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class=\"line\">    <span class=\"comment\">// 此处必须使用SystemClock.elapsedRealtime，否则闹钟无法接收</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> triggerAtMillis = SystemClock.elapsedRealtime();</span><br><span class=\"line\">    <span class=\"comment\">// 更新开启时间</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (interVal) &#123;</span><br><span class=\"line\">        triggerAtMillis += TIME_INTERVAL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// pendingIntent 为发送广播</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class=\"line\">        alarmManager.setExactAndAllowWhileIdle(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtMillis, pendingIntent);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class=\"line\">        alarmManager.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtMillis, pendingIntent);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// api19以前还是可以使用setRepeating重复发送广播</span></span><br><span class=\"line\">        alarmManager.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtMillis, TIME_INTERVAL, pendingIntent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 广播接收器</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KeepAliveReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TAG = KeepAliveReceiver.class.getSimpleName();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            String action = intent.getAction();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!TextUtils.isEmpty(action)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (action.equals(<span class=\"string\">&quot;ALERT_KEEP_ACTION&quot;</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 定时闹钟发送的保活心跳</span></span><br><span class=\"line\">                    <span class=\"comment\">// 在次发送闹钟</span></span><br><span class=\"line\">                    setKeepAliveAlarm(context, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 处理自己的逻辑</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<ul>\n<li><a href=\"http://www.52im.net/thread-1135-1-1.html\">http://www.52im.net/thread-1135-1-1.html</a></li>\n<li><a href=\"https://blog.csdn.net/carson_ho/article/details/79522975\">https://blog.csdn.net/carson_ho/article/details/79522975</a></li>\n</ul>\n","prev":{"title":"Android设备信息的那些事","link":"posts/1543208610"},"next":{"title":"Android开发View坐标了解","link":"posts/1542297919"},"plink":"https://blog.ixin.run/posts/1542901406/","toc":[{"id":"为什么是那些年","title":"为什么是那些年","index":"1"},{"id":"保活手段","title":"保活手段","index":"2"},{"id":"保活分类","title":"保活分类","index":"3"},{"id":"保活手段细说","title":"保活手段细说","index":"4","children":[{"id":"利用系统静态广播唤醒","title":"利用系统静态广播唤醒","index":"4.1"},{"id":"通过接入各大手机厂商自家的推送服务","title":"通过接入各大手机厂商自家的推送服务","index":"4.2"},{"id":"alarmmanager唤醒","title":"AlarmManager唤醒","index":"4.3"}]},{"id":"参考","title":"参考","index":"5"}],"reward":true,"copyright":{"author":"i猩人","link":"<a href=\"https://blog.ixin.run/posts/1542901406/\" title=\"那些年Android保活的奇技淫巧\">https://blog.ixin.run/posts/1542901406/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}