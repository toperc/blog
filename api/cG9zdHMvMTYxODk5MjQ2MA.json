{"title":"Android组件化可行性方案探讨和思考","date":"2021-04-21T08:06:46.000Z","date_formatted":{"ll":"2021年4月21日","L":"2021/04/21","MM-DD":"04-21"},"link":"posts/1618992460","comments":true,"tags":["组件化"],"categories":["Android"],"updated":"2021-05-14T13:27:29.533Z","content":"<h2 id=\"为什么要组件化\">为什么要组件化<a title=\"#为什么要组件化\" href=\"#为什么要组件化\"></a></h2>\n<p>组件化主要解决以下恼人问题：</p>\n<ol>\n<li>项目比较重，单次编译时间太久，尤其多次调试的时候，大部分时间都浪费在编译时间上</li>\n<li>合并代码总是遇到冲突</li>\n<li>高耦合，方法乱用</li>\n<li>自己的需求却需要改动别人的代码</li>\n<li>相同的功能未能剥离，用的时候只能多复制一份，搬砖活</li>\n<li>改动一丁点却需要完整回归测试</li>\n<li>功能责任不清晰，容易扯皮</li>\n<li>莫名bug出现</li>\n</ol>\n<p>无论是前端还是后端，组件化都是一个趋势。Android上组件化带来的好处最直接有以下几点：</p>\n<ol>\n<li>加快编译速度</li>\n<li>提高协作效率</li>\n<li>功能重用</li>\n</ol>\n<h2 id=\"组件划分\">组件划分<a title=\"#组件划分\" href=\"#组件划分\"></a></h2>\n<p>针对组件如何划分，每个项目都有自己的规则，但是大体上基本准则如下：</p>\n<ol>\n<li>壳工程</li>\n<li>Base组件</li>\n<li>common组件</li>\n<li>业务组件</li>\n</ol>\n<p>其中：</p>\n<p><strong>壳工程，不包含复杂的业务逻辑，主要用于业务组件的依赖，并最终合并成一个整体</strong>。网上好多同学都把壳工程解释为没有任何逻辑，我不并这么认为，因项目而异。壳工程可以想象为一个项目的大门，进门的基础设施我们可以简单处理一下，降低后期的内部沟通的复杂度。比如闪屏，比如app的主题和图标。当把各个业务组件剥离出去的时候，壳工程的逻辑也就很简单了，甚至可以忽略。</p>\n<p>Base组件，最底层最不易改动的，常常存放一些通用性比较高的基础功能和工具类。例如，BaseActivity、BaseFragment、总线、utils、日志、网络引擎、widget等。</p>\n<p>Common组件，这层就和业务相关了，是业务功能的公共部分，例如DataSource、公共资源、业务支撑（广告、分享、支付、推送…）。有些公司有自己的风格，可进一步把Common组件进行剥离，例如公司自有风格的widget抽取，业务支撑模块抽取。依赖于Base组件。</p>\n<p>业务组件，这个就不用说了，需求分析时和产品深度沟通，尽可能实现模块自身的完整性，高内聚。各个业务组件均依赖于Common组件。</p>\n<p><img src=\"\" alt=\"组件化架构\" class=\"φbs\"></p>\n<p>接下来根据自己的认知，归总几种组件化可实施方案，名字都是自己定义的。</p>\n<h2 id=\"单壳式组件化方案\">单壳式组件化方案<a title=\"#单壳式组件化方案\" href=\"#单壳式组件化方案\"></a></h2>\n<p>单壳式组件化方案，也是网上采用最多的经典组件化方案，例如<a href=\"https://github.com/luojilab/DDComponentForAndroid\" target=\"_blank\">DDComponentForAndroid</a>。单壳，顾名思义只有一个壳，即主工程。其他的业务模块需要根据gradle配置切换成Library还是Application。</p>\n<p>精简步骤：</p>\n<ol>\n<li>项目根目录里的新增<code>config.gradle</code>文件，该文件常常用于统一项目所有依赖的版本号。内部新增一个变量<code>isDebug</code>，用来控制模块形态是Library还是Application。如果是Application可单独调试，这个不多说了。 <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ext &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 组件调试开关</span></span><br><span class=\"line\"><span class=\"comment\">    * isDebug = true 是组件模块,说明是单独的App</span></span><br><span class=\"line\"><span class=\"comment\">    * isDebug = false是集成模式,说明是依赖Lib</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    isDebug = <span class=\"keyword\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">    android = [</span><br><span class=\"line\">            applicationId            : <span class=\"string\">&quot;com.example.myapp&quot;</span>,</span><br><span class=\"line\">            compileSdkVersion        : <span class=\"number\">28</span>,</span><br><span class=\"line\">            buildToolsVersion        : <span class=\"string\">&quot;28.0.3&quot;</span>,</span><br><span class=\"line\">            minSdkVersion            : <span class=\"number\">18</span>,</span><br><span class=\"line\">            targetSdkVersion         : <span class=\"number\">28</span>,</span><br><span class=\"line\">    ]</span><br><span class=\"line\"></span><br><span class=\"line\">    dependencies = [</span><br><span class=\"line\">            junit           : <span class=\"string\">&quot;junit:junit:4.13.2&quot;</span>,</span><br><span class=\"line\">            test_ext        : <span class=\"string\">&quot;androidx.test.ext:junit:1.1.2&quot;</span>,</span><br><span class=\"line\">            test_espresso   : <span class=\"string\">&quot;androidx.test.espresso:espresso-core:3.3.0&quot;</span>,</span><br><span class=\"line\">            ...</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>在业务组件的<code>build.gradle</code>中根据全局变量<code>isDebug</code>设置调试模式。 <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">println <span class=\"string\">&quot;module_more 调试模式：&quot;</span> + isDebug</span><br><span class=\"line\"><span class=\"keyword\">if</span> (isDebug) &#123;</span><br><span class=\"line\">    apply plugin: <span class=\"string\">&#x27;com.android.application&#x27;</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    apply plugin: <span class=\"string\">&#x27;com.android.library&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>如果想让业务组件单独运行，还需要在业务组件的AndroidManifest中配置启动项，配置Application（图标、主题、名称）、配置启动页。为了避免整个项目编译时资源合并冲突，因此我们不得已需要写两套AndroidManifest，一套用于集成模式下组件功能合并，另外一套用于自身模块的单独调试，两套AndroidManifest<code>业务必需配置</code>是一样的。 <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 模式切换</span></span><br><span class=\"line\">println <span class=\"string\">&quot;module_main 调试模式：&quot;</span> + isDebug</span><br><span class=\"line\"><span class=\"keyword\">if</span> (isDebug) &#123;</span><br><span class=\"line\">    apply plugin: <span class=\"string\">&#x27;com.android.application&#x27;</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    apply plugin: <span class=\"string\">&#x27;com.android.library&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">    compileSdkVersion rootProject.ext.android.compileSdkVersion</span><br><span class=\"line\">    buildToolsVersion rootProject.ext.android.buildToolsVersion</span><br><span class=\"line\"></span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isDebug)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 调试模式自定义applicationId，多组件可同时安装到手机上，方便联调观察。</span></span><br><span class=\"line\">            applicationId <span class=\"string\">&quot;com.example.myapp.module_main&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        minSdkVersion rootProject.ext.android.minSdkVersion</span><br><span class=\"line\">        targetSdkVersion rootProject.ext.android.targetSdkVersion</span><br><span class=\"line\">        versionCode <span class=\"number\">1</span></span><br><span class=\"line\">        versionName <span class=\"string\">&quot;1.0&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        testInstrumentationRunner rootProject.ext.android.testInstrumentationRunner</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    buildTypes &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            minifyEnabled <span class=\"keyword\">false</span></span><br><span class=\"line\">            <span class=\"function\">proguardFiles <span class=\"title\">getDefaultProguardFile</span><span class=\"params\">(<span class=\"string\">&#x27;proguard-android-optimize.txt&#x27;</span>)</span>, &#x27;proguard-rules.pro&#x27;</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">    &#125;</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">    sourceSets </span>&#123;</span><br><span class=\"line\">        main &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isDebug) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 单独调试时采用debug文件夹下的AndroidManifest，debug文件夹还可以存放一些其他调试代码，例如mock数据。</span></span><br><span class=\"line\">                manifest.srcFile <span class=\"string\">&#x27;src/main/debug/AndroidManifest.xml&#x27;</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 集成模式采用默认的AndroidManifest</span></span><br><span class=\"line\">                manifest.srcFile <span class=\"string\">&#x27;src/main/AndroidManifest.xml&#x27;</span></span><br><span class=\"line\">                <span class=\"comment\">// 集成模式下排除debug文件夹中的所有Java文件，不用打包到将来的apk中</span></span><br><span class=\"line\">                java &#123;</span><br><span class=\"line\">                    exclude <span class=\"string\">&#x27;**/debug/**&#x27;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"function\">implementation <span class=\"title\">project</span><span class=\"params\">(<span class=\"string\">&#x27;:common&#x27;</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>在壳工程的<code>build.gradle</code>下依赖所有组件 <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"function\">implementation <span class=\"title\">project</span><span class=\"params\">(<span class=\"string\">&#x27;:common&#x27;</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">    println &quot;main组件调试模式：&quot; + isDebug</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"comment\">// 非调试模式下，集成组件</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">if</span> <span class=\"params\">(!isDebug)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">implementation <span class=\"title\">project</span><span class=\"params\">(<span class=\"string\">&#x27;:module:module_main&#x27;</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">        implementation <span class=\"title\">project</span><span class=\"params\">(<span class=\"string\">&#x27;:module:module_more&#x27;</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">        implementation <span class=\"title\">project</span><span class=\"params\">(<span class=\"string\">&#x27;:module:module_user&#x27;</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">    &#125;</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>最后集成模式和单独调试只需要改变根目录<code>config.gradle</code>中的<code>isDebug</code>的值即可。</p>\n<h2 id=\"多壳式组件化方案\">多壳式组件化方案<a title=\"#多壳式组件化方案\" href=\"#多壳式组件化方案\"></a></h2>\n<p>单壳式组件化有一些弊端，例如切换调试模式，每次都要改变<code>isDebug</code>的值每次都要<code>sync</code>；组件中的AndroidManifest需要写两套；组件中单独调试和集成模式的代码都写在了一起…是不是感觉有点混乱呢？事实上调试代码一般写好后都不怎么动，为何不单独弄到一个地方，让library就作为一个纯粹的library，干干净净。即使调试代码被mock数据污染了我们也不怕，library又没动，进一步降低耦合。因此多壳式组件化方案应运而生。</p>\n<p>多壳式组件化，顾名思义有多个壳，甚至一个组件都有一个壳，多个组件公用一个壳。根据app资源合并规则，Library的壳里面的代码仅仅是Library工程单独调试时冗余出来的调试代码，很少有重复的部分。</p>\n<p>多壳组件化相比单壳组件化优化点：</p>\n<ol>\n<li>去除全局<code>isDebug</code>字段，不需要切换模式，不需要sync，想编译哪个就编译哪个。</li>\n<li>去除业务组件<code>build.gradle</code>中所有模式切换逻辑，library就是library。</li>\n<li>去除主模块<code>build.gradle</code>中只有调试模式才集成依赖的逻辑，主模块就是为打主包服务的，该依赖的都依赖。</li>\n</ol>\n<p>以上三点优化后瞬间清爽的一批，这时候我们只需盯着我们自己业务组件的壳工程即可，被损害了或者mock数据污染了也不怕，大不了重新搞一个，完全不影响主工程。</p>\n<p>有同学说这样岂不是很多Library了，看着密密麻麻。想想大厂的工程项目Library更多，他们是怎么处理的呢？一个方式，通过文件夹把Library分组，我们可以把所有业务组件分到一个文件夹下，这样就没有密集恐惧症了。我知道你还很洁癖，那你可以接着分组。</p>\n<h2 id=\"maven式组件化方案\">Maven式组件化方案<a title=\"#maven式组件化方案\" href=\"#maven式组件化方案\"></a></h2>\n<p>有些公司为了使业务组件可重用，例如外包公司，随便抽几个组件就能快速组件一个app，他们的方案是将各个业务组件打包成aar包，发布到公司自己Maven库中，主工程远程依赖这些库，这样有一些好处：</p>\n<ol>\n<li>组件间代码隔离，耦合最低，可动代码最少</li>\n<li>代码安全性高</li>\n<li>提高编译速度</li>\n<li>随意组合</li>\n</ol>\n<p>这也是很多大厂采用的方案。</p>\n<h2 id=\"组件化三大问题\">组件化三大问题<a title=\"#组件化三大问题\" href=\"#组件化三大问题\"></a></h2>\n<p>上边仅仅是搭建组件化的一些方案，真正搭建起来的时候，使用的时候会发现原来还有三座大山等着你：</p>\n<ol>\n<li>每个组件下的application如何实现</li>\n<li>组件间的页面的调用和跳转</li>\n<li>组件间的方法的调用</li>\n</ol>\n<h3 id=\"每个组件下的application如何实现\">每个组件下的application如何实现<a title=\"#每个组件下的application如何实现\" href=\"#每个组件下的application如何实现\"></a></h3>\n<p>每个组件下的application如何实现？换句话说是application共存问题。我们知道整个项目编译时资源需进行合并，而application的合并规则并不像AndroidManifest增量合并的，多个application共存会产生冲突，因此需要解决冲突，这里给出两个解决方案：</p>\n<ol>\n<li>写一个公共接口，每个application实现该接口，并在主模块的application中通过反射生成依次生成该接口的代理实现对象。</li>\n<li>采用运行时注解方式实现，原理和1类似。</li>\n</ol>\n<p>以下给出反射的处理方案，针对注解，大家可以了解一下运行时注解，个人建议采用注解，更加规范。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 公共接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IComponentApplication</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(Application application)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ModuleA的初始化</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> <span class=\"keyword\">implements</span> <span class=\"title\">IComponentApplication</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(Application application)</span></span>&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//主工程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String[] MODULESLIST =&#123;<span class=\"string\">&quot;com.moduleA.A&quot;</span>&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\">\t\tmodulesApplicationInit();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">modulesApplicationInit</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t <span class=\"keyword\">for</span> (String moduleImpl : MODULESLIST)&#123;</span><br><span class=\"line\">\t\t     <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t         Class&lt;?&gt; clazz = Class.forName(moduleImpl);</span><br><span class=\"line\">\t\t         Object obj = clazz.newInstance();</span><br><span class=\"line\">\t\t         <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> IComponentApplication)&#123;</span><br><span class=\"line\">\t\t             ((IComponentApplication) obj).init(BaseApplication.getInstance());</span><br><span class=\"line\">\t\t         &#125;</span><br><span class=\"line\">\t\t     &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">\t\t         e.printStackTrace();</span><br><span class=\"line\">\t\t     &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</span><br><span class=\"line\">\t\t         e.printStackTrace();</span><br><span class=\"line\">\t\t     &#125; <span class=\"keyword\">catch</span> (InstantiationException e) &#123;</span><br><span class=\"line\">\t\t         e.printStackTrace();</span><br><span class=\"line\">\t\t     &#125;</span><br><span class=\"line\">\t\t  &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"组件间页面的跳转\">组件间页面的跳转<a title=\"#组件间页面的跳转\" href=\"#组件间页面的跳转\"></a></h3>\n<p>两个组件完全没有相互依赖怎么获取相应的页面呢，从而实现跳转呢？其实这个思想也很简单，就像MVP架构一样，M和V没有联系，那就接住P层来进行两者沟通。这里也可以采用类似思想，例如moduleA启动moduleB页面，则可以通过moduleB提供的服务（行业用语，而是一个代理接口，真正实现是在moduleB中的，并不是四大组件中service）来间接跳转。moduleB提供的服务在一个公共模块“router”中，而这个router模块是所有组件都依赖的。因此moduleA通过“router”中的moduleB的服务就可以直捣黄龙了。</p>\n<h3 id=\"组件间方法的调用\">组件间方法的调用<a title=\"#组件间方法的调用\" href=\"#组件间方法的调用\"></a></h3>\n<p>未完待续…</p>\n","prev":{"title":"Android组件化APT技术实践","link":"posts/1619764951"},"next":{"title":"浅入深出了解Android传感器","link":"posts/1617159391"},"plink":"https://blog.ixin.run/posts/1618992460/","toc":[{"id":"为什么要组件化","title":"为什么要组件化","index":"1"},{"id":"组件划分","title":"组件划分","index":"2"},{"id":"单壳式组件化方案","title":"单壳式组件化方案","index":"3"},{"id":"多壳式组件化方案","title":"多壳式组件化方案","index":"4"},{"id":"maven式组件化方案","title":"Maven式组件化方案","index":"5"},{"id":"组件化三大问题","title":"组件化三大问题","index":"6","children":[{"id":"每个组件下的application如何实现","title":"每个组件下的application如何实现","index":"6.1"},{"id":"组件间页面的跳转","title":"组件间页面的跳转","index":"6.2"},{"id":"组件间方法的调用","title":"组件间方法的调用","index":"6.3"}]}],"reward":true,"copyright":{"author":"i猩人","link":"<a href=\"https://blog.ixin.run/posts/1618992460/\" title=\"Android组件化可行性方案探讨和思考\">https://blog.ixin.run/posts/1618992460/</a>","license":"本文遵循<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\"rel=\"external nofollow\" target=\"_blank\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接及本声明。"}}