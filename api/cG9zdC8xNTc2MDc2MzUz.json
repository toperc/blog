{"title":"Android开发混淆的那些事","date":"2019-12-11T14:57:42.000Z","date_formatted":{"ll":"2019年12月11日","L":"2019/12/11","MM-DD":"12-11"},"link":"post/1576076353","comments":true,"tags":["混淆"],"categories":["Android"],"updated":"2021-01-14T08:08:54.897Z","content":"<p>混淆想必大家都不陌生，android上用的这一套混淆规则和java混淆几乎是一样的。为何需要混淆呢？简单的说，就是将原本正常的项目文件，对其类，方法，字段，重新命名,a,b,c,d,e,f…之类的字母，达到混淆代码的目的，这样反编译出来，结构乱糟糟的，给反编译者制造一些代码阅读的麻烦。</p>\n<a id=\"more\"></a>\n<h2 id=\"proguard简介\">ProGuard简介<a title=\"#proguard简介\" href=\"#proguard简介\"></a></h2>\n<p><a href=\"https://www.guardsquare.com/en/products/proguard\" target=\"_blank\">ProGuard</a>是2002年由比利时程序员Eric Lafortune发布的一款优秀的开源代码优化、混淆工具，适用于Java和Android应用，目标是让程序更小，运行更快，在Java界处于垄断地位。主要分为四个模块：Shrinker（压缩器）、Optimizer（优化器）、Obfuscator（混淆器）、Retrace（堆栈反混淆）。<br>\n<img src=\"https://img-blog.csdnimg.cn/20200405233611689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpMDk3OA==,size_16,color_FFFFFF,t_70\" alt=\"ProGuard工作过程\"></p>\n<ol>\n<li>压缩（shrink）通过引用标记算法，移除未使用的类、方法、字段等</li>\n<li>优化（optimize）优化字节码，简化代码等操作</li>\n<li>混淆（obfuscate）使用简短的，无意义的名称重命名类名，方法名，参数字段等</li>\n<li>预校验（perverify）为class添加预校验消息</li>\n</ol>\n<h2 id=\"android启用压缩、混淆、优化\">Android启用压缩、混淆、优化<a title=\"#android启用压缩、混淆、优化\" href=\"#android启用压缩、混淆、优化\"></a></h2>\n<p>在 Android 中，我们平常所说的&quot;混淆&quot;其实有两层意思：</p>\n<ol>\n<li>是 Java 代码的混淆</li>\n<li>是资源的压缩</li>\n</ol>\n<p>其实这两者之间并没有什么关联，只不过习惯性地放在一起来使用。那么，说了这么多，Android平台上到底该如何开启混淆呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android &#123;</span><br><span class=\"line\">    buildTypes &#123;</span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            minifyEnabled <span class=\"keyword\">true</span></span><br><span class=\"line\">            shrinkResources <span class=\"keyword\">true</span></span><br><span class=\"line\">            <span class=\"function\">proguardFiles <span class=\"title\">getDefaultProguardFile</span><span class=\"params\">(<span class=\"string\">&#x27;proguard-android.txt&#x27;</span>)</span>, &#x27;proguard-rules.pro&#x27;</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">    &#125;</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>以上就是开启混淆的基本操作了，通过 minifyEnabled 设置为 true 来开启混淆。同时，可以设置 shrinkResources 为 true 来开启资源的压缩。</p>\n<p>不难看出，我们一般在打 release 包时才启用混淆，因为混淆会增加额外的编译时间，所以不建议在 debug 模式下启用。此外，需要注意的是：<strong>只有在启用混淆的前提下开启资源压缩才会有效！</strong></p>\n<p>以上代码中的 proguard-android.txt 表示 Android 系统为我们提供的默认混淆规则文件，而 <a href=\"http://proguard-rules.pro\">proguard-rules.pro</a> 则是我们想要自定义的混淆规则。</p>\n<p>如果你不对proguard-rules.pro文件做定制化，默认是整个工程全开启混淆的，但是由于一些三方代码、反射、自定义view等，一旦这些都混淆了编译器在运行时找不到具体的成员，从而会导致错误，所以我们也要忽略一些类或者成员的混淆。</p>\n<h2 id=\"android混淆配置关键字\">Android混淆配置关键字<a title=\"#android混淆配置关键字\" href=\"#android混淆配置关键字\"></a></h2>\n<h3 id=\"系统混淆配置\">系统混淆配置<a title=\"#系统混淆配置\" href=\"#系统混淆配置\"></a></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#混淆时不使用大小写混合类名</span><br><span class=\"line\">-dontusemixedcaseclassnames </span><br><span class=\"line\">#不跳过library中的非public的类</span><br><span class=\"line\">-dontskipnonpubliclibraryclasses </span><br><span class=\"line\">#打印混淆的详细信息</span><br><span class=\"line\">-verbose </span><br><span class=\"line\">#不进行优化，建议使用此选项</span><br><span class=\"line\">-dontoptimize </span><br><span class=\"line\">#不进行预校验,Android不需要,可加快混淆速度</span><br><span class=\"line\">-dontpreverify</span><br><span class=\"line\">#忽略警告</span><br><span class=\"line\">-ignorewarnings </span><br><span class=\"line\">#指定代码的压缩级别</span><br><span class=\"line\">-optimizationpasses <span class=\"number\">5</span>  </span><br></pre></td></tr></table></figure>\n<h3 id=\"proguard关键字\">Proguard关键字<a title=\"#proguard关键字\" href=\"#proguard关键字\"></a></h3>\n<p><img src=\"https://img-blog.csdnimg.cn/20200405233720736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpMDk3OA==,size_16,color_FFFFFF,t_70\" alt=\"Proguard关键字\" class=\"φcx\"></p>\n<p>如果你不确定你需要使用哪一个选项，那么你应该尽量使用 -keep 。它会确保指定的类和成员在 压缩阶段（shrinking step）不会被删除，并且在 混淆阶段（obfuscation step）不会被混淆。</p>\n<h3 id=\"proguard通配符\">Proguard通配符<a title=\"#proguard通配符\" href=\"#proguard通配符\"></a></h3>\n<p><img src=\"https://img-blog.csdnimg.cn/20200405233739707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpMDk3OA==,size_16,color_FFFFFF,t_70\" alt=\"Proguard通配符\" class=\"φcx\"></p>\n<p>上边的通配符没有返回类型。仅仅<init>通配符有一个参数列表。</p>\n<p>字段和方法的名称可以包含如下通配符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">? 匹配名称中的任意单个字符</span><br><span class=\"line\">* 匹配名称中的任意一部分</span><br></pre></td></tr></table></figure>\n<p>类型描述可以包含如下通配符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 匹配任意基本类型（‘boolean’,&#39;int&#39;以及其他，但是不包括‘void’）.</span><br><span class=\"line\">? 匹配类名中的任意单个字符</span><br><span class=\"line\">* 匹配类名中的任意部分，但是不包含包分隔符 。</span><br><span class=\"line\">** 匹配类名中的任意部分，可以包含任意个数的包分隔符。</span><br><span class=\"line\">*** 匹配任意类型（基本类型或者非基本类型，数组或者非数组）</span><br><span class=\"line\">... 匹配任意个数任意类型的参数。</span><br></pre></td></tr></table></figure>\n<p>注意：? , * 以及 ** 通配符永远都不会匹配基本类型。此外，仅仅 *** 通配符会匹配任意长度任意类型的数组。</p>\n<h2 id=\"哪些不应该进行混淆\">哪些不应该进行混淆<a title=\"#哪些不应该进行混淆\" href=\"#哪些不应该进行混淆\"></a></h2>\n<p>我们在了解了混淆的基本命令之后，很多人应该还是一头雾水：到底哪些内容该混淆？其实，我们在使用代码混淆时，ProGuard 对我们项目中大部分代码进行了混淆操作，为了防止编译时出错，我们应该通过 keep 命令保留一些元素不被混淆。所以，我们只需要知道哪些元素不应该被混淆：</p>\n<p><strong>枚举</strong></p>\n<p>项目中难免可能会用到枚举类型，然而它不能参与到混淆当中去。原因是：枚举类内部存在 values 方法，混淆后该方法会被重新命名，并抛出 NoSuchMethodException。庆幸的是，Android 系统默认的混淆规则中已经添加了对于枚举类的处理，我们无需再去做额外工作。</p>\n<p><strong>被反射的元素</strong></p>\n<p>被反射使用的类、变量、方法、包名等不应该被混淆处理。原因在于：代码混淆过程中，被反射使用的元素会被重命名，然而反射依旧是按照先前的名称去寻找元素，所以会经常发生 NoSuchMethodException 和 NoSuchFiledException 问题。</p>\n<p><strong>实体类</strong></p>\n<p>实体类即我们常说的&quot;数据类&quot;，当然经常伴随着序列化与反序列化操作。很多人也应该都想到了，混淆是将原本有特定含义的&quot;元素&quot;转变为无意义的名称，所以，经过混淆的&quot;洗礼&quot;之后，序列化之后的 value 对应的 key 已然变为没有意义的字段，这肯定是我们不希望的。同时，反序列化的过程创建对象从根本上来说还是借助于反射，混淆之后 key 会被改变，所以也会违背我们预期的效果。</p>\n<p><strong>四大组件</strong></p>\n<p>Android 中的四大组件同样不应该被混淆。原因在于：<br>\n四大组件使用前都需要在 AndroidManifest.xml 文件中进行注册声明，然而混淆处理之后，四大组件的类名就会被篡改，实际使用的类与 manifest 中注册的类并不匹配，故而出错。其他应用程序访问组件时可能会用到类的包名加类名，如果经过混淆，可能会无法找到对应组件或者产生异常。</p>\n<p><strong>JNI 调用的Java 方法</strong></p>\n<p>当 JNI 调用的 Java 方法被混淆后，方法名会变成无意义的名称，这就与 C++ 中原本的 Java 方法名不匹配，因而会无法找到所调用的方法。<br>\n其他不应该被混淆的</p>\n<p><strong>自定义控件不需要被混淆</strong></p>\n<p><strong>JavaScript 调用 Java 的方法不应混淆</strong></p>\n<p><strong>Java 的 native 方法不应该被混淆</strong></p>\n<p><strong>项目中引用的第三方库也不建议混淆</strong></p>\n<h2 id=\"混淆举例\">混淆举例<a title=\"#混淆举例\" href=\"#混淆举例\"></a></h2>\n<p>以下是一些混淆的举例和说明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;不混淆某个类</span><br><span class=\"line\">-keep public class name.huihui.example.Test &#123; *; &#125;</span><br><span class=\"line\">&#x2F;&#x2F;不混淆某个类的子类</span><br><span class=\"line\">-keep public class * extends name.huihui.example.Test &#123; *; &#125;</span><br><span class=\"line\">&#x2F;&#x2F;不混淆所有类名中包含了“model”的类及其成员</span><br><span class=\"line\">-keep public class **.*model*.** &#123;*;&#125;</span><br><span class=\"line\">&#x2F;&#x2F;不混淆某个接口的实现</span><br><span class=\"line\">-keep class * implements name.huihui.example.TestInterface &#123; *; &#125;</span><br><span class=\"line\">&#x2F;&#x2F;不混淆某个类的构造方法</span><br><span class=\"line\">-keepclassmembers class name.huihui.example.Test &#123; </span><br><span class=\"line\">    public &lt;init&gt;(); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;不混淆某个类的特定的方法</span><br><span class=\"line\">-keepclassmembers class name.huihui.example.Test &#123; </span><br><span class=\"line\">    public void test(java.lang.String); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;不混淆某个类的内部类</span><br><span class=\"line\">-keep class name.huihui.example.Test$* &#123;*;&#125;</span><br><span class=\"line\">&#x2F;&#x2F;两个常用的混淆命令，注意：</span><br><span class=\"line\">&#x2F;&#x2F;一颗星表示只是保持该包下的类名，而子包下的类名还是会被混淆；</span><br><span class=\"line\">&#x2F;&#x2F;两颗星表示把本包和所含子包下的类名都保持；</span><br><span class=\"line\">-keep class com.suchengkeji.android.ui.*</span><br><span class=\"line\">-keep class com.suchengkeji.android.ui.**</span><br><span class=\"line\">&#x2F;&#x2F;用以上方法保持类后，你会发现类名虽然未混淆，但里面的具体方法和变量命名还是变了，</span><br><span class=\"line\">&#x2F;&#x2F;如果既想保持类名，又想保持里面的内容不被混淆，我们就需要以下方法了</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;不混淆某个包所有的类</span><br><span class=\"line\">-keep class com.suchengkeji.android.bean.** &#123; *; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;不混淆某个具体类</span><br><span class=\"line\">-keep public class com.android.vending.licensing.ILicensingService</span><br></pre></td></tr></table></figure>\n<h3 id=\"一个通用的混淆模板\">一个通用的混淆模板<a title=\"#一个通用的混淆模板\" href=\"#一个通用的混淆模板\"></a></h3>\n<p>这里给大家提供一个通用的混淆模板</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">###########################################基本指令(基本不动)#######################################</span><br><span class=\"line\"></span><br><span class=\"line\">#代码混淆压缩比，在0~7之间，默认为5，一般不做修改</span><br><span class=\"line\">-optimizationpasses 5</span><br><span class=\"line\"></span><br><span class=\"line\">#混合时不使用大小写混合，混合后的类名为小写</span><br><span class=\"line\">-dontusemixedcaseclassnames</span><br><span class=\"line\"></span><br><span class=\"line\">#指定不去忽略非公共库的类</span><br><span class=\"line\">-dontskipnonpubliclibraryclasses</span><br><span class=\"line\"></span><br><span class=\"line\">#指定不去忽略非公共库的类的成员</span><br><span class=\"line\">-dontskipnonpubliclibraryclassmembers</span><br><span class=\"line\"></span><br><span class=\"line\">#这句话能够使我们的项目混淆后产生映射文件</span><br><span class=\"line\">#包含有类名-&gt;混淆后类名的映射关系</span><br><span class=\"line\">-verbose</span><br><span class=\"line\"></span><br><span class=\"line\">#不做预校验，preverify是proguard的四个步骤之一，Android不需要preverify，去掉这一步能够加快混淆速度。</span><br><span class=\"line\">-dontpreverify</span><br><span class=\"line\"></span><br><span class=\"line\">#保留Annotation不混淆</span><br><span class=\"line\">-keepattributes *Annotation*,InnerClasses</span><br><span class=\"line\"></span><br><span class=\"line\">#保留泛型不混淆</span><br><span class=\"line\">-keepattributes Signature</span><br><span class=\"line\"></span><br><span class=\"line\">#抛出异常时保留代码行号</span><br><span class=\"line\">-keepattributes SourceFile,LineNumberTable</span><br><span class=\"line\"></span><br><span class=\"line\">#指定混淆是采用的算法，后面的参数是一个过滤器 #这个过滤器是谷歌推荐的算法，一般不做更改</span><br><span class=\"line\">-optimizations !code&#x2F;simplification&#x2F;cast,!field&#x2F;*,!class&#x2F;merging&#x2F;*</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#########################################java部分###########################################</span><br><span class=\"line\"></span><br><span class=\"line\">#native方法不被混淆</span><br><span class=\"line\">-keepclasseswithmembernames class * &#123;</span><br><span class=\"line\">    native &lt;methods&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#枚举enum类不被混淆</span><br><span class=\"line\">-keepclassmembers enum * &#123;</span><br><span class=\"line\">    public static **[] values();</span><br><span class=\"line\">    public static ** valueOf(java.lang.String);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#Serializable类不被混淆</span><br><span class=\"line\">-keep public class * implements java.io.Serializable &#123;*;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#########################################android部分####################################</span><br><span class=\"line\"></span><br><span class=\"line\">#保留support下的所有类及其内部类</span><br><span class=\"line\">-keep class android.support.** &#123;*;&#125;</span><br><span class=\"line\">#基类不被混淆</span><br><span class=\"line\">-keep class * extends android.app.Activity</span><br><span class=\"line\">-keep class * extends android.app.Application</span><br><span class=\"line\">-keep class * extends android.app.Service</span><br><span class=\"line\">-keep class * extends android.content.BroadcastReceiver</span><br><span class=\"line\">-keep class * extends android.content.ContentProvider</span><br><span class=\"line\">-keep class * extends android.app.backup.BackupAgentHelper</span><br><span class=\"line\">-keep class * extends android.preference.Preference</span><br><span class=\"line\"></span><br><span class=\"line\">#自定义控件类不被混淆</span><br><span class=\"line\">-keepclasseswithmembers class * &#123;</span><br><span class=\"line\">    public &lt;init&gt;(android.content.Context, android.util.AttributeSet);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">-keepclasseswithmembers class * &#123;</span><br><span class=\"line\">    public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#表示不混淆任何一个View中的setXxx()和getXxx()方法，</span><br><span class=\"line\">#因为属性动画需要有相应的setter和getter的方法实现，混淆了就无法工作了。</span><br><span class=\"line\">-keep class * extends android.view.View&#123;</span><br><span class=\"line\">    *** get*();</span><br><span class=\"line\">    void set*(***);</span><br><span class=\"line\">    &lt;init&gt;(...);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># 保留R下面的资源</span><br><span class=\"line\">#不混淆资源类下static的</span><br><span class=\"line\">-keepclassmembers class **.R$* &#123;</span><br><span class=\"line\">    public static &lt;fields&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#Parcelable类不被混淆</span><br><span class=\"line\">-keep class * implements android.os.Parcelable &#123;</span><br><span class=\"line\">  public static final android.os.Parcelable$Creator *;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#WebView相关不被混淆</span><br><span class=\"line\">-keepclassmembers class * extends android.webkit.WebView &#123;*;&#125;</span><br><span class=\"line\">-keepclassmembers class * extends android.webkit.WebViewClient &#123;*;&#125;</span><br><span class=\"line\">-keepclassmembers class * extends android.webkit.WebChromeClient &#123;*;&#125;</span><br><span class=\"line\">-keepclassmembers class * &#123;</span><br><span class=\"line\">    @android.webkit.JavascriptInterface &lt;methods&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">########################################本项目混淆规则##########################################</span><br><span class=\"line\"></span><br><span class=\"line\">#非本项目不进行混淆</span><br><span class=\"line\">-keep class !com.ehai.store.** &#123;*;&#125;</span><br><span class=\"line\">-dontwarn **</span><br><span class=\"line\"></span><br><span class=\"line\">#########################################其他#####################################################</span><br><span class=\"line\">#</span><br><span class=\"line\">##避免混淆Bugly</span><br><span class=\"line\">#-dontwarn com.tencent.bugly.**</span><br><span class=\"line\">#-keep public class com.tencent.bugly.**&#123;*;&#125;</span><br><span class=\"line\">#</span><br><span class=\"line\">##极光推送</span><br><span class=\"line\">#-dontoptimize</span><br><span class=\"line\">#-dontpreverify</span><br><span class=\"line\">#</span><br><span class=\"line\">#-dontwarn cn.jpush.**</span><br><span class=\"line\">#-keep class cn.jpush.** &#123; *; &#125;</span><br><span class=\"line\">#-keep class * extends cn.jpush.android.helpers.JPushMessageReceiver &#123; *; &#125;</span><br><span class=\"line\">#</span><br><span class=\"line\">#-dontwarn cn.jiguang.**</span><br><span class=\"line\">#-keep class cn.jiguang.** &#123; *; &#125;</span><br><span class=\"line\">#</span><br><span class=\"line\">##微众银行OCR SDK 混淆</span><br><span class=\"line\">##webank-cloud-normal-proguard-rules.pro的规则已经被webank-cloud-ocr-proguard-rules.pro “include”了，不需要再添加</span><br><span class=\"line\">#-include webank-cloud-ocr-proguard-rules.pro</span><br></pre></td></tr></table></figure>\n<h2 id=\"混淆后的堆栈跟踪\">混淆后的堆栈跟踪<a title=\"#混淆后的堆栈跟踪\" href=\"#混淆后的堆栈跟踪\"></a></h2>\n<p>代码经过 ProGuard 混淆处理后，想要读取 StackTrace（堆栈追踪）信息就会变得很困难。由于方法名称和类的名称都经过混淆处理，即使程序发生崩溃问题，也很难定位问题所在。幸运的是，ProGuard 为我们提供了补救的措施，在着手进行之前，我们先来看一下 ProGuard 每次构建后生成了哪些内容。</p>\n<h3 id=\"混淆输出结果\">混淆输出结果<a title=\"#混淆输出结果\" href=\"#混淆输出结果\"></a></h3>\n<p>混淆构建完成之后，会在<code>&lt;module-name&gt;/build/outputs/mapping/./</code> 目录下生成以下文件：</p>\n<ul>\n<li>dump.txt<br>\n说明 APK 内所有类文件的内部结构。</li>\n<li>mapping.txt<br>\n提供混淆前后的内容对照表，内容主要包含类、方法和类的成员变量。</li>\n<li>seeds.txt<br>\n罗列出未进行混淆处理的类和成员。</li>\n<li>usage.txt<br>\n罗列出从 APK 中移除的代码。</li>\n</ul>\n<h2 id=\"如何从堆栈中还原proguard混淆后的代码\">如何从堆栈中还原ProGuard混淆后的代码<a title=\"#如何从堆栈中还原proguard混淆后的代码\" href=\"#如何从堆栈中还原proguard混淆后的代码\"></a></h2>\n<p>混淆后的代码一旦发生崩溃，那么所产生的日志也是混淆的，调试起来很麻烦，所以此时有必要将其还原到原生态进行分析。</p>\n<p><strong>还原前</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Caused by: java.lang.NullPointerException</span><br><span class=\"line\">at net.simplyadvanced.ltediscovery.be.u(Unknown Source)</span><br><span class=\"line\">at net.simplyadvanced.ltediscovery.at.v(Unknown Source)</span><br><span class=\"line\">at net.simplyadvanced.ltediscovery.at.d(Unknown Source)</span><br><span class=\"line\">at net.simplyadvanced.ltediscovery.av.onReceive(Unknown Source)</span><br></pre></td></tr></table></figure>\n<p><strong>还原后</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Caused by: java.lang.NullPointerException</span><br><span class=\"line\">at net.simplyadvanced.ltediscovery.UtilTelephony.<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">is800MhzNetwork</span><span class=\"params\">()</span><span class=\"params\">(Unknown Source)</span></span></span><br><span class=\"line\"><span class=\"function\">at net.simplyadvanced.ltediscovery.ServiceDetectLte.<span class=\"keyword\">void</span> <span class=\"title\">checkAndAlertUserIf800MhzConnected</span><span class=\"params\">()</span><span class=\"params\">(Unknown Source)</span></span></span><br><span class=\"line\"><span class=\"function\">at net.simplyadvanced.ltediscovery.ServiceDetectLte.<span class=\"keyword\">void</span> <span class=\"title\">startLocalBroadcastReceiver</span><span class=\"params\">()</span><span class=\"params\">(Unknown Source)</span></span></span><br><span class=\"line\"><span class=\"function\">at net.simplyadvanced.ltediscovery.ServiceDetectLte$2.<span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(android.content.Context,android.content.Intent)</span><span class=\"params\">(Unknown Source)</span></span></span><br></pre></td></tr></table></figure>\n<p>那么如何还原呢？这里提供两种方式：<strong>GUI工具和命令行</strong></p>\n<h3 id=\"gui工具还原\">GUI工具还原<a title=\"#gui工具还原\" href=\"#gui工具还原\"></a></h3>\n<ol>\n<li>打开/tools/proguard/bin/proguardgui.bat</li>\n<li>选择左边栏的ReTrace选项</li>\n<li>添加你的mapping文件和混淆过的堆栈信息</li>\n<li>点击ReTrace!</li>\n</ol>\n<p>如图：<br>\n<img src=\"https://img-blog.csdnimg.cn/20200405233837276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpMDk3OA==,size_16,color_FFFFFF,t_70\" alt=\"ProGuard工具\"></p>\n<h3 id=\"命令行还原\">命令行还原<a title=\"#命令行还原\" href=\"#命令行还原\"></a></h3>\n<ol>\n<li>需要你的ProGuard的mapping文件和你想要还原的堆栈信息（如stacktrace.txt）</li>\n<li>最简单的方法就是将这些文件拷贝到/tools/proguard/bin/目录</li>\n<li>运行以下命令</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Windows</span><br><span class=\"line\">retrace.bat -verbose mapping.txt stacktrace.txt &gt; out.txt</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;Mac\\Linux</span><br><span class=\"line\">retrace.sh -verbose mapping.txt stacktrace.txt &gt; out.txt</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\">参考<a title=\"#参考\" href=\"#参考\"></a></h2>\n<ul>\n<li><a href=\"https://tech.meituan.com/2018/04/27/mt-proguard.html\">https://tech.meituan.com/2018/04/27/mt-proguard.html</a></li>\n<li><a href=\"https://stuff.mit.edu/afs/sipb/project/android/sdk/android-sdk-linux/tools/proguard/docs/index.html#manual/introduction.html\">https://stuff.mit.edu/afs/sipb/project/android/sdk/android-sdk-linux/tools/proguard/docs/index.html#manual/introduction.html</a></li>\n<li><a href=\"https://developer.android.com/studio/build/shrink-code.html\">https://developer.android.com/studio/build/shrink-code.html</a></li>\n</ul>\n","prev":{"title":"记一次BuildConfig.DEBUG不准确导致的Bug","link":"post/1576077775"},"next":{"title":"Git分支管理最佳实践","link":"post/1574177460"},"plink":"https://blog.ixin.run/post/1576076353/","toc":[{"id":"proguard简介","title":"ProGuard简介","index":"1"},{"id":"android启用压缩、混淆、优化","title":"Android启用压缩、混淆、优化","index":"2"},{"id":"android混淆配置关键字","title":"Android混淆配置关键字","index":"3","children":[{"id":"系统混淆配置","title":"系统混淆配置","index":"3.1"},{"id":"proguard关键字","title":"Proguard关键字","index":"3.2"},{"id":"proguard通配符","title":"Proguard通配符","index":"3.3"}]},{"id":"哪些不应该进行混淆","title":"哪些不应该进行混淆","index":"4"},{"id":"混淆举例","title":"混淆举例","index":"5","children":[{"id":"一个通用的混淆模板","title":"一个通用的混淆模板","index":"5.1"}]},{"id":"混淆后的堆栈跟踪","title":"混淆后的堆栈跟踪","index":"6","children":[{"id":"混淆输出结果","title":"混淆输出结果","index":"6.1"}]},{"id":"如何从堆栈中还原proguard混淆后的代码","title":"如何从堆栈中还原ProGuard混淆后的代码","index":"7","children":[{"id":"gui工具还原","title":"GUI工具还原","index":"7.1"},{"id":"命令行还原","title":"命令行还原","index":"7.2"}]},{"id":"参考","title":"参考","index":"8"}],"reward":true,"copyright":{"custom":"转载请注明出处，谢谢支持。"}}